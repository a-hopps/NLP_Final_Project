{"statement": "You are given an integer n Check if n has an divisor greater than one does there exist such a number x x 1 that n is divisible by x and x is odd For example if n 6 then there is x 3 If n 4 then such a number does not exist ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "If the number has an odd divisor then it has an odd prime divisor To understand this fact we can consider what happens when multiplying even and odd numbers even even even even odd even odd even even odd odd There is only one even prime number So if a number has no odd divisors then it must be a power of two To check this fact for example you can divide by as long as it is divisible If at the end we got then the power of two You can also use the following condition to check If the number is a power of two then it contains only one unit in the binary notation Then contains units in all positions except the one in which the unit in is located So their bitwise AND does not contain units "}
{"statement": "You are given an array a of 2n integers You want to arrange the elements of the array in a circle such that no element is equal to the the arithmetic mean of its 2 neighbours More formally find an array b such that b is a permutation of a For every i from 1 to 2n b i neq frac b i 1 b i 1 2 where b 0 b 2n and b 2n 1 b 1 It can be proved that under the constraints of this problem such array b always exists ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The main idea is that we can split the numbers into the two halves the big half and small half we can place the bigger half at the odd positions and the smaller half at the even positions This works because the smallest big number is larger than the biggest small number Hence the mean of any two small numbers is smaller than any big number and the mean of any two big numbers is bigger than any small number "}
{"statement": "Monocarp has just learned a new card trick and can t wait to present it to you He shows you the entire deck of n cards You see that the values of cards from the topmost to the bottommost are integers a 1 a 2 dots a n and all values are different Then he asks you to shuffle the deck m times With the j th shuffle you should take b j topmost cards and move them under the remaining n b j cards without changing the order And then using some magic Monocarp tells you the topmost card of the deck However you are not really buying that magic You tell him that you know the topmost card yourself Can you surprise Monocarp and tell him the topmost card before he shows it ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The easiest way to solve to problem is probably to see the resemblense of a shuffle operation to an std rotate function So you can obtain the final deck by applying cyclic shifts of the deck by then and so on Since the shifts are cyclic it doesn t matter if you shift by or by or by for any non negative The result will be the same Thus you can calculate the sum of rotations you apply and subtract until it becomes less than That is taking it modulo Finally after rotating a sequence by some the th element of it indexed becomes the first one Thus you just want to print the th element of Overall complexity per testcase "}
{"statement": "Pak Chanek has n blank heart shaped cards Card 1 is attached directly to the wall while each of the other cards is hanging onto exactly one other card by a piece of string Specifically card i i 1 is hanging onto card p i p i i In the very beginning Pak Chanek must write one integer number on each card He does this by choosing any permutation a of 1 2 dots n Then the number written on card i is a i After that Pak Chanek must do the following operation n times while maintaining a sequence s which is initially empty Choose a card x such that no other cards are hanging onto it Append the number written on card x to the end of s If x neq 1 and the number on card p x is larger than the number on card x replace the number on card p x with the number on card x Remove card x After that Pak Chanek will have a sequence s with n elements What is the maximum length of the longest non decreasing subsequence dagger of s at the end if Pak Chanek does all the steps optimally dagger A sequence b is a subsequence of a sequence c if b can be obtained from c by deletion of several possibly zero or all elements For example 3 1 is a subsequence of 3 2 1 4 3 1 and 3 1 but not 1 3 3 7 and 3 10 4 ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "The cards form a rooted tree with card being the root where for each the parent of card is Let be the number on card when it is about to get removed To remove card we must previously remove all cards in the subtree of other than itself Thus we can see that is the minimum value of out of all cards in the subtree of Let the sequence mean that the th element of the longest non decreasing subsequence comes from card Then we can get the following observations We can only remove card if all other cards in the subtree of have been removed Hence for each every with must not be in the subtree of We can make to be the ancestor of by making This can be done by making it such that the minimum value of in the subtree of is simultaneously the minimum value of in the subtree of If is not the ancestor of then must hold Because forms a non decreasing sequence then must hold That means is guaranteed to be larger than the values of for all ancestors of This means after cannot continue with any ancestors of From the information above it means that when constructing we do one the following operation several times Append an ancestor of the last card Append a card that is not an ancestor of the last card and not a descendant of any of the previous cards After this we cannot choose any ancestor of the card before this new card In the optimal configuration the sequence resembles the following It consists of several paths of cards where each path is from a card to one of its ancestors For any pair of cards from two different paths one must not be an ancestor of the other We will use dynamic programming on tree Let denote the length of the longest non decreasing subsequence created from only doing operations to the subtree of Then we have two cases If card is used in the longest non decreasing subsequence then the maximum answer is the maximum number of cards in a path from card to one of the cards in the subtree of If card is not used in the longest non decreasing subsequence then the maximum answer is the sum of values of the children of card Time complexity "}
{"statement": "You are given a broken clock You know that it is supposed to show time in 12 or 24 hours format In 12 hours format hours change from to while in 24 hours it changes from to In both formats minutes change from to You are given a time in format that is currently displayed on the broken clock Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format For example if is displayed it is enough to replace the second with in order to get that is a correct time in 24 hours format However to make correct in 12 hours format one has to change at least two digits Additionally to the first change one can replace the second with and obtain ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s iterate over all possible values that can be shown on the clock First two digits must form a number from to in case of hours format and a number from to in case of hours format Second two digits must form a number from to For each value we will count the number of digits that differ from the original ones Finally choose the value that differs in the least number of digits "}
{"statement": "There is a process that takes place on arrays a and b of length n and length n 1 respectively The process is an infinite sequence of operations Each operation is as follows First choose a random integer i 1 le i le n 1 Then simultaneously set a i min left a i frac a i a i 1 b i 2 right and a i 1 max left a i 1 frac a i a i 1 b i 2 right without any rounding so values may become non integer See notes for an example of an operation It can be proven that array a converges i e for each i there exists a limit a i converges to Let function F a b return the value a 1 converges to after a process on a and b You are given array b but not array a However you are given a third array c Array a is good if it contains only and satisfies 0 leq a i leq c i for 1 leq i leq n Your task is to count the number of good arrays a where F a b geq x for q values of x Since the number of arrays can be very large print it modulo 10 9 7 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "First reduce the operations into something more manageable It turns out operation i sets ai 1 ai max bi ai 1 ai while keeping ai 1 ai constant Visually this is simultaneously moving ai up and ai 1 down until ai 1 a i bi Define f to be the final converged array Let s some observations If ai 1 ai bi is ever satisfied throughout the process if an operation ever moves anything fi 1 fi bi Equivalently if fi 1 fi bi then no operation i could have ever been conducted If no operation i has been conducted then 1 i is independent of i 1 n If i is the first operation that has never been conducted then ij 1aj ij 1fj because no sum could have been exchanged between ai and ai 1 Let s assume that we know that i is the first observation that hasn t been conducted We can then restore f1 because we know that f1 f1 b1 f1 b1 b2 a1 a2 ai To keep the tutorial clean we refer to the prefix of prefix summation of bi as bpi and the prefix summation of ai as api Namely we can solve for f1 api bpii given that i is the first observation never conducted It turns out that f1 min api bpii over all i This can be shown to be a lower bound on f1 because the answer is obviously in this set as there must be some i that is the first operation never conducted This can also be shown to be an upperbound on the answer by playing the game on each prefix i At each prefix i the term api bpii is an upperbound because if it s not equal to that term there must be some fi 1 fi bi so f1 api bpii because f1 f2 fi remains the same Returning to the actual problem we need to count arrays min api bpii x In other words api i x bpi must hold for all i Let s do dynamic programming on api Call dp i api the number of prefixes of length i with current prefix sum of api We can transition to i 1 from i using prefix sums on each valid api Define M max ai The current complexity is O QMN2 The final step is noticing that there are only O M valid integer positions that end up being important for f1 Intuitively this is because in nearly all cases every operation i ends up being used To rigorously prove let s find an upperbound on relevant x If M n x n bpi then there are 0 valid arrays Because x n bpi is concave and negative on the decreasing portion i e the function goes down immediately into negative if it ever becomes negative otherwise strictly increases we can draw the inequality 0 x n bpi otherwise every array ends up being good Reducing the inequalities we can realize that there is exactly M different possible solutions So we can precalculate in O M2N2 and answer in O 1 "}
{"statement": "Let s define of number a consisting of digits a 1 ldots a k and number b consisting of digits b 1 ldots b k we add leading zeroes to the shorter number to match longer length as number s a b consisting of digits a 1 b 1 mod 10 ldots a k b k mod 10 The of several integers is defined as follows s t 1 ldots t n s t 1 s t 2 ldots t n You are given an array x 1 ldots x n The task is to compute for each integer i 0 le i n number of ways to consequently choose one of the integers from the array n times so that the of these integers is equal to i Calculate these values modulo 2 58 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3400", "problem_editorial": "After reading the problem statement it is pretty clear that you should apply something like Hadamard transform but inner transform should have size ten instead of two There is no th root of one modulo except th and th roots so it is not possible to solve the problem just calculating all values modulo The main idea is that you should calculate all values in a polynomial ring modulo in this ring identity holds so is the one s th root Now the problem is there is no modular inverse of so we apply the trick Let s just use unsigned long long and in the end we will divide the answer by it is invertible because it is relatively prime to 2 and then we simply divide the answer by with integer division it can be easily shown that the result will be correct It is worth noting that after inverse transform you should eliminate monomes larger than by applying the identity modulo After that only the coefficient with remains and this will be the answer "}
{"statement": "You are given two integers a and b In one turn you can do one of the following operations Take an integer c c 1 and and replace a with frac a c Take an integer c c 1 and and replace b with frac b c Your goal is to make a equal to b using exactly k turns For example the numbers a 36 and b 48 can be made equal in 4 moves c 6 divide b by c Rightarrow a 36 b 8 c 2 divide a by c Rightarrow a 18 b 8 c 9 divide a by c Rightarrow a 2 b 8 c 4 divide b by c Rightarrow a 2 b 2 For the given numbers a and b determine whether it is possible to make them equal using exactly k turns ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s denote for the maximum number of moves for which the numbers and can be made equal It is easy to understand that the number of moves is maximum when and each time we divided or by a prime number That is sum of exponents of prime divisors of sum of exponents of prime divisors of Let s denote by the minimum number of moves for which the numbers and can be made equal Consider a few cases If then If or then Otherwise then Then the answer is possible in the following cases and and or and "}
{"statement": "Let s call an undirected graph of vertices if the following conditions fulfill the graph contains exactly edges the graph doesn t contain self loops and multiple edges for any integer any subgraph consisting of vertices contains at most edges A of a graph is some set of the graph vertices and some set of the graph edges At that the set of edges must meet the condition both ends of each edge from the set must belong to the chosen set of vertices Your task is to find a graph consisting of vertices ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1500", "problem_editorial": "I will describe two solutions First Consider all pairs After you should ouput the first pairs in lexicographical order It s clear to understand that it is enough to prove that interesting graph is correct or interesting graph is correct We will prove for interesting graph that it is correct This graph consists of triangles which have an common edge Let s fix some subset of vertexes which does not contains vertexes and In such sets there are no edges Let s fix some subset which contains exactly one vertex or In such subsets there are exactly edges where is the size of such subset In other subset there are exactly 2 k 2 1 edges where is the size of such subset Second Let s use some brute force to build graphs with interesting graphs with sizes vertexes Now to build interesting graph with vertexes We will build interesting graph and after that we will add to it another edges which is not in the graph We will build interesting graphs using the following approach Let s took disjointed components from graphs with number of vertexes from to in such way that there are exactly vertexes in graph "}
{"statement": "There are n planets in the universe Each planet has an l r during which it will be exposed to destruction by orangutans Orangutans can also expand the of any planet by 1 unit Specifically suppose the expansion is performed on planet p with l p r p Then the resulting may be either l p 1 r p or l p r p 1 Given a set of planets orangutans can destroy all planets if the of all planets in the set intersect at least one common point Let the of such a set denote the minimum number of expansions that must be performed Orangutans are interested in the sum of of all subsets of the planets in the universe As the answer can be large output it modulo 998 244 353 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Problem Credits Proof by QED satyam343 Analysis satyam343 Solution Easy Version To find the score of a set of intervals we follow these steps Initially the score is set to We perform the following process repeatedly Let be the interval with the smallest among all active intervals Let be the interval with the largest among all active intervals If add to the score mark intervals and as inactive and continue the process If stop the process At the end of this process all active intervals will intersect at least one common point Now we need to prove that the process indeed gives us the minimum possible score We can prove this by induction Let be some set of intervals and let and be the intervals defined above Consider the set i e is the set excluding and We claim that This is true because for and to intersect we must perform at least operations Our construction achieves the lower bound of Thus During the process we pair some intervals possibly none Specifically in the th step we pair the interval with the th smallest with the interval having the th largest and add the distance between them to the score In the problem G1 we can compute the contribution of each pair of intervals as follows Suppose we consider a pair Without loss of generality assume that The pair will be considered in some subset if there are exactly intervals such that and exactly intervals such that for some non negative integer Let there be intervals such that and intervals such that For to be paired in some subset we must choose intervals from the intervals on the left and intervals from the intervals on the right for some non negative integer There are no restrictions on the remaining intervals Therefore the contribution of is We can simplify this sum using the identity This is a form of the Vandermonde Identity Thus the contribution of becomes This can be computed in time Note that in the explanation above we assumed that the interval endpoints are distinct for simplicity If they are not we can order the intervals based on their values to maintain consistency "}
{"statement": "For the multiset of positive integers s s 1 s 2 dots s k define the Greatest Common Divisor GCD and Least Common Multiple LCM of s as follow gcd s is the maximum positive integer x such that all integers in s are divisible on x textrm lcm s is the minimum positive integer x that divisible on all integers from s For example gcd 8 12 4 gcd 12 18 6 6 and textrm lcm 4 6 12 Note that for any positive integer x gcd x textrm lcm x x Orac has a sequence a with length n He come up with the multiset t textrm lcm a i a j i j and asked you to find the value of gcd t for him In other words you need to calculate the GCD of LCMs of all pairs of elements in the given sequence ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "In this tutorial stands for a prime stands for the maximum of and stands for the answer if and only if there are at least integers in that if there are at most integers in that there exists so and On the contrary if there are at least integers in between every two different there will be at least one multiple of So for every Therefore Define as a set that consists of all the numbers in except So is divisible by at least numbers in Also if at least integers in we can always find According to the Observation Now consider how to calculate For every calculate and Therefore and we can get and in time Time complexity Enumerate every prime For a prime enumerate every and calculate which stands for the maximum integer that According to the Observation the second smallest is the maximum integer that Now let s optimize this solution If there has been at least two not divisible by then so just stop enumerate Time complexity of the optimized solution is because every integer can be divided for at most times "}
{"statement": "In the new messenger for the students of the Master s Assistance Center Keftemerum an update is planned in which developers want to optimize the set of messages shown to the user There are a total of n messages Each message is characterized by two integers a i and b i The time spent reading the set of messages with numbers p 1 p 2 ldots p k 1 le p i le n all p i are is calculated by the formula Large sum i 1 k a p i sum i 1 k 1 b p i b p i 1 Note that the time to read a set of messages consisting of message with number p 1 is equal to a p 1 Also the time to read an empty set of messages is considered to be 0 The user can determine the time l that he is willing to spend in the messenger The messenger must inform the user of the maximum possible size of the set of messages the reading time of which does not exceed l Note that the maximum size of the set of messages can be equal to 0 The developers of the popular messenger failed to implement this function so they asked you to solve this problem ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "SolutionLet the order in the response be Note that in the optimal response it will hold that It s not hard to prove that such an order minimizes the sum of the absolute differences of adjacent elements in the array Then this sum will turn into that is the difference between the highest and lowest value of in the set of messages Let s sort the pairs in ascending order of Fix the minimum value in the set of messages and the maximum value Note that the sum of the absolute differences of in the response will not change if taking values Thus the task reduces to finding the maximum number of messages so that Iterate over and Apply a greedy algorithm sort all values of and keep adding values until the time exceeds This solution works in which is too slow To speed up the solution while iterating over maintain a data structure that allows adding an element removing the maximum getting the maximum in C there are and In this data structure maintain the minimum values of so the sum of times does not exceed Then if the current time exceeds remove from the structure until the current time becomes no more than There will be no more than such removals We have obtained a solution in which is feasibly fast "}
{"statement": "You are given two distinct non negative integers x and y Consider two infinite sequences a 1 a 2 a 3 ldots and b 1 b 2 b 3 ldots where a n n oplus x b n n oplus y Here x oplus y denotes the bitwise XOR operation of integers x and y For example with x 6 the first 8 elements of sequence a will look as follows 7 4 5 2 3 0 1 14 ldots Note that the indices of elements start with 1 Your task is to find the length of the longest common subsegment dagger of sequences a and b In other words find the maximum integer m such that a i b j a i 1 b j 1 ldots a i m 1 b j m 1 for some i j ge 1 daggerA subsegment of sequence p is a sequence p l p l 1 ldots p r where 1 le l le r ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "SolutionConsider two numbers and such that Then consider the numbers and Let s look at the last bit of and Possible scenarios Both bits are equal to adding one will change the bits at the same positions therefore Both bits are equal to adding one will change the bits at the same positions and also add one to the next bit therefore we can similarly consider the next bit Bits are different adding one to the zero bit will only change one bit while the subsequent bit of the other number will be changed This means that It is clear that we need to maximize the number of zeros in the maximum matching suffix of and Obviously this number is equal to the maximum matching suffix of and Let be the length of the maximum matching suffix of and then the answer is This can be calculated in time for one test case where is the limit on and "}
{"statement": "You have 2n integers 1 2 dots 2n You have to redistribute these 2n elements into n pairs After that you choose x pairs and take minimum elements from them and from the other n x pairs you take maximum elements Your goal is to obtain the set of numbers b 1 b 2 dots b n as the result of taking elements from the pairs What is the number of different x s 0 le x le n such that it s possible to obtain the set b if for each x you can choose how to distribute numbers into pairs and from which x pairs choose minimum elements ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s prove that in the set minimum elements will be from pairs where we ll take minimums and analogically maximums will be from pairs where we ll take maximums By contradiction let s look at two pairs and where we will take maximum from and minimum from and if we swap elements and and get pair the result won t change but now minimum from pair will be less than maximum from So we can always make pairs in such a way that the chosen minimum from any pair will be less than the chosen maximum from any other pair Let s make set as all elements which are not in In the same way we can prove that minimums of are from pairs where we took maximums and maximums are from pairs where we took minimums Let s say and are sorted Now we ve proven that for a fixed we should pair with and with It s not hard to prove that it s optimal to pair and in the same way For a fixed we can just check that constructed pairs are valid But what happens if we move from to If for all was valid then for all pairs will be valid as well And on contrary if at least one pair wasn t valid then for the pair won t be valid as well Due to monotony we can find the maximum valid just checking only pairs and in the same way we can find maximum minimum such that all pairs are valid That s why all valid s form a segment and we need to find its borders We can find a maximum maximum with either binary search or with two pointers and print the length of the segment Time complexity is either or "}
{"statement": "There is a tale about the wise King Keykhosrow who owned a grand treasury filled with treasures from across the Persian Empire However to prevent theft and ensure the safety of his wealth King Keykhosrow s vault was sealed with a magical lock that could only be opened by solving a riddle The riddle involves two sacred numbers a and b To unlock the vault the challenger must determine the smallest key number m that satisfies two conditions m must be greater than or equal to at least one of a and b The remainder when m is divided by a must be equal to the remainder when m is divided by b Only by finding the smallest correct value of m can one unlock the vault and access the legendary treasures ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Solution Step 1 Prove that for the minimum value of we must have Step 2 To prove this show that if then will also satisfy the problem s requirements Step 3 Since if then must hold Therefore implies that satisfies the requirements Step 4 Thus must be divisible by both and The smallest such is which can be calculated in "}
{"statement": "Copying large hexadecimal base 16 strings by hand can be error prone but that doesn t stop people from doing it You ve discovered a bug in the code that was likely caused by someone making a mistake when copying such a string You suspect that whoever copied the string did not change any of the digits in the string nor the length of the string but may have permuted the digits arbitrarily For example if the original string was they may have changed it to or but not or Unfortunately you don t have access to the original string nor the copied string but you do know the length of the strings and their numerical absolute difference You will be given this difference as a hexadecimal string which has been zero extended to be equal in length to the original and copied strings Determine the smallest possible numerical value of the original string ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "First observe that for a solution to exist the sum of the digits in the input must be divisible by 15 This is because of the Casting out Nines rule but applied in base 16 Furthermore the sum of digits when divided by 15 tells us how many carries must be performed when adding the answer to the input We can try every possible set of positions for the carries of which there are at most ways Once the carries are fixed for each position we know the exact difference between the original digit in that position and the permuted digit in that position Now let s consider the permutation itself Any permutation can be decomposed into cycles Because we re looking for the minimum solution it must be the case that every cycle in the permutation contains a zero If there were a cycle without a zero we could reduce every number in the cycle by the minimum value and produce a smaller solution Furthermore because every cycle contains a common element that means the permutation can be written as a single cycle since two cycles with a common element can be merged into one cycle using that element To build such a cycle we can start at a zero and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit For each of the 2 S subsets of positions we can compute the minimum value that corresponds to a path through those positions This step is O S 2 S Side note the answer if it exists always begins with 0 There are 2 cases to consider If S begins with an f then the only possible solutions begin with a 0 Otherwise the value given by is a valid solution and starts with 0 "}
{"statement": "Jzzhu has two integers and He calls an integer point of a plane special if and Jzzhu defines a unit square as a square with corners at points where and are some integers Let s look at all the squares their sides not necessarily parallel to the coordinate axes with corners at the special points For each such square Jzzhu paints a dot in every unit square that is fully inside it After that some unit squares can contain several dots Now Jzzhu wonders how many dots he has painted on the plane Find this number modulo ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Consider there is only one query Let me descripe the picture above A grid square can be exactly contained by a bigger square which coincide with grid lines Let be the length of a side of the bigger square Let be the minimum distance between a vertice of the grid square and a vertice of the bigger square Let be the number of cells which are fully contained by the grid square We can divide a grid square into four right triangles and a center square For each right triangle the number of cells which are crossed by an edge of the triangle is Then the number of cells which are fully contained by the triangle is Firstly we enum from to Then the task is to calculate can be calculated by the following steps Enum all of the divisor of and the task is to calculate the count of where The count of where equals to Finally If there are multiple queries we can calculate the prefix sum of and then we can answer each query in "}
{"statement": "Lesha plays the recently published new version of the legendary game hacknet In this version character skill mechanism was introduced Now each player character has exactly skills Each skill is represented by a non negative integer the current skill level All skills have the same maximum level Along with the skills global ranking of all players was added Players are ranked according to the so called Force The of a player is the sum of the following values The number of skills that a character has perfected i e such that multiplied by coefficient The minimum skill level among all skills multiplied by coefficient Now Lesha has hacknetian currency units which he is willing to spend Each currency unit can increase the current level of any skill by if it s not equal to yet Help him spend his money in order to achieve the maximum possible value of the Force ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s save the original positions of skills and then sort the skills in non increasing order almost decreasing by current level We can always restore original order after Imagine that we have decided that we want to use the minimum level X and now we re choosing which skills we should bring to the maximum At first let s rise all skills below X to level X this will set some tail of array to X But the original array was sorted and this new change will not break the sort So our array is still sorted Obviously the skills we want to take to the maximum are the ones with highest current level They are in the prefix of array It is easy to show that any other selection is no better than this greedy one Now we have shown that the optimal strategy is to max out the skills in some prefix Now let s solve the problem Let s iterate over prefix to max out now on each iteration we need to know the highest minimum we can achieve let s store the index of the first element outside the prefix such that it is possible to reach the minimum level arrindex It is easy to recalc this index it slightly moves forward each turn and after precalcing the sum of all array s tails you can update it easily just move it forward until the invariant above holds And knowing this index is enough to calc the current highest possible minimum level min A arrindex sparemoney n index How to restore the answer Actually all you need to know is the count of maximums to take and minimum level to reach "}
{"statement": "On March 14 the day of the number pi is celebrated all over the world This is a very important mathematical constant equal to the ratio of the circumference of a circle to its diameter Polycarp was told at school that the number pi is irrational therefore it has an infinite number of digits in decimal notation He wanted to prepare for the Day of the number pi by memorizing this number as accurately as possible Polycarp wrote out all the digits that he managed to remember For example if Polycarp remembered pi as 3 1415 he wrote out Polycarp was in a hurry and could have made a mistake so you decided to check how many first digits of the number pi Polycarp actually remembers correctly ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "In the problem you had to find the largest common prefix LCP of the first characters of the number and the string To do this we will go from the beginning and compare the characters until we find a non matching one or until the string ends "}
{"statement": "Alice has just crafted a circuit with n lights and 2n switches Each component a light or a switch has two states on or off The lights and switches are arranged in a way that Each light is connected to switches Each switch is connected to light It s which light each switch is connected to When all switches are off all lights are also off If a switch is toggled from on to off or vice versa the state of the light connected to it will also toggle Alice brings the circuit which shows only the states of the 2n switches to her sister Iris and gives her a riddle what is the minimum and maximum number of lights that can be turned on Knowing her little sister s antics too well Iris takes no more than a second to give Alice a correct answer Can you do the same ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Observe that an even number of switch toggles on the same light will not change that light s status In other words a light is on if and only if exactly one of the two switches connecting to it is on Let s denote and as the number of off switches and on switches in the circuit We see that The maximum number of on lights is we can t achieve more than this amount since any on light decreases both and by and we can achieve this amount by matching pairs of one off switch and one on switch and the rest can be matched arbitrarily The minimum number of on lights is Since they have the same parity Then we can easily see that when both and are even we can match pairs of the same type of switches so there are no on lights in this case When both and are odd we must match one on switch with one off switch to make and even so there is one on light in this case The calculation of and can be easily done by a simple iteration over the switches Time complexity "}
{"statement": "Toad Ilya has a rooted binary tree with vertex 1 being the root A tree is a connected graph without cycles A tree is rooted if one vertex is selected and called the root A vertex u is a child of a vertex v if u and v are connected by an edge and v is closer to the root than u A leaf is a non root vertex that has no children In the tree Ilya has each vertex has children and each edge has some character written on it The character can be a lowercase English letter or the question mark Ilya will q times update the tree a bit Each update will replace exactly one character on some edge After each update Ilya needs to find if the tree is and if yes find its for each letter Well that s difficult to explain but we ll try To start with a string a is an of a string b if it is possible to rearrange letters in a without changing the letters itself so that it becomes b For example the string is an anagram of the string but the string is not an anagram of the string Consider a path from the root of the tree to a leaf The characters on the edges on this path form a string we say that this string is associated with this leaf The tree is if and only if it is possible to replace each question mark with a lowercase English letter so that for all pair of leaves the associated strings for these leaves are anagrams of each other If the tree is then its for the letter c is the maximum possible number of letters c in a string associated with some leaf in a valid replacement of all question marks Please after each update find if the tree is and if yes find the sum f c cdot ind c for all letters c where f c is the for the letter c and ind x is the index of this letter in the alphabet ind 1 ind 2 ind 26 ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "Ok let s make some useless ha ha in fact not observation at first obviously all leaves must have the same depth Now I will define the criterion for the tree to be good Let be the largest number of characters that contained on edges of some path from vertex to the leaf and be the length of a path from to the leaf Lemma tree is good iff for each vertex Obviously if the tree is good for each vertex because else you just don t have enough space in the subtree of the vertex to contain all required characters Why is it criterion If for each vertex it is satisfied from the root you can find some suitable characters on the edges from it and then it is easy to see that you can restore the children by induction Ok with this knowledge how to solve the problem Maybe some spooky tree data structures will help us Yup you can do it with the Dynamic tree DP technique with HLD and you will get the solution in even for not a binary tree But it is not very easy to realize it Let s remember that all leaves must have the same depth so I will give you another Lemma Lemma if you will compress all vertices with one son in the tree where all leaves have an equal depth then the depth of this tree will be Why let be the number of vertices on the depth then for each as each vertex at the depth should have at least one son and you have so there are distinct values among them so almost all without some values has which means that all vertices at the depth has exactly one son So with this knowledge you can compress the tree as I described and after each query just go up from the end of the changed edge and recalculate the DP Of course each edge now will have several characters on it so you should maintain a counter in each edge but it is more a realization aspect Finally here is the solution "}
{"statement": "ZS the Coder and Chris the Baboon has arrived at Udayland They walked in the park where trees grow They decided to be naughty and color the trees in the park The trees are numbered with integers from to from left to right Initially tree has color ZS the Coder and Chris the Baboon recognizes only different colors so where means that tree is ZS the Coder and Chris the Baboon decides to color only the uncolored trees i e the trees with They can color each of them them in any of the colors from to Coloring the th tree with color requires exactly litres of paint The two friends define the of a coloring of the trees as the number of contiguous groups each group contains some subsegment of trees you can split all the trees into so that each group contains trees of the same color For example if the colors of the trees from left to right are the beauty of the coloring is since we can partition the trees into contiguous groups of the same color ZS the Coder and Chris the Baboon wants to color all uncolored trees so that the beauty of the coloring is They need your help to determine the minimum amount of paint in litres needed to finish the job Please note that the friends can t color the trees that are already colored ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "We compute the following array denoting the minimum amount of paint needed to color the first trees such that it has beauty and the th tree is colored by color and initialize all these values to We can compute this dp array easily by considering two cases 1 When the last color used is equal to the current color then we should compare it with if it was originally uncolored or otherwise since the beauty of the coloring is the same 2 When the last color used is different from the current color then we should compare it with or for all except when is equal to the current color by similar reasoning If the current tree is uncolored we loop through all the possible colors to color it Naively implementing this dp will give an which is sufficient to pass for this problem However it is possible to optimize it into by avoiding iterating through all colors when considering the last color used and store two global minimums See the code for more the details Time Complexity or "}
{"statement": "Today Sakurako has a math exam The teacher gave the array consisting of a ones and b twos In an array Sakurako place either a or a in front of each element so that the sum of all elements in the array equals 0 Sakurako is not sure if it is possible to solve this problem so determine whether there is a way to assign signs such that the sum of all elements in the array equals 0 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "First of all this task is the same as divide an array into two arrays with equal sum So obviously we need to check if the sum of all elements is even which implies that the number of ones is even Then we can out half of 2s in one array and the other half in another but if number of 2s is odd then one array will have a greater sum then another so we need to put two 1s there So if we don t have two ones while the number of 2s is odd then the answer is NO Also if sum is odd the answer is also NO In all other cases the answer is YES "}
{"statement": "Little09 has been interested in magic for a long time and it s so lucky that he meets a magician The magician will perform n operations each of them is one of the following three 1 x Create a pig with x Health Points 2 x Reduce the Health Point of all living pigs by x 3 Repeat all previous operations Formally assuming that this is the i th operation in the operation sequence perform the first i 1 operations including Repeat operations involved in turn A pig will die when its Health Point is less than or equal to 0 Little09 wants to know how many living pigs there are after all the operations Please print the answer modulo 998 244 353 ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "SolutionLet Think about what Repeat is doing Assuming the total damage is is easy to calculate because it will be multiplied by after each Repeat and be added after each Attack After repeating each pig with a current HP of will clone a pig with a HP of Why Repeat will do what you just did again so each original pig will certainly create a pig the same as it and it will be attacked by so it can be considered that a pig with HP has been cloned Next the problem is to maintain a multiset which supports adding a number subtracting for all numbers and inserting each number after subtracting Find the number of positive elements in the final multiset in Repeat after the first Attack will multiply by every time so it will exceed in times That is only Repeat operations are effective So we can maintain in brute force Every time we do Repeat we take out all the numbers larger than then subtract and insert them again Note that we may do some Repeat operations when which will result in the number of pigs generated before multiplying by Therefore we also need to maintain the total multiplication If you use map to maintain it the time complexity is It can pass F1 You can also use some ways to make the time complexity "}
{"statement": "Recently Valery have come across an entirely new programming language Most of all the language attracted him with template functions and procedures Let us remind you that templates are tools of a language designed to encode generic algorithms without reference to some parameters e g data types buffer sizes default values Valery decided to examine template procedures in this language in more detail The description of a template procedure consists of the procedure name and the list of its parameter types The generic type parameters can be used as parameters of template procedures A procedure call consists of a procedure name and a list of variable parameters Let s call a procedure for this call if the following conditions are fulfilled its name equals to the name of the called procedure the number of its parameters equals to the number of parameters of the procedure call the types of variables in the procedure call match the corresponding types of its parameters The variable type matches the type of a parameter if the parameter has a generic type or the type of the variable and the parameter are the same You are given a description of some set of template procedures You are also given a list of variables used in the program as well as direct procedure calls that use the described variables For each call you need to count the number of procedures that are suitable for this call ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "In this task were given the list of template functions Each function have its name and the list of types of arguments also it can be used universal type Also there were given set of variables and thier types and some queries Each query is function which has name and list of arguments For each query you had to find how many functions from the given list fit to the function from query There fit means that functions have the same name same number of arguments and types of all arguments also equal For solving this problem it is needed to implement comparing of functions Constrains gave the possibility to brute force function from the given list and check if the names and arguments of functions are equal "}
{"statement": "You are given n integers a 1 a 2 ldots a n Is it possible to arrange them on a circle so that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors In other words check if there exists a rearrangement b 1 b 2 ldots b n of the integers a 1 a 2 ldots a n such that for each i from 1 to n at least one of the following conditions holds b i 1 b i b i 1 b i 1 b i b i 1 To make sense of the previous formulas for i 1 and i n one shall define b 0 b n and b n 1 b 1 ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s call local minimum if and local maximum if It s clear that in the arrangement satisfying the conditions from the statement if is a local minimum is a local maximum and vice versa Local minimums and local maximums will be alternating Then it s easy to see that such an arrangement can t exist for odd Indeed suppose that the conditions from the statement are satisfied for If we suppose that is local minimum we get that is local maximum is local minimum is local minimum is local maximum Clearly can t be a local maximum and a local minimum at the same time leading to a contradiction Let s now consider the case of even Sort the array so that Let s show that if for some then there is no arrangement satisfying the conditions from the statement Indeed consider such an arrangement we have numbers and no two of them can be adjacent so they occupy every second position In addition as local maximums and local minimums are alternating we get that all are local maximums or all are local minimums The first would imply that which isn t possible The second would imply that which isn t possible It turns out that if there is no such the arrangement exists Indeed we can arrange numbers on the circle in the following order Here for for and "}
{"statement": "One day Vasya got hold of information on the Martian dollar course in bourles for the next days The buying prices and the selling prices for one dollar on day are the same and are equal to Vasya has bourles He can buy a certain number of dollars and then sell it no more than once in days According to Martian laws one can buy only an integer number of dollars Which maximal sum of money in bourles can Vasya get by the end of day ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Since number of days is very small 2 103 we can just iterate over all possibilities of buy day and sell day This will take n2 time which is OK "}
{"statement": "Polycarp has an array of n n is even integers a 1 a 2 dots a n Polycarp conceived of a positive integer k After that Polycarp began performing the following operations on the array take an index i 1 le i le n and reduce the number a i by k After Polycarp performed some possibly zero number of such operations it turned out that numbers in the array became the same Find the maximum k at which such a situation is possible or print 1 if such a number can be arbitrarily large ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "can be arbitrarily large if and only if all numbers in the array are the same In this case we can choose any number and subtract it from all the numbers for example exactly once Suppose we fix some Let be the number of subtractions of the number from the number In this case all numbers will be equal if and only if for any two numbers and from the array Let be the minimum of Then all numbers in the array become the same if for each index we subtract from not but times Then we will never subtract from the element This means that there is always an element in the array from which we can never subtract This element is the minimum on the array Then from we will subtract exactly times Thus with the current it is possible to make all elements equal if and only if for all elements the value where is the minimum on the array is divisible by So the maximum is the greatest common divisor of all values of "}
{"statement": "Consider a sequence of digits of length 2 k a 1 a 2 ldots a 2 k We perform the following operation with it replace pairs a 2i 1 a 2i 2 with a 2i 1 a 2i 2 bmod 10 for 0 le i 2 k 1 For every i where a 2i 1 a 2i 2 ge 10 we get a candy As a result we will get a sequence of length 2 k 1 Less formally we partition sequence of length 2 k into 2 k 1 pairs each consisting of 2 numbers the first pair consists of the first and second numbers the second of the third and fourth ldots the last pair consists of the 2 k 1 th and 2 k th numbers For every pair such that sum of numbers in it is at least 10 we get a candy After that we replace every pair of numbers with a remainder of the division of their sum by 10 and don t change the order of the numbers Perform this operation with a resulting array until it becomes of length 1 Let f a 1 a 2 ldots a 2 k denote the number of candies we get in this process For example if the starting sequence is 8 7 3 1 7 0 9 4 then After the first operation the sequence becomes 8 7 bmod 10 3 1 bmod 10 7 0 bmod 10 9 4 bmod 10 5 4 7 3 and we get 2 candies as 8 7 ge 10 and 9 4 ge 10 After the second operation the sequence becomes 5 4 bmod 10 7 3 bmod 10 9 0 and we get one more candy as 7 3 ge 10 After the final operation sequence becomes 9 0 bmod 10 9 Therefore f 8 7 3 1 7 0 9 4 3 as we got 3 candies in total You are given a sequence of digits of length n s 1 s 2 ldots s n You have to answer q queries of the form l i r i where for i th query you have to output f s l i s l i 1 ldots s r i It is guaranteed that r i l i 1 is of form 2 k for some nonnegative integer k ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Claim f a1 a2 a2k a1 a2 a2k10 Clearly using it we can answer queries in O 1 if we create array prefsum in which prefsum i a1 ai Proof of claim Imagine that candy is equal to number 10 Then sum of all numbers doesn t change when we replace a b a b mod10 we take 10 iff a b exceeds a b mod10 Also note that sum of numbers candies is divisible by 10 because we take only tens Then in the end the remaining digit is equal to the remainder of the division of the initial sum by 10 so the number of candies is equal to the quotient "}
{"statement": "Polycarp has a favorite sequence a 1 dots n consisting of n integers He wrote it out on the whiteboard as follows he wrote the number a 1 to the left side at the beginning of the whiteboard he wrote the number a 2 to the right side at the end of the whiteboard then as far to the left as possible but to the right from a 1 he wrote the number a 3 then as far to the right as possible but to the left from a 2 he wrote the number a 4 Polycarp continued to act as well until he wrote out the entire sequence on the whiteboard For example if n 7 and a 3 1 4 1 5 9 2 then Polycarp will write a sequence on the whiteboard 3 4 5 2 9 1 1 You saw the sequence written on the whiteboard and now you want to restore Polycarp s favorite sequence ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "In this problem you can implement an algorithm opposite to that given in the condition Let s maintain two pointers to the left most and right most unhandled element Then restoring the original array you put the left most unhandled item in the first position put the right most unhandled item in the second position put the left most unhandled item in the third position put the right most unhandled item in the fourth position That is in general you put the leftmost elements on all odd positions and the rightmost ones on all even positions After processing each element you either move the left pointer forward by one or the right one backward by one "}
{"statement": "Alice and Bob play a game The game consists of several sets and each set consists of several rounds Each round is won either by Alice or by Bob and the set ends when one of the players has won x rounds in a row For example if Bob won five rounds in a row and x 2 then two sets ends You know that Alice and Bob have already played n rounds and you know the results of some rounds For each x from 1 to n calculate the maximum possible number of sets that could have already finished if each set lasts until one of the players wins x rounds in a row It is possible that the last set is still not finished in that case you should not count it in the answer ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Let s consider the following function minimum index such that there is a substring of string of length consisting of only characters and or and If this function has asymptotic then we can solve problem for Now let s precalculate two array and is equal the maximum integer such that substring consist only characters and is equal the maximum integer such that substring consist only characters and Also let s precalculate the arrays and of size contain all positions such that substring consist only characters and and or contain all positions such that substring consist only characters and and or After that let s solve problem for some Suppose that now we already processed first elements of If or then we increase the answer and change Otherwise we have to find the minimum element denote this element as in or such that If there is no such element then we found the final answer Otherwise let s increase answer and change and continue this algorithm "}
{"statement": "One day three best friends Petya Vasya and Tonya decided to form a team and take part in programming contests Participants are usually offered several problems during programming contests Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution Otherwise the friends won t write the problem s solution This contest offers problems to the participants For each problem we know which friend is sure about the solution Help the friends find the number of problems for which they will write a solution ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "It is needed just to implement actions described in statement You had to read data and to calculate number of members of team which were sure about the solution for every task If this number is greater than one the answer must be increased by one "}
{"statement": "It s hard times now Today Petya needs to score 100 points on Informatics exam The tasks seem easy to Petya but he thinks he lacks time to finish them all so he asks you to help with one There is a glob pattern in the statements a string consisting of lowercase English letters characters and It is known that character occurs in the pattern Also query strings are given it is required to determine for each of them if the pattern matches it or not Everything seemed easy to Petya but then he discovered that A pattern matches a string if it is possible to replace each character with one lowercase English letter and the character if there is one with any including empty string of lowercase English letters so that the resulting string is the same as the given string The good letters are given to Petya All the others are bad ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "If pattern doesn t contain to match pattern it s neccesary that string s size is equal to pattern size all letters in pattern match with the letters in string and in the positions on which pattern contains the string contains good characters If pattern contains split it into two strings contains all characters before and after it Note that string doesn t match pattern if it s size is less than Split the string into three is prefix of size is suffix of size and is the remaining substring The string mathes pattern if matches matches and contains only bad characters Obviously that we can make all checks in time of Final asymptotics is "}
{"statement": "You are given a permutation p 1 p 2 dots p n of 1 2 dots n You can perform the following operation some possibly 0 times choose a subarray l r of even length swap a l a l 1 swap a l 2 a l 3 if l 3 leq r dots swap a r 1 a r Sort the permutation in at most 10 6 operations You do not need to minimize the number of operations ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "SolutionLet s only perform operations such that all swapped pairs have Let s call such subarrays swappable First for each from left to right do the operation on where is the minimum index such that is swappable let s call it operation Then for each from right to left do the operation on where is the minimum index such that is swappable let s call it operation After these operations the array is sorted Let s prove it Assign to the indices such that and to the other indices After operation only assign letters in the prefix and ignore the other elements During the operations assign letters to all the elements Most of the following proofs are by induction After the operation supposing the properties were true after the operation An element of type will always remain of type Proof the only elements of type whose previous element changes are the ones in the subarray which are swapped with a smaller element of type There are no two consecutive elements of type Proof if you swap if it exists must be of type otherwise is swappable The elements of type are increasing Proof it s true if no become and it s also true if some become because any of them is adjacent to two After the operation The three properties above are still true The suffix contains the values in in order Proof is an so it must be the largest in which is Now let s understand how we can implement the algorithm Example implementation We maintain a segment tree The th position of the segment tree contains information about the element which was initially Note that the relative position of never changes for example if you want information about the last in the current permutation and you search them in the segment tree you will find exactly the last even though their indices will not correspond to the current indices We have to find the longest swappable subarray ending at It means we need the current positions of the For each maintain the current position and assume the position of all the is Also maintain for each element if it is a or not Note that the that are affected by each operation can be found in a suffix of the segment tree In this way finding the longest swappable subarray can be done with a binary search on the segment tree since cannot be consecutive you have to find the longest suffix such that the sum of the positions of the is the maximum possible i e if there are and the last of them is in position the sum of their positions must be After finding the longest subarray in the segment tree you have to perform the operation on it i e subtract from all the nonzero positions Some may become How to detect them Since never become a becomes after it is swapped with all the elements greater than it on its left So you can precompute the number of swaps that every needs to become and put it in the segment tree as well Again the operation is subtract from a range Detecting means detecting elements which need swaps to become You can find them after each operation by traversing the segment tree which must support range min on the number of swaps needed and set their position to and the number of swaps needed to Complexity moves time "}
{"statement": "Monocarp plays a computer game called Goblins and Gnomes In this game he manages a large underground city of gnomes and defends it from hordes of goblins The city consists of n halls and m one directional tunnels connecting them The structure of tunnels has the following property if a goblin leaves any hall he cannot return to that hall The city will be attacked by k waves of goblins during the i th wave i goblins attack the city Monocarp s goal is to pass all k waves The i th wave goes as follows firstly i goblins appear in some halls of the city and pillage them Then goblins start moving along the tunnels pillaging all the halls in their path Goblins are very greedy and cunning so they choose their paths so that no two goblins pass through the same hall Among all possible attack plans they choose a plan which allows them to After goblins are done pillaging they leave the city If all halls are pillaged during the wave Monocarp loses the game Otherwise the city is restored If some hall is pillaged during a wave goblins are still interested in pillaging it during the next waves Before each wave Monocarp can spend some time preparing to it Monocarp doesn t have any strict time limits on his preparations he decides when to call each wave by himself but the longer he prepares for a wave the fewer points he gets for passing it If Monocarp prepares for the i th wave for t i minutes then he gets max 0 x i t i cdot y i points for passing it obviously if he doesn t lose in the process While preparing for a wave Monocarp can block tunnels He can spend one minute to If Monocarp blocks a tunnel while preparing for a wave it stays blocked during the next waves as well Help Monocarp to defend against all k waves of goblins and get the maximum possible amount of points ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "First of all let s try to solve the following problem given a DAG cover its vertices with the minimum number of vertex disjoint paths Solving this problem allows us to calculate the number of goblins that can pillage all of the halls when the tunnel network is fixed This problem is a fairly classical one since the number of vertices in each path is greater than the number of arcs in it exactly by we should take the maximum possible number of arcs into our paths So we can reduce this problem to bipartite maximum matching build a bipartite graph where each part consists of vertices and for every directed arc in the original graph connect the vertex of the left part to the vertex in the right part of the bipartite graph The maximum matching in this graph allows us to pick the maximum number of arcs into the paths of the original problem the matching ensures that each vertex has at most one chosen ingoing arc and at most one chosen outgoing arc so the paths are vertex disjoint Okay now we at least can check if the goblin wave can pillage all of the halls Let s say that the minimum number of goblins required to pillage the original city is Obviously in order to pass the th wave and waves after it we have to increase this number In one minute Monocarp can block all of the tunnels leading to some hall or out of some hall and in terms of our reduction to the bipartite matching problem it means that we remove all edges connected to some vertex of the bipartite graph Obviously in one minute we can increase by at most since is equal to the difference between and the maximum matching size It turns out that it s always possible to choose a vertex that belongs to all maximum matchings in the bipartite graph note that it doesn t work in non bipartite graphs but in our problem it doesn t matter For the proof of this fact you can check the last paragraph of the editorial So each minute Monocarp prepares for a wave he increases the maximum number of goblins he can repel by Now the solution splits into two much easier parts The first part is finding a sequence in which Monocarp blocks the tunnels so that each his action reduces the size of the maximum matching by Since the constraints are small even a naive approach in always iterate on the vertex we try to remove from the graph and check that removing it is possible by running Kuhn s algorithm is fast enough The second part is to choose when Monocarp calls waves of goblins and when he prepares for them this can be easily done with dynamic programming let be the maximum Monocarp s score if he has already passed waves and the current size of the maximum matching is The most naive implementation of this dynamic programming runs in so the whole solution works in We can improve it to though it is not needed under these constraints Instead of finding the vertices to remove from the bipartite graph one by one let s find all of them at once in Recall that the size of maximum matching in a bipartite graph is equal to the size of its minimum vertex cover and the minimum vertex cover can be reconstructed after finding the maximum matching If we remove a vertex from the minimum vertex cover the size of the minimum vertex cover of the remaining graph is reduced by so the size of the maximum matching is reduced by as well It means that we can always choose to remove a vertex from the minimum vertex cover we found By the way it also proves that it s always possible to remove a vertex from a bipartite graph so the size of the maximum matching decreases by obviously if it s not already "}
{"statement": "There are n players labelled from 1 to n Among them there are k impostors and n k crewmates The number of impostors k is not given to you In each question you can choose three distinct integers a b c 1 le a b c le n and ask Among the players labelled a b and c are there more impostors or more crewmates You will be given the integer 0 if there are more impostors than crewmates and 1 otherwise Find the number of impostors k and the indices of players that are impostors after asking at most n 6 questions The jury is which means the indices of impostors may not be fixed beforehand and can depend on your questions It is guaranteed that there is at least one set of impostors which fulfills the constraints and the answers to your questions at any time ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Thanks must be given to arvindf232 and generic placeholder name for the solution Solution Step 1 Firstly query Due to the constraint among the results of these queries there must be at least one and one Now let s call a tuple that returns a majority tuple and vice versa From the easy version notice that finding one crewmate and one impostor is very helpful in determining the roles of the remaining players Let s make use of the above observation and pick one adjacent majority tuple and majority tuple Let s say we picked and Then we query and Among the four queries there must be a pair of adjacent queries with different results From the easy version we can directly find the index of an impostor and a crewmate In all the above cases we end up knowing an impostor and a crewmate using queries including the first step "}
{"statement": "There are three cards with letters texttt a texttt b texttt c placed in a row in some order You can do the following operation Pick two cards and swap them Is it possible that the row becomes texttt abc after the operation Output if it is possible and otherwise ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "There are only possible input strings and they are all given in the input so you can just output if is or and otherwise Another way to solve it is to count the number of letters in the wrong position A swap changes letters so if at most two letters are in the wrong position then it s possible otherwise it s not possible Of course you can also brute force all possible swaps and check if it works "}
{"statement": "Gildong owns a bulgogi restaurant The restaurant has a lot of customers so many of them like to make a reservation before visiting it Gildong tries so hard to satisfy the customers that he even memorized all customers preferred temperature ranges Looking through the reservation list he wants to satisfy all customers by controlling the temperature of the restaurant The restaurant has an air conditioner that has 3 states and When it s the restaurant s temperature remains the same When it s the temperature increases by 1 in one minute Lastly when it s the temperature decreases by 1 in one minute Gildong can change the state as many times as he wants at any integer minutes The air conditioner is initially Each customer is characterized by three values t i the time in minutes when the i th customer visits the restaurant l i the lower bound of their preferred temperature range and h i the upper bound of their preferred temperature range A customer is satisfied if the temperature is within the preferred range at the instant they visit the restaurant Formally the i th customer is satisfied if and only if the temperature is between l i and h i inclusive in the t i th minute Given the initial temperature the list of reserved customers visit times and their preferred temperature ranges you re going to help him find if it s possible to satisfy all customers ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Since the range of temperatures can be large it is impossible to consider all possible cases However we only need to find case that can satisfy all customers so let s try to maximize the possible range for each customer in the order of their visit time Let s define two variables and each representing the minimum and maximum possible temperature that can be set now Initially they are both and the current time is After minutes we can see that the possible range is This means if a customer that visits after minutes has preferred temperature range that intersects with this range inclusive Gildong can satisfy that customer In other words and must be satisfied Then we can reset and to fit this intersected range and If this can be continued until the last customer the answer is YES Otherwise the answer is NO Time complexity for each test case "}
{"statement": "After long term research and lots of experiments leading Megapolian automobile manufacturer AutoVoz released a brand new car model named Lada Malina One of the most impressive features of Lada Malina is its highly efficient environment friendly engines Consider car as a point in plane Car is equipped with engines numbered from to Each engine is defined by its velocity vector whose coordinates are measured in distance units per day An engine may be turned on at any level that is a real number between and inclusive that result in a term of in the final car velocity Namely the final car velocity is equal to Formally if car moves with constant values of during the whole day then its coordinate will change by the first component of an expression above and its coordinate will change by the second component of an expression above For example if all are equal to zero the car won t move and if all are equal to zero except then car will move with the velocity of the first engine There are factories in Megapolia th of them is located in On the th factory there are cars Lada Malina that are ready for operation As an attempt to increase sales of a new car AutoVoz is going to hold an international exposition of cars There are options of exposition location and time in the th of them exposition will happen in a point with coordinates in days Of course at the AutoVoz is going to bring as much new cars from factories as possible to the place of exposition Cars are going to be moved by enabling their engines on some certain levels such that at the beginning of an exposition car gets exactly to the exposition location However for some of the options it may be impossible to bring cars from some of the factories to the exposition location by the moment of an exposition Your task is to determine for each of the options of exposition location and time how many cars will be able to get there by the beginning of an exposition ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3400", "problem_editorial": "In the original contest there were subtasks for this problem and it s more convinient to understand the editorial going through these subtasks so we will leave them here The key part of a solution is to understand what are the locations that may be accessed from the origin in seconds First observation is that we should investigate it only in case when because is simply a scale factor Let s denote this set for as For the first group it s easy to see that P is a square with vertices in points So the first group may be solved with a straightforward approach we iterate through all the factories and check if it s possible to get for cars from th factories to the car exposition We can rotate the plane by degrees this may be done by the transformation after this each query region looks like a square Therefore it s necessary to check if point lies inside a square In the second group propeller velocities are two arbitrary vectors It can be shown that will always be a parallelogram centered in the origin built on vectors and as sides Thus this group is a matter of the same approach with a bit more complicated predicate one should be able to check that an integer point belongs to an integer parallelogram The key observation is that we may find an appropriate transformation of a plane that transforms this set into a rectangle Indeed there always exists an affine transformation performing what we want As an additional requirement we want to transform coordinates in such way that they are still integral and not much larger than the original coordinates The transformation looks like following The first expression is a signed distance to the line parallel to the vector and the second one is the signed distance from the line parallel to the vector Easy to see that belonging to some query parallelogram can be formulated in terms of and independendly belonging to some ranges Second group should be a hint for the third group One can find that the set is always a central symmetric polygon with the center in the origin Actually this Polygon is a Minkowski sum of segments Minkowski sum of sets is by definition the following set It can be built in time although in this problem is very small so one may use any inefficient approach that comes into his head like building a convex hull of all points After we found out a form of it s possible to solve the third group of tests in by checking if each possible factory location belongs into a query polygon in time Following groups are exactly the same but the constraints are higher they require using some geometric data structure to deal with range queries Fourth group and fifth group are very similar to first and second group correspondingly but we need to process the requests faster After the transformation of the plane the request can be reformulated as find sum of all factories inside a square so any 2d data structure may be applied like a segment tree of segment trees Another approach is to use a sweeping line algorithm with a segment tree or an appropriate binary search tree achieving a time complexity or To solve the sixth group we need to use a trapezoidal polygon area calculation algorithm applied to our problem Calculate the sum of points in each of trapezoid areas below each of the sides of a polygon and then take them with appropriate signs to achieve a result Such trapezoid area can be seen as a set of points satisfying the inequalities and Under transformation this area becomes a rectangle leading us to an time solution "}
{"statement": "An expedition group flew from planet ACM 1 to Earth in order to study the bipedal species its representatives don t even have antennas on their heads The flying saucer on which the brave pioneers set off consists of three sections These sections are connected by a chain the 1 st section is adjacent only to the 2 nd one the 2 nd one to the 1 st and the 3 rd ones the 3 rd one only to the 2 nd one The transitions are possible only between the adjacent sections The spacecraft team consists of aliens Each of them is given a rank an integer from to The ranks of all astronauts are distinct The rules established on the Saucer state that an alien may move from section to section only if it is senior in rank to all aliens who are in the segments and besides the segments and are of course required to be adjacent Any alien requires exactly minute to make a move Besides safety regulations require that no more than one alien moved at the same minute along the ship Alien is senior in rank to alien if the number indicating rank is more than the corresponding number for At the moment the whole saucer team is in the 3 rd segment They all need to move to the 1 st segment One member of the crew the alien with the identification number CFR 140 decided to calculate the minimum time in minutes they will need to perform this task Help CFR 140 figure out the minimum time in minutes that all the astronauts will need to move from the 3 rd segment to the 1 st one Since this number can be rather large count it modulo ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let Fn be the answer for the task where n is equal to the amount of aliens Let s assume that we ve solved problem for n 1 aliens i e we know the value of Fn 1 Let s try to find value of Fn Notice that the most junior alien in rank will be able to leave the 3rd section if and only if all other aliens are in the 1st section So now we know first Fn 1 actions Then the most junior alien may go to the 2nd section To make for him entrance to the 1st section possible it s necessary for all other aliens to return to the first one So Fn 1 more actions are necessary At last after the most junior alien will go to the 1st section Fn 1 more actions are required for n 1 other aliens to return to the 1st section from the 3rd So Fn Fn 1 1 Fn 1 1 Fn 1 It allows to count Fn using matrix exponentiation in O log n but we ll improve current solution Let s add 1 to both parts of the equality and after elementary operations we ll have Fn 3 Fn 1 1 1 Now it s easy to solve this reccurence Fn 3n 1 To count Fn quickly you should use binary power method Solution s complexity O log n Don t forget that if 3n mod m 0 answer is equal to m 1 but not 1 And in conclusion notice that the task is equal to Hanoi Towers problem with a slight modification it s impossible to move disks between one pair of rods "}
{"statement": "You are given an integer sequence a 1 a 2 ldots a n Let S be the set of all possible non empty subsequences of a without duplicate elements Your goal is to find the longest sequence in S If there are multiple of them find the one that minimizes lexicographical order after multiplying terms at odd positions by 1 For example given a 3 2 3 1 S 1 2 3 2 1 2 3 3 1 3 2 2 3 1 3 2 1 Then 2 3 1 and 3 2 1 would be the longest and 3 2 1 would be the answer since 3 2 1 is lexicographically smaller than 2 3 1 A sequence c is a subsequence of a sequence d if c can be obtained from d by the deletion of several possibly zero or all elements A sequence c is lexicographically smaller than a sequence d if and only if one of the following holds c is a prefix of d but c ne d in the first position where c and d differ the sequence c has a smaller element than the corresponding element in d ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Consider subtask Let s ignore the constraint where b should be lexicographically smallest How can we find the length of b Apparently it is the number of distinct elements in a Let s call it k Construct b from left to right without worsening the answer Now we know how to find the maximum possible length of b Let s try to construct b from left to right without worsening the answer and greedily minimize its lexicographical order Assume we pick a i as the j th element in b then there should be k j distinct elements in the subarray a i 1 n after deleting all elements that appear in the subarray b 1 j Assume we already construct b 1 b 2 ldots b j where b j a i and we want to find b j 1 and let l x be the last position where x occurs in the subarray a i 1 n or infty if it doesn t exist then we can choose anything in a i 1 min limits 1 le x le n l x And to minimize lexicographical order we need to choose the maximum element in it if j 1 is odd or the minimum element otherwise If there are multiple of them choose the leftmost one of them is optimal since we would have a longer suffix of a for future construction Then observe for the candidate window i e a i 1 min limits 1 le x le n l x its left bound and right bound are non decreasing so we can use priority queues or set to maintain all possible candidates by storing a pos pos and another priority queue or set to maintain all l x i And the total time complexity is O nlgn "}
{"statement": "You are given two integers and Find th smallest divisor of or report that it doesn t exist Divisor of is any such natural number that can be divided by it without remainder ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "If you find all the small divisors of n that are less than sqrt n you can find the rest of them dividing n by the small ones "}
{"statement": "Vasya is sitting on an extremely boring math class To have fun he took a piece of paper and wrote out numbers on a single line After that Vasya began to write out different ways to put pluses in the line between certain digits in the line so that the result was a correct arithmetic expression formally no two pluses in such a partition can stand together between any two adjacent pluses there must be at least one digit and no plus can stand at the beginning or the end of a line For example in the string ways add no pluses or are correct and ways or are incorrect The lesson was long and Vasya has written all the correct ways to place exactly pluses in a string of digits At this point he got caught having fun by a teacher and he was given the task to calculate the sum of all the resulting arithmetic expressions by the end of the lesson when calculating the value of an expression the leading zeros should be ignored As the answer can be large Vasya is allowed to get only its remainder modulo Help him ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Consider some way of placing all the pluses and a single digit di digits in the string are numbered starting from 0 from left to right This digit gives input of di 10l to the total sum where l is the distance to the nearest plus from the right or to the end of string if there are no pluses there If we sum up these quantities for all digits and all ways of placing the pluses we will obtain the answer For a given digit di and some fixed l how many ways are there to place the pluses First of all consider the case when the part containing the digit di is not last that is i l n 1 There are n 1 gaps to place pluses in total the constraint about di and the distance l means that after digits di di l 1 there are no pluses while after the digit di l there should be a plus That is the string should look as follows Here a dot means a gap without a plus and a question mark means that it s not important whether there is a plus or not So out of n 1 possible gaps there are l 1 gaps which states are defined and there is one plus used in these gaps That means that the other n 1 l 1 n l 2 gaps may contain k 1 pluses in any possible way that is the number of such placements is A similar reasoning implies that if the digit di is in the last part that is i l n 1 the number of placements is To sum up the total answer is equal to Let us transform the sum To compute these sums we will need to know all powers of 10 up to n th modulo 109 7 along with the binomial coefficients To compute the binomials recall that so it is enough to know all the numbers k for k upto n along with their modular inverses Also we should use the prefix sums of di that is the array The rest is simple evaluation of the above sums The total complexity is because the common algorithms for modular inverses that is Ferma s little theorem exponentiation or solving a diophantine equation using the Euclid s algorithm have theoritcal worst case complexity of However one can utilize a neat trick for finding modular inverses for first n consecutive numbers in linear time for a total complexity of O n for the description of the method refer to this comment by Kaban 5 not sure why it has a negative rating I found this quite insightful maybe anyone can give a proper source for this method "}
{"statement": "After a probationary period in the game development company of IT City Petya was included in a group of the programmers that develops a new turn based strategy game resembling the well known Heroes of Might Magic A part of the game is turn based fights of big squadrons of enemies on infinite fields where every cell is in form of a hexagon Some of magic effects are able to affect several field cells at once cells that are situated not farther than cells away from the cell in which the effect was applied The distance between cells is the minimum number of cell border crosses on a path from one cell to another It is easy to see that the number of cells affected by a magic effect grows rapidly when increases so it can adversely affect the game performance That s why Petya decided to write a program that can given determine the number of cells that should be repainted after effect application so that game designers can balance scale of the effects and the game performance Help him to do it Find the number of hexagons situated not farther than cells away from a given cell ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s count the number of cells having the distance of exactly n For n 0 it is 1 for n 1 it is 6 for n 2 it is 12 for n 3 it is 18 and so on One can notice that n 0 is a special case and then the amount increases by addition of 6 These numbers form an arithmetic progression In the problem we need to sum these numbers The formula of the sum of an arithmetic progression is first last amount 2 The first is 6 the last is 6n the amount is n So the sum is 6 6n n 2 3 n 1 n And plus 1 that is not in the arithmetic progression So the final formula is 1 3n n 1 To avoid overflow multiplication in the formula should be performed in 64 bit integer type For this either 3 or 1 or n should have 64 bit integer type The literals are 64 bit integer when they have suffix L in Java or LL in C "}
{"statement": "Mahmoud has an array consisting of integers He asked Ehab to find another array such that is lexicographically greater than or equal to is pairwise coprime for every and are coprime i e where is the greatest common divisor of and Ehab wants to choose a special array so he wants the lexicographically minimal array between all the variants Can you find it An array is lexicographically greater than an array if there exists an index such than and for all An array is equal to an array if for all ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Common things Let s call a number ok if it could be inserted to array as a new element without breaking any of the conditions i e it should be coprime with all the previously inserted elements Let s call the maximum number that could be inserted in the worst case For each integer from 2 to we ll precompute its prime divisors with sieve "}
{"statement": "Hosssam decided to sneak into Hemose s room while he is sleeping and change his laptop s password He already knows the password which is a string s of length n He also knows that there are k letters of the alphabet c 1 c 2 ldots c k Hosssam made a program that can do the following The program considers the current password s of some length m Then it finds all positions i 1 le i m such that s i 1 is one of the k special letters Then it deletes all of those positions from the password s If there are no positions to delete then the program displays an error message which has a very loud sound For example suppose the string s is and the special characters are and If he runs the program once the positions 1 and 3 will be deleted as they come before special characters so the password becomes If he runs the program again it deletes position 1 and the password becomes If he is wise he won t run it a third time Hosssam wants to know how many times he can run the program on Hemose s laptop without waking him up from the sound of the error message Can you help him ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s consider the non special characters as 0 and special characters as 1 since they are indistinguishable So now the problem is that we have a binary string where each 1 character removes the character before it each time the program is run The trivial case is when there is only one 1 character the answer then is just the number of 0 characters before it But what if there is more than one 1 character lets take for example when there are two 1 characters as follows The observation here is that when the first 1 character from the right reached the second 1 it acts as if it just replaced its place so we can say that each 1 character replaces another 1 as soon as it reaches it So we can partition the binary string into small partitions where each partition contains only one 1 character that is the rightmost character in the partition For example the string can be partitioned into We first calculate the amount of time each partition requires to remove all the 0 characters before it which is basically the number of 0 characters before it Each partition except for the first partition requires one more second to replace the 1 character in the previous partition So the answer is the maximum time required among all the partitions "}
{"statement": "Vasya has a sequence a consisting of n integers a 1 a 2 dots a n Vasya may pefrom the following operation choose some number from the sequence and swap any pair of bits in its binary representation For example Vasya can transform number 6 dots 00000000110 2 into 3 dots 00000000011 2 12 dots 000000001100 2 1026 dots 10000000010 2 and many others Vasya can use this operation any possibly zero number of times on any number from the sequence Vasya names a sequence as one if using operation mentioned above he can obtain the sequence with bitwise exclusive or of all elements equal to 0 For the given sequence a 1 a 2 ldots a n Vasya d like to calculate number of integer pairs l r such that 1 le l le r le n and sequence a l a l 1 dots a r is good ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Since we can swap any pair of bits in the number so all we need to know is just the number of ones in its binary representation Let create array b1 b2 bn where bi is number of ones in binary representation of ai Forget about array a we will work with array b Let s find a way to decide whether fixed segment is good or not It can be proven that two conditions must be met At first sum of bi at this segment should be even At second maximal element should be lower or equal to the sum of all other elements We will iterate over left borders of subsegments in descending order and for each left border l calculate number of right borders r such that l r is good Let s as first forget about condition on maximum and calculate cntAll l number of right borders r such that sum on segment l r is even and left border l is fixed We can calculate it by counting S0 and S1 the number of suffixes of array with even sum of bi and number of suffixes with odd sum If the current sum i lnbi is even then cntAll l S0 since i lrbi i lnbi i r 1nbi If i lnbi is odd then cntAll l S1 Since we forgot about condition on maximum some bad segments were counted Since ai 1018 then bi 61 That s why if length of the segment 61 condition on the maximum is always true So for a fixed l we can iterate over all right borders in the l l 61 and subtract number of segments with even sum and too large maximum since these segments were counted in the answer "}
{"statement": "One day Alex was creating a contest about his friends but accidentally deleted it Fortunately all the problems were saved but now he needs to find them among other problems But there are too many problems to do it manually Alex asks you to write a program which will determine if a problem is from this contest by its name It is known that problem is from this contest if and only if its name contains one of Alex s friends name His friends names are and ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "You need just implement what is written in the statements Count the total number of entries of the names and check if it s equal to "}
{"statement": "Vasya s telephone contains photos Photo number 1 is currently opened on the phone It is allowed to move left and right to the adjacent photo by swiping finger over the screen If you swipe left from the first photo you reach photo Similarly by swiping right from the last photo you reach photo It takes seconds to swipe from photo to adjacent For each photo it is known which orientation is intended for it horizontal or vertical Phone is in the vertical orientation and be rotated It takes second to change orientation of the photo Vasya has seconds to watch photos He want to watch as many photos as possible If Vasya opens the photo for the first time he spends second to notice all details in it If photo is in the wrong orientation he spends seconds on rotating it before watching it If Vasya has already opened the photo he just skips it so he doesn t spend any time for watching it or for changing its orientation It is not allowed to skip unseen photos Help Vasya find the maximum number of photos he is able to watch during seconds ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "What photos we will see in the end Some number from the beginning of the gallery and some from the end There are 4 cases First two cases are straightforward we can just emulate them Third and fourth cases can be done with the method of two pointers Note that if we see one more picture to the right we spend more time on the right side and the number of photos seen to the left will decrease This solution will run in Alternative solution is to fix how many photos we ve seen to the right and search how many we can see to the left with binary search For this method we will need to precompute times of seeing pictures to the right and to the left But this is solution is which is slightly worse then previous one but maybe it is easier for somebody "}
{"statement": "Wave is given five integers k l 1 r 1 l 2 and r 2 Wave wants you to help her count the number of ordered pairs x y such that all of the following are satisfied l 1 leq x leq r 1 l 2 leq y leq r 2 There exists a non negative integer n such that frac y x k n ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Problem Credits Proof by QED Lilypad Analysis macaquedev chromate00 Solution 1 Binary Search Clearly trying to bruteforce over all possible values of or is too slow because the bounds are However there is another variable that you can actually bruteforce over and that is This is because exponentiation famously makes numbers very big very quickly and if we set as small as possible i e we only need to check This is because so there cannot possibly be any solutions for for any Now let s rephrase the problem We need to find pairs such that Now we can check every value of from to and for each binary search to find the smallest such that fits the conditions and the largest Now we can subtract these two values and add this to the answer "}
{"statement": "Tina has a square grid with n rows and n columns Each cell in the grid is either 0 or 1 Tina wants to reduce the grid by a factor of k To do this Tina splits the grid into k times k nonoverlapping blocks of cells such that every cell belongs to exactly one block Tina then replaces each block of cells with a single cell equal to the value of the cells in the block For example the following demonstration shows a grid being reduced by factor of 3 000111000111000111111000111000111000 0110 Help Tina reduce the grid by a factor of k ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s define every k by k block of cells by its value in the top left corner since all cells in the block must have the same value So we can just print out the value of the cell in every k th row and every k th column "}
{"statement": "Tired of boring office work Denis decided to open a fast food restaurant On the first day he made a portions of dumplings b portions of cranberry juice and c pancakes with condensed milk The peculiarity of Denis s restaurant is the procedure of ordering food For each visitor Denis himself chooses a set of dishes that this visitor will receive When doing so Denis is guided by the following rules every visitor should receive at least one dish dumplings cranberry juice pancakes with condensed milk are all considered to be dishes each visitor should receive no more than one portion of dumplings no more than one portion of cranberry juice and no more than one pancake with condensed milk all visitors should receive different sets of dishes What is the maximum number of visitors Denis can feed ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "There are seven possible sets of dishes so the simplest solution is to iterate over all possible subsets of sets of dishes You can also go over permutations of sets of dishes and gather sets of dishes greedily in the selected order Note that the solution can be optimal only when it is impossible to add an additional set of dishes to it Let the solution be such that it is impossible to add a single set of dishes to it and it does not have any set consisting of one dish but there is a set consisting of two or three dishes containing this one dish Then you can replace the corresponding set with a set of one dish without worsening the answer This means that at the beginning you can greedily add all the sets consisting of one dish The same can show that any set of three dishes can be replaced with a set of two dishes so after the sets of one and two dishes are fixed it is enough to simply check whether you can add a set of three dishes However it is wrong to choose sets of two dishes greedily Suppose that after choosing sets of one dish there is one dish of the first type one dish of the second type and two dishes of the third type Then you can choose two sets of dishes but if you take at the beginning a set of dishes of the first and second types you won t get two different sets In this case you can simply iterate over the order of choosing sets of two dishes or notice that all such tests have the form where and solve them separately "}
{"statement": "There are n cities and n 1 undirected roads connecting pairs of cities Citizens of any city can reach any other city traveling by these roads Cities are numbered from 1 to n and the city 1 is a capital In other words the country has a tree structure There are m citizens living in the country A p i people live in the i th city but all of them are working in the capital At evening all citizens return to their home cities using the shortest paths Every person has its own mood somebody leaves his workplace in good mood but somebody are already in bad mood Moreover any person can ruin his mood on the way to the hometown Happiness detectors are installed in each city to monitor the happiness of person who visits the city The detector in the i th city calculates a happiness index h i as the number of people in good mood minus the number of people in bad mood Let s say for the simplicity that Happiness detector is still in development so there is a probability of a mistake in judging a person s happiness One late evening when all citizens successfully returned home the government asked uncle Bogdan the best programmer of the country to check the correctness of the collected happiness indexes Uncle Bogdan successfully solved the problem Can you do the same More formally ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "For each city count how many people will visit it Knowing this value and the value of the level of happiness we can calculate how many people visited the city in a good mood We can single out the criterions for the correctness of the values of the happiness indices is a multiple of For each an integer In each city the number of residents who passed this city in a good mood a non negative number not exceeding where are the cities where the resident can move out of the city on the way home This follows from the fact that the mood of the inhabitants can be deteriorated and cannot be improved This is enough since these conditions guarantee the correctness of the happiness indices by definition as well as the peculiarities of changes in the mood of residents "}
{"statement": "Bertown is a city with n buildings in a straight line The city s security service discovered that some buildings were mined A map was compiled which is a string of length n where the i th character is if there is a mine under the building number i and otherwise Bertown s best sapper knows how to activate mines so that the buildings above them are not damaged When a mine under the building numbered x is activated it explodes and activates two adjacent mines under the buildings numbered x 1 and x 1 if there were no mines under the building then nothing happens Thus it is enough to activate any one mine on a continuous segment of mines to activate all the mines of this segment For manual activation of one mine the sapper takes a coins He can repeat this operation as many times as you want Also a sapper can place a mine under a building if it wasn t there For such an operation he takes b coins He can also repeat this operation as many times as you want The sapper can carry out operations in any order You want to blow up all the mines in the city to make it safe Find the minimum number of coins that the sapper will have to pay so that after his actions there are no mines left in the city ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Since the activation of any mine explodes the entire segment of mines which it is you can immediately replace the input string with an array of mine segments We now have two operations We can delete any segment by coins or turn two adjacent segments into one segment for That is two segments can be deleted for a cost of or This means that you need to merge two segments while You need to go through all adjacent segments and check this condition "}
{"statement": "There are n students in the first grade of Nlogonia high school The principal wishes to split the students into two classrooms each student must be in exactly one of the classrooms Two distinct students whose name starts with the same letter will be chatty if they are put in the same classroom because they must have a lot in common Let x be the number of such pairs of students in a split Pairs a b and b a are the same and counted only once For example if there are 6 students and then splitting into two classrooms and will give x 4 3 chatting pairs in the first classroom 1 chatting pair in the second classroom splitting into two classrooms and will give x 1 0 chatting pairs in the first classroom 1 chatting pair in the second classroom You are given the list of the n names What is the minimum x we can obtain by splitting the students into classrooms Note that it is valid to place all of the students in one of the classrooms leaving the other one empty ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "First note that we can solve the problem for each starting letter independently because two students whose name starts with a different letter never form a chatty pair How do we solve the problem when all the students names start with the same letter We claim that it s best to split as evenly as possible If one classroom has students and the other has students with then by moving one of the students from the first classroom into the second we remove chatty pairs from the first classroom and create new chatty pairs in the second for a net result of chatty pairs removed So in the best splitting we have meaning we split as evenly as possible Then if denotes the number of students whose name starts with we will split them into a classroom containing students and one containing students So the total number of chatty pairs among students whose name starts with isThe expression is the same for the other letters in the alphabet and adding them all up gives us our answer We can also solve the problem without determining what the best splitting is If for each starting letter we try all the possible number of students to send into the first classroom and choose the one that gives the minimal then we will only have to do checks in total which is more than fast enough to solve the problem Complexity "}
{"statement": "Ivan plays some computer game There are n quests in the game Each quest can be upgraded once this increases the reward for its completion Each quest has 3 parameters a i b i p i reward for completing quest before upgrade reward for completing quest after upgrade a i b i and probability of successful completing the quest Each second Ivan can try to complete one quest and he will succeed with probability p i In case of success Ivan will get the reward and opportunity to upgrade any one quest not necessary the one he just completed In case of failure he gets nothing Quests after completing Ivan has t seconds He wants to maximize expected value of his total gain after t seconds Help him to calculate this value ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "Let s denote as Independent of our strategy we cannot get more than in one second in expected value But if we could upgrade one quest we would upgrade the quest which maximizes and then try to complete only this quest each second thus getting to expected value each second Therefore our strategy looks like this try to complete quests in some order once we complete one quest we will always get to expected value each second This observation leads to DP solution Once we have one quest completed we already know what we will get so interesting states are only those in which no quests are completed yet Then it is not important what quests we tried to complete before the only important parameter is remaining time If we succeed then we will get as a reward and for remaining seconds we will get each second otherwise we get nothing and now only seconds left This solution works in time which is too slow We can slightly rewrite the formula for transition Now we can see that we take maximum value of functions in point We can build convex hull on these lines thus getting solution But that s not all We can actually prove that or after some substitutions and simplifications This we will prove by actual meaning of Take optimal solution for seconds and do the same for seconds except that we don t have last second so we will just drop our action But we can t gain more than in one second so this drop cannot decrease answer more than Thus the inequality is proven This means that we only move right along over convex hull so for each line there will be consecutive seconds in which we are using that line If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster Let s start with learning how to make many DP transitions when we are staying on one line for the whole time It is more clear using first formula for DP transition we don t have max now because we already know which line to use We can see that to get vector from vector we can apply linear transformation i e multiply by some matrix To apply it times just use binary exponentiation to get th power of transition matrix To determine how long we actually have to stay on given line we will use binary search on answer We know for which value of we should move to the next line and we know that increases with each second so we can try to stay on given line for some time and see if we should actually change the line This is already solution but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time Final complexity is "}
{"statement": "Traveling around the world you noticed that many shop owners raise prices to inadequate values if the see you are a foreigner You define inadequate numbers as follows all integers from 1 to 9 are inadequate for an integer x ge 10 to be inadequate it is required that the integer lfloor x 10 rfloor is inadequate but that s not the only condition Let s sort all the inadequate integers Let lfloor x 10 rfloor have number k in this order Then the integer x is inadequate only if the last digit of x is strictly less than the reminder of division of k by 11 Here lfloor x 10 rfloor denotes x 10 rounded down Thus if x is the m th in increasing order inadequate number and m gives the remainder c when divided by 11 then integers 10 cdot x 0 10 cdot x 1 ldots 10 cdot x c 1 are inadequate while integers 10 cdot x c 10 cdot x c 1 ldots 10 cdot x 9 are not inadequate The first several inadequate integers are 1 2 3 4 5 6 7 8 9 10 20 21 30 31 32 ldots After that since 4 is the fourth inadequate integer 40 41 42 43 are inadequate while 44 45 46 ldots 49 are not inadequate since 10 is the 10 th inadequate number integers 100 101 102 ldots 109 are all inadequate And since 20 is the 11 th inadequate number none of 200 201 202 ldots 209 is inadequate You wrote down all the prices you have seen in a trip Unfortunately all integers got concatenated in one large digit string s and you lost the bounds between the neighboring integers You are now interested in the number of substrings of the resulting string that form an inadequate number If a substring appears more than once at different positions all its appearances are counted separately ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Let s take any inadequate number of length Let s keep 3 parameters for it which is the number of all inadequate numbers less of equal then which is the number of inadequate numbers less then which have length and which is the number of inadequate numbers grater then which have length We know that there are exactly modulo 11 inadequate numbers that come from by adding a new digit to the end Also because we know and we can find and parameters for each of those numbers Let s now notice that if instead of keeping and parameters we can keep all of them modulo 11 The parameters of all numbers that come from will still be defined because if we increase by 11 these parameters will be the same modulo 11 if we increase by 11 and parameters of all numbers that come from are increase by which is 0 modulo 11 The same is with parameter So these 3 parameters modulo 11 exactly define what new numbers will come from and the values of these 3 parameters for them Now we can create some kind of automaton of size where we will have 9 starting nodes and all paths from these nodes will be the inadequate numbers and for any inadequate number there will be path which will define it Now let s create dynamic which is how long we can go into the automaton by the characters of suffix of length of our given string starting from node in automaton We can calculate this in time and using it we can check for each suffix of what is its longest prefix that is an inadequate number and so we can solve the problem Actually during the contest it turned out that this problem has shorter solution but this is more general one which doesn t depend on the starting numbers in our case they were "}
{"statement": "An L shape is a figure on gridded paper that looks like the first four pictures below An L shape contains exactly three shaded cells denoted by which can be rotated in any way You are given a rectangular grid Determine if it contains L shapes only where L shapes can t touch an edge or corner More formally Each shaded cell in the grid is part of exactly one L shape and no two L shapes are adjacent by edge or corner For example the last two grids in the picture above satisfy the condition because the two L shapes touch by corner and edge respectively ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "The problem is mainly a tricky implementation problem Let s denote the of an L shape as the square in the middle the one that is side adjacent to two other squares Every elbow is part of exactly one L shape and every L shape has exactly one elbow Iterate through the grid and count the number of side adjacent neighbors they have If there is a cell with more than 2 or if there is a cell with exactly two neighbors on opposite sides then the answer is Otherwise if there are exactly 2 neighbors this cell is an elbow Mark all three cells of this L shape with a unique number say mark the first one you find with the second with and so on If you ever remark a cell that already has a number then two elbows are adjacent and you can output After all elbows are marked check if all shaded cells have a number If some don t then they are not part of an L shape so you can output Finally we should check that L shapes don t share edge or corner Just check for each number if it is only diagonally adjacent to other numbers equal to it or unshaded cells If it is diagonally adjacent to other unequal numbers then the answer is because two L shapes share an edge or corner then Otherwise the answer is There are many other solutions all of which are various ways to check the conditions The complexity is per testcase "}
{"statement": "To improve the boomerang throwing skills of the animals Zookeeper has set up an n times n grid with some targets The rows are numbered from 1 to n from top to bottom and the columns are numbered from 1 to n from left to right For each column Zookeeper will throw a boomerang from the bottom of the column below the grid upwards When the boomerang hits any target it will bounce off make a 90 degree turn to the right and fly off in a straight line in its new direction The boomerang can hit multiple targets and does not stop until it leaves the grid In the above example n 6 and the black crosses are the targets The boomerang in column 1 blue arrows bounces 2 times while the boomerang in column 3 red arrows bounces 3 times The boomerang in column i hits exactly a i targets before flying out of the grid However Zookeeper has lost the original positions of the targets Thus he asks you to construct a valid configuration of targets that matches the number of hits for each column or tell him that no such configuration exists If multiple valid configurations exist you may print any of them ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Clearly columns with are completely empty and we can ignore them Let s first consider just columns with s and s When a boomerang strikes its first target it will change directions from upwards to rightwards If the boomerang in column exits the grid on the right This means that if the target that it hits in on row there is no other target to its right on row For columns with the boomerang in column has to hit second target in some column before moving downwards The targets that this boomerang hits must be in the same row and since no row contains more than targets these are the only targets in the row Additionally there isn t any target below the second target This means This tells us that columns with must be matched with columns with to its right with If we only had and we can simply greedily match s to s that are available s initially seem difficult to handle The key observation is that s can link to s to its right The way to do this for the have the first target for one boomerang be the third target for another boomerang This allows us to chain the s together in one long chain Thus we only care about the first which has to use either a or a if it uses a that cannot be matched with a We should always use a if possible since it will never be used by anything else and the exact that we use also doesn t matter Thus the solution is as follows Process from right to left If the current value is a add it to a list of available ones If the current value is a match it with an available and remove the from the list If the current value is a match it with or in that order of preference Once we have found the chains and matches we can go from left to right and give each chain match some number of rows to use so that they do not overlap The final time complexity is Bonus Show that the directly simulating the path of each boomerang is overall Bonus unsolved Solve for "}
{"statement": "Polycarp lives on the coordinate axis Ox and travels from the point x a to x b It moves uniformly rectilinearly at a speed of one unit of distance per minute On the axis Ox at the point x c the base station of the mobile operator is placed It is known that the radius of its coverage is r Thus if Polycarp is at a distance less than or equal to r from the point x c then he is in the network coverage area otherwise no The base station can be located both on the route of Polycarp and outside it Print the time in minutes during which Polycarp will in the coverage area of the network with a rectilinear uniform movement from x a to x b His speed one unit of distance per minute ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "To get an answer we need to subtract from the whole time the time that we will be in the coverage area Let the left boundary of the cover be and the right boundary of the cover be Then the intersection boundaries will be Then the answer is calculated by the formula "}
{"statement": "You are given two integers n and k along with a string s Your task is to check whether all possible strings of length n that can be formed using the first k lowercase English alphabets occur as a subsequence of s If the answer is you also need to print a string of length n that can be formed using the first k lowercase English alphabets which does not occur as a subsequence of s If there are multiple answers you may print any of them A string a is called a subsequence of another string b if a can be obtained by deleting some possibly zero characters from b without changing the order of the remaining characters ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "We will try to construct a counter case If we can t the answer is YES otherwise NO We will greedily construct the counter case It is always optimal to choose the first character of our counter case as the character among the first English alphabets whose first index of occurrence in is the highest Add this character to our counter case remove the prefix up to this character from and repeat until the length of the counter case reaches or we reach the end of If the length of the counter case is less than find a character which does not appear in the last remaining suffix of Keep adding this character to the counter case until its length becomes This is a valid string which does not occur as a subsequence of Otherwise all possible strings of length formed using the first English alphabets occur as a subsequence of "}
{"statement": "Imp is really pleased that you helped him But it you solve the last problem his gladness would raise even more Let s define for some set of integers as the number of pairs in such that is than without a remainder You are to find such a set which is a subset of the set that contains all positive integers not greater than that ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Let the sought pairs be the edges in a graph with vertices Then the problem is reduced to finding such a vertex subset that the induced graph contains exactly edges Let be the number of edges in the graph on and be the number of divisors of strictly less than We claim that the answer always exists if otherwise it s obviously NO Let s enlighten it a bit Let s find the minimum possible such that and try to paraphrase the problem we have to throw away some vertices from the graph on vertices to leave exactly edges Note that the degree of vertex is equal to hence the most interesting numbers for us are primes strictly larger than since their degree is equal to Now it s time to expose the most important fact of the day we claim that At the same time the number of primes greater than is about Quite intuitive that asymptotically it s almost enough to throw only them away there are only possible counters and they all appear with which could be solved manually This observation is sufficient to get AC You could ve chosen the parallel way and note that vertices greater than do not share edges therefore they can be thrown away independently adding the statement from the previous paragraph greedy approach will do You could ve even written recursive bruteforce D Summarizing the aforementioned it works well "}
{"statement": "After William is done with work for the day he enjoys playing his favorite video game The game happens in a 2D world starting at turn 0 William can pick any cell in the game world and spawn in it Then each turn William may remain at his current location or move from the current location x y to one of the following locations x 1 y x 1 y x y 1 x y 1 To accelerate movement the game has n fast travel towers i th tower is located at location xa i ya i To be able to instantly travel to the tower from any location in the game world it must first be activated Activation of tower i happens at the moment when the player is in cell xa i ya i after this the tower remains active throughout the entire game William also knows that the game has m quests i th quest can be completed instantly by being at location xb i yb i on turn t i William wants to find out the maximal number of quests he will be able to complete by optimally traversing the game world ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "For convenience we will sort quests by time Let s make two DP minimum amount of time it takes to visit the set of towers and complete quests William is in one of the towers maximum number of quests that William can complete if he visited a set of towers and the last completed quest is quest number It is assumed that the current time for this state is equal to and William is at the coordinate DP transitions will be as follows where minimum distance among all towers from the set to the tower only if where minimum distance among all towers from the set to the quest only if where distance between two quests without instant travel choosing the optimal route either directly to the quest or through the tower where distance from quest number to tower number minimum distance from one of the towers from the set to the tower for each quest William can choose any starting coordinate Therefore he can choose to start at the coordinate with the quest and wait for it All other states initialized as for each tower William can choose any starting coordinate Therefore he can choose the coordinate of the tower and be in it at time All other states initialized as The answer is the maximum value among all There are states in total From each state there are transitions Hence the time complexity is "}
{"statement": "Allen and Bessie are playing a simple number game They both know a function f 0 1 n to mathbb R i e the function takes n binary arguments and returns a real value At the start of the game the variables x 1 x 2 dots x n are all set to 1 Each round with equal probability one of Allen or Bessie gets to make a move A move consists of picking an i such that x i 1 and either setting x i to 0 or x i to 1 After n rounds all variables are set and the game value resolves to f x 1 x 2 dots x n Allen wants to maximize the game value and Bessie wants to minimize it Your goal is to help Allen and Bessie find the expected game value They will play r 1 times though so between each game exactly one value of f changes In other words between rounds i and i 1 for 1 le i le r f z 1 dots z n to g i for some z 1 dots z n in 0 1 n You are to find the expected game value in the beginning and after each change ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "One can show by induction that the expected value of the game is Consider the first turn For notation let be the expected value of the game when is set to and let be the expected value of the game when is set to By induction it is easy to see that Consider Allen s strategy If it is Allen s turn he will set where are such that is maximal As for all it is clear that is actually minimal among all the This means that Bessie would have chosen to set if it were her turn Therefore the expected game value is "}
{"statement": "Monocarp is going to host a party for his friends He prepared n dishes and is about to serve them First he has to add some powdered pepper to each of them otherwise the dishes will be pretty tasteless The i th dish has two values a i and b i its tastiness with red pepper added or black pepper added respectively Monocarp won t add both peppers to any dish won t add any pepper multiple times and won t leave any dish without the pepper added Before adding the pepper Monocarp should first purchase the said pepper in some shop There are m shops in his local area The j th of them has packages of red pepper sufficient for x j servings and packages of black pepper sufficient for y j servings Monocarp goes to exactly one shop purchases multiple possibly zero packages of each pepper in such a way that More formally if he purchases x red pepper packages and y black pepper packages then x and y should be non negative and x cdot x j y cdot y j should be equal to n For each shop determine the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes If it s impossible to purchase the packages in the said way print ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Let s start by learning how to answer a query all red pepper and black pepper options are available Let s iterate over all options to put the peppers and choose the maximum of them First let s use the red pepper for all dishes Now we want to select some of them to use black pepper instead of red pepper Which ones do we choose When we switch from the red pepper to the black pepper the total tastiness changes by for the th dish They are completely independent of each other so we want to choose largest of these values Let be the sequence of values of in a non increasing order Thus black peppers will yield the result of We can answer a query by looking for a maximum in the sequence Now consider an arbitrary query Let be all options for the amount of available black peppers for the query Naively we could iterate over all of them and choose the maximum one However notice an interesting thing about the sequence of the answers By definition it is non strictly convex In particular one idea that can be extracted from this is the following Find the position of an arbitrary maximum in this sequence Then everything to the left of is is non increasing Everything to the right of it is non increasing Thus for a query it s enough to consider only two options the one closest to the maximum from the left and from the right Now we only have to learn how to get these options fast enough For a query we want to solve what s called a diophantine equation An arbitrary solution can be obtained by using extended Euclid algorithm Let it be some Then we would want to check the answer for black peppers The amount of solutions to the equation is either infinite or zero If it s infinite all solutions will be of the form for any integer Remember that not all the solutions will be in a range Finally find the two solutions that are the closest to the maximum check that they are in the range and print the best answer of them Overall complexity "}
{"statement": "Bob lives in a square grid of size n times n with rows numbered 1 through n from top to bottom and columns numbered 1 through n from left to right Every cell is either allowed or blocked but you don t know the exact description of the grid You are given only an integer n Bob can move through allowed cells but only in some limited directions When Bob is in an allowed cell in the grid he can move to an adjacent cell if it is allowed You can ask at most 4 cdot n queries of form r 1 c 1 r 2 c 2 1 le r 1 le r 2 le n 1 le c 1 le c 2 le n The answer will be if Bob can get from a cell r 1 c 1 to a cell r 2 c 2 and otherwise In particular if one of the two cells or both is a blocked cell then the answer is for sure Since Bob doesn t like short trips you can only ask queries with the manhattan distance between the two cells at least n 1 i e the following condition must be satisfied r 2 r 1 c 2 c 1 ge n 1 It s guaranteed that Bob can get from the top left corner 1 1 to the bottom right corner n n and your task is to find a way to do it You should print the answer in form where S is a string of length 2 cdot n 2 consisting of characters and denoting moves down and right respectively The down move increases the first coordinate by 1 the right move increases the second coordinate by 1 If there are multiple solutions any of them will be accepted You should terminate immediately after printing the solution ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Hint Move from to the middle by asking queries query row col n n starting with Similarly move from to the middle by asking queries query 1 1 row col How to ensure that we will meet in the same cell in the middle The unusual condition in this problem is that must be satisfied in every query Without it the following simple code would solve the problem int row 1 col 1 while row n col n if row 1 n query row 1 col n n row move down else col move right This program starts in and greedily moves down if after this move we could still reach the cell Otherwise it must move right But in this problem we can only get half the way this method We must stop at the antidiagonal one of cells So maybe it s a good idea to move backward from the same way and meet at the antidiagonal Not really We indeed can apply the same algorithm starting from and going towards but possibly we will end in a different cell in the middle It s possible even for an empty grid without any blocked cells We are very close to a correct solution but let s focus on a thought process for a moment Analyzing some other possible approach might help with that The limitation about the distance at least is just enough to ask a query between and a cell from the antidiagonal and also that cell and for int row 1 row n row int col n 1 row if query 1 1 row col query row col n n print row col This pseudocode would print for a middle cell in our path a cell reachable from and from which the is reachable But after choosing some cell like this it isn t that easy to find a way to the corner cells In our first idea we were able to get from to one of the and from to one of the but maybe a different one Now a very important observation is the first piece of code in this editorial will reach the leftmost equivalently downmost because we always prefer moving down instead of right For example in an empty we would reach the bottom left corner Now we see that we need to guarantee the same when moving from So we should prioritize left direction over the up direction row n col n while row col n 1 if query 1 1 row col 1 col 1 move left else row 1 move up "}
{"statement": "The little girl loves the problems on array queries very much One day she came across a rather well known problem you ve got an array of n elements the elements of the array are indexed starting from 1 also there are q queries each one is defined by a pair of integers l i r i 1 le l i le r i le n You need to find for each query the sum of elements of the array with indexes from l i to r i inclusive The little girl found the problem rather boring She decided to reorder the array elements before replying to the queries in a way that makes the sum of query replies maximum possible Your task is to find the value of this maximum sum ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Lets calculate for each cell of the initial array the number of queries that cover this cell It s claimed that we should associate the cell with bigger value to the cell with bigger value in initial array More formally suppose is an array in cell of which is written the number of queries that cover cell Suppose is an initial array Let s sort those arrays It s claimed that the answer in this case can be calculated with following formula Let s proof this statements We will take a look at some indexes and at elements corresponding to shis indexes Those elements add to the answer the following value Let s swap and Now those elements elements add to the answer the following value Let s take a look at the following difference So swapping of two elements leads us to nonincreasing of the total result This means that our arrangement is optimal Now we need to calculate array fast enough For this purpose one can use different data structures which support segment modifications segment tree Cartesian tree and so on But there exists much easier method Let s create some array When we have query we should increase value by and decrease value by In such a tricky way we increase all elements in segment by After processing all of the queries we need to make a loop which visit every element of array In this loop we can easily calculate all elements of array Now we are ready to get the final answer The complexity of author s solution is C code Java code "}
{"statement": "The cities of Byteland and Berland are located on the axis Ox In addition on this axis there are also disputed cities which belong to each of the countries in their opinion Thus on the line Ox there are three types of cities the cities of Byteland the cities of Berland disputed cities Recently the project BNET has been launched a computer network of a new generation Now the task of the both countries is to connect the cities so that the network of this country is The countries agreed to connect of cities with BNET cables in such a way that If you look at the cities of Byteland and the disputed cities then in the resulting set of cities any city should be reachable from any other one by one or more cables If you look at the cities of Berland and the disputed cities then in the resulting set of cities any city should be reachable from any other one by one or more cables Thus it is necessary to choose a set of pairs of cities to connect by cables in such a way that both conditions are satisfied simultaneously Cables allow bi directional data transfer Each cable connects exactly two distinct cities The cost of laying a cable from one city to another is equal to the distance between them Find the minimum total cost of laying a set of cables so that two subsets of cities Byteland and disputed cities Berland and disputed cities are connected Each city is a point on the line Ox It is technically possible to connect the cities a and b with a cable so that the city c a c b is not connected to this cable where a b and c are simultaneously coordinates of the cities a b and c ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "We will call the disputed cities purple points the cities of Byteland blue points and the cities of Berland red points If there are no any purple points among the given points you just need to connect all the neighboring red points between each other and all the neighboring blue points with each other Thus the answer is the sum of the distances between the leftmost red point and the rightmost red point and between the leftmost blue point and the rightmost red point Otherwise you firstly should connect all the neighboring purple points with each other Consider what you should do to connect the red points All the red points to the left of the leftmost purple point should be connected as follows first from the left with the second from the left second from the left with the third from the left and so on The rightmost of these red points should be connected to the leftmost purple point All the red points to the right of the rightmost purple point are connected in a similar way Consider all the gaps between the neighboring purple points and all the red and blue points between them They should be connected in one of two ways The first way is to connect the left purple with the leftmost red the rightmost red with the right purple and also connect all the neighboring red dots Similarly we should make for the blue points Let the total length of the edges for such a connection is equal to The second way is to connect the left and right purple point Now consider only the purple points and the red ones All adjacent points need to be connected to each other except those which are on the maximum distance from all other pairs If there are several then we do not connect any pair Similarly we make for the purple and blue points Let the total length of the edges for such a connection is equal to If we should connect points from the current gap in the second way otherwise in the first "}
{"statement": "You are given two bracket sequences not necessarily regular s and t consisting only of characters and You want to construct the shortest bracket sequence that contains both given bracket sequences as not necessarily contiguous Recall what is the regular bracket sequence is the regular bracket sequence if S is the regular bracket sequence then is a regular bracket sequence if S and T regular bracket sequences then ST concatenation of S and T is a regular bracket sequence Recall that the subsequence of the string s is such string t that can be obtained from s by removing some possibly zero amount of characters For example and are subsequences of but and are not ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Firstly notice that the length of the answer cannot exceed copies of Now we can do some kind of simple dynamic programming Let be the minimum possible length of the prefix of the regular bracket sequence if we are processed first characters of the first sequence first characters of the second sequence and the current balance is Each dimension of this dp should have a size nearby The base of this dp is all other values Transitions are very easy if we want to place the opening bracket then we increase if the th character of exists and equals the same with the second sequence and the balance increases by one and the length of the answer increases by one If we want to place the closing bracket then we increase if the th character of exists and equals the same with the second sequence and the balance decreases by one and the length of the answer increases by one Don t forget to maintain parents in this dp to restore the actual answer The last problem that can be unresolved is how to write this dp The easiest way is bfs because every single transition increases our answer by one Then we can restore answer from the state You can write it recursively but I don t sure this will look good And you also can write it just with nested loops if you are careful enough Time complexity If you know the faster solution please share it "}
{"statement": "Recently in school Alina has learned what are the they are data structures that always preserves the previous version of itself and access to it when it is modified After reaching home Alina decided to invent her own persistent data structure Inventing didn t take long there is a bookcase right behind her bed Alina thinks that the bookcase is a good choice for a persistent data structure Initially the bookcase is empty thus there is no book at any position at any shelf The bookcase consists of shelves and each shelf has exactly positions for books at it Alina enumerates shelves by integers from to and positions at shelves from to Initially the bookcase is empty thus there is no book at any position at any shelf in it Alina wrote down operations which will be consecutively applied to the bookcase Each of the operations has one of four types Place a book at position at shelf if there is no book at it Remove the book from position at shelf if there is a book at it Invert book placing at shelf This means that from every position at shelf which has a book at it the book should be removed and at every position at shelf which has not book at it a book should be placed Return the books in the bookcase in a state they were after applying th operation In particular means that the bookcase should be in initial state thus every book in the bookcase should be removed from its position After applying each of operation Alina is interested in the number of books in the bookcase Alina got A in the school and had no problem finding this values Will you do so ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Note that the data is delivered all at once offline Then we can build a tree of versions then run out of the DFS root and honestly handle each request in the transition from the top to the top Note that Alina uses operations that relate to the columns We can make an array of versions of the shelves and each version of the cabinet to provide an array of indices and the corresponding shelves to store it explicitly Then for the operation such as changing wardrobe shelves a new version which has been changed this version of the index is recorded on the same shelf position This approach eliminates the decision on the use of extra memory for storing unnecessary information "}
{"statement": "Vasya has started watching football games He has learned that for some fouls the players receive yellow cards and for some fouls they receive red cards A player who receives the second yellow card automatically receives a red card Vasya is watching a recorded football match now and makes notes of all the fouls that he would give a card for Help Vasya determine all the moments in time when players would be given red cards if Vasya were the judge For each player Vasya wants to know only the moment of time when he would receive a red card from Vasya ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "We need 2 arrays for the first and second team in which we must save status of the player is he clear yellow carded or sent off Then while inputing we must output the players name if he wasn t sent off and after the event he must be sent off "}
{"statement": "The round carousel consists of n figures of animals Figures are numbered from 1 to n in order of the carousel moving Thus after the n th figure the figure with the number 1 follows Each figure has its own type the type of the animal corresponding to this figure the horse the tiger and so on The type of animal of the i th figure equals t i You want to color each figure in one of the colors You think that it s boring if the carousel contains two different figures with the distinct types of animals going one right after another and colored in the same color Your task is to color the figures in such a way that the number of distinct colors used is the minimum possible and there are no figures of the different types going one right after another and colored in the same color If you use exactly k distinct colors then the colors of figures should be denoted with integers from 1 to k ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "The answer to this problem is at most Let s prove it by construction Firstly if all are equal then the answer is Otherwise there are at least two different values in the array so the answer is at least If is even then the answer is always because you can color figures in the following way If is odd then consider two cases The first case is when some pair of adjacent figures have the same type Then the answer is because you can merge these two values into one and get the case of even Otherwise all pairs of adjacent figures have different types and if you consider this cyclic array as a graph cycle of length then you can notice that it isn t bipartite so you need at least colors to achieve the answer color all vertices in such a way that any two adjacent vertices have different colors And the answer looks like "}
{"statement": "Building bridges did not help Bernard and he continued to be late everywhere Then Rudolf decided to teach him how to use the subway Rudolf depicted the subway map as an undirected connected graph without self loops where the vertices represent stations There is at most one edge between any pair of vertices Two vertices are connected by an edge if it is possible to travel directly between the corresponding stations bypassing other stations The subway in the city where Rudolf and Bernard live has a color notation This means that any edge between stations has a specific color Edges of a specific color together form a subway line A subway line contain unconnected edges and forms a connected subgraph of the given subway graph An example of the subway map is shown in the figure Rudolf claims that the route will be optimal if it passes through the minimum number of subway lines Help Bernard determine this minimum number for the given departure and destination stations ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2000", "problem_editorial": "Let s construct a bipartite graph where one part is the vertices of the original graph i e subway stations and the other part is the subway lines We add an edge between a station vertex and a line vertex if in the original subway graph the station is incident to an edge of the corresponding subway line In the new graph we find the shortest path between the vertices corresponding to the departure and destination stations for example using breadth first search The answer to the problem will be the shortest path divided in half "}
{"statement": "The Major Oak grows i i new leaves in the i th year It starts with 1 leaf in year 1 Leaves last for k years on the tree In other words leaves grown in year i last between years i and i k 1 inclusive Robin considers even numbers lucky Help Robin determine whether the Major Oak will have an even number of leaves in year n ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The key observation is that ii has the same even odd parity as i Therefore the problem reduces to finding whether the sum of k consecutive integers ending in n is even This can be done by finding the sum of n k 1 n k 2 n 1 n which is k 2n k 1 2 and checking its parity Alternatively one can count the number of odd numbers in those k consecutive integers Note Originally the number of leaves grown was to be im according to the fractal nature of life where m is set to some integer Developers decided to replace m with i for simplicity following Filikec s suggestion "}
{"statement": "The time on the planet Lapituletti goes the same way it goes on Earth but a day lasts h hours and each hour lasts m minutes The inhabitants of that planet use digital clocks similar to earth ones Clocks display time in a format the number of hours in decimal is displayed first then after the colon follows the number of minutes in decimal the number of minutes and hours is written with leading zeros if needed to form a two digit number Hours are numbered from 0 to h 1 and minutes are numbered from 0 to m 1 That s how the digits are displayed on the clock Please note that digit 1 is placed in the of its position A standard mirror is in use on the planet Lapituletti Inhabitants often look at the reflection of the digital clocks in the mirror and feel happy when what you see on the reflected clocks is a valid time that means that you see valid digits in the reflection and this time can be seen on the normal clocks at some moment of a day The image of the clocks in the mirror is reflected against a vertical axis The reflection is not a valid time The reflection is a valid time with h 24 m 60 However for example if h 10 m 60 then the reflection is not a valid time An inhabitant of the planet Lapituletti begins to look at a mirrored image of the clocks at some time moment s and wants to know the nearest future time moment which can possibly happen on the next day when the reflected clock time is valid It can be shown that with any h m s such a moment exists If the reflected time is correct at the moment the inhabitant began to look at the clock that moment is considered the nearest You are asked to solve the problem for several test cases ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "In order to solve the problem you need to look over all the moments of time after the given one and check if the reflected time is correct in that moment of time If such moment of time does not exist on the current day the moment of the next day is always correct For realization you need to notice that digits transform into themselves after reflection transforms into transforms into and other digits transform into incorrect digits after reflection "}
{"statement": "You are given two binary square matrices a and b of size n times n A matrix is called binary if each of its elements is equal to 0 or 1 You can do the following operations on the matrix a number of times 0 or more vertical You choose the number j 1 le j le n and for all i 1 le i le n do the following a i j a i j oplus 1 oplus is the operation exclusive or horizontal You choose the number i 1 le i le n and for all j 1 le j le n do the following a i j a i j oplus 1 Note that the elements of the a matrix change after each operation For example if n 3 and the matrix a is begin pmatrix 1 1 0 0 0 1 1 1 0 end pmatrix Then the following sequence of operations shows an example of transformations vertical j 1 a begin pmatrix 0 1 0 1 0 1 0 1 0 end pmatrix horizontal i 2 a begin pmatrix 0 1 0 0 1 0 0 1 0 end pmatrix vertical j 2 a begin pmatrix 0 0 0 0 0 0 0 0 0 end pmatrix Check if there is a sequence of operations such that the matrix a becomes equal to the matrix b ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "It is clear that the order of operations does not affect the final result also it makes no sense to apply the same operation more than once by the property of the operation Let s construct a sequence of operations that will reduce the matrix to the matrix if the answer exists Let s try iterate over will we use the operation horizontal Now by the each element of the first line we can understand whether it is necessary to apply the operation vertical if Let s apply all necessary operations vertical It remains clear whether it is necessary to apply the operation horizontal for Let s look at each element of the first column by it you can understand whether it is necessary to apply the operation horizontal if "}
{"statement": "Vanya has a scales for weighing loads and weights of masses grams where is some integer not less than exactly one weight of each nominal value Vanya wonders whether he can weight an item with mass using the given weights if the weights can be put on both pans of the scales Formally speaking your task is to determine whether it is possible to place an item of mass and some weights on the left pan of the scales and some weights on the right pan of the scales so that the pans of the scales were in balance ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Convert to number system of base If all digits of number or then we can measure the weight of the item with putting weights that have digits equal to on one pan and our item on another one If this condition isn t satisfied then we should iterate from lower digit to high and if digit is not equal to or we try to substract from it and increment higher digit If it becomes equal to then we can put weight with number of this digit on the same pan with our item if it becomes equal to then we don t put weight in another case we can t measure the weight of our item and answer is Time complexity C code Wild Hamster Java code Wild Hamster Java code Zlobober "}
{"statement": "Natasha travels around Mars in the Mars rover But suddenly it broke down namely the logical scheme inside it The scheme is an undirected tree connected acyclic graph with a root in the vertex 1 in which every leaf excluding root is an input and all other vertices are logical elements including the root which is output One bit is fed to each input One bit is returned at the output There are four types of logical elements AND 2 inputs OR 2 inputs XOR 2 inputs NOT 1 input Logical elements take values from their direct descendants inputs and return the result of the function they perform Natasha knows the logical scheme of the Mars rover as well as the fact that only one input is broken In order to fix the Mars rover she needs to change the value on this input For each input determine what the output will be if Natasha changes this input ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2000", "problem_editorial": "Let s count the bit at each vertex This can be done using depth first search on this tree Now for each vertex let s check whether the bit on the output of the scheme will change if the bit in the current vertex is changed If all the vertices on the path from this vertex to the output of the scheme If at least one of them does not change then the output of the scheme does not change and vice versa if the output of the scheme is changed then each vertex on the path under consideration will change Now the solution can be implemented as follows For each vertex let s make a note whether the bit on the output of the scheme will be changed if the bit on the current vertex is changed For output of the scheme this note is Now let s do the depth first search on this tree If note at the current vertex is equal to then at the inputs to it we make the note equal otherwise for each input to this vertex we do the following Let s see if the current vertex is changed if the current input is changed If it is changed then at this input we will make the note equal otherwise Complexity "}
{"statement": "You are given a picture consisting of n rows and m columns Rows are numbered from 1 to n from the top to the bottom columns are numbered from 1 to m from the left to the right Each cell is painted either black or white You think that this picture is not interesting enough You consider a picture to be interesting if there is at least one in it A cross is represented by a pair of numbers x and y where 1 le x le n and 1 le y le m such that in row x and in column y are painted black For examples each of these pictures contain crosses The fourth picture contains 4 crosses at 1 3 1 5 3 3 and 3 5 Following images don t contain crosses You have a brush and a can of black paint so you can make this picture interesting Each minute you may choose a white cell and paint it black What is the minimum number of minutes you have to spend so the resulting picture contains at least one cross You are also asked to answer multiple independent queries ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s consider each cell as a center of a cross and take the fastest one to paint Calculating each time naively will take overall which is too slow Notice how the answer for some cell can be represented as if is white else where is the number of white cells in row and is the same for column The first two terms can be precalculated beforehand Overall complexity per query "}
{"statement": "You have been asked to organize a very important art conference The first step is to choose the dates The conference must last for a certain number of consecutive days Each day one lecturer must perform and the same lecturer cannot perform more than once You asked n potential lecturers if they could participate in the conference Lecturer i indicated that they could perform on any day from l i to r i inclusive A certain segment of days can be chosen as the conference dates if there is a way to assign an available lecturer to each day of the segment assigning each lecturer to no more than one day For each k from 1 to n find how many ways there are to choose a segment of k consecutive days as the conference dates ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "For a segment of days how can we tell if there s a way to assign a lecturer to each day of the segment Consider a bipartite graph the first part consists of the days in the segment the second part consists of all lecturers an edge between a day and a lecturer exists if that lecturer is available on that day We need to check if the maximum matching covers all vertices in the first part If this is the case we ll call the segment of days A common way to check if a segment is valid is to use Hall s marriage theorem In our case we can formulate it as follows If for each subset of days the number of lecturers available on at least one day of that subset is at least then this segment of days is valid It might be tempting to only consider subsets which form contiguous subsegments However consider the following test case 31 32 22 2For a segment of days the only subset that violates the Hall s marriage theorem condition is which is not contiguous Let s try to fix that Suppose there are two lecturers with equal let their availability segments be and where Then if we replace with the answer does not change This can be easily seen if you consider the set of all pairs of days that these two lecturers can cover and notice that this set stays the same after the transformation Note that when replacing with is effectively equivalent to removing one of the lecturers their segment becomes empty We can keep applying this operation until all are distinct potentially removing some lecturers in the process This process can be simulated in time by going left to right using a priority queue Why is this transformation useful Consider a subset of days that violates the Hall s marriage theorem condition Suppose it s non contiguous say days and belong to while none of days belong to Then if we include days into then will still violate the condition proof left as an exercise As a consequence if we include all gaps in we ll still get a violating subset but this time it will be contiguous We have described a transformation that makes all distinct Similarly we can apply it in the same way to make all distinct After that we ll get another useful property monotonicity Specifically if is a violating subset then and are violating subsets as well Now we can see that a segment of days is valid iff it is not a violating subset itself i e instead of checking all subsets of the segment it s enough to just check the whole segment To finish the solution we can use the two pointers technique to find all valid segments in linear time solve the problem for "}
{"statement": "Little Petya is learning to play chess He has already learned how to move a king a rook and a bishop Let us remind you the rules of moving chess pieces A chessboard is 64 square fields organized into an table A field is represented by a pair of integers the number of the row and the number of the column in a classical game the columns are traditionally indexed by letters Each chess piece takes up exactly one field To make a move is to move a chess piece the pieces move by the following rules A rook moves any number of fields horizontally or vertically A bishop moves any number of fields diagonally A king moves one field in any direction horizontally vertically or diagonally Petya is thinking about the following problem what minimum number of moves is needed for each of these pieces to move from field to field At that we assume that there are no more pieces besides this one on the board Help him solve this problem ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1100", "problem_editorial": "There are two approaches to this task The first is use BFS to find the shortest path three times The second is to notice that "}
{"statement": "You are given a string s consisting of characters and or You have to remove several possibly zero characters from the beginning of the string and then several possibly zero characters from the end of the string The cost of the removal is the of the following two values the number of characters left in the string the number of characters removed from the string What is the cost of removal you can achieve ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "There are many different approaches to this problem dynamic programming binary search greedy two pointers anything you want The model solution uses an approach based on binary search so I ll describe it First of all why does binary search work Let s say that the number of s is If the cost of deletion is then we have deleted at most characters and have left at most characters Let s increase the number of characters we delete from the prefix of the string until the number of deleted s becomes if it s always possible So if we consider the segment of values the fact that we can get cost implies that we can get cost so we can use binary search on segment to find the minimum achievable cost Now how to check if we can obtain the cost of deletion equal to One possible way to do this is to form an array where is the position of the th character in the string and find the minimum value of in this array the string that should remain has to contain at least characters and the minimum value of is the minimum possible length of such string Then we can find the number of s in this string and check if it is greater than or not "}
{"statement": "Polycarp and his friends want to visit a new restaurant The restaurant has n tables arranged along a straight line People are already sitting at some tables The tables are numbered from 1 to n in the order from left to right The state of the restaurant is described by a string of length n which contains characters the table is occupied and the table is empty Restaurant rules prohibit people to sit at a distance of k or less from each other That is if a person sits at the table number i then all tables with numbers from i k to i k except for the i th should be free In other words the absolute difference of the numbers of any two occupied tables must be strictly greater than k For example if n 8 and k 2 then strings satisfy the rules of the restaurant strings do not satisfy to the rules of the restaurant since each of them has a pair of with a distance less than or equal to k 2 In particular if the state of the restaurant is described by a string without or a string with one then the requirement of the restaurant is satisfied You are given a binary string s that describes the current state of the restaurant It is guaranteed that the rules of the restaurant are satisfied for the string s Find the maximum number of free tables that you can occupy so as not to violate the rules of the restaurant Formally what is the maximum number of that can be replaced by such that the requirement will still be satisfied For example if n 6 k 1 s then the answer to the problem will be 1 since only the table at position 3 can be occupied such that the rules are still satisfied ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s split a given string into blocks of consecutive zeros Then in each such block you can independently put the maximum number of people who fit in it But there are three cases to consider If the current block is not the first and not the last then there are ones at the border and this means that the first tables of the current block and the last are prohibited Therefore remove these zeroes from the string If the current block is the first then the one is at the end and you need to delete the last zeros If the current block is the last then in the beginning there is one and you need to delete the first zeros Also as a separate case you need to consider a string consisting only of zeros Then there is exactly one block from which you do not need to remove zeros Now all the tables in each block are free then in each block we can put Sum these values over all blocks "}
{"statement": "The mayor of the Central Town wants to modernize Central Street represented in this problem by the Ox axis On this street there are n antennas numbered from 1 to n The i th antenna lies on the position x i and has an initial scope of s i it covers all integer positions inside the interval x i s i x i s i It is possible to increment the scope of any antenna by 1 this operation costs 1 coin We can do this operation as much as we want multiple times on the same antenna if we want To modernize the street we need to make all positions from 1 to m inclusive covered by one antenna Note that it is authorized to cover positions outside 1 m even if it s not required What is the minimum amount of coins needed to achieve this modernization ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "We can add an antenna It will not modifiy the answer because it would be non optimal to increase the scope of this antenna Let be the minimum cost to cover all positions from to inclusive knowing that position is covered We compute in decreasing order of Base case is The default transition is If position is initially covered Otherwise let s consider all antennas and their initial intervals If let then a possible transition is We take the minimum of all these transitions Note that we always extend intervals as less as possible but it s optimal because If after using this interval we use another interval at the right of the time spent to extend could have been used to extend instead which will be more optimal If was the last interval used we don t care because the default transition will take care of this case The final answer will be There are states and transitions hence final complexity is with very low constant can also get AC because of very low constant Implementation "}
{"statement": "A monopole magnet is a magnet that only has one pole either north or south They don t actually exist since real magnets have two poles but this is a programming contest problem so we don t care There is an n times m grid Initially you may place some north magnets and some south magnets into the cells You are allowed to place as many magnets as you like even multiple in the same cell An operation is performed as follows Choose a north magnet and a south magnet to activate If they are in the same row or the same column and they occupy different cells then the north magnet moves one unit closer to the south magnet Otherwise if they occupy the same cell or do not share a row or column then nothing changes Note that the south magnets are immovable Each cell of the grid is colored black or white Let s consider ways to place magnets in the cells so that the following conditions are met There is at least one south magnet in every row and every column If a cell is colored black then it is possible for a north magnet to occupy this cell after some sequence of operations If a cell is colored white then it is impossible for a north magnet to occupy this cell after some sequence of operations Determine if it is possible to place magnets such that these conditions are met If it is possible find the minimum number of north magnets required there are no requirements on the number of south magnets ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2000", "problem_editorial": "Suppose two cells A and B are colored black in the same row Since there must be a south magnet in every row there are segments of black cells from A and B to the cell with the south magnet The same result holds for columns Therefore for a solution to exist every row and every column has exactly one segment of black cells or is all white Suppose there is an all white row but not an all white column Or similarly an all white column but not an all white row Then wherever we place a south magnet in this row its column will have a black cell But then the south magnet would be reachable contradicting the fact that the row is all white Therefore there should be an all white row if and only if there is an all white column or no solution exists Now that we have excluded these cases where no solution exists let s construct a solution Place a south magnet in a cell if The cell is colored black or Its row and column are both all white Then place one north magnet in each connected component of black cells A north magnet cannot travel between components so this is optimal "}
{"statement": "For his birthday Kevin received the set of pairwise distinct numbers 1 2 3 ldots n as a gift He is going to arrange these numbers in a way such that the minimum absolute difference between two consecutive numbers be maximum possible More formally if he arranges numbers in order p 1 p 2 ldots p n he wants to maximize the value min limits i 1 n 1 lvert p i 1 p i rvert where x denotes the absolute value of x Help Kevin to do that ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s prove that the minimum difference of consecutive elements is not greater than To do it let s prove that larger value is not achievable Consider element of a permutation with value It will have at least one adjacent element in the constructed permutation And the maximum absolute difference of this element with the adjacent elements is at most Now we will construct the permutation with the minimum absolute difference of consecutive elements equals to Assign Now we can construct such permutation It s easy to see that the minimum absolute difference of consecutive elements equals to "}
{"statement": "It is never too late to play the fancy Binary Cards game There is an infinite amount of cards of positive and negative ranks that are used in the game The absolute value of any card rank is a power of two i e each card has a rank of either or for some integer There is an infinite amount of cards of any valid rank At the beginning of the game player forms his deck that is some multiset possibly empty of cards It is allowed to pick any number of cards of any rank but the small deck is considered to be a skill indicator Game consists of rounds In the th round jury tells the player an integer After that the player is obligated to draw such a subset of his deck that the sum of ranks of the chosen cards is equal to it is allowed to not draw any cards in which case the sum is considered to be equal to zero If player fails to do so he loses and the game is over Otherwise player takes back all of his cards into his deck and the game proceeds to the next round Player is considered a winner if he is able to draw the suitable set of cards in each of the rounds Somebody told you which numbers the jury is going to tell you in each round Now you want to pick a deck consisting of the minimum number of cards that allows you to win the Binary Cards game ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "There are two observations required to solve this problem You don t have to take two cards with same number If you took two cards with number you can take card with number and card with number and answer will remain correct If you took card with number you don t have to take card with number You can take cards and instead Consider all numbers If there are no odd numbers you don t have to take or cards Otherwise you have to take either or Try both possibilities and add value of taken card to all odd numbers After this step all numbers are even so you can just divide them by and solve the same problem with divided number After each step of this algorithm maximum possible absolute value of card is also divided by so in worst case complexity will be where is a maximum absolute value of number Solution of the equation is so it s fast enough What about ternary cards "}
{"statement": "Rahul and Tina are looking forward to starting their new year at college As they enter their new classroom they observe the seats of students are arranged in a n times m grid The seat in row r and column c is denoted by r c and the distance between two seats a b and c d is a c b d As the class president Tina has access to k buckets of pink paint The following process occurs First Tina chooses exactly k seats in the classroom to paint with pink paint One bucket of paint can paint exactly one seat After Tina has painted k seats in the previous step Rahul chooses where he sits He will not choose a seat that has been painted pink due to his hatred of the colour pink After Rahul has chosen his seat Tina chooses a seat for herself She can choose any of the seats painted or not other than the one chosen by Rahul Rahul wants to choose a seat such that he sits as close to Tina as possible However Tina wants to sit as far away from Rahul as possible due to some complicated relationship history that we couldn t fit into the statement Now Rahul wonders for k 0 1 dots n cdot m 1 if Tina has k buckets of paint how close can Rahul sit to Tina if both Rahul and Tina are aware of each other s intentions and they both act as strategically as possible Please help satisfy Rahul s curiosity ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s denote Rahul s seat as and Tina s seat as Notice that the in the distance between their seats and are independent of each other i e both the coordinate and coordinate of Tina s seat are independent From the answer to the hint above we can see that the optimal seat for Tina in a dimensional classroom is one of the edge seats and combining this with the previous observation means that the optimal seat for Tina is always one of the corner seats Since Rahul chooses seats optimally he will know that Tina will choose one of the corner seats so he will choose a seat such that the maximum distance from it to one of the corner seats is minimised As Tina also chooses which seats to paint optimally the best strategy for her is to paint the seats with minimum maximum distance to one of the corner seats pink We can implement this by calculating for each seat the maximum distance to one of the corner seats from it and storing these values in an array After sorting this array in non decreasing order we can simply print the first values of the array as the th value of the array indexed is the optimal answer for This can be implemented in time per test case "}
{"statement": "Oh no The coronavirus has caught you and now you re sitting in a dark cellar with tied legs but not hands You have a delicious cookie a laptop in front of you and your ideal development environment is open The coronavirus convinces you to solve the following problem You are given two arrays A and B of size n You can do operations of two types with array A Reverse array A That is the array A 1 A 2 ldots A n transformes into A n A n 1 ldots A 1 Replace A with an array of its prefix sums That is the array A 1 A 2 ldots A n goes to A 1 A 1 A 2 ldots A 1 A 2 ldots A n You need to understand if you can get an array B from the array A If it is possible you will have to restore the order of these operations by minimizing the number of operations of the second type Fortunately the coronavirus is good today so he has allowed you not to restore actions if the minimum number of second type operations is more than 2 cdot 10 5 But coronavirus resents you so if you restore the answer the total number of operations should not exceed 5 cdot 10 5 Solve this problem and get the cookie or the coronavirus will extend the quarantine for five years and make the whole economy collapse ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Let s define a few operations and constants replace an array with its prefix sums array reverse an array restore the original array from a prefix sums array the array values upper bound First we can prove that is unambiguosly defined for strictly increasing arrays Consider an array Let be the prefix sums array of Notice that for Thus we can restore from Note that if we apply to an array for which doesn t hold the resulting array will have a non positive element which is forbidden by the statements Now let s analyze how many operations can theoretically be applied for arrays of different lengths let s call their count We can do that by applying to array while all numbers are below It s obvious that we ll need no more than s for an array of length It can also be proved that Let s restore the array in steps One each step we have several cases If equals or we know how to get from If is strictly increasing apply If is strictly decreasing apply Otherwise the answer is This solution will run infinitely when and so the case when has to be handled separately The asymptotic of this solution is Notice that because we can t have two operations in a row It means this solution will fit into TL for but we need a separate solution for Consider an array If we it while the array will be transformed into It means we can several iterations at once So the solution for is First sort and so that they both increase and take this into account when printing answer Now start the loop If we can break the loop if otherwise the answer is If we can calculate how many operations we should apply to transform into modify the answer accordingly and jump to the next iteration for after applying one operation This algorithm is very similar to the Euclidian s algorithm and that s how we can prove there will be s The overall complexity is for for "}
{"statement": "There are n nodes arranged in a circle numbered from 1 to n in the clockwise order You are also given a binary string s of length n Your task is to construct a tree on the given n nodes satisfying the two conditions below or report that there such tree does not exist For each node i 1 le i le n the degree of node is even if s i 0 and odd if s i 1 No two edges of the tree intersect internally in the circle The edges are allowed to intersect on the circumference Note that all edges are drawn as straight line segments For example edge u v in the tree is drawn as a line segment connecting u and v on the circle A tree on n nodes is a connected graph with n 1 edges ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "TutorialLet s check some cases when it is not possible to construct the answer When all vertices have an even degree then there is no way to generate a tree because every tree contains at least leaves When there are an odd number of vertices with odd degrees then there is no tree possible because the sum of degrees must be even It turns out that it is always possible to construct a tree if none of the above is true The following construction works Select some vertex such that the previous vertex of assumed cyclically has an odd degree i e Clearly such a vertex always exists Now left rotate times such that the selected vertex is now at index Note that after the rotation will become Now we can see that can be divided into several segments such that each segment ends with some vertex having an odd degree And each segment should contain exactly one vertex with an odd degree So where may appear times Connect vertex to the starting vertex of each segment and connect adjacent vertices inside each segment It can be clearly seen that edges will never intersect internally The only thing we need to verify is the degree constraints Proof The degree condition is valid for each segment as each vertex with an even degree is connected with other vertices and the last vertex with an odd degree will be connected to only one vertex i e it s previous one or vertex if it was only on its segment Let be the number of vertices with odd degree If then there will be segments which is an odd number hence vertex will be connected to odd number of vertices If then there will be segments which is an even number hence vertex will be connected to even number of vertices Note that we renumbered the vertices during rotation which should be handled in implementation The intuition for the above approach comes from the case when all are in which we create a star network Overall complexity "}
{"statement": "Mocha likes arrays so before her departure Chamo gave her an array a consisting of n positive integers as a gift Mocha doesn t like arrays containing different numbers so Mocha decides to use magic to change the array Mocha can perform the following three step operation some possibly zero times Choose indices l and r 1 leq l r leq n Let x be the median dagger of the subarray a l a l 1 ldots a r Set all values a l a l 1 ldots a r to x Suppose a 1 2 3 4 5 initially If Mocha chooses l r 3 4 in the first operation then x 3 the array will be changed into a 1 2 3 3 5 If Mocha chooses l r 1 3 in the first operation then x 2 the array will be changed into a 2 2 2 4 5 Mocha will perform the operation until the array contains only the same number Mocha wants to know what is the maximum possible value of this number dagger The median in an array b of length m is an element that occupies position number lfloor frac m 1 2 rfloor after we sort the elements in non decreasing order For example the median of 3 1 4 1 5 is 3 and the median of 5 25 20 24 is 20 ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "SolutionRead the hints If the answer is the minimum element If we iterate over all subarrays of length and the answer is the maximum value of the median of all subarrays of length "}
{"statement": "You are given two strings s and t Both strings have length n and consist of lowercase Latin letters The characters in the strings are numbered from 1 to n You can successively perform the following move any number of times possibly zero swap any two adjacent neighboring characters of s i e for any i 1 2 dots n 1 you can swap s i and s i 1 You can t apply a move to the string t The moves are applied to the string s one after another Your task is to obtain the string t from the string s Find any way to do it with at most 10 4 such moves ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "This problem can be solved using the next greedy approach let s iterate over all from to If go further Otherwise let s find any position such that and move the character from the position to the position If there is no such position in the answer is Upper bound on time complexity and the size of the answer of this solution is "}
{"statement": "You are given a tree a connected graph without cycles with n vertices Consider a fixed integer k Then the graph G k is an undirected graph with n vertices where an edge between vertices u and v exists if and only if the distance between vertices u and v in the given tree is k For each k from 1 to n print the number of connected components in the graph G k ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "Find the diameter the longest path in the original tree Now if the number is greater than the length of the diameter then there will be no edges in the graph Otherwise the ends of this diameter are connected to each other and possibly to other vertices as well Then we can pre calculate the answer for each in descending order Let s maintain the set of vertices already reachable Then for updating the answer for only vertices at a distance from one end of the diameter can be added to the answer "}
{"statement": "There is a house with n flats situated on the main street of Berlatov Vova is watching this house every night The house can be represented as an array of n integer numbers a 1 a 2 dots a n where a i 1 if in the i th flat the light is on and a i 0 otherwise Vova thinks that people in the i th flats are disturbed and cannot sleep if and only if 1 i n and a i 1 a i 1 1 and a i 0 Vova is concerned by the following question what is the minimum number k such that if people from exactly k pairwise distinct flats will turn off the lights then nobody will be disturbed Your task is to find this number k ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "The first observation is that we are interested only in patterns of kind All other patterns don t make sense at all So let s build a greedy approach Let s iterate over the given array from the left to the right and maintain that the prefix of the given answer is already correct If now we are at some position and and the prefix from to is already correct then which one we have to replace When we replace the left one then we cannot do better in the future but when we replace the right one then we can fix some on the suffix of the array The easiest example is If now we are at the position then we will do better if we will set "}
{"statement": "Polycarpus got hold of a family relationship tree The tree describes family relationships of people numbered 1 through Each person in the tree has no more than one parent Let s call person a 1 ancestor of person if is the parent of Let s call person a ancestor of person if person has a 1 ancestor and is a ancestor of s 1 ancestor Family relationships don t form cycles in the found tree In other words there is no person who is his own ancestor directly or indirectly that is who is an ancestor for himself for some Polycarpus wonders how many counsins and what kinds of them everybody has He took a piece of paper and wrote pairs of integers Help him to calculate the number of th cousins that person has for each pair ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "In this problem you have some set of rooted down oriented trees First launch depth first search from every root of every tree and renumber the vertices Denote size of subtree of vertex as In this way all descendants of vertex including wiil have numbers Then we wiil handle requests in their order First go up from vertex on steps to the root using binary rise like in LCA algorithm Denote this vertex If doesn t exist print else you should count the number of descendants of vertex on the same height as vertex For this write all numbers of vertices for every height in some array Then you should determine which of these vertices are descendants of You can do it using binary search in corresponding array Find the segment of appropriate vertices because we know the numbers of all descendants of find the amount of them subtract one vertex and this is the answer The complexity of the solution is "}
{"statement": "After a hard day Vitaly got very hungry and he wants to eat his favorite potato pie But it s not that simple Vitaly is in the first room of the house with room located in a line and numbered starting from one from left to right You can go from the first room to the second room from the second room to the third room and so on you can go from the th room to the th room Thus you can go to room only from room The potato pie is located in the th room and Vitaly needs to go there Each pair of consecutive rooms has a door between them In order to go to room from room you need to open the door between the rooms with the corresponding key In total the house has several types of doors represented by uppercase Latin letters and several types of keys represented by lowercase Latin letters The key of type can open the door of type if and only if and are the same letter written in different cases For example key can open door Each of the first rooms contains exactly one key of some type that Vitaly can use to get to next rooms Once the door is open with some key Vitaly won t get the key from the keyhole but he will immediately run into the next room In other words each key can open no more than one door Vitaly realizes that he may end up in some room without the key that opens the door to the next room Before the start his run for the potato pie Vitaly can buy any number of keys of any type that is guaranteed to get to room Given the plan of the house Vitaly wants to know what is the minimum number of keys he needs to buy to surely get to the room which has a delicious potato pie Write a program that will help Vitaly find out this number ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "To solve this problem we need to use array cnt In this array we will store number of keys of every type which we already found in rooms but didn t use Answer will store in variable ans Now we iterate on string If current element of string si is lowercase letter key we make cnt si Else if current element of string si uppercase letter door and cnt tolower si 0 we make cnt tolower si else we make ans It remains only to print ans Asymptotic behavior of this solution O s where s length of string s "}
{"statement": "Today DZY begins to play an old game In this game he is in a big maze with rooms connected by corridors each corridor allows to move in both directions You can assume that all the rooms are connected with corridors directly or indirectly DZY has got lost in the maze Currently he is in the first room and has lives He will act like the follows Firstly he will randomly pick one of the corridors going from his current room Each outgoing corridor has the same probability to be picked Then he will go through the corridor and then the process repeats There are some rooms which have traps in them The first room definitely has no trap the th room definitely has a trap Each time DZY enters one of these rooms he will lost one life Now DZY knows that if he enters the th room with exactly 2 lives firstly he will lost one live but then he will open a bonus round He wants to know the probability for him to open the bonus round Please help him ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Define important room as the trap room Let be equal to the probability that DZY starts at is a important room or 1 and is the next important room DZY arrived For each we can calculate in by gauss elimination Let be equal to the th important room DZY arrived So specially Let be the probability for DZY to open the bonus round Easily we can know So we can calculate ans in is equal to the number of important rooms by matrix multiplication So we can solve the problem in we should optimize this algorithm We can find that each time we do gauss elimination the variable matrix is unchanged So we can do gauss elimination once to do preprocessing in Then for each time calculating the only thing to do is substitute the constants In this way we can calculate in In this way we can solve this problem in "}
{"statement": "Harry Potter and He Who Must Not Be Named engaged in a fight to the death once again This time they are located at opposite ends of the corridor of length Two opponents simultaneously charge a deadly spell in the enemy We know that the impulse of Harry s magic spell flies at a speed of meters per second and the impulse of You Know Who s magic spell flies at a speed of meters per second The impulses are moving through the corridor toward each other and at the time of the collision they turn round and fly back to those who cast them without changing their original speeds Then as soon as the impulse gets back to it s caster the wizard reflects it and sends again towards the enemy without changing the original speed of the impulse Since Harry has perfectly mastered the basics of magic he knows that after the second collision both impulses will disappear and a powerful explosion will occur exactly in the place of their collision However the young wizard isn t good at math so he asks you to calculate the distance from his position to the place of the second meeting of the spell impulses provided that the opponents do not change positions during the whole fight ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Let s start with determining the position of the first collision Two impulses converge with a speed p q so the first collision will occur after seconds The coordinate of this collision is given by the formula Note that the distance one impulse passes while returning to it s caster is equal to the distance it has passed from the caster to the first collision That means impulses will reach their casters simultaneously and the situation will be identic to the beginning of the duel Hence the second collision third fourth etc will occur at exactly the same place as the first one "}
{"statement": "Evirir the dragon found an array a 1 a 2 ldots a n of n non negative integers In one operation they can choose a non empty subarray text b of a and replace it with the integer operatorname mex b text They want to use this operation any number of times to make a only contain zeros It can be proven that this is always possible under the problem constraints What is the minimum number of operations needed text An array c is a subarray of an array d if c can be obtained from d by the deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end text The minimum excluded MEX of a collection of integers f 1 f 2 ldots f k is defined as the smallest non negative integer x which does not occur in the collection f ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Case 1 All elements are Then the answer is Case 2 Some element is non zero and all non zero elements form a contiguous subarray Then the answer is since we can choose that subarray and replace it with a Case 3 Otherwise the answer is Solution "}
{"statement": "As you very well know the whole Universe traditionally uses three dimensional Cartesian system of coordinates In this system each point corresponds to three real coordinates In this coordinate system the distance between the center of the Universe and the point is calculated by the following formula Mushroom scientists that work for the Great Mushroom King think that the Universe isn t exactly right and the distance from the center of the Universe to a point equals To test the metric of mushroom scientists the usual scientists offered them a task find such that the distance between the center of the Universe and the point is maximum possible in the metric of mushroom scientists The mushroom scientists aren t good at maths so they commissioned you to do the task Note that in this problem it is considered that ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "The answer for this problem is Prove This is AM GM inequality Link for whom don t know it The equality becomes only when And you should check on zeroes If a b c 0 you can choose any good answer x y z S "}
{"statement": "You have an array of integers initially empty You have to perform q queries Each query is of one of two types 1 x add the element x to the end of the array 2 x y replace all occurrences of x in the array with y Find the resulting array after performing all the queries ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s solve the problem from the end Let s maintain the array what number will become if we apply to it all the already considered queries of type If the current query is of the first type then we simply add to the resulting array If the current query is of the second type then we have to change the value of Since all occurrences of must be replaced with it is enough to assign Since we process each query in the final complexity is There is also an alternative solution Let s process queries in the direct order Let s store all its positions in an array for each number Then for the first query it is enough to put the index in the corresponding array of positions And for a query of the second type we have to move all the positions of the number into an array of positions of the number The naive implementation is obviously too slow but we can use the small to large method then the complexity of the solution will be "}
{"statement": "You are given two arrays of integers a 1 a 2 ldots a n and b 1 b 2 ldots b n Before applying any operations you can reorder the elements of each array as you wish Then in one operation you will perform both of the following actions if the arrays are not empty Choose any element from array a and remove it all remaining elements are shifted to a new array a Choose any element from array b and remove it all remaining elements are shifted to a new array b Let k be the final size of both arrays You need to find the minimum number of operations required to satisfy a i b i for all 1 leq i leq k This problem was too easy so the problem author decided to make it more challenging You are also given a positive integer m Now you need to find the sum of answers to the problem for m pairs of arrays c i b where 1 leq i leq m Array c i is obtained from a as follows c i 1 i c i j a j for 2 leq j leq n ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let s learn how to solve the problem for a fixed value of a1 Notice that we can perform a binary search on the answer Let s learn how to check if we can remove k elements from both arrays such that ai bi holds for the remaining elements It will be advantageous to sort both arrays remove the k largest elements from the first array and the k smallest elements from the second array and then simply check if the condition holds for our pair of arrays Thus for a fixed value of a1 we can solve the problem in O nlogn Let f i be the answer to the problem for a1 i We make the following observation there exists a value x such that f 1 f 2 f x f x 1 1 f x 2 1 f inf 1 Indeed changing one element of array a cannot worsen the answer by more than 1 Then we can use binary search to find this value x The overall complexity is O nlognlogm "}
{"statement": "Petya got an array a of numbers from 1 to n where a i i He performed n operations sequentially In the end he received a new state of the a array At the i th operation Petya chose the first i elements of the array and cyclically shifted them to the right an arbitrary number of times elements with indexes i 1 and more remain in their places One cyclic shift to the right is such a transformation that the array a a 1 a 2 dots a n becomes equal to the array a a i a 1 a 2 dots a i 2 a i 1 a i 1 a i 2 dots a n For example if a 5 4 2 1 3 and i 3 that is this is the third operation then as a result of this operation he could get any of these three arrays a 5 4 2 1 3 makes 0 cyclic shifts or any number that is divisible by 3 a 2 5 4 1 3 makes 1 cyclic shift or any number that has a remainder of 1 when divided by 3 a 4 2 5 1 3 makes 2 cyclic shifts or any number that has a remainder of 2 when divided by 3 Let s look at an example Let n 6 i e initially a 1 2 3 4 5 6 A possible scenario is described below i 1 no matter how many cyclic shifts Petya makes the array a does not change i 2 let s say Petya decided to make a 1 cyclic shift then the array will look like a textbf 2 textbf 1 3 4 5 6 i 3 let s say Petya decided to make 1 cyclic shift then the array will look like a textbf 3 textbf 2 textbf 1 4 5 6 i 4 let s say Petya decided to make 2 cyclic shifts the original array will look like a textbf 1 textbf 4 textbf 3 textbf 2 5 6 i 5 let s say Petya decided to make 0 cyclic shifts then the array won t change i 6 let s say Petya decided to make 4 cyclic shifts the array will look like a textbf 3 textbf 2 textbf 5 textbf 6 textbf 1 textbf 4 You are given a final array state a after all n operations Determine if there is a way to perform the operation that produces this result In this case if an answer exists print the numbers of cyclical shifts that occurred during each of the n operations ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "The first thing to notice the answer always exists For numbers answer choices as well as permutation combinations It remains only to restore the answer from this permutation We will restore by performing reverse operations On the th operation will be selectd the first elements of the array and rotate them times to the left elements with numbers and more remain in their places Where is equal to if otherwise and is the index of the number Thus for each from right to left performing a left cyclic shift operation we move the number at index As a result we move numbers times The time complexity "}
{"statement": "Once upon a time Oolimry saw a suffix array He wondered how many strings can produce this suffix array More formally given a suffix array of length n and having an alphabet size k count the number of strings that produce such a suffix array Let s be a string of length n Then the i th suffix of s is the substring s i ldots n 1 A suffix array is the array of integers that represent the starting indexes of all the suffixes of a given string after the suffixes are sorted in the lexicographic order For example the suffix array of is 3 2 4 1 0 5 6 as the array of sorted suffixes is texttt imry texttt limry texttt mry texttt olimry texttt oolimry texttt ry texttt y A string x is lexicographically smaller than string y if either x is a prefix of y and x neq y or there exists such i that x i y i and for any 1 leq j i x j y j ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "First let s consider a simpler problem Is it possible to make a string with a certain suffix array given an alphabet size Consider two adjacent suffixes in the suffix array xy and ab where and are some strings and and are some characters i e is the first character of that suffix and similarly for If and don t exist we consider them as i e smaller than everything Also xy comes before ab Observation If the position of is less than the position of in the suffix array must be less than Otherwise must be less than or equal to This can be easily shown as xy must be lexicographically smaller than ab This is sufficient also Thus we can iterate through the suffix array and check if where is the suffix array and is the position of the th element in the suffix array If this condition holds then the th character must be strictly less than the th character Thus we can just count how many such pairs exist If this count is larger than the alphabet size no such string is possible Otherwise such string exists Note that special care must be taken when considering as may not be defined indexed After tackling the simpler question we move on to the full question of counting how many such strings are there If we consider the string as an array and the order of the array as the order of the suffix array meaning that the th element of this array is the th element of the string We have now transformed the question into Given that some elements must be greater than the previous elements while others can be equal Count how many arrays are there such that the largest element is less than Consider the difference array some elements must be while some can be We add padding to the front and back of the array so as to account for the first value being non zero and the last element being less than These two elements are both Let be the number of elements that must be in the difference array Now this becomes count how many arrays of non negative elements sum to This can be solved using stars and bars so the final answer comes out to be which can be found easily Note that we define when Final Complexity or depending on how you find the modular inverse Btw was chosen to also be so as to hide the final complexity "}
{"statement": "Gildong is experimenting with an interesting machine In Graph Traveler there is a directed graph consisting of n vertices numbered from 1 to n The i th vertex has m i outgoing edges that are labeled as e i 0 e i 1 ldots e i m i 1 each representing the destination vertex of the edge The graph can have multiple edges and self loops The i th vertex also has an integer k i written on itself A on this graph works as follows Gildong chooses a vertex to start from and an integer to start with Set the variable c to this integer After arriving at the vertex i or when Gildong begins the travel at some vertex i add k i to c The next vertex is e i x where x is an integer 0 le x le m i 1 satisfying x equiv c pmod m i Go to the next vertex and go back to step 2 It s obvious that a travel never ends since the 2nd and the 3rd step will be repeated endlessly For example assume that Gildong starts at vertex 1 with c 5 and m 1 2 e 1 0 1 e 1 1 2 k 1 3 Right after he starts at vertex 1 c becomes 2 Since the only integer x 0 le x le 1 where x equiv c pmod m i is 0 Gildong goes to vertex e 1 0 1 After arriving at vertex 1 again c becomes 1 The only integer x satisfying the conditions is 1 so he goes to vertex e 1 1 2 and so on Since Gildong is quite inquisitive he s going to ask you q queries He wants to know how many vertices will be visited if he starts the travel from a certain vertex with a certain value of c Note that you should count the vertices that will be visited only finite times ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2300", "problem_editorial": "Since a travel will never end it is clear that every travel will eventually get into an infinite loop But we should consider more than just the vertices since could be different every time he visits the same vertex Since the number of outgoing edges of each vertex is at most we can see a can be reduced to for each vertex Therefore we can think that the graph actually has vertices each with a single outgoing edge To simulate the travels we just need to follow the exact process written in the description except that should be kept in modulo The problem is when to stop and how to count the number of vertices that are in the loop We can stop simulating until we find a state that we already have visited There can be two cases when we find a visited state The first case is when we have not visited this state in the previous travels i e this is the first travel that visits this state We need to check all of the states after the first visit of this state and count the number of distinct vertices Duplicated vertices can be removed simply by using a set or more efficiently using timestamp Then we can apply the answer to all of the states we visited in this travel The second case is when the state was visited in one of the previous travels We know that both the previous travel and the current travel will end in the same loop so we can apply the same answer to all of the states we visited in this travel On a side note the simulation can be done with recursion but this can lead to maximum of recursion depth This causes stack overflow or recursion limit excess for some languages including Java Time complexity "}
{"statement": "Long time ago Alex created an interesting problem about parallelogram The input data for this problem contained four integer points on the Cartesian plane that defined the set of vertices of some non degenerate positive area parallelogram Points not necessary were given in the order of clockwise or counterclockwise traversal Alex had very nice test for this problem but is somehow happened that the last line of the input was lost and now he has only three out of four points of the original parallelogram He remembers that test was so good that he asks you to restore it given only these three points ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Denote the input points as and the point we need to find as Consider the case when the segments and are the diagonals of parallelogram Vector is equal to the sum of two vectors As in the parallelogram the opposite sides are equal and parallel and we can conclude that So the coordinates of the point D can be calculated as The cases where the diagonals are and and are processed in the same way Prove that all three given points are different Let s suppose it s wrong Without losing of generality suppose that the points got in cases and are equal Consider the system of two equations for the equality of these points We can see that in can be simplified as And we got a contradiction as all the points are distinct "}
{"statement": "Tom loves vowels and he likes long words with many vowels His favorite words are vowelly words We say a word of length k is vowelly if there are positive integers n and m such that n cdot m k and when the word is written by using n rows and m columns the first row is filled first then the second and so on with each row filled from left to right every vowel of the English alphabet appears at least once in every row and every column You are given an integer k and you must either print a vowelly word of length k or print 1 if no such word exists In this problem the vowels of the English alphabet are ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "First which boards could we feasibly fill with characters satisfying that every row and column contains one vowel at least once Well if we have a board with less than 5 rows then each column contains less than 5 characters so we cannot have every vowel on each column and we can t fill the board Similarly we can t fill a board with less than 5 columns Ok so say now that we have a board with at least 5 rows and at least 5 columns Can we fill it Yes we can It s enough to fill it by diagonals as shown in the following picture Now we can easily solve the problem If n cdot m k then n must divide k and m frac k n So we can iterate over all possible n from 5 to k check whether n divides k and in that case check whether m frac k n is at least 5 If this works for at least one value of n then we can fill the n cdot m board by diagonals as shown before and obtain our vowelly word by reading the characters row by row If we don t find any values of n satisfying this then no vowelly word exists Complexity mathcal O k "}
{"statement": "Consider a simplified penalty phase at the end of a football match A penalty phase consists of at most 10 kicks the first team takes the first kick the second team takes the second kick then the first team takes the third kick and so on The team that scores more goals wins if both teams score the same number of goals the game results in a tie The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks For example if after the 7 th kick the first team has scored 1 goal and the second team has scored 3 goals the penalty phase ends the first team cannot reach 3 goals You know which player will be taking each kick so you have your predictions for each of the 10 kicks These predictions are represented by a string s consisting of 10 characters Each character can either be or This string represents your predictions in the following way if s i is then the i th kick will definitely score a goal if s i is then the i th kick definitely won t score a goal if s i is then the i th kick could go either way Based on your predictions you have to calculate the minimum possible number of kicks there can be in the penalty phase that means the earliest moment when the penalty phase is stopped considering all possible ways it could go Note that you may know that some kick will won t be scored but the referee doesn t ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "After you have fixed the values of you can easily find the number of kicks needed to decide the winners in constant time If you iterate over all possible values of you can get solution which works in for one testcase which is enough to pass The other possible solution is to notice that it s optimal to change of one team to and to for other So you only have two candidates to check "}
{"statement": "Luba has a ticket consisting of digits In one move she can choose digit in any position and replace it with arbitrary digit She wants to know the minimum number of digits she needs to replace in order to make the ticket lucky The ticket is considered lucky if the sum of first three digits equals to the sum of last three digits ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s iterate over all 6 digit numbers Now we will calculate number of positions in which digit of current ticket differs from digit of input ticket and call it Then answer will be minimal value over all lucky tickets "}
{"statement": "Vanya got an important task he should enumerate books in the library and label each book with its number Each of the books should be assigned with a number from to Naturally distinct books should be assigned distinct numbers Vanya wants to know how many digits he will have to write down as he labels the books ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "We can find out a formula for this problem for answer will be for answer will be for answer will be so for answer will be Time complexity where is the length of n We also could just try options and solve problem for each option UPD Don t use function pow to find powers of 10 because it doesn t work right sometimes C code Wild Hamster Java code Wild Hamster Python code Zlobober "}
{"statement": "For an array a define its as sum i 1 n operatorname mex dagger a 1 a 2 ldots a i You are given a permutation ddagger p of the set 0 1 2 ldots n 1 Find the maximum cost across all cyclic shifts of p dagger operatorname mex b 1 b 2 ldots b m is the smallest non negative integer x such that x does not occur among b 1 b 2 ldots b m ddaggerA permutation of the set 0 1 2 n 1 is an array consisting of n distinct integers from 0 to n 1 in arbitrary order For example 1 2 0 4 3 is a permutation but 0 1 1 is not a permutation 1 appears twice in the array and 0 2 3 is also not a permutation n 3 but there is 3 in the array ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "SolutionLet s analyze how the values of each prefix mex changes upon performing a cyclic shift to the left The first prefix mex is popped Each prefix mex with a value less than doesn t change Each prefix mex with a value greater than becomes is appended to the back Let s keep our prefix mexes compressed meaning that we keep the value and its frequency instead of keeping multiple same values After that we can simulate the above process naively with a deque because the potential will decrease by the number of performed operations This solution works in time "}
{"statement": "You are given an undirected unweighted connected graph consisting of n vertices and m edges It is guaranteed that there are no self loops or multiple edges in the given graph Your task is to choose lfloor frac n 2 rfloor vertices in this graph so unchosen vertex is adjacent in other words connected by an edge to at least one of chosen vertices It is guaranteed that the answer exists If there are multiple answers you can print any You will be given multiple independent queries to answer ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1700", "problem_editorial": "Firstly let s run bfs on the given graph and calculate distances for all vertices In fact we don t need distances we need their parities The second part is to find all vertices with an even distance all vertices with and odd distance and print the smallest by size part Why is it always true Firstly it is obvious that at least one of these sizes will not exceed And secondly because we are checking just parities of distances it is obvious that each vertex of some parity is connected with at least one vertex of the opposite parity because it has this parity from some vertex of the opposite parity "}
{"statement": "You are given a multiset of powers of two More precisely for each i from 0 to n exclusive you have cnt i elements equal to 2 i In one operation you can choose any one element 2 l 1 and divide it into two elements 2 l 1 You should perform q queries Each query has one of two types 1 pos val assign cnt pos val 2 x k calculate the minimum number of operations you need to make at least k elements with value lower or equal to 2 x Note that all queries of the second type don t change the multiset that is you just calculate the minimum number of operations you don t perform them ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Several observations Generally we have two types of operations divide and either or If then in one division we ll get element so we can just keep track of the total possible number of these operations as If then if we decide to split whole to s then we get elements but in operations i e in one division we ll get elements So it s preferably to fully split than Also the less the more profitable each division As a result let s act greedy let s say we need more elements Let s iterate over in the increasing order If then let s fully split in in operations decrease increase a counter of operations and increase accordingly If then the situation becomes complicated We can either don t touch and try to use preserved operations with small if or split in two s Now we spent one operation and get two If then we don t need one of and can split further only one If then it s optimal to fully split one of and proceed further with only one and recalculated and In both cases we can solve optimal splitting of recursively in the same manner as Since in each step we lower then we need to check only cases per each query Note that we can treat situation in packs for several with equal so the first part also works in The resulting complexity is per query "}
{"statement": "You are an intergalactic surgeon and you have an alien patient For the purposes of this problem we can and we will model this patient s body using a 2 times 2k 1 rectangular grid The alien has 4k 1 distinct organs numbered 1 to 4k 1 In healthy such aliens the organs are arranged in a particular way For example here is how the organs of a healthy such alien would be positioned when viewed from the top for k 4 Here the represents empty space In general the first row contains organs 1 to 2k 1 in that order from left to right and the second row contains organs 2k 2 to 4k 1 in that order from left to right and then empty space right after Your patient s organs are complete and inside their body but they somehow got shuffled around Your job as an intergalactic surgeon is to put everything back in its correct position All organs of the alien must be in its body during the entire procedure This means that at any point during the procedure there is exactly one cell in the grid that is empty In addition you can only move organs around by doing one of the following things You can switch the positions of the empty space with any organ to its immediate left or to its immediate right if they exist In reality you do this by sliding the organ in question to the empty space You can switch the positions of the empty space with any organ to its immediate top or its immediate bottom if they exist the empty space is on the column column or in the column Again you do this by sliding the organ in question to the empty space Your job is to figure out a sequence of moves you must do during the surgical procedure in order to place back all 4k 1 internal organs of your patient in the correct cells If it is impossible to do so you must say so ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3400", "problem_editorial": "The shortcuts thing in the output section is basically a way for you to define i e you can create simpler useful operations and then you can combine them into more complex operations Now to solve the problem we may represent the grid by the circular permutation obtained by going around the grid once say in a clockwise order starting from say the top left corner Without the middle column this circular permutation cannot be changed we can rotate it but that s it Thus to make progress we must use the middle column The key insight here is that moving something through the middle column corresponds to one and only one kind of operation which on our circular permutation corresponds to Notice that it simply moved a couple of places to the right In other words moving through the middle corresponds to a rotation of elements Since we can also rotate the whole thing this rotation can be performed in our permutation But since rotations and full rotations i e rotations are both permutations and these are the only available moves this means that inputs that are an odd permutation away from the target state are unsolvable You can also notice this right away once you realize that this problem is essentially the sliding picture puzzle but with even more restricted moves Amazingly the converse is true This follows from the fact that we can produce a rotation from the given operations You may want to try to come up with it yourself so instead of giving the sequence of moves directly I ll just give you a hint there is a sequence of that is equivalent to the rotation or and it only involves and If you still can t find it you could also write a backtracking program that finds it Once we have any single rotation it can then be applied anywhere again using with full rotations Also it is a well known fact that any even permutation is representable by a product of rotations This means that all even permutations are solvable Now determining which inputs are solvable is one thing but actually finding the solution is a whole different beast Fortunately the shortcuts thing is here to make it a bit easier The most important milestone is being able to come up with a sequence corresponding to a rotation assign an uppercase letter for such an operation After that you will only need rotations and full rotations to solve the rest "}
{"statement": "The new Die Hard movie has just been released There are people at the cinema box office standing in a huge line Each of them has a single or ruble bill A Die Hard ticket costs rubles Can the booking clerk sell a ticket to each person and give the change if he initially has no money and sells the tickets strictly in the order people follow in the line ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "In the problem you need to decide whether cashier can give a change to all customers if the price of the ticket is 25 rubles and there s 3 kinds of bills 25 50 and 100 rubles There s no money in the ticket office in the beginning Let s consider 3 cases The solution is to keep track of the number of 25 and 50 ruble bills and act greedily when giving change to 100 rubles try 25 50 first and then 25 25 25 "}
{"statement": "Allen has a LOT of money He has n dollars in the bank For security reasons he wants to withdraw it in cash we will not disclose the reasons here The denominations for dollar bills are 1 5 10 20 100 What is the minimum number of bills Allen could receive after withdrawing his entire balance ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The problem is to minimize given that It is pretty simple to see that we can operate greedily take as many as we can then then etc The solutions works because each number in the sequence is a divisor of the number after it "}
{"statement": "There are cities and two way roads in Berland each road connects two cities It is known that there is no more than one road connecting each pair of cities and there is no road which connects the city with itself It is possible that there is no way to get from one city to some other city using only these roads The road minister decided to make a reform in Berland and to orient all roads in the country i e to make each road one way The minister wants to the number of cities for which the number of roads that begins in the city to the number of roads that ends in it ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2200", "problem_editorial": "Let s solve this problem for each connected component separately At first we need to understand fact that in each connected component there are even number of vertices with odd degree Let in the current connected component there are vertices with odd degree and they have numbers Then we need to add in graph non directional edges So in the current component now all vertices have even degree and there is exist Euler cycle which we need to find and orientate all edges in the order of this cycle It is easy to show that after that for all vertices which had even degree before we added the edges in degree is equal to out degree In the other words we show that the maximum number of vertices with equal in and out degrees in orientated graph equals to the number of vertices with even degree in non orientated graph After we found Euler cycles for all connected components we need to print orientation of the edges and be careful and do not print edges which we added to the graph to connect vertices with odd degrees "}
{"statement": "Squirrel Liss loves nuts There are trees numbered to from west to east along a street and there is a delicious nut on the top of each tree The height of the tree is Liss wants to eat all nuts Now Liss is on the root of the tree with the number In one second Liss can perform one of the following actions Walk up or down one unit on a tree Eat a nut on the top of the current tree Jump to the next tree In this action the height of Liss doesn t change More formally when Liss is at height of the tree she jumps to height of the tree This action can t be performed if Compute the minimal time in seconds required to eat all nuts ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "The optimal path of Liss is as follows First she starts from the root of tree 1 Walk up the tree to the top and eat a nut Walk down to the height min h1 h2 Jump to the tree 2 Walk up the tree to the top and eat a nut Walk down to the height min h2 h3 and so on "}
{"statement": "Today on a math lesson the teacher told Vovochka that the Euler function of a positive integer is an arithmetic function that counts the positive integers less than or equal to n that are relatively prime to n The number is coprime to all the positive integers and Now the teacher gave Vovochka an array of positive integers and a task to process queries to calculate and print modulo As it is too hard for a second grade school student you ve decided to help Vovochka ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Read input including queries to solve them offline Sort the queries by making sure to keep their original indices Use Sieve of Erastosthenes to precalculate primes up to Use those primes to factorize all the values of this step takes We want to store the results in two data structures Initialize a BIT or segment tree that can calculate range products modulo with the values from Use to find the leftmost index for each prime factor Multiply those positions in by We can now answer queries with using To advance by to eventually answer the rest of the queries Sample 65793661 "}
{"statement": "International Women s Day is coming soon Polycarp is preparing for the holiday There are n candy boxes in the shop for sale The i th box contains d i candies Polycarp wants to prepare the maximum number of gifts for k girls Each gift will consist of boxes The girls should be able to share each gift equally so the total amount of candies in a gift in a pair of boxes should be divisible by k In other words two boxes i and j i ne j can be combined as a gift if d i d j is divisible by k How many boxes will Polycarp be able to give Of course each box can be a part of no more than one gift Polycarp cannot use boxes partially or redistribute candies between them ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let be the number of boxes with candies modulo Firstly the number of of boxes we can obtain using two boxes with remainder modulo is Secondly if is even then we also can obtain of boxes using two boxes with remainder modulo and its number is And for any other remainder from to the number of pairs of boxes is So if we sum up all these values the answer is this sum multiplied by two because we have to print the number of boxes not pairs "}
{"statement": "Coming up with a new problem isn t as easy as many people think Sometimes it is hard enough to name it We ll consider a title if it doesn t occur as a substring in any titles of recent Codeforces problems You ve got the titles of last problems the strings consisting of lowercase English letters Your task is to find the shortest original title for the new problem If there are multiple such titles choose the lexicographically minimum one Note that title of the problem can t be an empty string A of string where is the length of string is string String is than string if either and or there exists such number that and The string characters are compared by their ASCII codes ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "The total number of different strings of 2 letters is but the total length of the input strings is no more than It means that the length of answer is no more than 2 So just check all the strings of length 1 and 2 "}
{"statement": "Mocha is a young girl from high school She has learned so much interesting knowledge from her teachers especially her math teacher Recently Mocha is learning about binary system and very interested in bitwise operation This day Mocha got a sequence a of length n In each operation she can select an arbitrary interval l r and for all values i 0 leq i leq r l replace a l i with a l i a r i at the same time where denotes the bitwise AND operation This operation can be performed For example if n 5 the array is a 1 a 2 a 3 a 4 a 5 and Mocha selects the interval 2 5 then the new array is a 1 a 2 a 5 a 3 a 4 a 4 a 3 a 5 a 2 Now Mocha wants to minimize the maximum value in the sequence As her best friend can you help her to get the answer ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "We assume the answer is In its binary representation one bit will be only if in all the s binary representation this bit is Otherwise we can use one operation to make this bit in become 0 which is a smaller answer So we can set initially Then we iterate over the sequence and make the is the anwser finally "}
{"statement": "A football league has recently begun in Beautiful land There are n teams participating in the league Let s enumerate them with integers from 1 to n There will be played exactly frac n n 1 2 matches each team will play against all other teams exactly once In each match there is always a winner and loser and there is no draw After all matches are played the organizers will count the number of Let s call a triple of three teams A B C beautiful if a team A win against a team B a team B win against a team C and a team C win against a team A We look only to a triples of different teams and the order of teams in the triple is important The beauty of the league is the number of beautiful triples At the moment m matches were played and their results are known What is the maximum beauty of the league that can be after playing all remaining matches Also find a possible results for all remaining frac n n 1 2 m matches so that the league has this maximum beauty ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Firstly Let s calculate the number of non beautiful triples given all result of matches It is obvious that for each non beautiful triple there exactly is one team that wins over the others So if a team wins other teams then team A corresponds to non beautiful triple If we define as the number of wins of teams Then the number of non beautiful triples will be Notice that So we only need to minimize the square sum The remain can be solved easily by Mincost Maxflow Creating source sink each match node for each match haven t played yet each team node for each team Add an edge between source and each match node with capacity cost Add an edge between each match node and each of two team nodes with capacity cost Assuming after matches played th team wins matches We add edges between the th team node and sink with capacity and costs The min cost after run Mincost Maxflow plus will give us the minimal square sum Base on Mincost Maxflow idea we can solve in more sophisticated way At any moment we will try to pick a team with minimal number of wins Then we try to give it one more win by setting result of a match that haven t used so far and possibly changing results of a path of matches to keep the number of win of others If not pick next one and so on Complexity "}
{"statement": "Karen has just arrived at school and she has a math test today The test is about basic addition and subtraction Unfortunately the teachers were too busy writing tasks for Codeforces rounds and had no time to make an actual test So they just put one question in the test that is worth all the points There are integers written on a row Karen must alternately add and subtract each pair of adjacent integers and write down the sums or differences on the next row She must repeat this process on the values on the next row and so on until only one integer remains The first operation should be addition Note that if she ended the previous row by adding the integers she should start the next row by subtracting and vice versa The teachers will simply look at the last integer and then if it is correct Karen gets a perfect score otherwise she gets a zero for the test Karen has studied well for this test but she is scared that she might make a mistake somewhere and it will cause her final answer to be wrong If the process is followed what number can she expect to be written on the last row Since this number can be quite large output only the non negative remainder after dividing it by ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "There are a couple of ways to solve this problem The easiest way is to calculate the coefficients or contributions of each number to the final sequence In fact the contribution of any number is determined by its position as well as the To do this using brute force we can compute the contribution of each element by just running a brute force on for all positions and then trying to observe patterns In any case one should eventually realize that the pattern depends on When the pattern is When the pattern is When the pattern is When the pattern is This is perhaps what most contestants did in the contest We will not prove that this is correct instead a more elegant solution will be suggested First simplify the problem so that only addition ever happens In fact this version is much easier the contribution of the element when there are elements is precisely Now let s go back to the original task We will repeatedly perform the operation until the number of elements is even and the first operation is addition to reduce the number of cases we have to handle It can be observed that regardless of our starting this will happen somewhere within the first two rows We can therefore just brute force it Observe the following picture Consider the blue elements only Am I the only one whose mind is on the verge of exploding Notice that they are doing precisely the simpler version of the task In other words if we consider only we are basically solving the simple version of the task In fact the same can be said of Why is this true Well look at the picture Notice that if we have an even number of elements with the first element being addition then after rows it will again be even and the first element will also be addition so the pattern simply continues We can hence compute the final two values on the second to last row and then add or subtract them depending on what the final operation should be In fact this also explains the patterns we observed for and To compute quickly we can use the formula We can just preprocess all relevant factorials in and also their modular multiplicative inverses modulo in order to perform the division This runs in or just if you are willing to consider the a constant "}
{"statement": "Li Hua wants to solve a problem about varphi Euler s totient function Please recall that varphi x sum limits i 1 x gcd i x 1 dagger ddagger He has a sequence a 1 a 2 cdots a n and he wants to perform m operations 1 l r 1 le l le r le n for x in l r change a x into varphi a x 2 l r 1 le l le r le n find out the minimum changes needed to make sure a l a l 1 cdots a r In each change he chooses x in l r change a x into varphi a x Each operation of this type is independent which means the array doesn t actually change Suppose you were Li Hua please solve this problem dagger gcd x y denotes the greatest common divisor GCD of integers x and y ddagger The notation textrm cond equals 1 if the condition textrm cond is true and 0 otherwise ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Denote Also denote It can be proven that after operations any will become and more operations are useless In other words Let s construct a tree of size where is the root and the father of is The height of the tree is After some precalculating we can find the LCA of two vertices within We can use a dsu to maintain the next not element of each and use a segment tree to maintain the LCA minimal depth and answer in the range We can brute force the changes using the dsu and meanwhile do point update on the segment tree The queries can be solved using a range query on the segment tree With the potential method we denote as the minimum integer which satisfies Since each successful operation on will decrease by the maximum number of successful operations we can perform on is Therefore the maximum number of successful operations is For each successful operation we visit nodes on the segment tree and merge the information of two subtrees for times Because of the time complexity of calculating LCA We need time to merge the information So all the operations will take up time We need to initialize within time and binary lifting the ancestors on the tree within time We also need for each query In conclusion the time complexity is The above algorithm is enough to pass this problem However it has a mass number of information merging operations so it runs quite slowly We use the segment tree not only to maintain the LCA minimal depth and answer of the ranges but also whether If we enter a node whose we can just ignore it Otherwise we recursively work on the segment tree until leaf and brute force update its information Time complexity is the same but it s much more efficient Bonus Can you solve this problem within "}
{"statement": "The orangutan has gifted you an array a of length n Using a you will construct two arrays b and c both containing n elements in the following manner b i min a 1 a 2 ldots a i for each 1 leq i leq n c i max a 1 a 2 ldots a i for each 1 leq i leq n Define the of a as sum i 1 n c i b i i e the sum of c i b i over all 1 leq i leq n Before you calculate the you can the elements of a however you want Find the maximum that you can get if you shuffle the elements of a optimally ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Problem Credits Proof by QED Analysis Proof by QED Solution First what is the maximum possible value of for any Since is the maximum element of some subset of and is the minimum element of some subset of the maximum possible value of is Also note that for any reordering of By reordering such that the largest element of appears first and the smallest element of appears second the maximum possible value of the score is achieved This results in a score of "}
{"statement": "It s May in Flatland and there are m days in this month Despite the fact that May Holidays are canceled long time ago employees of some software company still have a habit of taking short or long vacations in May Of course not all managers of the company like this There are n employees in the company that form a tree like structure of subordination each employee has a unique integer id i between 1 and n and each employee with id i except the head manager whose id is 1 has exactly one direct manager with id p i The structure of subordination is not cyclic i e if we start moving from any employee to his direct manager then we will eventually reach the head manager We define that an employee u is a subordinate of an employee v if v is a direct manager of u or the direct manager of u is a subordinate of v Let s i be the number of subordinates the i th employee has for example s 1 n 1 because all employees except himself are subordinates of the head manager Each employee i has a bearing limit of t i which is an integer between 0 and s i It denotes the maximum number of the subordinates of the i th employee being on vacation at the same moment that he can bear If at some moment strictly more than t i subordinates of the i th employee are on vacation and the i th employee himself is not on a vacation he becomes In each of the m days of May exactly one event of the following two types happens either one employee leaves on a vacation at the beginning of the day or one employee returns from a vacation in the beginning of the day You know the sequence of events in the following m days Your task is to compute for each of the m days the number of displeased employees on that day ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "In terms of trees we have a rooted tree whose vertices may be activated and deactivated and each vertex has a limit for the number of deactivated vertices among its descendants We are required to switch the state of some vertex and after each query we report the number of activated vertices unsatisfied vertices Let the balance of a vertex be equal to the difference between its limit of deactivated descendants and the actual number of deactivated vertices among its descendants In such terms we are interested in the number of activated vertices with the negative balance Let s utilize the idea of sqrt optimization Consider a block of k consecutive queries let us answer all of them Suppose this query affects the state of vertices v1 v2 vl l k let us call such vertices interesting Then during the current query block the balance will change only for the vertices that have at least one interesting vertex in its subtree Let s perform a classical trick of building the condensed tree containing the given interesting vertices Namely sort all the interesting vertices in order of their visit when doing DFS and add all vertices of form lca vi vi 1 for all 1 i l to the set of interesting vertices After such procedure all vertices whose balance may change may be splitted into O k vertical paths each of which ends in an interesting vertex Now we are going to consider separately the interesting vertices and the interior vertices of all paths between interesting vertices In each of the paths the balance of all vertices is changed simultaneously thus we may sort all the vertices in each path by balance and then group all vertices having the same balance together Introduce a pointer that initially stands at the first satisfied group with non negative balance When the balance of all groups is changed by 1 instead of actually changing the value of balance we may just shift the pointer by at most one position to the left or to the right artificially changing the origin and accounting at most one group the pointer has passed in the answer On each query we have to perform such an operation with every path and interesting vertex that is located above the queried vertex Since each vertex and each path is processed in O 1 processing a single query takes O k time and processing all queries inside a block takes O k2 time It is possible to build all paths and groups in running time of a single DFS plus sort time std sort or counting sort for grouping vertices of equal balance This part of solution takes O n per each query block or O nlogn depending on used sorting algorithm If we use count sort the resulting complexity will be O mk k2 n finally we can take k n and get O mn running time "}
{"statement": "A portal of dark forces has opened at the border of worlds and now the whole world is under a terrible threat To close the portal and save the world you need to defeat n monsters that emerge from the portal one after another Only the sorceress Vika can handle this She possesses two magical powers water magic and fire magic In one second Vika can generate w units of water mana and f units of fire mana She will need mana to cast spells Initially Vika have 0 units of water mana and 0 units of fire mana Each of the n monsters that emerge from the portal has its own strength expressed as a positive integer To defeat the i th monster with strength s i Vika needs to cast a water spell or a fire spell of at least the same strength In other words Vika can spend at least s i units of water mana on a water spell or at least s i units of fire mana on a fire spell Vika can create and cast spells instantly Vika can cast an unlimited number of spells every second as long she has enough mana for that The sorceress wants to save the world as quickly as possible so tell her how much time she will need ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "First let s note that Vika can defeat all the monsters at once in the last second There is no point in spending mana gradually Now let s say we know how many seconds Vika will accumulate mana before spending it Then we also know how much mana she will have accumulated by that time How should she spend it Note that the total strength of the monsters is given to us Therefore it is enough for us to spend as much of the available water mana as possible so that there is enough fire mana left for the remaining monsters This is a well known knapsack problem Finally let s note that we don t need to iterate over the number of seconds and build the knapsack each time It is enough to build it initially and then iterate over how much water mana we will spend and whether we will have enough fire mana left for the rest "}
{"statement": "You are given an array a of length n The of a is the MEX dagger of a 1 a 2 a 2 a 3 ldots a n 1 a n Find the minimum score of a if you are allowed to rearrange elements of a in any order Note that you are to construct the array a that achieves the minimum score dagger The MEX minimum excluded of an array is the smallest non negative integer that does not belong to the array For instance The MEX of 2 2 1 is 0 because 0 does not belong to the array The MEX of 3 1 0 1 is 2 because 0 and 1 belong to the array but 2 does not The MEX of 0 3 1 2 is 4 because 0 1 2 and 3 belong to the array but 4 does not ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Hint 1 First let s determine if can be That means we can t place two s next to each other This is achievable when the number of s is not greater than Then determine if can be That means we can t place and next to each other Therefore if there is no in or there exist an element in we can simply rearrange as to make The last case there are only and in and the number of s is greater than We want to make which is the minimum Since the number of s is not greater than the number of s we can rearrange as to make "}
{"statement": "Mihai and Slavic were looking at a group of n frogs numbered from 1 to n all initially located at point 0 Frog i has a hop length of a i Each second frog i hops a i units forward Before any frogs start hopping Slavic and Mihai can place trap in a coordinate in order to catch all frogs that will ever pass through the corresponding coordinate However the children can t go far away from their home so they can only place a trap in the first n points that is in a point with a coordinate between 1 and n and the children can t place a trap in point 0 since they are scared of frogs Can you help Slavic and Mihai find out what is the maximum number of frogs they can catch using a trap ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "We disregard any larger than since we can t catch them anyway We keep in how many frogs we have for each hop distance We go through each from to and add to every multiple of smaller or equal to This action is a harmonic series and takes time We go through all from to and take the maximum "}
{"statement": "There are frogs sitting on the coordinate axis For each frog two values are known the position and the initial length of the tongue of the th frog it is guaranteed that all positions are different mosquitoes one by one are landing to the coordinate axis For each mosquito two values are known the coordinate of the position where the th mosquito lands and the size of the th mosquito Frogs and mosquitoes are represented as points on the coordinate axis The frog can eat mosquito if mosquito is in the same position with the frog or to the right and the distance between them is not greater than the length of the tongue of the frog If at some moment several frogs can eat a mosquito the leftmost frog will eat it with minimal After eating a mosquito the length of the tongue of a frog increases with the value of the size of eaten mosquito It s possible that after it the frog will be able to eat some other mosquitoes the frog should eat them in this case For each frog print two values the number of eaten mosquitoes and the length of the tongue after landing all mosquitoes and after eating all possible mosquitoes by frogs Each mosquito is landing to the coordinate axis only after frogs eat all possible mosquitoes landed before Mosquitoes are given in order of their landing to the coordinate axis ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Let s maintain the set of not eaten mosquitoes for example with set in C or with TreeSet in Java and process mosquitoes in order of their landing Also we will maintain the set of segments where is the position of the th frog and where is the current length of the tongue of the th frog Let the current mosquito landed in the position Let s choose segment with minimal such that If the value we found the frog that will eat mosquito Otherwise the current mosquito will not be eaten and we should add it to our set If the th frog will eat mosquito then it s tongue length will be increased by the size of mosquito and we should update segment After that we should choose the nearest mosquito to the right the from frog and if it s possible eat that mosquito by the th frog this can be done with lower bound in C Possibly we should eat several mosquitoes so we should repeat this process several times Segments we can store in segment tree by position and value Now to find segment we need we can do binary search by the value of and check the maximum value on the prefix to be at least This will work in time We can improve this solution Let s go down in segment tree in the following manner if the maximum value in the left subtree of segment tree is at least then we will go to the left otherwise we will go to the right Complexity "}
{"statement": "Effluvium of the MindYou are given a positive integer n Find any permutation p of length n such that the sum operatorname lcm 1 p 1 operatorname lcm 2 p 2 ldots operatorname lcm n p n is as large as possible Here operatorname lcm x y denotes the least common multiple LCM of integers x and y A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "A well know fact is that for any two positive integers and Since for all positive we get that All of this should hint that for even the optimal permutation looks like this Add for odd it looks like this Complexity Turns out the formal proof is pretty hard You are welcome to try and find something simpler Define as if and otherwise It is easy to see that We will find the maximum possible value of and show that it is reached by our construction Suppose we want to solve this problem find the max possible value of if for all This is equivalent to maximizing because if there is such an index it is always optimal to swap with for any Let s build a graph on this permutation with n vertices and add all edges Except for maybe all the other cycles have a length of at least 2 Let s look at one such cycle The optimal value with no restrictions on the value of would be but right now we have Subtracting one from the other So we need to minimize the sum of over all cycles If is even it is easy to see the minimum possible value of this is and it doesn t matter what equals to For odd we have to look at two cases and In the first case the minimum possible sum is in the second case it is which is worse that in the previous case Returning to the original problem our constructions also achieve this minimal difference from even when we change back into so they are optimal "}
{"statement": "Two beavers Timur and Marsel play the following game There are logs each of exactly meters in length The beavers move in turns For each move a beaver chooses a log and gnaws it into some number more than one of parts the length of each one is expressed by an integer and is no less than meters Each resulting part is also a log which can be gnawed in future by any beaver The beaver that can t make a move loses Thus the other beaver wins Timur makes the first move The players play in the optimal way Determine the winner ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "If n is even Marsel wins he just symmetrically repeats moves of Timur Now consider a case of odd n If Timur cannot move he is losing automatically If he can do a move he always can split one log into few parts that this parts cannot be splitted again It can be done if we have find minimal t that k t m and t m Next we split log into parts with length t Thereafter Timur symmetrically repeats moves of Marsel and wins For checking that Timur could move or not you can iterate over all divisors of m If there is exists some divisor t that k t m Timar can do a move Chech of all divisors can be done in time "}
{"statement": "Ashish has a tree consisting of n nodes numbered 1 to n rooted at node 1 The i th node in the tree has a cost a i and binary digit b i is written in it He wants to have binary digit c i written in the i th node in the end To achieve this he can perform the following operation any number of times Select any k nodes from the subtree of any node u and shuffle the digits in these nodes as he wishes incurring a cost of k cdot a u Here he can choose k ranging from 1 to the size of the subtree of u He wants to perform the operations in such a way that every node finally has the digit corresponding to its target Help him find the minimum total cost he needs to spend so that after all the operations every node u has digit c u written in it or determine that it is impossible ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": " Let the parent of node be If we can do the shuffling which was done at at instead Thus we can do the operation Let us denote nodes that have and as type and those that have and as type Firstly the answer is if and only if the number of nodes of type and type are unequal We also observe that only nodes of type and should be shuffled it is unoptimal to shuffle those which already have Thus we should try to exchange the values of type and type nodes We use the key idea by going down from the root and at every node setting where is the parent node of in the tree Thus the s now follow a special structure they are non increasing from the root to the leaves This paves the way for our greedy solution we will go upwards from the leaves and at each node interchange type and type nodes until we have no nodes in one of these types Then we pass on the remaining nodes to the parent to be shuffled "}
{"statement": "In Omkar s last class of math he learned about the least common multiple or LCM LCM a b is the smallest positive integer x which is divisible by both a and b Omkar having a laudably curious mind immediately thought of a problem involving the LCM operation given an integer n find positive integers a and b such that a b n and LCM a b is the minimum value possible Can you help Omkar solve his ludicrously challenging math problem ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Short Solution The two integers are and where is the largest proper factor of Proof Let the two integers be and Assume WLOG that Notice that this implies that We first claim that if and we prove this as follows if then there exists some integer such that The integer can then be written as which is a multiple of Thus if We now show that if We show this by using the fact that iff so if and so And since must be a multiple of both and it follows that We have now established that to minimize must be a factor of And since when is a factor of we need to minimize so we must maximize by choosing it to be the largest proper factor of i e the largest factor of other than We then simply need to find the largest proper factor of If is the smallest prime dividing then so it suffices to find the smallest prime factor of We can do this by simply checking all values of such that If is not prime then it must have a prime factor not exceeding Furthermore if we do not find a factor of between and then must be prime so we simply get and We re given that so meaning that we will check less than numbers which runs well under the time limit "}
{"statement": "You are given an array a consisting of n positive integers You are allowed to perform this operation any number of times possibly zero choose an index i 2 le i le n and change a i to a i a i 1 Is it possible to make a i 0 for all 2 le i le n ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "For all is the multiple of is equivalent to the YES answer must be the multiple of Otherwise cannot become zero In the whole process is always the multiple of So must be the multiple of Otherwise cannot become zero In the whole process is always the multiple of So must be the multiple of Otherwise cannot become zero For all is the multiple of So we can perform operations to make and then make Consider everything in the reverse order You are given an array consisting of positive integers where and zeros You are given an array consisting of positive integers It is guaranteed that You are allowed to perform this operation any number of times possibly zero Choose an index and change to Is it possible to change to Check if is the multiple of "}
{"statement": "We call a string if after merging all the consecutive equal characters the resulting string is palindrome For example is good because after the merging step it will become Given a string you have to find two values the number of good substrings of even length the number of good substrings of odd length ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Merging Step We have to convert string like aaaabbbaabaaa into ababa Important ObservationA substring made of the string will be a good palindrome if their starting and ending characters are same If the starting and ending characters are same then the middle characters after merging will be alternating between a and b eg abaa is not a palindrome but it is a good palindrome After merging step it becomes aba Note that in the string left after merging the consecutive characters will alternate between a and b So if we are currently at the character then we can have to simply check how many positions we have encountered upto now having the same character as that of For counting even and odd separately we can make count of a s and b s at even and odd positions So if we are at position for counting even good palindromes you just need to add count of number of characters a s at odd position For counting odd good palindromes you just need to add count of number of characters a s at even position Complexity n where is length of string Solution codes Note that you can also consult following comment for alternate editorial "}
{"statement": "We ll call a sequence of integers a good sequence if we can add to it at most numbers in such a way that after the sorting the sequence will be an arithmetic progression with difference You got hold of some sequence consisting of integers Your task is to find its longest contiguous subsegment such that it is a good sequence ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "In this problem you have to find longest subsegment satisfying the condition Reduce problem to If then answer is longest subsegment from equal numbers this case we solve separately If then notice that if on some subsegment there are two numbers so that "}
{"statement": "You are given two arrays a and b of positive integers with length n and m respectively Let c be an n times m matrix where c i j a i cdot b j You need to find a subrectangle of the matrix c such that the sum of its elements is at most x and its area the total number of elements is the largest possible Formally you need to find the largest number s such that it is possible to choose integers x 1 x 2 y 1 y 2 subject to 1 leq x 1 leq x 2 leq n 1 leq y 1 leq y 2 leq m x 2 x 1 1 times y 2 y 1 1 s and sum i x 1 x 2 sum j y 1 y 2 c i j leq x ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Note that for a subrectangle corresponding to x 1 y 1 x 2 y 2 x 1 y 1 x 2 y 2 as in the statement c i j c i j corresponds to the term we get when we multiply i x 1 x 2 a i j y 1 y 2 b j i x 1 x 2 a i j y 1 y 2 b j This allows us to decouple the rows and the columns of the matrix More specifically consider the subarray of a a with indices from x 1 x 1 to x 2 x 2 let s call it a x 1 x 2 a x 1 x 2 and also consider the subarray of b b with indices from y 1 y 1 to y 2 y 2 let s call it b y 1 y 2 b y 1 y 2 Define the cost of a subarray as the sum of elements in it Then the sum of the subrectangle equals the cost of a x 1 x 2 a x 1 x 2 times the cost of b y 1 y 2 b y 1 y 2 So now we focus on only the one dimensional arrays given to us For a given value C C of the cost let s try to find the maximum length of a subarray of a a with cost C C let s call this C C Using this we can compute the maximum length of a subarray that has a cost at most C C by finding the prefix maximums of Let s also do this for the array b b The problem now reduces to finding max A i B j maxA i B j subject to the constraints i j x i j x for two monotonically non decreasing arrays A A and B B the reduction follows by setting A A to be the array found in the previous paragraph for a a and B B to be the analogue of A A for b b Now this problem can be solved in linear time in the sizes of the arrays using two pointers let s iterate over i i from right to left Note that the rightmost j j such that i j x i j x is in fact x i x i and this is non decreasing as i i decreases In fact since B B is non decreasing two pointers are redundant and we can simply query B x i B x i Note that there is one potential catch the sizes of A A and B B might be large But the constraints on the arrays a a and b b show that the maximum size is 4 1 0 6 4 10 6 and the constraints on n n show that we can run an O n 2 O n 2 loop to compute the arrays A A and B B from a a and b b fast enough The time complexity is O max i 1 n a i i 1 m b i n 2 m 2 O max i 1 n a i i 1 m b i n 2 m 2 "}
{"statement": "Anya is engaged in needlework Today she decided to knit a scarf from semi transparent threads Each thread is characterized by a single integer the transparency coefficient The scarf is made according to the following scheme horizontal threads with transparency coefficients a 1 a 2 ldots a n and vertical threads with transparency coefficients b 1 b 2 ldots b m are selected Then they are interwoven as shown in the picture below forming a piece of fabric of size n times m consisting of exactly nm nodes After the interweaving tightens and there are no gaps between the threads each node formed by a horizontal thread with number i and a vertical thread with number j will turn into a cell which we will denote as i j Cell i j will have a transparency coefficient of a i b j The of the resulting scarf will be the number of its sub squares dagger in which there are no pairs of neighboring dagger dagger cells with the same transparency coefficients Anya has not yet decided which threads to use for the scarf so you will also be given q queries to increase decrease the coefficients for the threads on some ranges After each query of which you need to output the interestingness of the resulting scarf dagger A sub square of a piece of fabric is defined as the set of all its cells i j such that x 0 le i le x 0 d and y 0 le j le y 0 d for some integers x 0 y 0 and d 1 le x 0 le n d 1 le y 0 le m d d ge 0 dagger dagger Cells i 1 j 1 and i 2 j 2 are neighboring if and only if i 1 i 2 j 1 j 2 1 ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "SolutionLet s assume that for some then for any the cells and will have the same transparency A similar statement can be made if there is an index Then the positions divide the array into textit blocks in each of which all neighboring pairs are not equal to each other It is clear that if there is a square consisting of cells such that and then the segment is entirely contained in one of these textit blocks of the array Similarly the array can also be divided into blocks and then the segment will also be entirely contained in one of the blocks Let s try to solve the problem in time if there are no neighboring elements with the same values in the arrays and also assuming that This formula can be further transformed by introducing a quadruple of numbers for each natural number Then if and if But if there are neighboring identical elements in the arrays and then this means that they are somehow divided into blocks If these are blocks of lengths in the array and blocks of lengths in the array then the answer to the problem is Let s learn how to quickly calculate sums of the form To do this we will create 4 segment trees to quickly calculate the sums over segments of taking into account the multiplicity of in the array Now the calculation of is reduced to segment tree queries The sum is calculated similarly Now we just need to put our solution together We will maintain the blocks of arrays and in an online mode It is very convenient to do this by storing the positions in a data structure like std set and also by working with the differential array i e maintaining not the array itself but the array of differences between neighboring elements To recalculate the answer we will count the number of squares that are involved in a specific block of the array or using the above result As a result we have a solution in P S A solution in will not work due to a large constant I tried very hard to rule it out D "}
{"statement": "Kristina has a string s of length n consisting only of lowercase and uppercase Latin letters For each pair of lowercase letter and its matching uppercase letter Kristina can get 1 burl However pairs of characters cannot overlap so each character can only be in one pair For example if she has the string s aAaaBACacbE she can get a burl for the following character pairs s 1 a and s 2 A s 4 a and s 6 A s 5 B and s 10 b s 7 C and s 9 c Kristina wants to get more burles for her string so she is going to perform no more than k operations on it In one operation she can either select the lowercase character s i 1 le i le n and make it uppercase or select uppercase character s i 1 le i le n and make it lowercase For example when k 2 and s aAaaBACacbE it can perform one operation choose s 3 a and make it uppercase Then she will get another pair of s 3 A and s 8 a Find number of burles Kristina can get for her string ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Count two arrays and such that contains the number of occurrences of th letter of the alphabet in the string in upper case while in lower case Let s add all existing pairs to the answer so let s add to it for each letter Subtract this minimum from and to get the number of unpaired identical letters Next we will act greedily if there is some set of at least two identical letters in the same case we can apply the operation to half of them and get new pairs Therefore for each letter we will add to the answer and decrease by that amount "}
{"statement": "Iahub got lost in a very big desert The desert can be represented as a square matrix where each cell is a zone of the desert The cell represents the cell at row and column Iahub can go from one cell only down or right that is to cells or Also there are cells that are occupied by volcanoes which Iahub cannot enter Iahub is initially at cell and he needs to travel to cell Knowing that Iahub needs second to travel from one cell to another find the minimum time in which he can arrive in cell ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Our first observation is that if there is a path from 1 1 to N N then the length of path is 2 N 2 Since all paths have length 2 N 2 it follows that if there is at least one path the answer is 2 N 2 and if there isn t the answer is 1 How to prove it Every path from 1 1 to N N has exactly N 1 down directions and exactly N 1 right directions So total length for each path is N 1 N 1 2 N 2 So we reduced our problem to determine if there is at least one path from 1 1 to N N This is the challenging part of this task considering that N 10 9 How would you do it for a decently small N let s say N 10 3 One possible approach would be for each row keep a set of reachable columns We could easily solve this one by doing this if i j denotes element from ith row and jth column then i j is is not reachable if if i j contains a volcano then i j is not reachable Otherwise if at least one of i 1 j and i j 1 is reachable then i j is reachable Otherwise i j is not reachable What s the main problem of this approach It needs to keep track of 10 9 lines and in worst case each of those lines can have 10 9 reachable elements So worst case we need 10 9 10 9 10 18 operations and memory Can we optimize it We can note for beginning that we don t need to keep track of 10 9 lines only m lines are really necessarily We need only lines containing at least one obstacle in worst case when each line contains only one obstacle we need m lines How to solve it this way Suppose line number x contains some obstacles and lines x 1 x 2 x 3 do not contain any obstacle Suppose we calculated set S y cell x y is reachable How would look S1 S2 S3 corresponding to lines x 1 x 2 x 3 For S1 we can reach cell x 1 ymin where ymin is minimal value from set S Then we can also reach ymin 1 ymin 2 N by moving right from x 1 ymin So S1 ymin ymin 1 N How do S2 and S3 look It s easy to see that they ll be as well ymin ymin 1 N So we get following optimization suppose set of lines containing at least one obstacle is L1 L2 Lk We need to run algorithm only for lines L1 L1 1 L2 L2 1 L3 L3 1 Lk Lk 1 It looks like we didn t make anything with this optimization Even if we calculate for m lines each line can still have 10 9 reachable positions So worst case we perform 10 14 operations We need something better for managing information from a line You can note that for a given line y there are a lot of positions having consecutive values There are a lot of positions x y and x y 1 both reachable This should give us following idea what if instead of keeping reachable positions we keep reachable ranges That is for each line x we keep a set of ranges S a b all cells x k with a k b are reachable How many ranges can it be for a line If the line contains m obstacles there are m 1 ranges Suppose for line x all cells are reachable but for line x 1 cells x 1 3 x 1 5 x 1 N 1 are blocked Then the ranges of reachable cells are 1 2 4 4 6 N 2 and N N By now we get worst case m lines and worst case each line having m elements so in worst case we d have to handle m m 10 10 events This may still look too much but happily this bound is over estimated If a line has o obstacles there can be at most o 1 ranges If lines L1 L2 Lk have o1 o2 ok obstacles there ll be at most o1 o2 ok k ranges But o1 o2 ok m and also k is at most m proved above why we re interested in at most m lines so in worst case we get m m 2 m ranges Yaay finally a decent number of states for this problem So we iterate each line we re interested in Let s find set of ranges for this line thinking that all cells from line above are reachable This is easy to do After we get our ranges like all cells from above can be visited let s think how having obstacles above can influence current ranges After adding ranges from above current ranges can t increase obviously they can only decrease remain the same or some of them can become empty So let s take each range a b from current line and see how it will transform after adding ranges from previous line Given range a b it can transform only in a b with a a If a b then obviously range is empty Why second number of range keeps constant Let a smallest reachable column from current line which is in range a b It s enough to check a a as if a b range will be empty It s obviously why we need to keep a smallest value possible a we re interested to keep range as big as possible and as less as we cut from left as big it is Once we ve found a in range a b or a b if range is empty all cells a 1 a 2 b are reachable as well by going right from a so if interval is not empty then second number defining it remains b Next question is how to find a fast enough In order a point a to be reachable on current range it also needs to exist a range on previous line containing it If the range from previous line is pa pb then a needs to follow 3 conditions a minimal such as pa a pb a a What if instead of finding a we find pa pb Then a is max pa a In order a to be as small as possible since a is constant pa needs to be as small as possible So we reduced it to pa minimal pb a a pb a Intervals from previous line are disjoint no 2 intervals cross each other It means that if pb is minimal than pa is minimal too if we increase pb then pa will increase too so it won t be minimal Hence you need to find an interval pa pb such as pb is minimal and pb a Then a is max a pa This is easy to do if we sort all intervals from previous line increasing by second value pb then we binary search for value a Finally after running algorithm for all lines last range from last line has second number N assuming ranges are sorted increasing by second value then there exist a path otherwise there does not exist This algorithm should run O m logm worst case good enough to pass "}
{"statement": "You are given a string s consisting of n lowercase Latin letters Let s define a substring as a contiguous subsegment of a string For example is a substring of it starts in position 3 and ends in position 6 but or aren t substrings of this string So the substring of the string s from position l to position r is s l r s l s l 1 dots s r You have to choose one of the substrings of the given string and reverse it i e make s l r s r s r 1 dots s l to obtain a string that is lexicographically Note that it to obtain the minimum possible string If it is impossible to reverse some substring of the given string to obtain a string that is less print Otherwise print and suitable substring String x is lexicographically less than string y if either x is a prefix of y and x ne y or there exists such i 1 le i le min x y that x i y i and for any j 1 le j i x j y j Here a denotes the length of the string a The lexicographic comparison of strings is implemented by operator in modern programming languages ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "If the answer is then we always can reverse a substring of length So we need to check only pairs of adjacent characters in If there is no such pair of characters for all from to then the answer is Why is it so Consider the substring we have to reverse It is obvious that otherwise it is pointless to reverse this substring Then consider two cases then by transitivity and then we can go to a smaller substring otherwise and it means that we can take the substring "}
{"statement": "There is a tree of n vertices and a permutation p of size n A token is present on vertex x of the tree Alice and Bob are playing a game Alice is in control of the permutation p and Bob is in control of the token on the tree In Alice s turn she pick two u and v positions u neq v such that the token is neither at vertex u nor vertex v on the tree and swap their positions in the permutation p In Bob s turn he move the token to an adjacent vertex from the one it is currently on Alice wants to sort the permutation in increasing order Bob wants to prevent that Alice wins if the permutation is sorted in increasing order at the beginning or end of her turn Bob wins if he can make the game go on for an infinite number of moves which means that Alice is never able to get a sorted permutation Both players play optimally Alice makes the first move Given the tree the permutation p and the vertex x on which the token initially is find the winner of the game ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3000", "problem_editorial": "Let us call all such that satisfy as If it is called Also a notation like means swap and in the permutation We are going to show that it is always possible for Alice to win if the diameter of the tree is First of all it should be obvious that no matter what moves are made we will eventually end up at a state where we have just marked vertices and the token is either on one of them or neither of them with Alice having to move In the latter case we have a trivial win As long as there are marked numbers you can always find a pair of numbers to swap that will unmark one of the numbers One can imagine this in terms of the cycle decomposition of the permutation Next let us show that from the former state we can also force a state where the two marked vertices are adjacent to each other with Alice having to move If the two marked vertices are already adjacent we don t need to do anything Else let s say we have and where is the vertex with the token on it Now consider two cases If is at distance from we can choose any adjacent vertex to Let it be Swap and Now Bob has the option of moving the token onto or not It wouldn t be optimal to move it away from because then we can force the sequence and Bob won t be able to cover any vertex with his token So Bob must move his token onto Swap and which puts in its right place Now Bob must move this token onto so we did it If is instead at distance from pick the vertex between and as and we can repeat the same analysis as above Now let s say we have and with being the vertex with the token on it Let us show that if possible we can always move over and over effectively jumping over the opposite vertex For the first one pick some vertex adjacent to not Let it be Swap and Now Bob has the option of moving to either or If he moves to we can force and win If he moves to we swap putting in the right place and Bob has to move his token to Now we can see that the marked vertex which was jumped over to reach For the second one pick some vertex adjacent to not Let it be Bob must move his token to Swap and putting in the right place Bob must move his token to Now we can see that the marked vertex with a token which was jumped over to reach Like this we can move all over the tree Now let s move such that both of the marked vertices lie on a diameter of the tree and one of them is at one end of it Consider a tree with diameter That means we have a line of at least vertices taking the two marked vertices at one end Let s consider just the first vertices and show that we can always win here Say we have a configuration like where and are marked and has the token on it If has the token on it instead we can use the moving strategy explained before to first move to and then to and then it is equivalent to the first configuration Swap and Now Bob must move his token to Swap and putting in its right place Now no matter where Bob moves after his turn no vertex will be covered and we can force and win Therefore if the diameter of the tree is we always win If the diameter of the tree is it is a star graph and this is a more problematic case First of all we must check if the permutation is already sorted or we can win in the first move We can only win in the first move if only swap is required to sort the permutation and the token is on neither of the numbers we need to swap If the above is not possible several cases follow Let us make the following observation first If Bob is at the center of the star and the center is a marked vertex Bob can infinitely stall Alice Let s call the center and suppose we need to swap the number with it to put it in its right place is definitely at a leaf and vertex away because of the structure of the star graph So when Bob s turn comes he can simply move the token to where is and alternate this way between and infinitely stalling Alice Obviously even if we try swapping with a different number we can just move to where is next until there are just two vertices left the center and a leaf So Bob wins In light of this it never makes sense to mark the center in our turn if it is unmarked and not covered by the token So we have cases to think of now Token on center and center is marked vertex As explained before Alice loses here Before discussing the rest of the cases let us define as the minimum number of swaps required to sort the permutation and is if the token is on the center and if it is on a leaf Now I claim that the parity of is invariant The magnitude of changes by exactly every turn and we can say the same about So considering all possible changes we can see the sum of the changes is always Hence proved Consider the possible end states for the game all with marked vertices and with Alice having to move Token at center center marked Token at unmarked leaf center marked Token at marked leaf center marked Token at center center unmarked Token at unmarked leaf center unmarked Token at marked leaf center unmarked Observe that end states and will never occur if the game lasts longer than turn because if you go back by turn Bob would have a more optimal move Therefore in states and we can win in the very first move Further observe that states and will never occur if the center was initially unmarked or we could unmark it in the first move The only other possibility would be us being unable to unmark the center in the first move which is a losing state So we only care about states and now Observe that state is a winning position while state is a losing position Also observe that state has odd but state has even Now let us continue with the cases and use these facts Token at center and center is unmarked vertex Check the parity of here If it is odd we win otherwise we lose follows from the invariance of Token at leaf and center is marked vertex If we cannot unmark the center vertex in our very first move we ll reach a losing position If we can check parity of Odd is win even is lose When can we not unmark the center vertex Only if the token is on Otherwise it is always possible Token at leaf and center is unmarked vertex Check parity of Odd is win even is lose This completes the solution Time complexity or depending on whether you use cycles or inversions to find the parity of "}
{"statement": "You are given a multiset S Over all pairs of subsets A and B such that B subset A B A 1 greatest common divisor of all elements in A is equal to one find the sum of sum x in A x cdot sum x in B x modulo 998 244 353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Let s calculate the required product of the sums for the sets the greatest common divisor of the elements of which is First let s select all the elements that are divisible by To find only those sets whose GCD is exactly one can find the product of the sums for all subsets and subtract the answers of all such that and divides without a remainder To find the products of all subsets of a set of elements consider two cases the product will be counted times Each element in the set can be removed and this will add the product The number of elements and the number select the rest of the subset the product will be counted The first term is similar to the example above And the second is obtained if is removed from the set the number of ways to choose a subset of elements is It is only to count the individual sums and for all elements that are divisible by To do this you can maintain for already added numbers their number sum sum of squares of numbers and pairwise sum of numbers The answer to the problem will be "}
{"statement": "You are given a set of n segments on the axis Ox each segment has integer endpoints between 1 and m inclusive Segments may intersect overlap or even coincide with each other Each segment is characterized by two integers l i and r i 1 le l i le r i le m coordinates of the left and of the right endpoints Consider all integer points between 1 and m inclusive Your task is to print all such points that don t belong to any segment The point x belongs to the segment l r if and only if l le x le r ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "In this problem all you need is to check for each point from to if it cannot belongs to any segment It can be done in by two nested loops or in by easy prefix sums calculation Both solutions are below "}
{"statement": "You are given an undirected graph consisting of n vertices and n edges where n is divisible by 6 Each edge has a weight which is a positive greater than zero integer The graph has the following structure it is split into frac n 3 triples of vertices the first triple consisting of vertices 1 2 3 the second triple consisting of vertices 4 5 6 and so on Every pair of vertices from the same triple is connected by an edge There are no edges between vertices from different triples You have to paint the vertices of this graph into two colors red and blue Each vertex should have exactly one color there should be exactly frac n 2 red vertices and frac n 2 blue vertices The coloring is called valid if it meets these constraints The weight of the coloring is the sum of weights of edges connecting two vertices with different colors Let W be the maximum possible weight of a valid coloring Calculate the number of valid colorings with weight W and print it modulo 998244353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s ignore the constraint on the number of red blue vertices for a moment What is the maximum possible weight of a coloring From any triple we can have any two edges connect vertices of different colors So the maximum possible weight of a coloring not necessarily a valid one is the sum of all edge weights except for the minimum weight in each triple Let s show that it is always possible to choose a valid coloring to achieve this weight In each triple we should make sure that the two maximum edges connect vertices with different colors to do this we can color the vertex incident to both of these edges in one color and the two other vertices will be painted in the other color So for each triple of vertices there will be either one red vertex and two blue ones or two red ones and one blue Let s suppose the first triples have one red vertex and two blue vertices each and the other triples have one blue vertex and two red vertices each That way we obtain a valid coloring with maximum possible weight Okay now let s try to find out how do we calculate the number of valid colorings with the maximum possible weight Each triple of vertices will be either red two red vertices one blue or blue the other way around Since exactly half of the vertices should be red then exactly half of the triples should be red so the number of ways to choose a color for all triples is After choosing the color of each triple let s choose how we actually color them The triples are independent so for each triple we can introduce the coefficient which is the number of ways to color it so that its weight is maximized and the triple has some specific type either red or blue doesn t matter since these are symmetric Choosing the vertex which will be different from its neighbors is equivalent to choosing the edge which will not be included in the weight of the coloring this is the edge which is not incident to the chosen vertex So is equal to the number of ways to choose that vertex in the th triple so that the weight is maximized i e the weight of the edge not incident to the chosen vertex should be minimized Thus is just the number of minimum edge weights in the th triple The formula for the final answer is "}
{"statement": "Alex Bob and Carl will soon participate in a team chess tournament Since they are all in the same team they have decided to practise really hard before the tournament But it s a bit difficult for them because chess is a game for two players not three So they play with each other according to following rules Alex and Bob play the first game and Carl is spectating When the game ends the one who lost the game becomes the spectator in the next game and the one who was spectating plays against the winner Alex Bob and Carl play in such a way that there are no draws Today they have played games and for each of these games they remember who was the winner They decided to make up a log of games describing who won each game But now they doubt if the information in the log is correct and they want to know if the situation described in the log they made up was possible that is no game is won by someone who is spectating if Alex Bob and Carl play according to the rules Help them to check it ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "This task is about pure implementation Maintain the number of current spectator and check if he doesn t win With knowledge of current winner and current spectator you can easily get the third player by formula just the sum of all numbers without the known ones Overall complexity "}
{"statement": "Hossam gives you a sequence of integers a 1 a 2 dots a n of length n Moreover he will give you q queries of type l r For each query consider the elements a l a l 1 dots a r Hossam wants to know the number in this sequence such that it occurs in this sequence an number of times You need to compute the answer for each query before process the next query ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Note that we were asked to solve the problem in mode If this were not the case then the Mo Algorithm could be used How to solve this task in mode Consider two ways The first way is as follows Let s build a persistent bitwise trie on a given array where the th version of the trie will store numbers such that occurs on the subsegment an odd number of times This can be done as follows Let be an empty trie and will be obtained as follows first we assign then if occurs in then we will erase the number from otherwise we will insert it there Suppose we need to get answer on the query Note that if is included in but is not included in or is included in but is not included in then this means that the number on the segment occurs an odd number of times Otherwise the number occurs an even number of times recall that is an even number Thus we need to find a minimum number such that it occurs either in or in but not in both at once If there is no such number then you need to output Let s go down and in parallel on the same prefix of the number If and are equal then the same numbers are contained there and then the answer is Next we will assume that the answer is not The left subtree of the vertex is the son to whom the transition along the edge of is going and the right subtree is the vertex to which the transition along the edge of is going Let us now stand at the vertices and respectively If the left subtrees of and are equal it means that the same numbers are contained there so there is no point in going there so we go along the right edge Otherwise the left subtree of contains at least one number that is not in the left subtree of or vice versa so we will go down the left edge The number in which we ended up will be the answer Note that in order to compare two subtrees for equality you need to use the hashing technique of root trees Then we can compare the two subtree for Thus we get the asymptotics If we compress the numbers of the sequence in advance then we can get the asymptotics of Let s consider the second way Let s compress the numbers in the sequence in advance Let if the prefix contains the number an even number of times and if the prefix contains the number an odd number of times Then in order to get an answer to the query we need to take the bitwise exclusive OR arrays and and find in it the minimum such that The number will be the answer Obviously now this solution need much time and memory In order to optimize the amount of memory consumed we will use bitsets However even in this case we consume memory of the order of which is still a lot So let s not remember about all but only some For example let s get some constant and remeber only about Then when we need to answer the next query we will find the right block on which we store almost all the numbers we are looking for and then we will insert erase for missing numbers If you select then this solution will fit in memory However if you use in then most likely this solution will still receive the verdict Therefore to solve this problem you need to write your own fast bitset The asymptotics of such a solution would be However due to a well chosen and a self written bitset the constant in this solution will be very small and under given constraints such a solution can work even faster than the first one "}
{"statement": "Inaka has a disc the circumference of which is n units The circumference is equally divided by n points numbered clockwise from 1 to n such that points i and i 1 1 leq i n are adjacent and so are points n and 1 There are m straight segments on the disc the endpoints of which are all among the aforementioned n points Inaka wants to know if her image is i e if there is an integer k 1 leq k n such that if all segments are rotated clockwise around the center of the circle by k units the new image will be the same as the original one ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s brute force the value of k and check if it s possible to rotate the image by k to get the same image We can do this by iterating through all segments a b and checking that a k b k is a segment the endpoints taken modulo n if needed This gives an O nm solution however you can notice that we only need to check divisors of n rather than all values from 1 to n This is because the set of segments a b a k b k a 2k b 2k is exactly equal to a b a gcd n k b gcd n k a 2gcd n k b 2gcd n k Thus this take O m d n where d n denotes the number of divisors of n which is fast enough to pass this problem There is also a faster linear time solution We can reduce this to a problem of finding the largest period of a string For every point we can sort the length of the segments starting from that point length in this case refers to clockwise distance We also add some null character to denote a point For instance the first sample case s string might start like 2 1 1 4 8 10 1 that represent the points from 1 to 3 Such a string can be computed in O mlogm time Then after finding this string we just want to check the period is bigger than 1 Let w be the length of the string We can find this by concatenating the string to itself then use z algorithm to check if there is any is any index i from 1 to w 1 that is at least w "}
{"statement": "You have a vertical strip with n cells numbered consecutively from 1 to n from top to bottom You also have a token that is initially placed in cell n You will move the token up until it arrives at cell 1 Let the token be in cell x 1 at some moment One shift of the token can have either of the following kinds Subtraction you choose an integer y between 1 and x 1 inclusive and move the token from cell x to cell x y Floored division you choose an integer z between 2 and x inclusive and move the token from cell x to cell lfloor frac x z rfloor x divided by z rounded down Find the number of ways to move the token from cell n to cell 1 using one or more shifts and print it modulo m Note that if there are several ways to move the token from one cell to another in one shift all these ways are considered check example explanation for a better understanding ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "This problem was inspired by Blogewoosh 4 a long time ago Pretty clearly we are facing a dynamic programming problem Let be the number of ways to move from cell to cell Then and is the answer to the problem However a straightforward implementation has time complexity and is too slow Let s look at the main formula for again The first sum is easy to optimize just maintain the sum of and recalculate it by adding This takes just time per cell For the second sum note that can take at most different values over We can handle this sum as follows Find the sum over all directly We only need to consider now For any such value Let s loop over a cell for how many different values of it s true that By definition of the floor function Solving this inequality we get The length of this segment gives us the coefficient of in the sum This gives us an solution which is enough for the subtask in Division 2 To get a faster solution let denote the multiset of cells where we can go to from cell this multiset contains values How is different from contains an extra occurrence of because we can subtract from contains an extra occurrence of because we can divide by For each that is a divisor of contains an occurrence of that replaces an occurrence of We don t need to maintain itself but we can maintain the sum of over all and recalculate this sum as we go from to The total number of changes to is limited by the total number of divisors of all numbers from to that is However if implemented directly we need to quickly find the divisors of each and we can only afford memory due to the memory limit We can achieve that by preparing a sieve of Eratosthenes factorizing and generating all its divisors A better way is do it the reverse way once we find for some let s traverse and add to This way the time complexity stays and the memory complexity is "}
{"statement": "Given an array a of length n and an integer k you are tasked to find any two numbers l and r l leq r such that For each x l leq x leq r x appears in a at least k times i e k or more array elements are equal to x The value r l is maximized If no numbers satisfy the conditions output For example if a 11 11 12 13 13 14 14 and k 2 then for l 12 r 14 the first condition fails because 12 does not appear at least k 2 times for l 13 r 14 the first condition holds because 13 occurs at least k 2 times in a and 14 occurs at least k 2 times in a for l 11 r 11 the first condition holds because 11 occurs at least k 2 times in a A pair of l and r for which the first condition holds and r l is maximal is l 13 r 14 ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s call a value if it appears at least times For example if and then good values are So we need to find the longest subarray of this array in which all values are consecutive For example the subarray is the answer because all values are good and the length of the array is longest There are many ways to do this For example we can see when the difference between two elements is more than and then break the array into parts based on that For instance You can also iterate from left to right and keep track of the size of the current array Time complexity "}
{"statement": "There is a string s of length n consisting of the characters and You are walking on this string You start by standing on top of the first character of s and you want to make a sequence of moves such that you end on the n th character In one step you can move one space to the left if you are not standing on the first character or one space to the right if you are not standing on the last character You may not stay in the same place however you may visit any character including the first and last character number of times At each point in time you write down the character you are currently standing on We say the string is if there exists some sequence of moves that take you from the first character to the last character such that the string you write down is a regular bracket sequence A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are and and are not You are given q queries Each query flips the value of a character from to or vice versa After each query determine whether the string is walkable Queries are so the effects of each query carry on to future queries ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "For a string to be walkable we need to be even because the parity of the balance factor changes on each move and it has to be zero at the end of the process So if is odd the string is never walkable Now consider the set that contains all indices indexed satisfying one of the below conditions is even and is odd and Now consider a few cases If is empty then is of the form and is therefore trivially walkable by just moving to the right If is odd then is of the form We can show that it is never walkable because for every in the first section when we land on this before leaving this section of the string for the first time the balance factor must be Therefore when we try to move across the the balance factor will go to and the walk will no longer be valid If is even then is of the form and we can show that it is never walkable using a somewhat symmetric argument to the previous case but considering the ending of the walk instead of the beginning Otherwise is even and is odd We will prove that it is walkable In this case s is of the form To form a valid walk keep moving to the right until you hit the then alternate back and forth on the times After this move to the right until you hit the Note that during this process the balance factor can never go negative because it will always be at least Once you reach the alternate back and forth on it until the balance factor hits Because n is even this will happen on the rightmost character of the At this point just walk to the right until you hit the end at which point the balance factor will once again be So we just need to maintain the set across all of the queries and do these simple checks after each query to see if is walkable Complexity "}
{"statement": "Toad Rash has a binary string s A binary string consists only of zeros and ones Let n be the length of s Rash needs to find the number of such pairs of integers l r that 1 leq l leq r leq n and there is at least one pair of integers x k such that 1 leq x k leq n l leq x x 2k leq r and s x s x k s x 2k Find this number of pairs for Rash ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Lemma there are no strings without such x k of length at least 9 In fact you just can write brute force to find all good strings and then realize that they all are small Ok so with this you can just write some sort of naive solution for each l find the largest r such that l r is a good string and then add n r to the answer You can do it in 9 9 n or in 9 n as I do in my solution"}
{"statement": "You are given a sequence a a 1 a 2 dots a n consisting of n integers Let s call a group of consecutive elements a Each is characterized by two indices the index of its left end and the index of its right end Denote by a l r a of the sequence a with the left end in l and the right end in r i e a l r a l a l 1 dots a r For example if a 31 4 15 92 6 5 then a 2 5 4 15 92 6 a 5 5 6 a 1 6 31 4 15 92 6 5 are We split the given sequence a into so that each element is in one the sums of elements for all are For example if a 55 45 30 30 40 100 then such a sequence can be split into three a 1 2 55 45 a 3 5 30 30 40 a 6 6 100 Each element belongs to exactly the sum of the elements of each is 100 Let s define of split as the length of the longest For example the thickness of the split from the example above is 3 Find the minimum thickness among all possible splits of the given sequence of a into in the required way ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s iterate over the length of the first segment of the split Having fixed it we actually fixed the sum that needs to be collected on all other segments Since each element must belong to exactly one segment we can build other segments greedily If we have found a solution we will remember the length of the longest segment in it and try to update the answer We have possible lengths of the first segment for each of which we greedily built the answer for Thus the asymptotics of the solution will be "}
{"statement": "There are students who have taken part in an olympiad Now it s time to award the students Some of them will receive diplomas some wiil get certificates and others won t receive anything Students with diplomas and certificates are called But there are some rules of counting the number of diplomas and certificates The number of certificates must be times greater than the number of diplomas The number of must i e not be greater than half of It s possible that there are no You have to identify the maximum possible number of according to these rules Also for this case you have to calculate the number of students with diplomas the number of students with certificates and the number of students who are not ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let be the number of students with diplomas and students with certificates is always So the total number of winners is It should not exceed so the maximum value for will be hit in where is Overall complexity "}
{"statement": "Author has gone out of the stories about Vasiliy so here is just a formal task description You are given queries and a multiset initially containing only integer There are three types of queries add integer to multiset erase one occurrence of integer from multiset It s guaranteed that at least one is present in the multiset before this query you are given integer and need to compute the value i e the maximum value of bitwise exclusive OR also know as XOR of integer and some integer from the multiset Multiset is a set where equal elements are allowed ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Can someone explain logic behind this submission https codeforces com contest 706 submission 19826426 It seems extremely simplistic and doesn t seem to use tries "}
{"statement": "The Shuseki Islands are an archipelago of small islands in the Yutampo Sea The islands are evenly spaced along a line numbered from to from the west to the east These islands are known to contain many treasures There are gems in the Shuseki Islands in total and the th gem is located on island Mr Kitayuta has just arrived at island With his great jumping ability he will repeatedly perform jumps between islands to the east according to the following process First he will jump from island to island After that he will continue jumping according to the following rule Let be the length of the previous jump that is if his previous jump was from island to island let He will perform a jump of length or to the east That is he will jump to island or if they exist The length of a jump must be positive that is he cannot perform a jump of length when If there is no valid destination he will stop jumping Mr Kitayuta will collect the gems on the islands visited during the process Find the maximum number of gems that he can collect ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let m be the number of the islands that is 30001 First let us describe a solution with time and memory complexity of O m2 We will apply Dynamic Programming let dp i j be the number of the gems that Mr Kitayuta can collect after he jumps to island i when the length of his previous jump is j let us assume that he have not collect the gems on island i Then you can calculate the values of the table dp by the following dp i j 0 if i m actually these islands do not exist but we can suppose that they exist and when Mr Kitayuta jumps to these islands he stops jumping dp i j the number of the gems on island i max dp i j j dp i j 1 j 1 if i m j 1 he cannot perform a jump of length 0 dp i j the number of the gems on island i max dp i j 1 j 1 dp i j j dp i j 1 j 1 if i m j 2 This solution is unfeasible in terms of both time and memory However the following observation makes it an Accepted solution there are only 491 values of j that we have to consider which are d 245 d 244 d 243 d 244 and d 245 Why First let us find the upper bound of j Suppose Mr Kitayuta always performs the l 1 jump l the length of the previous jump Then he will reach the end of the islands before he performs a jump of length d 246 because d d 1 d 2 d 245 1 2 245 245 245 1 2 30135 30000 Thus he will never be able to perform a jump of length d 246 or longer Next let us consider the lower bound of j in a similar way If d 246 then obviously he will not be able to perform a jump of length d 246 or shorter because the length of a jump must be positive Suppose Mr Kitayuta always performs the l 1 jump where d 247 Then again he will reach the end of the islands before he performs a jump of length d 246 because d d 1 d 2 d 245 245 244 1 245 245 1 2 30135 30000 Thus he will never be able to perform a jump of length d 246 or shorter Therefore we have obtained a working solution similar to the O m2 one but we will only consider the value of j between d 245 and d 245 The time and memory complexity of this solution will be O m1 5 since the value 245 is slightly larger than This solution can be implemented by for example using a normal two dimensional array with a offset like this dp i j offset The time limit is set tight in order to fail most of naive solutions with search using std map or something so using hash maps unordered map will be risky although the complexity will be the same as the described solution "}
{"statement": "Hr0d1y has q queries on a binary string s of length n A binary string is a string containing only characters and A query is described by a pair of integers l i r i 1 leq l i lt r i leq n For each query he has to determine whether there exists a good subsequence in s that is equal to the substring s l i ldots r i A substring s i ldots j of a string s is the string formed by characters s i s i 1 ldots s j String a is said to be a subsequence of string b if a can be obtained from b by deleting some characters without changing the order of the remaining characters A subsequence is said to be if it is not contiguous and has length ge 2 For example if s is then the subsequences s 1s 2s 4 and s 1s 5s 7 are good while s 1s 2s 3 is not good Can you help Hr0d1y answer each query ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "In each query the answer is YES iff the first character of the given substring is not the first occurence of that character or the last character of the given substring is not the last occurrence of that character in the string The condition stated above is both necessary and sufficient Proof that it is necessary Assume that a non contiguous subsequence exists when the condition is false If the first character of the substring is the first occurrence of its kind then the subsequence cannot start before it Similarly if the last character of the substring is the last occurrence of its kind then the subsequence cannot end after it In such a case the only subsequence that is of the same length as the given substring and equal to it is the substring itself However this subsequence is contiguous which is a contradiction Thus it is a necessary condition Proof that it is sufficient If the first character of the substring occurs at some index then the subsequence is good If the last character of the substring occurs at some index then the subsequence is good Thus it is sufficient Time complexity or for each case depending on implementation "}
{"statement": "Eshag has an array a consisting of n integers Eshag can perform the following operation any number of times choose some subsequence of a and delete every element from it which is larger than AVG where AVG is the average of the numbers in the chosen subsequence For example if a 1 4 3 2 4 and Eshag applies the operation to the subsequence containing a 1 a 2 a 4 and a 5 then he will delete those of these 4 elements which are larger than frac a 1 a 2 a 4 a 5 4 frac 11 4 so after the operation the array a will become a 1 3 2 Your task is to find the number of elements Eshag can delete from the array a by applying the operation described above some number maybe zero times A sequence b is a subsequence of an array c if b can be obtained from c by deletion of several possibly zero or all elements ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "We state that every element except for the elements with the smallest value can be deleted Proof denote as the minimum element s of the array in each operation pick and some other element say which is bigger than since then will be deleted Doing this for every will result in the deletion of every element except for the elements with the smallest value So the answer to the problem is where is the number of times appeared in complexity "}
{"statement": "You are given a string consisting of lowercase English letters and an integer Find the lexicographically smallest string of length such that its set of letters is a subset of the set of letters of and is lexicographically smaller than It s guaranteed that the answer exists Note that the set of letters is a set not a multiset For example the set of letters of is String is lexicographically smaller than string if is a prefix of is not equal to or there exists such that and for all it is satisfied that For example is lexicographically smaller than is lexicographically smaller than lexicographically smaller than and lexicographically smaller than ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Consider cases If we should simply add minimum symbols from If we need to replace all symbols in the suffix of first symbols of string consisting of largest symbols to smallest symbols and next symbol before this suffix replace with next symbol that exists in the string Complexity of this solution is "}
{"statement": "You are given an array a consisting of n positive integers Find a subset of its elements such that their sum is i e divisible by 2 or determine that there is no such subset Both the given array and required subset may contain equal values ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "If there is an even element in array there is an answer consisting of only it Otherwise if there is at least two odd elements in array there is an answer consisting of this two elements Otherwise array is only one odd element and there is no answer "}
{"statement": "You are given an undirected graph with n vertices and m edges Also you are given an integer k Find either a clique of size k or a non empty subset of vertices such that each vertex of this subset has at least k neighbors in the subset If there are no such cliques and subsets report about it A subset of vertices is called a clique of size k if its size is k and there exists an edge between every two vertices from the subset A vertex is called a neighbor of the other vertex if there exists an edge between them ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2600", "problem_editorial": "div1 B It is easy to see that if the answer is because if no matter whether we have a clique of size or a subset of the graph with we will have more than edges in total Now the main idea is to suppose is the vertex with minimum degree if we should delete becuase can not be in clique or the subset of vertices such that each vertex of this subset has at least neighbors in the subset so we have to erase and all edges attached to it If remaining vertices will form a subset that every vertex have at least neighbors in the subset so we ll print this subset as answer If we consider and all neighbors of as candidate for clique of size then we erase and all edges attached to it If we erase all vertices and didn t found any good subset then we should check clique candidates for checking clique candidates fast iterate over vertices and name current vertex then for neighbors of set to and otherwise for each clique candidate that contains like we check edge between and in using array every time we find new clique candidate we remove at least edges so number of clique candidates is at most for every candidate we check edges in overall so time complexity is "}
{"statement": "It seems like the year of 2013 came only yesterday Do you know a curious fact The year of 2013 is the first year after the old 1987 with only distinct digits Now you are suggested to solve the following problem given a year number find the minimum year number which is strictly larger than the given one and has only distinct digits ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "This is a very straight forward problem Just add 1 to a year number while it still has equal digits "}
{"statement": "Rainbow built cells in a row that are numbered from 1 to from left to right There are cells with treasure We call each of these cells Treasure Cell The th Treasure Cell is the th cell and the value of treasure in it is dollars Then Freda went in the first cell For now she can go just cells forward or return to the first cell That means Freda was able to reach the 1st th th th cells and so on Then Rainbow gave Freda operations Each operation is one of the following three types Add another method she can also go just cells forward at any moment For example initially she has only one method If at some moment she has methods then she can reach all the cells with number in form where some non negative integer Reduce the value of the treasure in the th Treasure Cell by dollars In other words to apply assignment Ask the value of the most valuable treasure among the cells Freda can reach If Freda cannot reach any cell with the treasure then consider the value of the most valuable treasure equal to 0 and do nothing Otherwise take the most valuable treasure away If several Treasure Cells have the most valuable treasure take the Treasure Cell with the minimum number not necessarily with the minimum number of cell After that the total number of cells with a treasure is decreased by one As a programmer you are asked by Freda to write a program to answer each query ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2500", "problem_editorial": "Firstly we solve such a problem if we can go exactly k k1 k2 or kp cells forward each step what cells can we reach We divide the H cells into k groups Group 0 1 k 1 The i th cell should be in Group i mod k Let D i be the minimum cell we can reach in Group i Then we can reach all the cells which number are bigger then D i in Group i Regard the groups as points Regard k k1 k2 kp as edges And use a Shortest Path Algorithm to calculate all D i Notice that there are at most 20 operations of type 1 we are able to run such an algorithm after each of these operations The total time complexity is O 20 k 20 log k with Dijkstra Secondly we build a binary heap to solve operations of type 2 and 3 These are basic operations of binary heap The time complexity is O NlogN In C you can also use priority queue from STL and lazy tags So we can solve the whole problem in O 400klogk NlogN "}
{"statement": "There are n candies in a candy box The type of the i th candy is a i 1 le a i le n You have to prepare a gift using some of these candies with the following restriction the numbers of candies of each type presented in a gift should be all distinct i e for example a gift having two candies of type 1 and two candies of type 2 is bad It is also possible that of some types will be taken to a gift You really like some of the candies and don t want to include them into the gift but you want to eat them yourself instead For each candy a number f i is given which is equal to 0 if you really want to keep i th candy for yourself or 1 if you don t mind including it into your gift It is possible that two candies of the same type have different values of f i You want your gift to be as large as possible but you don t want to include too many of the candies you want to eat into the gift So you want to calculate the maximum possible number of candies that can be included into a gift and among all ways to choose maximum number of candies you want to maximize the number of candies having f i 1 in your gift You have to answer q independent queries ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "First of all to maximize the number of candies in the gift we can use the following greedy algorithm let s iterate on the number of candies of some type we take from to backwards For fixed let s try to find any suitable type of candies A type is suitable if there are at least candies of this type in the box If there exists at least one such type that wasn t used previously let s pick any such type and take exactly candies of this type and decrease It does not matter which type we pick if we only want to maximize the number of candies we take Okay let s now modify this solution to maximize the number of candies having We initially could pick any type that has at least candies but now we should choose a type depending on the number of candies with in this type For example if we have two types having and candies with respectively and we want to pick candies from one type and candies from another type and and it s better to pick candies of the first type and candies of the second type In this case we have candies with in the other case it s And if and then So when we want to pick a type of candies such that we will take exactly candies of this type it s optimal to choose a type that wasn t used yet contains at least candies and has maximum possible number of candies with This best type can be maintained with a multiset or a set of pairs "}
{"statement": "During the Russian Code Cup programming competition the testing system stores all sent solutions for each participant We know that many participants use random numbers in their programs and are often sent several solutions with the same source code to check Each participant is identified by some unique positive integer and each sent solution is characterized by two numbers the number of different solutions that are sent before the first solution identical to and the number of the participant who is the author of the solution Consequently all identical solutions have the same It is known that the data in the testing system are stored in the chronological order that is if the testing system has a solution with number of the participant with number then the testing system has a solution with number of the same participant stored somewhere before During the competition the checking system crashed but then the data of the submissions of all participants have been restored Now the jury wants to verify that the recovered data is in chronological order Help the jury to do so ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let us create array with elements which is filled with In the cell we will contain the maximal number of the submissions of the participant with identifier We will process submissions in the given order Let us process submission If then the answer is NO else we will update array Solution 6396297 "}
{"statement": "There are n startups Startups can be or If a startup is then that means it has exactly one startup that it is following An active startup can have arbitrarily many acquired startups that are following it An active startup cannot follow any other startup The following steps happen until there is exactly one active startup The following sequence of steps takes exactly 1 day Two distinct active startups A B are chosen uniformly at random A fair coin is flipped and with equal probability A acquires B or B acquires A i e if A acquires B then that means B s state changes from active to acquired and its starts following A When a startup changes from active to acquired all of its previously acquired startups become active For example the following scenario can happen Let s say A B are active startups C D E are acquired startups under A and F G are acquired startups under B If A acquires B then the state will be A F G are active startups C D E B are acquired startups under A F and G have no acquired startups If instead B acquires A then the state will be B C D E are active startups F G A are acquired startups under B C D E have no acquired startups You are given the initial state of the startups For each startup you are told if it is either acquired or active If it is acquired you are also given the index of the active startup that it is following You re now wondering what is the expected number of days needed for this process to finish with exactly one active startup at the end It can be shown the expected number of days can be written as a rational number P Q where P and Q are co prime integers and Q not 0 pmod 10 9 7 Return the value of P cdot Q 1 modulo 10 9 7 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3200", "problem_editorial": "You can solve this most likely by brute forcing small cases and looking for a pattern Here s a proof of the pattern Let s define a potential of a startup with followers to be equal to For example an active startup with zero followers has potential zero Now in one day if we choose a startup with followers and a startup with followers the expected change in sum of potentials is equal to regardless of the values of and The potential of the final state is and we can compute the current potential in linear time so the expected number of turns is the difference between them To prove this more rigorously we can use show that this process is a martingale so we can use https en wikipedia org wiki Optional stopping theorem to show that the expected number of days is exactly equal to this difference "}
{"statement": "This matrix M of size n times n contains only and without quotes The element in the i th row and the j th column i j is defined as M i j where 1 leq i j leq n We define a appearing in the i th row and the j th column 1 i j n if and only if M i j M i 1 j 1 M i 1 j 1 M i 1 j 1 M i 1 j 1 The following figure illustrates a cross appearing at position 2 2 in a 3 times 3 matrix X X X X X Your task is to find out the number of in the given matrix M Two are different if and only if they appear in different rows or columns ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The solution is simple Just check if can appear in every positions Two nesting for loops will be enough to solve this problem "}
{"statement": "There are two binary strings a and b of length n a binary string is a string consisting of symbols 0 and 1 In an operation you select a prefix of a and simultaneously invert the bits in the prefix 0 changes to 1 and 1 changes to 0 and reverse the order of the bits in the prefix For example if a 001011 and you select the prefix of length 3 it becomes 011011 Then if you select the entire string it becomes 001001 Your task is to transform the string a into b in at most 3n operations It can be proved that it is always possible ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "The easy version has two main solutions Solution 1 O n time with 3n operations The idea is to fix the bits one by one That is make s1 t1 then make s2 t2 etc To fix the bit i when si ti we can flip the prefix of length i then flip the prefix of length 1 and again flip the prefix of length i These three operations do not change any other bits in s so it s simple to implement in O n Since we use 3 operations per bit we use at most 3n operations overall Solution 2 O n2 time with 2n operations In this solution we take a similar approach to solution 1 in that we fix the bits one by one This time we will fix the bits in reverse order To fix the bit i we can either flip the prefix of length i or flip the first bit and then flip the prefix of length i Since we do this in reverse order the previously fixed bits do not get messed up by this procedure And we use at most 2 operations per bit so 2n operations overall However we do have to simulate the operations in order to check if we should flip the first bit Simulating an operation can easily be done in O n time per operation or O n2 time to simulate all operations "}
{"statement": "A connected undirected graph is called a if each vertex of this graph belongs to at most one simple cycle A in a undirected graph is a sequence of distinct vertices such that for any exists an edge between vertices and and also exists an edge between vertices and A in a undirected graph is a sequence of not necessarily distinct vertices such that for any exists an edge between vertices and and furthermore each We ll say that a simple path starts at vertex and ends at vertex You ve got a graph consisting of vertices and edges that is a vertex cactus Also you ve got a list of pairs of interesting vertices for which you want to know the following information the number of distinct simple paths that start at vertex and end at vertex We will consider two simple paths distinct if the sets of edges of the paths are distinct For each pair of interesting vertices count the number of distinct simple paths between them As this number can be rather large you should calculate it modulo ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "In this problem you should find the number of simple paths between some pair of vertices in vertex cactus If you learn the structure of these graphs it is not hard to see that if we ll squeeze each cycle in one vertex we get a tree So let s squeeze all cycles in source graph and get this tree Also every vertex of this tree we ll mark if it is squeezed cycle let s call this vertices 1 vertices or single vertex in source graph this vertices we ll call 0 vertices Then we ll do the following to find the number of paths between vertices and in source graph Suppose is a vertex corresponding to in obtained tree it can be a single vertex or a vertex corresponding to a squeezed cycle with and is a vertex corresponding to Let s denote is the number of 1 vertices in path from to in tree Than it is easy to understand that the answer for query is because every cycle 1 vertex increase the number of possible ways twice you can go from one vertex to other by two ways in cycle It means that we need to count the number of 1 vertex on the path from one vertex to other in tree quickly to answer a query We can do it in a following way Hang our tree for one vertex which we ll call a root Denote for every vertex is the number of 1 vertex on the way to the root including root and vertex itself Suppose we want to find the number of 1 vertex on the path from to Denote is the least common ancestor of vertices and Than number of 1 vertex on the way from to is equal to if is 0 vertex and if is 1 vertex The least common ancestor can be found by standard method binary method recovery Finally we have solution "}
{"statement": "Shohag has an integer n Please help him find an integer sequence 1 le a 1 lt a 2 lt ldots lt a n le 100 such that a i bmod i neq a j bmod j text is satisfied over all pairs 1 le i lt j le n It can be shown that such a sequence always exists under the given constraints text a bmod b denotes the remainder of a after division by b For example 7 bmod 3 1 8 bmod 4 0 and 69 bmod 10 9 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "A general approach to tackle ad hoc problems is to play around with the conditions and see if we can add more constraints to limit the search space Let s analyze the modular condition We know that and all values are distinct Let s explore this step by step is always can be or But since all values must be distinct must be otherwise it would equal can be or Similarly must be to avoid duplication with or must be This leads to the constraint Next let s consider the increasing sequence condition Since the sequence must be increasing we add the constraint To further limit the search space note that can be up to and must be This suggests that we can restrict to values up to Let s compile the constraints Now we need to build the sequence that satisfies these conditions Let s build the sequence starting from the end Thus can be or Since must be So can be or Since must be Thus can be or or Since and the odd numbers greater than have already been used must be If we limit the elements to there is exactly one sequence that satisfies all conditions The sequence is which is We can validate the solution by checking if it satisfies all the constraints So all are distinct and values are under So the sequence is valid "}
{"statement": "Today Adilbek is taking his probability theory test Unfortunately when Adilbek arrived at the university there had already been a long queue of students wanting to take the same test Adilbek has estimated that he will be able to start the test only T seconds after coming Fortunately Adilbek can spend time without revising any boring theorems or formulas He has an app on this smartphone which contains n Japanese crosswords to solve Adilbek has decided to solve them all one by one in the order they are listed in the app without skipping any crossword For each crossword a number t i is given that represents the time it takes an average crossword expert to solve this crossword the time is given in seconds Adilbek is a true crossword expert but unfortunately he is sometimes unlucky in choosing the way to solve the crossword So it takes him either t i seconds or t i 1 seconds to solve the i th crossword equiprobably with probability frac 1 2 he solves the crossword in exactly t i seconds and with probability frac 1 2 he has to spend an additional second to finish the crossword All these events are independent After T seconds pass or after solving the last crossword if he manages to do it in less than T seconds Adilbek closes the app if he finishes some crossword at the same moment that crossword is considered solved otherwise Adilbek does not finish solving the current crossword at all He thinks it would be an interesting probability theory problem to calculate E the expected number of crosswords he will be able to solve completely Can you calculate it Recall that the expected value of a discrete random variable is the probability weighted average of all possible values in this problem it means that the expected value of the number of solved crosswords can be calculated as E sum limits i 0 n i p i where p i is the probability that Adilbek will solve exactly i crosswords We can represent E as rational fraction frac P Q with Q 0 To give the answer you should print P cdot Q 1 bmod 10 9 7 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Let s use as usual linearity of an expected value where is an indicator function and equal to iff Adilbek will be able to solve the th crossword How to calculate If then is always On the other hand if is always Otherwise we need to calculate the needed probability To calculate we can iterate over the number of crosswords among first ones which will require extra time Obviously if then we don t have enough time to solve the th crossword also Let s denote There are ways to choose crosswords with extra time among all variants So the final formula is following The only problem is the efficiency But we can find out several interesting properties At first The other one since then And this exactly the efficient way to transform to by multiplying and adding one coefficient we can transform the prefix sum of the th row to the prefix sum of the row And to reduce the length of the prefix sum we can just subtract unnecessary coefficients In result the total complexity is maybe with extra factor because of modular arithmetic "}
{"statement": "Vladislav has a string of length 5 whose characters are each either texttt A or texttt B Which letter appears most frequently texttt A or texttt B ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Since the string is of an odd length we know that the number of s can t be equal to the number of s So there is always only one possible answer Denote variables a counter and b counter the count of s and s in the string respectively Let s just iterate through all 5 characters of the string and increase the a counter every time we see an and the b counter every time we see a If the a counter is greater than the b counter we output and otherwise "}
{"statement": "You are given an array a consisting of n integers Let the function f b return the minimum number of operations needed to make an array b a palindrome The operations you can make are choose two adjacent elements b i and b i 1 remove them and replace them with a single element equal to b i b i 1 or choose an element b i 1 remove it and replace it with two positive integers x and y x 0 and y 0 such that x y b i For example from an array b 2 1 3 you can obtain the following arrays in one operation 1 1 1 3 2 1 1 2 3 3 2 4 or 2 1 2 1 Calculate displaystyle left sum 1 le l le r le n f a l r right where a l r is the subarray of a from index l to index r inclusive In other words find the sum of the values of the function f for all subarrays of the array a ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "To begin with let s find out how to solve the problem for a single subarray in linear time If equal numbers are at both ends we can remove them and reduce the problem to a smaller size thus we have decreased the length of the array by in operations or by if there is only one element Otherwise we have to do something with one of these numbers either merge the smaller one with its neighbor or split the larger one It can be shown that it doesn t matter which of these actions we take so let s split the larger of the two numbers at the ends in such a way that the numbers at the ends become equal and then we can remove the equal numbers at the ends thus we reduce the length of the array by in operation In this case the answer for the array depends on the number of situations where the ends of the array have equal numbers and the number of situations where they are different Now let s understand how to quickly calculate how many times when processing a subarray we encounter a situation where the ends have equal numbers After removing these equal numbers at the ends we obtain a subarray such that numbers with equal sums have been removed from the prefix and suffix compared to the original subarray We can determine how many such subarrays can be obtained from the original one by removing a prefix and a suffix with equal sums For this we can use prefix sums Let the prefix sum at the beginning of the segment be and at the end be If we remove a prefix and a suffix with sum the sums become and At the same time the sum for the smaller subarray remains the same Therefore for each such subarray that results from the situation the elements on the right and left were equal we removed them the sum is the same as that of the original segment To calculate the number of shorter segments with the same sum for each segment we can iterate through all segments in order of increasing length and store in a map the count of subarrays with each sum This leads us to solve the problem in "}
{"statement": "Wilbur is playing with a set of points on the coordinate plane All points have non negative integer coordinates Moreover if some point belongs to the set then all points such that and also belong to this set Now Wilbur wants to number the points in the set he has that is assign them distinct integer numbers from to In order to make the numbering Wilbur imposes the condition that if some point gets number then all from the set such that and must be assigned a number not less than For example for a set of four points and there are two aesthetically pleasing numberings One is and another one is Wilbur s friend comes along and challenges Wilbur For any point he defines it s as Now he gives Wilbur some and asks him to find an aesthetically pleasing numbering of the points in the set such that the point that gets number has it s special value equal to that is Now Wilbur asks you to help him with this challenge ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Note that if there is an integer so that the number of equal to differs from the number of the given squares whose weight equals then the answer is automatically NO This can be easily checked by using a map for the and the weights of the squares and checking if the maps are the same This step takes time Let be an integer and let be the set of all so that Let be the set of all special points so that the weight of is Note that and have the same number of elements Suppose that are the elements of Let if or and Suppose that are the elements of Note that the point has to be labeled by for Now each special point is labeled It remains to check if this is a valid labeling This can be done by taking an array of vectors The vector will denote the points with coordinate This vector can be easily made from the points given in time and since the points are already labeled will denote the label for the point Now for all points the point if it is special and the point if it is special must have a greater number than This step takes a total of time Complexity Code Solution Bonus Can you do this problem in time Comments This problem was inspired by the representation theory of the group of permutations Representation theory of the Symmetric Group Essential objects in the study of are Young diagrams and standard Young tableau Young Tableau The weight of a point as defined by the problem is basically the same thing as the content of a square in a standard Young tableaux If you have questions feel free to message me Let us solve this problem using dynamic programming First let us reindex the trees by sorting them by coordinate Let where we would like to consider the problem of if we only have trees standing where indicates that tree falls right and if it falls left and indicates that tree falls right and if it falls left We start with the case that Wilbur chooses the left tree and it falls right The plan is to calculate the expected length in this scenario and multiply by the chance of this case occurring which is We can easily calculate what is the farthest right tree that falls as a result of this and call it Then if this means the entire segment falls from which the length of the ground covered by trees in can be calculated However be careful when as there may be overlapping covered regions when the tree falls right but the tree falls left If only then we just consider adding the length of ground covered by trees falling right and add to the value of the subproblem There is another interesting case where Wilbur chooses the left tree and it falls left In this case we calculate the expected length and multiply by the chance of this occurring which is The expected length of ground covered by the trees here is just the length contributed by tree falling left which we must be careful calculating as there might be overlapping covered regions with the th tree falling left and the th tree falling right Then we also add the value of subproblem Doing this naively would take time but this can be lowered to by precalculating what happens when tree falls left or right We should also consider the cases that Wilbur chooses the right tree but these cases are analogous by symmetry Complexity Code Solution Solution 1 Suppose that is a string in the query Reverse and the direction of all the moves that can be made on the table Note that starting at any point that is part of a cycle there is a loop and then edges that go out of the loop So for every point it can be checked by dfs whether the can be made by starting at that point by storing what is in the cycle Moreover note that in the reversed graph each point can only be a part of one cycle Therefore the total time for the dfs in a query is This is good enough for queries to run in time Complexity where is the number of distinct characters in the table and is the query string for the th query Code Solution Solution 2 Actually too slow see comment by waterfalls below for more details For each string dfs from every node that has in degree equal to in the original graph There will be a path which leads into a cycle after which anything in the cycle can be used any number of times in Only every node with in degree equal to has to be checked because every path which leads to a cycle is part of a larger path which starts with a vertex of in degree that leads into a cycle This solution is slower but it works in practice since it is really hard for a string to match so many times in the table Each query will take time but it is much faster in practice Complexity where is the number of distinct characters in the table and is the query string of the th query "}
{"statement": "There are banks in the city where Vasya lives they are located in a circle such that any two banks are neighbouring if their indices differ by no more than Also bank and bank are neighbours if No bank is a neighbour of itself Vasya has an account in each bank Its balance may be negative meaning Vasya owes some money to this bank There is only one type of operations available transfer some amount of money from any bank to account in any bank There are no restrictions on the size of the sum being transferred or balance requirements to perform this operation Vasya doesn t like to deal with large numbers so he asks you to determine the minimum number of operations required to change the balance of each bank account to zero It s guaranteed that this is possible to achieve that is the total balance of Vasya in all banks is equal to zero ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "We have array and should make all numbers in it be equal to zero with minimal number of operations Sum of all equals to zero We can divide array into parts of consecutive elements with zero sum If part has length we can use all pairs of neighbours in operations and make all numbers be equal to zero with operations So if we sum number of operations in each part we get where is number of parts We should maximize to get the optimal answer One of the part consists of some prefix and probably some suffix Each of other parts is subarray of Let s calculate prefix sums Each part has zero sum so prefix sums before each part subarray are the same So we can calculate number of occurencies of the most frequent number in prefix sums and answer will be equal to Bonus how to hack solutions with overflow Code "}
{"statement": "There is an undirected tree of n vertices connected by n 1 bidirectional edges There is also a snake stuck inside of this tree Its head is at vertex a and its tail is at vertex b The snake s body occupies all vertices on the unique simple path between a and b The snake wants to know if it can reverse itself that is to move its head to where its tail started and its tail to where its head started Unfortunately the snake s movements are restricted to the tree s structure In an operation the snake can move its head to an adjacent vertex not currently occupied by the snake When it does this the tail moves one vertex closer to the head so that the length of the snake remains unchanged Similarly the snake can also move its tail to an adjacent vertex not currently occupied by the snake When it does this the head moves one unit closer to the tail Let s denote a snake position by h t where h is the index of the vertex with the snake s head t is the index of the vertex with the snake s tail This snake can reverse itself with the movements 4 7 to 5 1 to 4 2 to 1 3 to 7 2 to 8 1 to 7 4 Determine if it is possible to reverse the snake with some sequence of operations ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "Let the length of the snake be Let s call a node a pivot if there exist three edge disjoint paths of length extending from Clearly if one of the snake s endpoints head or tail can reach a pivot then the snake can rotate through these paths reversing itself I claim two things If a snake s endpoint can reach some pivot then it can reach all pivots If a snake s endpoint cannot reach a pivot the snake cannot reverse itself Let s prove claim 1 Say there are two pivots and and a snake s endpoint can reach At most one edge from is on the path between and So let s put the snake in one of the other branches of Then we can move the snake back through and on the path to Let s prove claim 2 Consider the longest path in the tree If it is impossible for the snake to enter this path we may delete the path without changing the possible snake positions so we apply induction on the smaller tree Otherwise if the snake can enter the path we can show that it can never leave And therefore it is also initially in the path because snake moves are reversible Assume for contradiction that the snake can leave the path Then in its last move leaving the path it occupies a length path from a node in the longest path And because we said it was the longest path both of those branches must have length at least as well But then the snake s endpoint is at a pivot giving us a contradiction This completes the proof of claim 2 Now that we understand claims 1 and 2 how can we use them First we can detect if any node is a pivot using DP to find the longest 3 paths from each node If a pivot does not exist we output Otherwise root the tree at the pivot Let s move the snake back and forth in a greedy fashion like this Move the head to the deepest leaf it can reach Then move the tail to the deepest leaf it can reach And repeat If at any point one endpoint becomes an ancestor of the other we can move the snake up to Otherwise if no more progress can be made progress is determined by the smallest reachable depth of an endpoint then the snake cannot reverse itself Clearly the snake can only go back and forth times before progress stops We can simulate the back and forth motion by answering th ancestor queries with binary lifting Complexity is It s also possible to achieve with two pointers Consider the path of nodes initially occupied by the snake numbered from to Each node has a subtree of non snake nodes Let be the height of the non snake subtree of node We can maintain two pointers and where is the maximum achievable index of the head and is the minimum achievable index of the tail We do a similar back and forth motion as in solution Send the head to the node that minimizes then send the tail to the node that maximizes and repeat The snake can reverse itself if and only if a pivot exists and can swap places Can you prove that the number of times the snake must switch between moving the head and tail is "}
{"statement": "Something happened in Uzhlyandia again There are riots on the streets Famous Uzhlyandian superheroes Shean the Sheep and Stas the Giraffe were called in order to save the situation Upon the arriving they found that citizens are worried about maximum values of the Main Uzhlyandian Function which is defined as follows In the above formula must hold where is the size of the Main Uzhlyandian Array and means absolute value of But the heroes skipped their math lessons in school so they asked you for help Help them calculate the maximum value of among all possible values of and for the given array ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "We can solve the problem for segments with odd and even separately Let s build arrays and Obviously that segment with the greatest sum in array starts in some even index In every segment starting in odd index we can move one position right and make answer not worse because every element of odd index in is non positive Also sum of segment starting in even index of equals to value of on the same segment Analogically for array and odd starting indexes So the answer equals to maximal of maximal sums of arrays and The segment with the greatest sum can be found with the two pointers method or using prefix sums Such solution works with complexity "}
{"statement": "AquaMoon and Cirno are playing an interesting game with arrays Cirno has prepared two arrays a and b both consist of n non negative integers AquaMoon can perform the following operation an arbitrary number of times possibly zero She chooses two indices i and j 1 le i j le n then decreases the i th element of array a by 1 and increases the j th element of array a by 1 The resulting values at i th and j th index of array a are a i 1 and a j 1 respectively Each element of array a If i j this operation doesn t change the array a AquaMoon wants to make some operations to make arrays a and b equal Two arrays a and b are considered equal if and only if a i b i for all 1 leq i leq n Help AquaMoon to find a sequence of operations that will solve her problem or find that it is impossible to make arrays a and b equal Please note that you the number of operations ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "First if the sum of elements in is not equal to the sum of elements in then the solution does not exist Each time find a position satisfying and find such a satisfying Then let until the two arrays become the same "}
{"statement": "An electrical grid in Berland palaces consists of 2 grids main and reserve Wires in palaces are made of expensive material so selling some of them would be a good idea Each grid main and reserve has a head node its number is 1 Every other node gets electricity from the head node Each node can be reached from the head node by a unique path Also both grids have exactly n nodes which do not spread electricity further In other words every grid is a rooted directed tree on n leaves with a root in the node which number is 1 Each tree has independent enumeration and nodes from one grid are not connected with nodes of another grid Also the palace has n electrical devices Each device is connected with one node of the main grid and with one node of the reserve grid Devices connect only with nodes from which electricity is not spread further these nodes are the tree s leaves Each grid s leaf is connected with exactly one device It is guaranteed that the whole grid two grids and n devices can be shown in this way like in the picture above main grid is a top tree whose wires are directed from the top to the down reserve grid is a lower tree whose wires are directed from the down to the top devices horizontal row between two grids which are numbered from 1 to n from the left to the right wires between nodes do not intersect Formally for each tree exists a depth first search from the node with number 1 that visits leaves in order of connection to devices 1 2 dots n firstly the node that is connected to the device 1 then the node that is connected to the device 2 etc Businessman wants to sell remove amount of wires so that each device will be powered from at least one grid main or reserve In other words for each device should exist at least one path to the head node in the main grid or the reserve grid which contains only nodes from one grid ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "We assume that the leaves of the trees are numbered in the same way as the devices to which these leaves are connected Let s calculate for each tree let s call them and the maximum number of edges that can be removed so that on the segment exists a path from each leaf to the root of the opposite tree Let s calculate for some fixed Let s call bamboo the connected set of ancestors of the node such that each node has at most child and the node itself is in this set Obviously is the maximum length of s bamboo Suppose we have already calculated Let s calculate Obviously we can remove all edges counted in We can also remove the resulting bamboo of the leaf because we do not need to have paths from the leaves to the root in the tree for which we are calculating Let s prove that we cannot remove more edges For each tree exists a depth first search from the node that visits leaves in order of connection to devices so for each node the set of leaf indices in its subtree is a segment If there is in the segment for the node then the th leaf is in the subtree of the node Let s have a look at the nodes whose subtree does not contain leaf If in their subtree there are nodes not from the segment then we cannot remove edge to the parent of this node because we don t want to lose the path to the root for the nodes out of the segment we are calculating the answer only for the segment So in the s subtree leaves are only from the segment Leaves from the segment were calculated in Then the segment for the s nodes is So we can remove the edge from each such node to its parent And the set of these nodes is a bamboo from the leaf because we have already removed all bamboos on segment So to calculate it is enough to know and the maximum length of s bamboo This can be calculated in time complexity Let s calculate the answer for the th prefix Let s take a look at the answer some suffix of leaves has a path to the root in only one tree and the rest of prefix has a maximum answer if not then we take the maximum answer for the prefix which will improve the answer Then we get the formula and which can be calculated in the time complexity Then the answer is Can you solve this problem with linear time complexity for example "}
{"statement": "You are given n lengths of segments that need to be placed on an infinite axis with coordinates The first segment is placed on the axis so that one of its endpoints lies at the point with coordinate 0 Let s call this endpoint the of the first segment and let s call its as that endpoint that is not the start The start of each following segment must coincide with the end of the previous one Thus if the length of the next segment is d and the end of the previous one has the coordinate x the segment can be placed either on the coordinates x d x and then the coordinate of its end is x d or on the coordinates x x d in which case its end coordinate is x d The total of the axis by these segments is defined as their overall union which is basically the set of points covered by at least one of the segments It s easy to show that the coverage will also be a segment on the axis Determine the minimal possible length of the coverage that can be obtained by placing all the segments on the axis without changing their order ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "One possible solution involves the method of dynamic programming As a state of DP we will use the number of already placed segments and the distance from the end of the last segment to the current left boundary of the coverage and in the DP we will store the minimal possible distance from the end of the last segment to the current right boundary of the coverage We can prove that the answer never exceeds where is the maximal length of the segments To do this let us define a region of length specifically the segment If the end of the last segment has a coordinate we put the next segment to the left otherwise we put it to the right With this algorithm none of the end endpoints of the segments will go beyond the marked boundaries because to do so the segment must be placed from the coordinate of one sign beyond the boundary of the opposite sign and thus must have a length greater than which contradicts how we defined Using this fact we will consider the DP for and as the minimum distance between the end of the th segment and the right boundary of the axis coverage of the first segments when the distance to the left boundary of the coverage equals to The end of the th segment here is the beginning of the first one that is the point The base of DP is since when no segments are placed the coverage boundaries and the current point are all coincident Next we consider the forward dynamic programming relaxation for every there are two cases to consider the case of the next segment being placed to the left and the case of it being placed to the right value below refers to the distance to the right boundary of the coverage and is an alias for If a segment of length is placed to the left side then the new distance to the left boundary will be equal to and distance to the right boundary will always be which gives us the relaxation formula If a segment of length is placed to the right side then the new distance to the right boundary will be equal to and distance to the left boundary will always be which gives us the relaxation formula The values in array can be calculated in ascending order by Then the answer for the problem can be found as the minimum sum of and in the last row of that is The time complexity is "}
{"statement": "All of Slavic s friends are planning to travel from the place where they live to a party using their bikes And they all have a bike except Slavic There are n cities through which they can travel They all live in the city 1 and want to go to the party located in the city n The map of cities can be seen as an undirected graph with n nodes and m edges Edge i connects cities u i and v i and has a length of w i Slavic doesn t have a bike but what he has is money Every city has exactly one bike for sale The bike in the i th city has a slowness factor of s i Once Slavic buys a bike he can use it to travel from the city he is currently in to any neighboring city by taking w i cdot s j time considering he is traversing edge i using a bike j he owns Slavic can buy as many bikes as he wants as money isn t a problem for him Since Slavic hates traveling by bike he wants to get from his place to the party in the shortest amount of time possible And since his informatics skills are quite rusty he asks you for help What s the shortest amount of time required for Slavic to travel from city 1 to city n Slavic can t travel without a bike It is guaranteed that it is possible for Slavic to travel from city 1 to any other city ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "We can build a graph with nodes where each node is responsible for the pair where is the index of the city and is the speed we have when we are at this city Then we can use Dijkstra s algorithm to compute the shortest path on this graph by considering all edges of node when we are at a pair which has as the city and the new would be the minimum value of and where is the neighboring city we are considering After computing all shortest paths from node we just find the minimum value of for all from to and that will be our answer "}
{"statement": "You are given two binary strings x and y which are binary representations of some two integers let s denote these integers as f x and f y You can choose any integer k ge 0 calculate the expression s k f x f y cdot 2 k and write the binary representation of s k in let s denote it as rev k For example let x 1010 and y 11 you ve chosen k 1 and since 2 1 10 2 so s k 1010 2 11 2 cdot 10 2 10000 2 and rev k 00001 For given x and y you need to choose such k that rev k is read notes if you don t know what does lexicographically means It s guaranteed that with given constraints k exists and is finite ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Multiplying by power of is shift left binary operation you probably should know it Reverse and for the simplicity and look at leftmost in let s denote its position as If you move it to in then you make the lexicographically bigger than the reverse of So you should move it to in too You can choose any with position Let be the minimum position of in such that You must move to otherwise the in still be present in and it will be not optimal So the solution is next reverse and find find print "}
{"statement": "You are given a sequence a initially consisting of n integers You want to transform this sequence so that all elements in it i e it contains several occurrences of the same element To achieve this you choose some integer x and then perform the following operation any number of times possibly zero choose some segment l r of the sequence and remove it But there is one exception More formally you choose some contiguous subsequence a l a l 1 dots a r such that a i ne x if l le i le r and remove it After removal the numbering of elements to the right of the removed segment changes the element that was the r 1 th is now l th the element that was r 2 th is now l 1 th and so on i e the remaining sequence just collapses Note that you x after you chose it For example suppose n 6 a 1 3 2 4 1 2 Then one of the ways to transform it in two operations is to choose x 1 then choose l 2 r 4 so the resulting sequence is a 1 1 2 choose l 3 r 3 so the resulting sequence is a 1 1 Note that choosing x is not an operation Also note that you remove any occurrence of x Your task is to find the number of operations required to transform the sequence in a way described above You have to answer t independent test cases ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Firstly let s remove all consecutive equal elements just keep one occurrence of each such element For example the array becomes Now the answer for each is the number of its occurrences plus one Why is it so Because we need to remove all segments of elements between every pair of consecutive occurrences of The number of such segments is the number of occurrences of minus one There is also a segment before the first occurrence of and a segment after the last occurrence of But the first segment doesn t exist for the first element and the last segment doesn t exist for the last element So after removing consecutive elements let s calculate for each the number of its occurrences plus one subtract one from the value of the first element and from the value of the last element Then the answer is the minimum among these values for all "}
{"statement": "Airports often use moving walkways to help you walking big distances faster Each such walkway has some speed that effectively increases your speed You can stand on such a walkway and let it move you or you could also walk and then your effective speed is your walking speed plus walkway s speed Limak wants to get from point 0 to point L on a straight line There are n disjoint walkways in between The i th walkway is described by two integers x i and y i and a real value s i The i th walkway starts at x i ends at y i and has speed s i Every walkway is located inside the segment 0 L and no two walkways have positive intersection However they can touch by endpoints Limak needs to decide how to distribute his energy For example it might make more sense to stand somewhere or to walk slowly to then have a lot of energy to walk faster Limak s initial energy is 0 and it must never drop below that value At any moment he can walk with any speed v in the interval 0 2 and it will cost him v energy per second but he continuously recovers energy with speed of 1 energy per second So when he walks with speed v his energy increases by 1 v Note that negative value would mean losing energy In particular he can walk with speed 1 and this won t change his energy at all while walking with speed 0 77 effectively gives him 0 23 energy per second Limak can choose his speed arbitrarily any real value in interval 0 2 at every moment of time including the moments when he is located on non integer positions Everything is continuous non discrete What is the fastest time Limak can get from 0 to L ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "Some minor tips Everything is a walkway When there is no walkway it is a walkway of speed 0 You can increase all speeds by 1 and assume that you own speed is in 1 1 Energy is an entity which is speed time which is distance Also if you spend x energy per segment of len l and speed v it is not important how exactly you will distribute it over the walking process In any way you will walk by feet l x meters in time l x v So it turns out it s better to distribute more energy to low speeded walkways because the denominator is smaller Assume that you by default save up all energy on any non feet path for feet path it s always optimal to walk with speed 1 0 after speeds hack so now save up s Build an energy graphic where the Ox axis will correspond to the point you are in not time It will be a piecewise linear function so it is enough to store it s value only in points corresponding to points between walkways Iterate over walkways in the order of speed and try to steal as much energy as possible to the current walkway What are the limits of stealing energy there is a restriction based on l and v if you take too much energy you wouldn t be able to fully walk it up the graphic must still be able above 0 at all points The latter condition is just a suffix minima on a segment tree "}
{"statement": "One day Vasya was sitting on a not so interesting Maths lesson and making an origami from a rectangular mm mm sheet of paper Usually the first step in making an origami is making a square piece of paper from the rectangular sheet by folding the sheet along the bisector of the right angle and cutting the excess part After making a paper ship from the square piece Vasya looked on the remaining mm mm strip of paper He got the idea to use this strip of paper in the same way to make an origami and then use the remainder if it exists and so on At the moment when he is left with a square piece of paper he will make the last ship from it and stop Can you determine how many ships Vasya will make during the lesson ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "It s easy to see that described process is equivalent to the following loop But such naive approach will obviously lead to verdict TLE since it makes operations even on the third sample test The key idea is to replace repeating subtraction operations with integer division operations This leads to the logarithmic time solution that looks similar to the Euclid algorithm The first observation is that the new Hamming distance may not be less than the old one minus two since we change only two characters So the task is to actually determine if we can attain decrease by two one or can t attain decrease at all The decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order like double bundle If there are no such positions then we just need to check that we may decrease the distance This can be done by just fixing the character that stands on the wrong position like in permanent pergament here n stands in wrong pair with m and there is also unmatched m so we may fix this position Otherwise the answer is to keep everything as it is Implementation can be done by keeping for each pair x y of symbols position where such pair appears in S and T and then by carefully checking the conditions above Obviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std set or some logarithmic data structure This solution works in But there is also a nice linear solution if we answer all queries in reverse order Suppose segments are not cutting but merging In this case we may keep the horizontal and vertical cut lines in double linked lists and track the current maximum that can only increase and become equal to the newly merged segment each time This solution works in One may think that this task is about graph theory but it after some investigation and several equivalent changes in task statement it can be reduced to the well known greedy problem Initially you have that points may lie together in a set if they are not too close i e This is obviously equivalent to the following condition Let s consider interval of radius with center in point and call this interval to be the interval of point i Then the statement actually says that no two such intervals should be intersecting This task is well known and can be solved greedily after sorting segments in ascending order of right endpoint It s easy to prove that this solution is correct Among all ways to choose first segments the best way is the one that minimizes x coordinate of the right endpoint of the last segment since it restricts us in the least possible way Problem legend asks you to add minimum number of edges to the given connected undirected graph possibly with loops and duplicating edges and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even First idea is that the resulting graph before we choose the direction but after we added some edges will contain Euler circuit since all degrees are even That s almost what we need if we have an Euler circuit that contains even number of edges we may direct them like following a b c d e It s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree so the resulting degrees will be even But if the Euler circuit is odd meaning that there is odd number of edges in the graph we must add some extra edge to the graph before we continue the easiest way is to add a loop from vertex 0 to itself since it doesn t affect the Euler tour but now tour length is even so everything is ok Now we should think how to add edges optimally It s easy to see that the optimal way is to first fix all odd degrees of vertices i e combine all odd vertices by pairs and put an edge in each pair and then possibly add an extra loop as described above The last part is to actually find an Euler circuit and to print the answer There were issues with this task Intended constraints were actually and the intended solution was using Fast Fourier Transformation that leads to running time But unfortunately the statement contained wrong constraints so we reduced input size during the tour Nevertheless we will add the harder version of this task and you will be able to submit it shortly Key idea is to reduce this task to a polynomial multiplication Let s solve the task in following manner For each position i of the S for each character c from ATGC we will calculate match c i that is equal to the number of c characters that have matching symbol in S if we put string T in position i Then the criteria for us to have an occurrence at position i is that match A i match T i match G i match C i T that means exactly that each character from T being put at position i has a corresponding character in S Now let s find out how to calculate match c i Let s keep only c characters and not c characters in both strings and denote them by 1 and 0 respectively Let s also spread each 1 in string S by the distance k to the left and to the right For example k 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111 and for the character C it will be 0111001110 This bitvector can be calculated in by putting two events 1 and 1 in string S in positions and for each in original string S and then sweeping from left to right over the string S and processing those events Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S In constraints this can be done by using bitsets in Nevertheless this task can be seen as calculation of polynomials S and reversed T product We will keep this as an exercise for those who decide to submit the harder version of this task Let s draw a bounding box that contains all intersection points Let s fix a triangle and consider three angles shown on the picture Calculate area of intersection of those area with the bounding box and call this area to be the area of an angle Then it s easy to see that those three angles are complement to the triangle itself in the bounding box i e triangle area is bounding box area minus three angle areas This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane how much times does it appear in total answer if we sum all values like over all triples of lines Actually the angle is considered as many times as many lines there are that intersect both sides of its right adjacent angle So our task is reduced to calculate for each angle on plane how much lines intersect its sides i e its rays This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right Key idea is that the exact of four angles formed by the pair of lines that is crossed by some third line c can be determined by two numbers its polar angle alpha and its crossing with a coordinate x Further details are shown on the picture below There is also a nice short solution from enot110 here "}
{"statement": "There are boys and girls studying in the class They should stand in a line so that boys and girls alternated there as much as possible Let s assume that positions in the line are indexed from left to right by numbers from 1 to Then the number of integers such that positions with indexes and contain children of different genders position has a girl and position has a boy or vice versa must be as large as possible Help the children and tell them how to form the line ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Lets assume that we have more boys than girls the other case is solved similarly Then we can construct one of the optimal solutions in the following way we add pairs consisting of a boy and a girl BG in that order to the end of the line until we don t have girls any more Then add remaining boys to the end of the line For instance with 7 boys and 4 girls we will come to the solution BGBGBGBGBBB "}
{"statement": "You ve got an pixel picture Each pixel can be white or black Your task is to change the colors of as few pixels as possible to obtain a barcode picture A picture is a barcode if the following conditions are fulfilled All pixels in each column are of the same color The width of each monochrome vertical line is at least and at most pixels In other words if we group all neighbouring columns of the pixels with equal color the size of each group can not be less than or greater than ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Firstly you should calculate number of white and black pixels in every column After that you should calculate number of white and black pixels for every prefix in sequence of columns Now you can calculate number of black or white pixels in every vertical line of any width in O 1 Now you should use dynamic programming Let s dp i j will store numbers of repainted pixels in prefix from the 1st column to the j th and color of the last column will be white for i 0 and black for i 1 Than you can recalculate dp using forlulas dp 0 0 dp 1 0 0 Answer will be min dp 0 m dp 1 m This solution works in O nm m y x "}
{"statement": "Filip has a row of cells some of which are blocked and some are empty He wants all empty cells to have water in them He has two actions at his disposal 1 place water in an empty cell 2 remove water from a cell and place it in any other empty cell If at some moment cell i 2 le i le n 1 is empty and both cells i 1 and i 1 contains water then it becomes filled with water Find the minimum number of times he needs to perform action 1 in order to fill all empty cells with water Note that you don t need to minimize the use of action 2 Note that blocked cells neither contain water nor can Filip place water in them ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Solution Read the hints If there are 3 consecutive empty cells we can place water in cells and and then move water from cell to all other cells If there are no such cells we have to place water on every empty cell So if we find substring in the array the answer is otherwise the answer is the number of empty cells Time and memory complexities are "}
{"statement": "Valera is a collector Once he wanted to expand his collection with exactly one antique item Valera knows sellers of antiques the th of them auctioned items Currently the auction price of the th object of the th seller is Valera gets on well with each of the sellers He is perfectly sure that if he outbids the current price of one of the items in the auction in other words offers the seller the money that is strictly greater than the current price of the item at the auction the seller of the object will immediately sign a contract with him Unfortunately Valera has only units of money Help him to determine which of the sellers he can make a deal with ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "You need to implement what written in statement You could act like that let s calculate minimum item price from seller Then if we can make a deal with seller otherwise we can t Jury s "}
{"statement": "Monocarp had a permutation a of n integers 1 2 n a permutation is an array where each element from 1 to n occurs exactly once Then Monocarp calculated an array of integers b of size n where b i left lfloor frac i a i right rfloor For example if the permutation a is 2 1 4 3 then the array b is equal to left left lfloor frac 1 2 right rfloor left lfloor frac 2 1 right rfloor left lfloor frac 3 4 right rfloor left lfloor frac 4 3 right rfloor right 0 2 0 1 Unfortunately the Monocarp has lost his permutation so he wants to restore it Your task is to find a permutation a that corresponds to the given array b If there are multiple possible permutations then print any of them The tests are constructed in such a way that least one suitable permutation exists ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "We have for each we can rewrite this as follows or From here we can see that for each there is a segment of values that can be assigned to So we have to match each number from to with one of these segments To solve this problem we can iterate from to Let the current number be then it can be paired with a segment without a pair such that and the right bound is minimum among all such segments because it will be the first to end among these segments To do this it is enough to maintain a set with open segments that have not yet been assigned a pair and choose from it a segment with the minimum right bound Before running this method you can sort the segments by their left border so they can be easily added to this set when we go from to we will need to insert all segments that begin with that s why it s convenient to have them sorted by their left border beforehand "}
{"statement": "After a wonderful evening in the restaurant the time to go home came Leha as a true gentlemen suggested Noora to give her a lift Certainly the girl agreed with pleasure Suddenly one problem appeared Leha cannot find his car on a huge parking near the restaurant So he decided to turn to the watchman for help Formally the parking can be represented as a matrix There is exactly one car in every cell of the matrix All cars have their own machine numbers represented as a positive integer Let s index the columns of the matrix by integers from to from left to right and the rows by integers from to from top to bottom By coincidence it turned out that for every cell the number of the car which stands in this cell is equal to the minimum positive integer which can t be found in the cells and Leha wants to ask the watchman requests which can help him to find his car Every request is represented as five integers The watchman have to consider all cells of the matrix such that and and if the number of the car in cell does not exceed increase the answer to the request by the number of the car in cell For each request Leha asks the watchman to tell him the resulting sum Due to the fact that the sum can turn out to be quite large hacker asks to calculate it modulo However the requests seem to be impracticable for the watchman Help the watchman to answer all Leha s requests ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "At first let s examine that numbers in the matrix are equal to binary xor of the row and column Precisely the number in cell is equal to Now let s split the query into 4 queries to the matrix prefix as we usually do it in matrix sum queries In order to find the answer to the query we have to maintain 2 dp on bits and where the number of placed bits flags of equality in query and flag of equality of row and column xor with Flag of equality is a boolean equal to if our number became less then prefix and if prefix is still equal If you aren t familiar with such dp please try to solve another task with dp on prefix with less number of flags will maintain the number of cells that are suitable for the arguments and accumulated sum "}
{"statement": "You are given a string s of lowercase Latin letters The following operation can be used select one character from to that occurs at least once in the string And replace all such characters in the string with the previous one in alphabetical order on the loop For example replace all with or replace all with And you are given the integer k the maximum number of operations that can be performed Find the minimum lexicographically possible string that can be obtained by performing no more than k operations The string a a 1a 2 dots a n is lexicographically smaller than the string b b 1b 2 dots b n if there exists an index k 1 le k le n such that a 1 b 1 a 2 b 2 a k 1 b k 1 but a k b k ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Greedy idea To minimize the string we will go from left to right and maintain a variable maximal character from which we will reduce everything to a Initially it is a and we spend of operations on it Then at the next symbol we can either reduce it to a in no more than operations or reduce to a the prefix we have already passed and minimize the next character in the remaining operations "}
{"statement": "Masha has n types of tiles of size 2 times 2 Each cell of the tile contains one integer Masha has an of tiles of each type Masha decides to construct the square of size m times m consisting of the given tiles This square also has to be a and each cell of this square has to be covered with exactly one tile cell and also sides of tiles should be parallel to the sides of the square All placed tiles cannot intersect with each other Also each tile should lie inside the square See the picture in Notes section for better understanding Symmetric with respect to the main diagonal matrix is such a square s that for each pair i j the condition s i j s j i holds I e it is true that the element written in the i row and j th column equals to the element written in the j th row and i th column Your task is to determine if Masha can construct a square of size m times m which is a symmetric matrix and consists of tiles she has Masha can use any number of tiles of each type she has to construct the square Note that she rotate tiles she can only place them in the orientation they have in the input You have to answer t independent test cases ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Firstly if is odd then the answer is by obvious reasons Otherwise we can notice that the top left and the bottom right values of the tile do not matter since we can place tiles symmetrically So we only need to check that there is some tile that its top right value equals its bottom left value because this is how we get main diagonal symmetry "}
{"statement": "New Year is coming Vasya has prepared a New Year s verse and wants to recite it in front of Santa Claus Vasya s verse contains n parts It takes a i seconds to recite the i th part Vasya can t change the order of parts in the verse firstly he recites the part which takes a 1 seconds secondly the part which takes a 2 seconds and so on After reciting the verse Vasya will get the number of presents equal to the number of parts he fully recited Vasya can skip at most one part of the verse while reciting it if he skips more than one part then Santa will definitely notice it Santa will listen to Vasya s verse for no more than s seconds For example if s 10 a 100 9 1 1 and Vasya skips the first part of verse then he gets two presents Note that it is possible to recite the whole verse if there is enough time Determine which part Vasya needs to skip to obtain the maximum possible number of gifts If Vasya shouldn t skip anything print If there are multiple answers print any of them You have to process t test cases ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "If then answer is Otherwise let s find we minimum index such that It s useless to skip a part because Vasya just has not time to recite previous part it s change nothing So he has to skip a part And among such parts it s beneficial to skip part with maximum value of "}
{"statement": "You are given two simple undirected graphs F and G with n vertices F has m 1 edges while G has m 2 edges You may perform one of the following two types of operations any number of times Select two integers u and v 1 leq u v leq n such that there is an edge between u and v in F Then remove that edge from F Select two integers u and v 1 leq u v leq n such that there is no edge between u and v in F Then add an edge between u and v in F Determine the minimum number of operations required such that for all integers u and v 1 leq u v leq n there is a path from u to v in F there is a path from u to v in G ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1500", "problem_editorial": "Let s solve the problem for each operation First consider the operation that removes an edge from F Divide G into its connected components and assign each vertex a component index Then for each edge in F if it connects vertices with different component indices remove it and increment the operation count This guarantees no path between x and y in F if there is none in G Next to ensure a path exists between x and y in F if there is one in G we divide F into connected components After removing excess edges each component of F only contains vertices of the same component index The number of operations needed now is the difference between the number of connected components in F and G All operations can be efficiently performed using DFS or DSU "}
{"statement": "Now Serval is a junior high school student in Japari Middle School and he is still thrilled on math as before As a talented boy in mathematics he likes to play with numbers This time he wants to play with numbers on a rooted tree A tree is a connected graph without cycles A rooted tree has a special vertex called the root A parent of a node v is the last different from v vertex on the path from the root to the vertex v Children of vertex v are all nodes for which v is the parent A vertex is a leaf if it has no children The rooted tree Serval owns has n nodes node 1 is the root Serval will write some numbers into all nodes of the tree However there are some restrictions Each of the nodes except leaves has an operation max or min written in it indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons respectively Assume that there are k leaves in the tree Serval wants to put integers 1 2 ldots k to the k leaves each number should be used exactly once He loves large numbers so he wants to maximize the number in the root As his best friend can you help him ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "If we want to check whether is the answer I didn t say I want to do binary search then we can set all the numbers no less than as and the numbers less than as Then we can use to represent that the maximum number on node is the th smallest number of leaves within subtree of There should be at least ones in the subtree of such that the number on is one Then is the final answer Complexity "}
{"statement": "You are given an array of integers The cost of a subsegment is the number of unordered pairs of distinct indices within the subsegment that contain equal elements Split the given array into non intersecting non empty subsegments so that the sum of their costs is minimum possible Each element should be present in exactly one subsegment ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "First let us solve the problem in time with a simple DP Let be the smallest cost of a partition of first elements into parts Clearly We can optimize the cost computation by moving from right to left and maintaining frequency for each element since by introducing an element into the segment we increase the cost by the number of occurences of To optimize this further let us note that the leftmost optimal value of for a particular is monotonous in on any step Indeed suppose that and for But since introducing an element into a segment is at least as costly as introducing it into a segment Finally and which contradicts the optimality of We can now apply the divide and conquer DP optimization suppose that for a segment we know that for each Choose as the midpoint of and find by explicitly trying all values in We now proceed recursively into segments with and with Assuming unit cost for computation one can show that the computation of all values of for a particular takes time The final detail is that the time needed to compute can be made amortized constant that is in total per layer if we store the value from the parent segment and add remove segment elements one by one to obtain all subsequent values The total complexity is now "}
{"statement": "You are given a strip of paper s that is n cells long Each cell is either black or white In an operation you can take any k consecutive cells and make them all white Find the minimum number of operations needed to remove all black cells ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The key idea is greedy Let s go from the left to the right and if the current cell is black we should use the operation starting at this cell it may go off the strip but that s okay we can always shift it leftwards to contain all the cells we need it to We can implement this in iterate from left to right with a variable and when you see a black cell you should skip the next cells because the eraser will take care of them and increase the number of operations by The answer is the total number of operations Why does it work Notice the order of operations doesn t matter Consider the leftmost black cell we erase It means none of the cells to its right are black So it doesn t make sense to use the operation on any of the cells to its right since they are already white It is at least as good to use the operation starting at this cell and to the cells on the left since we may or may not hit another black cell "}
{"statement": "You like the card board game Set Each card contains k features each of which is equal to a value from the set 0 1 2 The deck contains all possible variants of cards that is there are 3 k different cards in total A feature for three cards is called if it is the same for these cards or pairwise distinct Three cards are called a if all k features are good for them For example the cards 0 0 0 0 2 1 and 0 1 2 form a set but the cards 0 2 2 2 1 2 and 1 2 0 do not as for example the last feature is not good A group of cards is called a if there is strictly more than one set among them How many meta sets there are among given n distinct cards ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "SolutionFor every two cards there is always a single card that forms a set with them 1 That means that two sets can share at most one card Let s prove that there are no more than sets in a meta set Let s define cards as Let s guess that is a set All other sets can have at most one card among according to 1 so they must include and So we have at most one other set otherwise they would have two same cards which is prohibited according to 1 So every meta set looks like sets with one common card Let s call this card a central card Now there is just a simple combinatorics For each card we want to know the number of sets that include it If this number is then we should add to the answer it is the number of meta sets with this card as a central card To get the number of sets for each card we can iterate over all pairs of cards generate the complement to the set and add to that card in a map hashmap Complexity is or "}
{"statement": "You are given a string s consisting of the characters and You need to replace all the characters with in the string s by or so that the string becomes a palindrome and has a characters and b characters Note that each of the characters is replaced from the others A string t of length n is called a palindrome if the equality t i t n i 1 is true for all i 1 le i le n For example if s a 4 and b 4 then you can replace the characters in the following ways For the given string s and the numbers a and b replace all the characters with in the string s by or so that the string becomes a palindrome and has a characters and b characters ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "First let s find such positions such that symbols in symmetric positions are uniquely determined If then If then at the end we will not get a palindrome in any way so the answer is Note that after such a replacement the remaining characters are split into pairs except maybe the central one If the center character is then it is necessary to put the character if is odd or if is odd if neither nor is odd then the answer is Now the remaining characters are split into pairs i e if then This allows the remaining characters and to be replaced greedily If and then and decrease for If and then and decrease for Otherwise the answer is "}
{"statement": "Monocarp is playing a computer game Now he wants to complete the first level of this game A level is a rectangular grid of 2 rows and n columns Monocarp controls a character which starts in cell 1 1 at the intersection of the 1 st row and the 1 st column Monocarp s character can move from one cell to another in one step if the cells are adjacent by side and or corner Formally it is possible to move from cell x 1 y 1 to cell x 2 y 2 in one step if x 1 x 2 le 1 and y 1 y 2 le 1 Obviously it is prohibited to go outside the grid There are traps in some cells If Monocarp s character finds himself in such a cell he dies and the game ends To complete a level Monocarp s character should reach cell 2 n at the intersection of row 2 and column n Help Monocarp determine if it is possible to complete the level ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "At first glance it seems like a graph problem And indeed this problem can be solved by explicitly building a graph considering cells as the vertices and checking that there is a safe path from start to finish via DFS BFS DSU any other graph algorithm or data structure you know But there s a much simpler solution Since there are only two rows in a matrix it s possible to move from any cell in the column to any cell in column if they are both safe of course It means that as long as there is at least one safe cell in each column it is possible to reach any column of the matrix and the cell as well It s easy to see that if this condition is not met there exists a column with two unsafe cells and this also means that this column and columns to the right of it are unreachable So the problem is reduced to checking if there is a column without any unsafe cells To implement this you can read both rows of the matrix as strings let these strings be and and check that there is a position such that both and are equal to "}
{"statement": "Kristina had an array a of length n consisting of non negative integers She built a new array b of length n 1 such that b i max a i a i 1 1 le i le n 1 For example suppose Kristina had an array a 3 0 4 0 5 of length 5 Then she did the following Calculated b 1 max a 1 a 2 max 3 0 3 Calculated b 2 max a 2 a 3 max 0 4 4 Calculated b 3 max a 3 a 4 max 4 0 4 Calculated b 4 max a 4 a 5 max 0 5 5 As a result she got an array b 3 4 4 5 of length 4 You only know the array b Find any matching array a that Kristina may have originally had ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "To solve the problem you can build an array as follows at Let s show that from the constructed array we can get an array equal to the original array If then If then So at If and then If then If then By the construction of the array it is not possible that and So If then If then So We get that for so and array is built correctly "}
{"statement": "Narek found out that the kids only know the vowels of the English alphabet the letters mathtt a mathtt e mathtt i mathtt o and mathtt u so Narek needs to make a string that consists of vowels only After making the string he ll ask the kids to count the number of subsequences that are palindromes Narek wants to keep it simple so he s looking for a string such that the amount of palindrome subsequences is minimal Help Narek find a string of length n consisting of English letters mathtt a mathtt e mathtt i mathtt o and mathtt u which the amount of in it dagger A string is called a palindrome if it reads the same from left to right and from right to left ddagger String t is a subsequence of string s if t can be obtained from s by removing several possibly zero or all characters from s and concatenating the remaining ones without changing their order For example mathtt odocs is a subsequence of texttt c color red texttt od texttt ef color red texttt o texttt r color red texttt c texttt e color red texttt s ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Full SolutionLet s define the numbers of vowels by and assume we have fixed them Obviously At first let s not consider the empty string as it doesn t change anything Then the number of palindrome subsequences will be at least every subsequence consisting of the same letter minus the five empty strings Now notice that if we put the same characters consecutively then the answer would be exactly and that would be the best possible answer for that fixed numbers there cannot be other palindrome subsequences because if the first and last characters are the same then all the middle part will be the same as well Now we need to find the best array To do this let s assume there are 2 mumbers and in the array such that Then This means that replacing and with and will not change the sum of the array but will make the number of palindrome subsequences smaller We can do this replacing process until no two numbers in have difference bigger than Actually there is only one such array not considering its permutations and it contains only s and s "}
{"statement": "In one kingdom there are cities and two way roads Each road connects a pair of cities and for each road we know the level of drivers dissatisfaction the value For each road we know the value how many lamziks we should spend to reduce the level of dissatisfaction with this road by one Thus to reduce the dissatisfaction with the th road by we should spend lamziks And In accordance with the king s order we need to choose roads and make them the An important condition must hold it should be possible to travel from any city to any other by the The road ministry has a budget of lamziks for the reform The ministry is going to spend this budget for repair of some roads to reduce the dissatisfaction with them and then to choose the Help to spend the budget in such a way and then to choose the main roads so that the total dissatisfaction with the will be as small as possible The dissatisfaction with some roads can become negative It is not necessary to spend whole budget It is guaranteed that it is possible to travel from any city to any other using existing roads Each road in the kingdom is a two way road ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2200", "problem_editorial": "If you choose any roads then price of reducing overall dissatisfaction is equal to where is price of reducing by dissatisfaction of th edge So the best solution is to choose one edge and reduce dissatisfaction of it until running out of budget Let s construct minimal spanning tree using Prim or Kruskal algorithm using edges of weights equal to dissatisfaction and calculate minimal price of reducing dissatisfaction Time complexity Now we can iterate over edges implying that current is the one to be reduced to minimum For example for every edge we can build new MST and recalculate answer It s Therefore we should use this fact it s poinless to reduce dissatisfaction of edges which weren t selected to be main Then we can transform original MST instead of constructing new ones Add next edge to MST now it contains a cycle from which edge with maximal dissatisfaction is about to be deleted This can be achieved in such a way find LCA of vertices of new edge in and using binary lifting with precalc in find the edge to delete Time complexity "}
{"statement": "In all schools in Buryatia in the 1 class everyone is told the theory of Fibonacci strings A is a subsegment of a string where all the letters are the same and are bounded on the left and right by the ends of the string or by letters other than the letters in the block A string is called a string if when it is divided into blocks their lengths in the order they appear in the string form the Fibonacci sequence f 0 f 1 1 f i f i 2 f i 1 starting from the zeroth member of this sequence A string is called if it possible to reorder its letters to get a string Burenka decided to enter the Buryat State University but at the entrance exam she was given a difficult task She was given a string consisting of the letters of the Buryat alphabet which contains exactly k letters and was asked if the given string is The string can be very long so instead of the string she was given the number of appearances of each letter c i for the i th letter in that string Unfortunately Burenka no longer remembers the theory of Fibonacci strings so without your help she will not pass the exam ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "At the beginning let s check that the number n the sum of all ci is representable as the sum of some prefix of Fibonacci numbers otherwise we will output the answer NO Let s try to type the answer greedily going from large Fibonacci numbers to smaller ones For the next Fibonacci number let s take the letter with the largest number of occurrences in the string from among those that are not equal to the previous letter taken to avoid the appearance of two adjacent blocks from the same letter which cannot be If there are fewer occurrences of this letter than this number then the answer is NO Otherwise we will put the letter on this Fibonacci number and subtract it from the number of occurrences of this letter If we were able to dial all the Fibonacci numbers then the answer is YES Why does the greedy solution work Suppose at this step you need to take Fi I will say take a number from ct this will mean taking Fi letters t from string let s look at the maximum cx now if it cannot be represented as the sum of Fibonacci numbers up to Fi among which there are no neighbors then the answer is no It can be proved that if cx Fi 1 then it is impossible to represent cx If there is exactly one number greater than or equal to Fi at the step then there is only one option to take a number so the greedy solution works If there are two such numbers and they are equal then the option to take a number is exactly one up to the permutation of letters the greedy solution works again If there are cj Fi cx Fi j x then we note that the larger of the numbers cj cx will be greater than Fi if we don t take it then at the next step this number will be greater than Fi 1 i will be 1 less according to the above proven answer will not be so taking the larger of the numbers is always optimal The complexity of the solution is O klog n log k "}
{"statement": "Your friend Kirchhoff is shocked with the current state of electronics design Ohmygosh Watt is wrong with the field All these circuits are inefficient There s so much capacity for improvement The electrical engineers must not conduct their classes very well It s absolutely revolting he said The negativity just keeps flowing out of him but even after complaining so many times he still hasn t lepton the chance to directly change anything These circuits have too much total resistance Wire they designed this way It s just causing a massive loss of resistors Their entire field could conserve so much money if they just maximized the potential of their designs Why can t they just try alternative ideas The frequency of his protests about the electrical engineering department hertz your soul so you have decided to take charge and help them yourself You plan to create a program that will optimize the circuits while keeping the same circuit layout and maintaining the same effective resistance A has two endpoints and is associated with a certain constant R called its The circuits we ll consider will be formed from individual resistors joined together in or in forming more complex circuits The following image illustrates combining circuits in series or parallel According to your friend Kirchhoff the effective resistance can be calculated quite easily when joining circuits this way When joining k circuits in with effective resistances R 1 R 2 ldots R k the effective resistance R of the resulting circuit is the sum R R 1 R 2 ldots R k When joining k circuits in with effective resistances R 1 R 2 ldots R k the effective resistance R of the resulting circuit is found by solving for R in frac 1 R frac 1 R 1 frac 1 R 2 ldots frac 1 R k if at least one R i 0 then the effective resistance of the whole circuit is simply R 0 Circuits will be represented by strings Individual resistors are represented by an asterisk For more complex circuits suppose s 1 s 2 ldots s k represent k ge 2 circuits Then represents their circuit represents their circuit For example represents the following circuit Given a circuit your task is to assign the resistances of the individual resistors such that they satisfy the following requirements Each individual resistor has a resistance value The effective resistance of the whole circuit is r The sum of the resistances of the individual resistors is minimized If there are n individual resistors then you need to output the list r 1 r 2 ldots r n 0 le r i and r i is an integer where r i is the resistance assigned to the i th individual resistor that appears in the input from left to right If it is impossible to accomplish the task you must say so as well If it is possible then it is guaranteed that the minimum sum of resistances is at most 10 18 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Instead of minimizing the cost which feels like a hard number theory problem let s try to minimize the cost first This is a bit easier but it should help us solve the integer case by at least giving us a lower bound If we re allowed to assign arbitrary real numbers as costs then we can deduce that the minimum cost to obtain a resistance of is proportional to This is because we can just scale resistances arbitrarily so if we have an optimal solution for one given with optimal cost then to get any other target resistance we can simply scale all resistances by and we get a circuit with resistance and cost that should also be optimal To prove this more rigorously define to be the optimal cost for a target resistance Then the scaling idea above shows that which is equivalent to By symmetry and so Therefore must be linear in i e for some Thus we just need to find this proportionality constant for our input circuit This can be computed inductively For a basic resistor For circuits with constants joined in series For circuits with constants joined in parallel The latter two can be derived with some basic calculus For the case of parallel circuits using Lagrange multipliers is the easiest way at least for me But note that all three statements imply via induction that Even more using the formulas above we can deduce the following stronger statement You can also prove this via induction and it s actually not that hard The hardest part is knowing what to prove in the first place Once we have this statement we can now turn its proof into a recursive algorithm that actually computes these parallel resistors the whole circuit is equivalent to The most straightforward proof of it naturally translates into such an algorithm We then assign a resistance of to everything else Finally using the same analysis as before to obtain a resistance of in a parallel circuit of resistors the optimal way is to assign to everything But if is an integer then is an integer as well and since we re assigning to everything else it means that the minimum cost to achieve can be achieved in integers as well "}
{"statement": "Levko loves strings of length consisting of lowercase English letters very much He has one such string For each string of length Levko defines its beauty relative to as the number of pairs of indexes such that substring The boy wondered how many strings are there such that their beauty relative to equals exactly Help him find the remainder after division this number by A substring of string is string String is lexicographically larger than string if there is such number that and The string characters are compared by their ASCII codes ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Let s count amount of such substrings of that are bigger than corresponding substring of and begin at the position If this amount equals If this amount equals If then let s find such nearest position that If needed amount of substrings will be If needed amount of substrings will be We can rephrase this If it will be new substrings where means how many last elements in and is equal Let s make dp means that we viewed positions have needed substrings and Lets iterate their common prefix If we can count this value using partial sums If Let s iterate Let s note that so and This means that third cycle will make at most iterations when we find value of Let s count total number of iterations "}
{"statement": "A one dimensional Japanese crossword can be represented as a binary string of length An encoding of this crossword is an array of size where is the number of segments formed completely of s and is the length of th segment No two segments touch or intersect For example If and the crossword is then its encoding is an array If and the crossword is then its encoding is an array If and the crossword is then its encoding is an array If and the crossword is then its encoding is an empty array Mishka wants to create a new one dimensional Japanese crossword He has already picked the length and the encoding for this crossword And now he needs to check if there is crossword such that its length and encoding are equal to the length and encoding he picked Help him to check it ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "The only answer is when no segment can be moved one cell either to the left or to the right So there should be exactly one cell between two consecutive segments and the first and the last segments should touch the borders Thus total count of cells needed is Overall complexity "}
{"statement": "Polycarp has found a table having an infinite number of rows and columns The rows are numbered from 1 starting from the topmost one The columns are numbered from 1 starting from the leftmost one Initially the table hasn t been filled and Polycarp wants to fix it He writes integers from 1 and so on to the table as follows The leftmost topmost cell of the table is filled with the number 1 Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm First Polycarp selects the leftmost non filled cell in the first row and fills it Then while the left neighbor of the last filled cell is filled he goes down and fills the next cell So he goes down until the last filled cell has a non filled neighbor to the left look at the vertical arrow going down in the figure above After that he fills the cells from the right to the left until he stops at the first column look at the horizontal row in the figure above Then Polycarp selects the leftmost non filled cell in the first row goes down and so on A friend of Polycarp has a favorite number k He wants to know which cell will contain the number Help him to find the indices of the row and the column such that the intersection of the row and the column is the cell containing the number k ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s call a set of cells being filled from the topmost row to the leftmost column a E g the st layer consists of the single number the nd layer consists of the numbers and the rd layer consists of the numbers and etc The number of cells in layers forms an arithmetic progression The first layer consists of cells the th layer consists of cells The minimum number in the th layer is equal to the sum of sizes of all layers from the st to the th plus Suppose that belongs to the th layer Consider the value of Polycarp fills exactly cells on the th layer before he starts filling the cells from the right to the left i e while he goes down Therefore if the number belongs to the th row and the th column Otherwise the number belongs to the th row and the th column Consider a way to find the coordinates of a given number Let s iterate by the layer number to which given the number belongs calculating the values of and going to the next layer let s calculate the next layer parameters as follows The iteration must be stopped if the layer number is such that Using the values of and we can calculate the given number s coordinates in the described way in The total time of calculating the coodrinates for one given is where is the number of the layer to which the given belongs Let s represent the value of as hence Therefore the coordinates of one number may be calculated in At the same time as it follows from the formulas the layer number can be calculated as follows the square root of rounded up To avoid accuracy problems you can calculate the value using a loop "}
{"statement": "A word or a sentence in some language is called a if all the characters of the alphabet of this language appear in it Pangrams are often used to demonstrate fonts in printing or test the output devices You are given a string consisting of lowercase and uppercase Latin letters Check whether this string is a pangram We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "To check that every letter is present in the string we can just make a boolean array of size 26 and for every letter set the corresponding variable to TRUE In the end check that there are 26 TRUEs That is an O n solution Also don t forget to change all letters to lowercase or all to uppercase To make all the letters lowercase one could use standard functions like tolower in Python Also it is known that the letters from a to z have consecutive ASCII numbers as well as A to Z an ASCII number of symbol is ord c in most languages So to get the number of a lowercase letter in the alphabet one can use ord c ord a in most languages or simply c a in C or C because a char in C C can be treated as a number to check if a letter is lowercase the inequality ord a ord c ord c ord z should be checked Challenge how many pangrams of length n are there Strings that differ only in capitalization of some letters are considered distinct Can you find the answer modulo some prime p in linear time "}
{"statement": "Door s family is going celebrate Famil Doors s birthday party They love Famil Door so they are planning to make his birthday cake weird The cake is a square consisting of equal squares with side length Each square is either empty or consists of a single chocolate They bought the cake and randomly started to put the chocolates on the cake The value of Famil Door s happiness will be equal to the number of pairs of cells with chocolates that are in the same row or in the same column of the cake Famil Doors s family is wondering what is the amount of happiness of Famil going to be Please note that any pair can be counted no more than once as two different cells can t share both the same row and the same column ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Consider that we have chocolates in the row and chocolates in the column The answer to the problem would be It is obvious that every pair would be calculated exactly once as we have no more than one chocolate in the same square Time Complexity C Solution "}
{"statement": "Happy PMP is freshman and he is learning about algorithmic problems He enjoys playing algorithmic games a lot One of the seniors gave Happy PMP a nice game He is given two permutations of numbers through and is asked to convert the first one to the second In one move he can remove the last number from the permutation of numbers and inserts it back in an arbitrary position He can either insert last number between any two consecutive numbers or he can place it at the beginning of the permutation Happy PMP has an algorithm that solves the problem But it is not fast enough He wants to know the minimum number of moves to convert the first permutation to the second ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "It is easy to see that if we replace each number in the first permutation with position of that number in the second permutation the problem reduces to sorting the first permutation Each time we take a number from the end of array we can postpone its insertion until we know the most suitable position for insertion Note that it is not good to insert a number and take it again as we could make a better decision first time we took the number So as long as the remainder of the array is not in increasing order we should take more numbers from the end But as soon as you have an increasing subsequence you can insert the numbers you have taken to make the array sorted Therefore to solve the problem we find the largest i such the numbers from 1 to i are in increasing order The answer would be n i "}
{"statement": "You are given an array a of n integers and a set B of m positive integers such that 1 leq b i leq lfloor frac n 2 rfloor for 1 le i le m where b i is the i th element of B You can make the following operation on a Select some x such that x appears in B Select an interval from array a of size x and multiply by 1 every element in the interval Formally select l and r such that 1 leq l leq r leq n and r l 1 x then assign a i a i for every i such that l leq i leq r Consider the following example let a 0 6 2 1 4 5 and B 1 2 0 6 2 1 4 5 is obtained after choosing size 2 and l 4 r 5 0 6 2 1 4 5 is obtained after choosing size 1 and l 3 r 3 Find the maximum sum limits i 1 n a i you can get after applying such operation any number of times possibly zero ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Solution If we have assume since all elements of are at most it is possible to multiply all intervals of size by either multiplying an interval of size that starts at the position of the interval of size and an interval of size that ends at the same position as the interval or multiply an interval of size that ends at the same position as the interval of size and another interval of size that starts at the same position as the interval of size For two elements it is possible to add to repeatedly doing this it is possible to get Let by applying the previous reduction is the smallest element that can be obtained and all other elements will be its multiples then the problem is reduced to multiplying intervals of size by any number of times maximize Let s define the string of size 0 indexed such that if the th element is not multiplied by or otherwise The operation flips all values of in a substring of size Let s define as the xor over all values such that note that is defined for the values In any operation all values of change simultaneously since they are all at the beginning only the states of such that all are equal are reachable To prove that all states of with all equal are reachable let s start with any state of such that and repeatedly select the rightmost such that and and flip the substring that ends in that position after doing that as many times as possible for If for any then which is a contradiction since and all change simultaneously then The case with all values of equal to is similar After this it is possible to solve the problem with Let be the maximum sum of such that and and be the same such that The answer to the problem is 0 indexed This can be computed in Code "}
{"statement": "Rick and Morty are playing their own version of Berzerk which has nothing in common with the famous Berzerk game This game needs a huge space so they play it with a computer In this game there are objects numbered from to arranged in a circle in clockwise order Object number is a black hole and the others are planets There s a monster in one of the planet Rick and Morty don t know on which one yet only that he s not initially in the black hole but Unity will inform them before the game starts But for now they want to be prepared for every possible scenario Each one of them has a set of numbers between and inclusive Rick s set is with elements and Morty s is with elements One of them goes first and the player changes alternatively In each player s turn he should choose an arbitrary number like from his set and the monster will move to his th next object from its current position clockwise If after his move the monster gets to the black hole he wins Your task is that for each of monster s initial positions and who plays first determine if the starter wins loses or the game will stuck in an infinite loop In case when player can lose or make game infinity it more profitable to choose infinity game ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "For each state of monster possible states the position and whose turn it is we will determine if it will be won lost or stuck in loop the player whose turn it is will win lose or the game will never end if this state happens For this purpose first each state with monster on is lost Then if we consider a graph that its vertices are our states we will recursively determine the answer for each vertex If a state has an edge to a lost state it s won and if all its edges are to won states it s lost The vertices that are neither lost or won at the end have answer loop You can implement this using a simple memoize Time complexity "}
{"statement": "Jayden has an array a which is initially empty There are n operations of two types he must perform in the given order Jayden appends an integer x 1 leq x leq n to the end of array a Jayden appends x copies of array a to the end of array a In other words array a becomes a underbrace a ldots a x It is guaranteed that he has done at least one operation of the first type before this Jayden has q queries For each query you must tell him the k th element of array a The elements of the array are numbered from 1 ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "First let s precalculate some things lsti last element after performing the first i operations dpi number of elements after the first i operations Now let s try answering some query k If we have some dpi k then the answer is lsti Otherwise let s find the first i such that dpi k This i will be a repeat operation and our answer will lie within one of the repetitions Our list at this point will look like l1 l2 ldpi 1 length dpi 1 l1 l2 ldpi 1 length dpi 1 l1 l2 ldpi 1 length dpi 1 l1 l 2 ldpi 1 length dpi 1 Let the k th element be the bolded l2 of the final repetition As you can see finding the k the element is equivalent to finding the kmoddpi 1 th element Thus we should do k kmoddpi 1 and repeat But there is one more case If k 0 moddpi 1 then the answer is lsti 1 "}
{"statement": "There is a vending machine that sells lemonade The machine has a total of n slots You know that initially the i th slot contains a i cans of lemonade There are also n buttons on the machine each button corresponds to a slot with exactly one button corresponding to each slot Unfortunately the labels on the buttons have worn off so you which button corresponds to which slot When you press the button corresponding to the i th slot one of two events occurs If there is a can of lemonade in the i th slot it will drop out and you will take it At this point the number of cans in the i th slot decreases by 1 If there are no cans of lemonade left in the i th slot nothing will drop out After pressing the can drops out so quickly that it is impossible to track from which slot it fell The contents of the slots are hidden from your view so you cannot see how many cans are left in each slot The only thing you know is the initial number of cans in the slots a 1 a 2 ldots a n Determine the minimum number of button presses needed to guarantee that you receive at least k cans of lemonade Note that you can adapt your strategy during the button presses based on whether you received a can or not It is guaranteed that there are at least k cans of lemonade in total in the machine In other words k leq a 1 a 2 ldots a n ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s make a few simple observations about the optimal strategy of actions First if after pressing a certain button no cans have been obtained there is no point in pressing that button again Second among the buttons that have not yet resulted in a failure it is always advantageous to press the button that has been pressed the least number of times This can be loosely justified by the fact that the fewer times a button has been pressed the greater the chance that the next press will be successful as we have no other information to distinguish these buttons from one another From this our strategy clearly emerges let s sort the array let In the first action we will press all buttons times It is clear that all these presses will yield cans and in total we will collect cans If no further presses are needed However if we need to make at least one more press Since all buttons are still indistinguishable to us it may happen that this press will be made on the button corresponding to and will be unsuccessful Next we will press all remaining buttons times these presses will also be guaranteed to be successful After that again if does not exceed the number of cans already collected we finish otherwise we need to make at least one more press which may hit an empty cell And so on In total the answer to the problem will be where is the smallest number from to such that the following holds here we consider "}
{"statement": "Alice and Bob are playing a game They have a tree consisting of n vertices Initially Bob has k chips the i th chip is located in the vertex a i all these vertices are unique Before the game starts Alice will place a chip into one of the vertices of the tree The game consists of turns Each turn the following events happen sequentially exactly in the following order Alice either moves her chip to an adjacent vertex or doesn t move it for each Bob s chip he either moves it to an adjacent vertex or doesn t move it Note that this choice is done independently for each chip The game ends when Alice s chip shares the same vertex with one or multiple of Bob s chips Note that Bob s chips may share the same vertex even though they are in different vertices at the beginning of the game Alice wants to maximize the number of turns Bob wants to minimize it If the game ends in the middle of some turn Alice moves her chip to a vertex that contains one or multiple Bob s chips this turn is counted For each vertex calculate the number of turns the game will last if Alice places her chip in that vertex ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "This task was inspired by an older edu task and another task proposed by RockyB Let s learn to solve the problem for at least one starting vertex for Alice Let this vertex be In general Alice s strategy is basically this run to some vertex as fast as possible and stay in it until Bob reaches Hesitation on a way to this vertex won t be optimal Visiting the same vertex multiple times won t as well I guess that can be proven more formally by analyzing the set of possible solutions after each move What properties should vertex have for Alice to be able to escape to it There shouldn t be a way for Bob to catch her midway However it s not necessary to check any midway intersections If Bob can catch her anywhere on a path she can also follow her to the end by moving the same path and catch her at the destination Thus this vertex should be further from any Bob s chips than from So you can precalculate the distance to the closest Bob s chip to each vertex Just push all chips to a queue and run a bfs We ve learned to solve the problem in for each vertex Just iterate over all vertices and take the maximum of over such of them that have greater than the distance from to Now the solution can go two ways You can stop thinking here and obtain an one or think more and get an The first one goes like that Notice that the function if the Alice can make at least moves from vertex is monotonous in regard to So we can binary search the answer The check query transforms to the following Consider all vertices with distance less or equal to from There should exist at least one vertex with value for the check to return true So at least the maximum value of them should be greater than That is basically a centroid exercise Let each centroid store such an array that is the maximum value of over all such that belong to this centroid s subgraph and are no further than distance from the centroid That array can be constructed in for all centroids in total You can easily see that the length of this array doesn t exceed the number of vertices in the subgraph of the corresponding centroid that is be definition For the query iterate over all centroids belongs to and check the value from some cell of each one s array For the second solution let s reverse the problem Consider the vertex Alice escapes to If there is a starting vertex no further than from it then the answer for can be updated with So we can update the subgraph of vertices with distance no more than with the maximum of their current answer and The solution will be almost the same centroid Iterate over all centroids belongs to and write into the cell of each one s array where is the distance from to this centroid Then build an array of prefix maximums over this array Finally for each collect the best answer over all centroids belongs to Overall complexity or "}
{"statement": "The Finals of the Russian Code Cup 2214 will be held in hotels Two hotels let s assume that they are the main hotels will host all sorts of events and the remaining hotels will accommodate the participants The hotels are connected by roads you can get from any hotel to any other one The organizers wonder what is the minimum time all the participants need to get to the main hotels if each participant goes to the main hotel that is nearest to him and moving between two hotels connected by a road takes one unit of time The hosts consider various options for the location of the main hotels For each option help the organizers to find minimal time ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2800", "problem_editorial": "This problem has two solutions The first one Let s hang the tree on some vertex Afterwards let us calculate for eah vertex it s height and most distant vertices in its subtree Also let s calculate arrays for the lowest common ancestors problem For each vertex and the power of two we have and And the last part of this solution Let us be given the query Firstly we find Afterwards we need to find vertex which is situated on the middle of the path between and Really we need to split the tree by this vertex count the longest path from in its tree and count the longest path from in its tree If we can imagine in the main tree we can not delete this vertex but with our precalculated arrays recalc this two values First solution 6396376 The second solution In a few words Let s find the diameter of the tree Precalc the answer for each vertices on the prefix Then on the query we find two distant vertices on this diameter and the path Obviously diameter should contain the middle of the path when we find it using precalculated results on the prefixes and suffixes we can obtain the answer Second solution cerealguy 6396390 "}
{"statement": "A contest contains n problems and the difficulty of the i th problem is expected to be b i There are already n problem proposals and the difficulty of the i th problem is a i Initially both a 1 a 2 ldots a n and b 1 b 2 ldots b n are sorted in non decreasing order Some of the problems may be more difficult than expected so the writers must propose more problems When a new problem with difficulty w is proposed the most difficult problem will be deleted from the contest and the problems will be sorted in a way that the difficulties are non decreasing In other words in each operation you choose an integer w insert it into the array a sort array a in non decreasing order and remove the last element from it Find the minimum number of new problems to make a i le b i for all i ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Enumerate through the array if at some index then propose a problem with difficulty Time complexity for each test case It can also be solved in if we record the problems we ve added "}
{"statement": "After completing the last level of the enchanted temple you received a powerful artifact of the 255th level Do not rush to celebrate because this artifact has a powerful rune that can be destroyed with a single s which you are going to find We define the spell as some consisting only of the letters and At any time you can cast an arbitrary non empty spell t and the rune on the artifact will begin to resist of the rune is the edit distance between the strings that specify the casted spell t and the rune destroying spell s Edit distance of two strings s and t is a value equal to the minimum number of one character operations of replacing inserting and deleting characters in s to get t For example the distance between and is 2 the distance between and is 1 the distance between and is 3 The edit distance is 0 if and only if the strings are equal It is also worth considering that the artifact has a resistance limit if you cast more than n 2 spells where n is the length of spell s the rune will be blocked Thus it takes n 2 or fewer spells to destroy the rune that is on your artifact Keep in mind that the required destructive spell s must also be counted among these n 2 spells Note that the length n of the rune destroying spell s is not known to you in advance It is only known that its length n does not exceed 300 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Firstly let s find out the number of letters and in the hidden string in two queries This can be done for example using queries and of length Let the answers to these queries be and then the number of letters and would be and respectively These answers are explained by the fact that i e for string it takes steps to remove the letters at the end of the string and then replace letters with to change the string into the string Now we know the length Consider an arbitrary string of length and let the answer to its query be Then if we replace the letter with the opposite one from to or from to then we may have one of two situations decreased by then the letter after the change coincides with the letter otherwise the letter before the change matches the letter Thus you can loop from left to right and for each position find out the character starting for example from the string of length The current algorithm guesses the string in queries In order to get rid of one unnecessary query note that we do not need to make a query to find out the character in the last position If the number of letters whose location we know is equal to then the last character cannot be which means it is Similarly for the symmetric case Thus we can guess the string in queries Similarly it is possible to solve for an arbitrary alphabet in queries where is the size of the alphabet For an arbitrary alphabet there is also a solution using random which solves the problem on average in queries but it will not work in this task since the chance to spend more than queries is quite large "}
{"statement": "You have a rooted tree consisting of vertices Each vertex of the tree has some color We will assume that the tree vertices are numbered by integers from 1 to Then we represent the color of vertex as The tree root is a vertex with number 1 In this problem you need to answer to queries Each query is described by two integers The answer to query is the number of such colors of vertices that the subtree of vertex contains at least vertices of color You can find the definition of a rooted tree by the following link ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Use binary search tree and merge them by rank Use binary search tree that supports O n merging to get O nlogn solution O n sqrt n Dfs the tree to transform the problem to To solve this problem "}
{"statement": "You are playing your favorite rhythm game osu mania The layout of your beatmap consists of n rows and 4 columns Because notes at the bottom are closer you will process the bottommost row first and the topmost row last Each row will contain exactly one note represented as a For each note 1 2 dots n in the order of processing output the column in which the note appears ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Problem Credits cry Analysis cry Solution Implement the statement Iterate from to and use the find method in std string in C or index in python to find the character "}
{"statement": "Alice received a set of Toy Train from Bob It consists of one train and a connected railway network of n stations enumerated from 1 through n The train occupies one station at a time and travels around the network of stations in a circular manner More precisely the immediate station that the train will visit after station i is station i 1 if 1 leq i n or station 1 if i n It takes the train 1 second to travel to its next station as described Bob gave Alice a fun task before he left to deliver m candies that are initially at some stations to their independent destinations using the train The candies are enumerated from 1 through m Candy i 1 leq i leq m now at station a i should be delivered to station b i a i neq b i The train has infinite capacity and it is possible to load off any number of candies at a station However only candy can be loaded from a station onto the train before it leaves the station You can choose any candy at this station The time it takes to move the candies is negligible Now Alice wonders how much time is needed for the train to deliver all candies Your task is to find for each station the minimum time the train would need to deliver all the candies were it to start from there ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "We can consider the pickup requests from each station individually The overall answer for some fixed starting station is simply the maximum time needed to fulfill deliveries among all pickup stations Suppose the starting station for the train is fixed at some station s 1 s n Consider some station i 1 i n Let out i denote the number of candies that need to be picked up from station i If out i 0 we do not consider this station From now on we assume out i 1 Each time that the train visits station i to pick up a candy we can choose which candy it should pick up Therefore we should find an order that would minimize the time needed to fulfill all deliveries from pickup station i It turns out however that the only thing that matters is the last candy to be delivered Suppose the last candy is to be delivered to station e the total time needed to fulfill all pickup requests from station i would be dist s i n out i 1 dist i e where dist a b represents the time needed to travel from station a to station b Take some time to think why this is the case With this formulated it is now clear that we have to choose the last candy to deliver that minimizes dist i e All of this can be done in O n with an O n m pre process only once to find the optimal last candy for each pickup station To find the answer for every starting station for the train we can simply run the above algorithm n times The time complexity is O n2 m "}
{"statement": "Manao is taking part in a quiz The quiz consists of consecutive questions A correct answer gives one point to the player The game also has a counter of consecutive correct answers When the player answers a question correctly the number on this counter increases by 1 If the player answers a question incorrectly the counter is reset that is the number on it reduces to 0 If after an answer the counter reaches the number then it is reset and the player s score is doubled Note that in this case first 1 point is added to the player s score and then the total score is doubled At the beginning of the game both the player s score and the counter of consecutive correct answers are set to zero Manao remembers that he has answered exactly questions correctly But he does not remember the order in which the questions came He s trying to figure out what his minimum score may be Help him and compute the remainder of the corresponding number after division by ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Assume that Manao has doubled his score i e gave k consecutive correct answers exactly X times Then the least possible score is obtained when this doublings happen in the beginning of the game i e when he answers the first X k questions and never manages to answer k consecutive questions after that The correctness of this statement follows from the following for any other scenario with X doublings all of these doublings can be moved into the beginning and the total score will not increase Hence for X 1 Manao s minimum score is k 2 m k he answers k consecutive questions the score doubles then he answers m k questions For X 2 the minimum possible score is k 2 k 2 m 2 k for X 3 k 2 k 2 k 2 m 3 k For the general case a formula 2 1 2 2 2 X k m X k 2 X 1 2 k m X k is derived The abovementioned observation shows that the minimum score grows monotonically when X is increased so all we need is to find the minimum feasible X It should satisfy the inequalities X k n and X n n mod k k k 1 n mod k m More on the second inequality Manao answered the first X k questions thus there are n X k left Now he can answer at most k 1 question from each k questions If k divides n X k which is the same as k divides n the inequality becomes X k n X k k k 1 m but the remainder complicates it a bit X k n X k n X k mod k k k 1 n X k mod k m This formula can be simplified to the one written earlier So the minimum X is equal to max 0 m n n mod k k k 1 n mod k You ll need exponentiation by squaring to compute the score corresponding to this value of X Thus the overall complexity of this solution is O log n "}
{"statement": "Little Vasya went to the supermarket to get some groceries He walked about the supermarket for a long time and got a basket full of products Now he needs to choose the cashier to pay for the products There are cashiers at the exit from the supermarket At the moment the queue for the th cashier already has people The th person standing in the queue to the th cashier has items in the basket Vasya knows that the cashier needs 5 seconds to scan one item after the cashier scans each item of some customer he needs 15 seconds to take the customer s money and give him the change Of course Vasya wants to select a queue so that he can leave the supermarket as soon as possible Help him write a program that displays the minimum number of seconds after which Vasya can get to one of the cashiers ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "In this problem you were to find waiting the time for every queue by summing up the purchases of all the people and return the minimum "}
{"statement": "Alice got tired of playing the tag game by the usual rules so she offered Bob a little modification to it Now the game should be played on an undirected rooted tree of vertices Vertex is the root of the tree Alice starts at vertex and Bob starts at vertex The moves are made in turns Bob goes first In one move one can either stay at the current vertex or travel to the neighbouring one The game ends when Alice goes to the same vertex where Bob is standing Alice wants to minimize the total number of moves and Bob wants to maximize it You should write a program which will determine how many moves will the game last ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1700", "problem_editorial": "If you check some games then you will notice that the most optimal strategy for Bob is always like this Climb up for some steps possibly zero Go to the lowest vertex from it Stay in this vertex till the end Thus let s precalc the depth the distance from the root of the lowest vertex of each subtree using dfs distance from Alice s starting node and from Bob s starting node to the vertex again dfs bfs Now iterate over all vertices and check if Bob can reach this vertex earlier than Alice If he can then update the answer with the lowest vertex that can be reached from this one The answer is doubled depth of the obtained lowest reachable vertex That is the time which will take Alice to get there Overall complexity "}
{"statement": "Given an integer n Consider all pairs of integer arrays a and p of the same length such that n prod a i p i i e a 1 p 1 cdot a 2 p 2 cdot ldots a i 1 p i 0 and a i is the product of some possibly one prime numbers For example for n 28 2 2 cdot 7 1 4 1 cdot 7 1 the array pair a 2 7 p 2 1 is correct but the pair of arrays a 4 7 p 1 1 is not because 4 2 2 is a product of non distinct prime numbers Your task is to find the maximum value of sum a i cdot p i i e a 1 cdot p 1 a 2 cdot p 2 ldots over all possible pairs of arrays a and p Note that you do not need to minimize or maximize the length of the arrays ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "First is equivalent to the product of for times so it is sufficient to set all to Decomposite to some prime factors greedily choose the most number of distinct prime numbers the product is the maximum "}
{"statement": "You are given an array a 1 a 2 dots a n and two integers m and k You can choose some subarray a l a l 1 dots a r 1 a r The cost of subarray a l a l 1 dots a r 1 a r is equal to sum limits i l r a i k lceil frac r l 1 m rceil where lceil x rceil is the least integer greater than or equal to x For example if m 3 k 10 and a 2 4 15 3 4 8 3 then the cost of some subarrays are a 3 dots a 3 15 k lceil frac 1 3 rceil 15 10 5 a 3 dots a 4 15 3 k lceil frac 2 3 rceil 12 10 2 a 3 dots a 5 15 3 4 k lceil frac 3 3 rceil 16 10 6 a 3 dots a 6 15 3 4 8 k lceil frac 4 3 rceil 24 20 4 a 3 dots a 7 15 3 4 8 3 k lceil frac 5 3 rceil 27 20 7 Your task is to find the maximum cost of some subarray possibly empty of array a ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "At first let s solve this problem when and it is the problem of finding subarray with maximum sum For each position from to we want to know the value of where and We will calculate it the following way will be the maximum of two values because we can take segments of length The maximum sum of some subarray is equal to So now we can calculate the values of the same way is the maximum of two values 0 After calculating all values we can easily solve this problem At first let s iterate over the elements When we fix some element lets iterate over the value and update the answer with value "}
{"statement": "A well known art union called Kalevich is Alive manufactures objects d art pictures The union consists of painters who decided to organize their work as follows Each painter uses only the color that was assigned to him The colors are distinct for all painters Let s assume that the first painter uses color 1 the second one uses color 2 and so on Each picture will contain all these colors Adding the th color to the th picture takes the th painter units of time Order is important everywhere so the painters work is ordered by the following rules Each picture is first painted by the first painter then by the second one and so on That is after the th painter finishes working on the picture it must go to the th painter if each painter works on the pictures in some order first he paints the first picture then he paints the second picture and so on each painter can simultaneously work on at most one picture However the painters don t need any time to have a rest as soon as the th painter finishes his part of working on the picture the picture immediately becomes available to the next painter Given that the painters start working at time 0 find for each picture the time when it is ready for sale ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "All we need is to iterate over all painters and for each painter to iterate over all pictures In the inner loop we also remember when the painter finished working on the picture to make sure that the next painter will not start working on it earlier Submission 6606994 "}
{"statement": "There are n left boots and n right boots Each boot has a color which is denoted as a lowercase Latin letter or a question mark Thus you are given two strings l and r both of length n The character l i stands for the color of the i th left boot and the character r i stands for the color of the i th right boot A lowercase Latin letter denotes a specific color but the question mark denotes an indefinite color Two specific colors are if they are exactly the same An indefinite color is with any specific or indefinite color For example the following pairs of colors are compatible and The following pairs of colors are compatible and Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible Print the maximum number of such pairs and the pairs themselves A boot can be part of at most one pair ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Use greedy approach in this problem At first match such pairs that colors are exactly the same and they are specific not indefinite After it match each indefinite colored left boot if any with any specific colored right boot Possibly some indefinite colored left boots stay unmatched Similarly match each indefinite colored right boot if any with any specific colored left boot And finally match indefinite colored left and right boots if any "}
{"statement": "Andrewid the Android is a galaxy famous detective He is now investigating the case of vandalism at the exhibition of contemporary art The main exhibit is a construction of matryoshka dolls that can be nested one into another The matryoshka dolls are numbered from to A matryoshka with a smaller number can be nested in a matryoshka with a higher number two matryoshkas can not be directly nested in the same doll but there may be chain nestings for example In one second you can perform one of the two following operations Having a matryoshka that isn t nested in any other matryoshka and a matryoshka such that doesn t contain any other matryoshka and is not nested in any other matryoshka you may put in Having a matryoshka directly contained in matryoshka such that is not nested in any other matryoshka you may get out of According to the modern aesthetic norms the matryoshka dolls on display were assembled in a specific configuration i e as several separate chains of nested matryoshkas but the criminal following the mysterious plan took out all the dolls and assembled them into a single large chain In order to continue the investigation Andrewid needs to know in what minimum time it is possible to perform this action ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Suppose we don t need to disassemble some sequence of dolls Then no doll can be inserted into no doll from this chain So we don t need to disassemble a sequence of dolls only if they are consecutive and start from Let the length of this chain be Then we will need to get one doll from another times Now we have a sequence and all other dolls by themselves chains in total so we need to put one doll into another times operations in total Time solution "}
{"statement": "Fox Ciel and her friends are in a dancing room There are boys and girls here and they never danced before There will be some songs during each song there must be exactly one boy and one girl are dancing Besides there is a special rule either the boy in the dancing pair must dance for the first time so he didn t dance with anyone before or the girl in the dancing pair must dance for the first time Help Fox Ciel to make a schedule that they can dance as many songs as possible ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Let s define remainNew of people haven t danced before So at beginning remainNew n m and we have And it s not hard to construct one schedule get this maximal possible answer "}
{"statement": "A programming coach has students to teach We know that is divisible by Let s assume that all students are numbered from to inclusive Before the university programming championship the coach wants to split all students into groups of three For some pairs of students we know that they want to be on the same team Besides if the th student wants to be on the same team with the th one then the th student wants to be on the same team with the th one The coach wants the teams to show good results so he wants the following condition to hold if the th student wants to be on the same team with the th then the th and the th students must be on the same team Also it is obvious that each student must be on exactly one team Help the coach and divide the teams the way he wants ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1500", "problem_editorial": "Input data represents a graph If there is a connected component with at least vertexes then answer is Every connected component with vertexes is a complete team Other teams are made from or vertex components If amount of vertex components is greater than vertex answer is Otherwise match vertex components with vertex If there are some vertex components left then split them into groups of three This algorithm works in Also you could implement solution uthor s solution "}
{"statement": "Twilight Sparkle learnt that the evil Nightmare Moon would return during the upcoming Summer Sun Celebration after one thousand years of imprisonment on the moon She tried to warn her mentor Princess Celestia but the princess ignored her and sent her to Ponyville to check on the preparations for the celebration Twilight Sparkle wanted to track the path of Nightmare Moon Unfortunately she didn t know the exact path What she knew is the parity of the number of times that each place Nightmare Moon visited Can you help Twilight Sparkle to restore any path that is consistent with this information Ponyville can be represented as an undirected graph vertices are places edges are roads between places without self loops and multi edges The path can start and end at any place also it can be empty Each place can be visited multiple times The path must not visit more than places ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2200", "problem_editorial": "Brief description Given a undirected graph with n nodes and the parity of the number of times that each place is visited Construct a consistent path Analysis There is no solution if there is more than 1 connected component which have odd node because we can t move between two component otherwise it is always solvable This fact is not obvious let s focus on one component You can select any node to start denoted it as r root Start from r you can go to any other odd node then back Each time you can eliminate one odd node After that if r itself is odd you can simply delete the first or last element in your path it must be r The only spot of the above method is the size of the path can been large as O n2 We need a more local observation Let s check the following dfs function This dfs maintain the following loop invariant before we leave a node u we clear all odd node in the sub tree rooted at u as well as u itself The only u can break the invariant is the root itself So after dfs we use O 1 time to check weather root is still a odd node if yes delete the first or last element of the path it must be r After that all the node will been clear each node can involve at most 4 items in the path So the size of the path will less than or equal to 4n Thus the overall complexity is O n m "}
{"statement": "is an array of positive integers all of which are not greater than You have to process queries to this array Each query is represented by two numbers and Several operations are performed in each query each operation changes to There operations are applied until becomes greater than The answer to the query is the number of performed operations ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "There are two possible solutions in time First of them answers each query using simple iteration changes to for each query until becomes greater than as stated in the problem But it is too slow Second solution precalculates answers for each and if then else But this uses memory and can be done in time Now we can notice that if then second solution will use only time and memory and if then first solution will do not more than operations on each query So we can combine these two solutions Time complexity "}
{"statement": "John Doe started thinking about graphs After some thought he decided that he wants to paint an undirected graph containing exactly cycles of length A cycle of length is an unordered group of three distinct graph vertices and such that each pair of them is connected by a graph edge John has been painting for long but he has not been a success Help him find such graph Note that the number of vertices there shouldn t exceed or else John will have problems painting it ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 1, "problem_dificulty": "1600", "problem_editorial": "Let s add edge in order of increasing a and for equal b in order of increasing b here a and b the least and the greatest vertices of the edge If the new edge adds too much 3 cycles we won t add it We can count the number of new 3 cycles in O n complexity they all contain the new edge so it s enough to check all variants of the third vertex Obviously we will obtain some proper graph because we can always add a vertex and two edges to make a new triangle So there is always an answer The complexity of this solution is O n3 Let s proof that 100 vertices are always enough for the given restrictions on n For some p after first p iterations we will have a complete graph of p vertices Now we have exactly C p 3 triangles Consider p such that C p 3 k and C p 3 is maximal For the given restrictions p 85 From this moment if we add u from some vertex we increase the total number of 3 cycles on C u 2 So we have to present a small number that is less than C 85 3 as sum of C i 2 The first number we subtruct will differ C 85 1 on some value not greater than C 85 1 85 because C n k C n 1 k C n 1 k 1 The second number we subtruct will differ the number we have on some value not greater than C 14 1 14 and so on For every k it s enough to use not more that 90 vertices "}
{"statement": "Pak Chanek a renowned scholar invented a card puzzle using his knowledge In the puzzle you are given a board with n rows and m columns Let r c represent the cell in the r th row and the c th column Initially there are k cards stacked in cell 1 1 Each card has an integer from 1 to k written on it More specifically the i th card of the stack in cell 1 1 has the number a i written on it It is known that no two cards have the same number written on them In other words the numbers written on the cards are a permutation of integers from 1 to k All other cells are empty You need to move the k cards to cell n m to create another stack of cards Let b i be the number written on the i th card of the stack in cell n m You should create the stack in cell n m in such a way so that b i i for all 1 leq i leq k In one move you can remove the from a cell and place it onto an adjacent cell a cell that shares a common side If the target cell already contains one or more cards you place your card You must do each operation while satisfying the following restrictions Each cell other than 1 1 and n m must not have more than one card on it You cannot move a card onto cell 1 1 You cannot move a card from cell n m Given the values of n m k and the array a determine if the puzzle is solvable ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Let card be the card with number written on it Notice that we must put the cards into the stack in in order from card card card and so on until card The key observation for this problem is that under given constraints if we ignore cells and we can always move any card to either or if and only if there is at least one empty cell We can obtain this by considering the fact that an empty cell can move to any cell and can be used to rotate any square of cells Because if we ignore cells and each cell is a part of a square Moving a desired card to a one of or can be done by firstly moving the empty cell to be adjacent to the desired card and then only doing rotations that simultaneously move the empty cell and the desired card Therefore we can iterate the card in the stack from top to bottom While iterating one should maintain all of the cards in the board that are not in cell or We define those group of cards as active cards Each time we put a move a card out of we add the card to the active cards Before finishing the iteration we will try to move one or more cards from the active cards to as long as there is a card we can move We can maintain the active cards with a priority queue or a set The active cards can be moved around freely if and only if there is at least one empty cell in the grid if we ignore and Therefore to check whether or not we can solve the puzzle we just need to check whether or not there exists a moment where the number of active cards exceed There also exists a solution with a time complexity of just by iterating the positions of each card number but it will not be explained here Time complexity for each test case or "}
{"statement": "There are n football teams in the world The Main Football Organization MFO wants to host at most m games MFO wants the i th game to be played between the teams a i and b i in one of the k stadiums Let s ij be the numbers of games the i th team played in the j th stadium MFO does not want a team to have much more games in one stadium than in the others Therefore for each team i the absolute difference between the maximum and minimum among s i1 s i2 ldots s ik should not exceed 2 Each team has w i the amount of money MFO will earn for game of the i th team If the i th team plays l games MFO will earn w i cdot l MFO needs to find what games in what stadiums they need to host in order to earn as much money as possible not violating the rule they set However this problem is too complicated for MFO Therefore they are asking you to help them ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3100", "problem_editorial": "Let s assume that We can randomly assign colors to edges If there is a vertex that does not satisfy the condition then we can choose color which appears the smallest number of times and color which appears the biggest number of times We will recolor edges that have one of these two colors Let s consider this graph only with edges with colors and Let s add a fake vertex This graph may have many components If a component has at least one vertex with odd degree we connect each such vertex with Otherwise let s choose any vertex from that component and add edges to Therefore the graph will be connected and each vertex will have an even degree Thus we will be able to find an Euler cycle Let s color the odd edges in the cycle in and even edges in As a result the difference between these two colors for each vertex will be at most Let s do this operation while there is a vertex which does not satisfy the condition If let s split the edges into two groups with the equal sizes that is and If a group has not greater than edges then do the algorithm at the beginning of the tutorial Otherwise split it again If you found the answers for two groups you need to find the answer for the combined graph Let be the most popular color in the first group the second most popular color the least popular color in the first group Similarly let be the most popular color in the second graph etc So in the combined graph should be equal to should be equal to In other words we take the most popular color in the first group and color the least popular color in the second group with that color If there is a vertex that does not satisfy the condition recolor the graph according to the algorithm explained in the third paragraph "}
{"statement": "You are given an array Some element of this array is a iff it is strictly less than both of its neighbours that is and Also the element can be called iff it is strictly greater than its neighbours that is and Since and have only one neighbour each they are neither local minima nor local maxima An element is called a iff it is either local maximum or local minimum Your task is to calculate the number of local extrema in the given array ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Iterate over indices from to and check if at least one of given local extremum conditions holds Overall complexity "}
{"statement": "Johnny s younger sister Megan had a birthday recently Her brother has bought her a box signed as It contains many necklace parts and some magic glue The necklace part is a chain connecting two pearls Color of each pearl can be defined by a non negative integer The magic glue allows Megan to merge two pearls possibly from the same necklace part into one The beauty of a connection of pearls in colors u and v is defined as follows let 2 k be the greatest power of two dividing u oplus v exclusive or of u and v Then the beauty equals k If u v you may assume that beauty is equal to 20 Each pearl can be combined with another at most once Merging two parts of a necklace connects them Using the glue multiple times Megan can finally build the necklace which is a cycle made from connected necklace parts so every pearl in the necklace is combined with precisely one other pearl in it The beauty of such a necklace is the minimum beauty of a single connection in it The girl wants to use all available necklace parts to build necklace consisting of with the largest possible beauty Help her ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 1, "problem_dificulty": "2500", "problem_editorial": "Say that we want to check if it is possible to construct a necklace with beauty at least To this end we will construct a graph of vertices For a necklace part with pearls in colors and there will be an edge in this graph between vertices with zero based indices and In a necklace with beauty at least only pearl with colors having last bits the same can be glued together Note that this is the exact condition that the edge endpoints have to satisfy to be in the same vertex Since all the necklace parts have to be used a necklace of beauty at least is an Euler cycle of this graph The solution will construct the graph mentioned above for all possible values of we can iterate over all of them since there are only of them If the constructed graph is Eulerian it is possible to achieve the current value of In order to find a sample necklace with the optimal beauty one has to find the Euler cycle in the graph corresponding to the optimal value In another version of this task you are not allowed to glue pearls of the same color together There is also a guarantee that there are no three pearls of the same color Time complexity of the solution is the same "}
{"statement": "You are given a permutation a 1 a 2 ldots a n of integers from 0 to n 1 Your task is to find how many permutations b 1 b 2 ldots b n are to permutation a Two permutations a and b of size n are considered if for all intervals l r 1 le l le r le n the following condition is satisfied operatorname MEX a l a l 1 ldots a r operatorname MEX b l b l 1 ldots b r where the operatorname MEX of a collection of integers c 1 c 2 ldots c k is defined as the smallest non negative integer x which does not occur in collection c For example operatorname MEX 1 2 3 4 5 0 and operatorname MEX 0 1 2 4 5 3 Since the total number of such permutations can be very large you will have to print its remainder modulo 10 9 7 In this problem a permutation of size n is an array consisting of n distinct integers from 0 to n 1 in arbitrary order For example 1 0 2 4 3 is a permutation while 0 1 1 is not since 1 appears twice in the array 0 1 3 is also not a permutation since n 3 and there is a 3 in the array ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "SolutionLet be the position of in permutation Since the only possible position of in permutation is exactly Without loss of generality we will assume that For every interval must be at least For every other interval cannot exceed The only position for which satisfies both of these constraints is exactly Let s consider the current interval as being If we can say that for every interval must be at least Similarly for every other interval cannot exceed Both of these constraints are only met if occurs in permutation on some position Since only positions are currently occupied in the total number of similar permutations will be multiplied by Otherwise can be placed in permutation only on Additionally the current interval will be extended to include resuting in either or After processing and the algorithm for processing is very similar to the one presented earlier If the answer gets multiplied by Otherwise the current interval is extended to include Time complexity per testcase "}
{"statement": "Mahmoud wrote a message of length He wants to send it as a birthday present to his friend Moaz who likes strings He wrote it on a magical paper but he was surprised because some characters disappeared while writing the string That s because this magical paper doesn t allow character number in the English alphabet to be written on it in a string of length more than For example if he can t write character on this paper in a string of length or more String is allowed while string is not Mahmoud decided to split the message into some non empty substrings so that he can write every substring on an independent magical paper and fulfill the condition The sum of their lengths should be and they shouldn t overlap For example if and he wants to send string he can split it into and and use magical papers or into and and use magical papers He can t split it into and because the sum of their lengths is greater than He can split the message into single string if it fulfills the conditions A substring of string is a string that consists of some consecutive characters from string strings and are substrings of string while strings and are not Any string is a substring of itself While Mahmoud was thinking of how to split the message Ehab told him that there are many ways to split it After that Mahmoud asked you three questions How many ways are there to split the string into substrings such that every substring fulfills the condition of the magical paper the sum of their lengths is and they don t overlap Compute the answer modulo What is the maximum length of a substring that can appear in some valid splitting What is the minimum number of substrings the message can be spit in Two ways are considered different if the sets of split positions differ For example splitting and are considered different splittings of message ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let be the number of ways to split the prefix of ending at index into substrings that fulfills the conditions Let it be 1 indexed Our base case is Our answer is Now let s calculate it for every Let be the minimum possible index such that the substring from to satisfies the condition Let be a moving pointer At the beginning and it decreases Every time we decrease We calculate the new value of depending on the current character like that While is greater than or equal to we add to To find the longest substring Find maximum To find the minimum number of substrings there is an easy greedy solution Find the longest valid prefix and delete it and do the same again until the string is empty The number of times this operation is repeated is our answer Or see the dynamic programming solution in the code Code http pastebin com 4JiXSwfU Time complexity Try to find an solution I ll post a hard version of some problems on this blog soon Problem authors me and mahmoudbadawy Solution authors me and mahmoudbadawy Testers me and mahmoudbadawy "}
{"statement": "Amr bought a new video game Guess Your Way Out The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node Let s index all the leaf nodes from the left to the right from 1 to The exit is located at some node where the player doesn t know where the exit is so he has to guess his way out Amr follows simple algorithm to choose the path Let s consider infinite command string consisting of alternating characters and Amr sequentially executes the characters of the string using following rules Character means go to the left child of the current node Character means go to the right child of the current node If the destination node is already visited Amr skips current command otherwise he moves to the destination node If Amr skipped two consecutive commands he goes back to the parent of the current node before executing next command If he reached a leaf node that is not the exit he returns to the parent of the current node If he reaches an exit the game is finished Now Amr wonders if he follows this algorithm how many nodes he is going to visit before reaching the exit ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Hint Simulate the algorithm until we reach a leaf node assume that it s not the exit Now the question is Are there some nodes that are guaranteed to be visited before trying to reach the exit again Solution The first observation is that in order to return to a parent we will have to visit all nodes of the right or the left subtree of some node first Now imagine we are in the situation below where is the exit By applying the algorithm we ll reach node Both the and are in different subtrees of the root Which means before going to the proper subtree in which the Exit exists we ll have to visit all the nodes of the left subtree marked in red This means we have to get the node which the Exit and the current leaf node are in different subtrees which will be the least common ancestor LCA of the two nodes Assume the subtree height is This means we visited node By adding the nodes above the subtree which we visited during executing the string for the first time the total number of visited nodes will be Now let s go to the other subtree Obviously we don t need any other nodes except this subtree So let s do the same we did to the original tree to this subtree Execute the algorithm until we reach a leaf node get the LCA add to the solution where is the height of the subtree of the LCA node where the leaf node exists And so on we keep applying the rules until after executing the algorithm we will reach the exit Also we can do the same operations in by beginning to move from the root if the exit is located to the left we go to the left and ans and then set the next command to R else if it is located to the right we will visited the whole left subtree so we add the left subtree nodes to the answer and then set the next command to L and so on Time complexity or Challenge What if the pattern is given as an input e g LRRLLRRRLRLRLRR How can this problem be solved Implementation 9529181 "}
{"statement": "There is a fun game where you need to feed cats that come and go The level of the game consists of n steps There are m cats the cat i is present in steps from l i to r i inclusive In each step you can feed all the cats that are currently present or do nothing If you feed the same cat more than once it will overeat and you will immediately lose the game Your goal is to feed as many cats as possible without causing any cat to overeat Find the maximum number of cats you can feed Formally you need to select several integer points from the segment from 1 to n in such a way that among given segments none covers two or more of the selected points and as many segments as possible cover one of the selected points ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s use dynamic programming Let be the answer for the first moves Then there are two possible cases we fed the cats on step or not If we did not feed the cats on step then because this is the best result for the first moves and nothing has changed on this move If we fed the cats on step then we could not have fed the cats later than when the first of the present cats arrived because then it would overeat Using the structure we will find the step at which it arrived In this case we will feed all the present cats and can choose the best way to feed the cats for the first moves At each of the moves we will choose the best of the two options To maintain the with the moments of the cats arrivals we will add them at these moments in time and remove them at the departure moments for each we can store all that will leave at that moment "}
{"statement": "You are given a bracket sequence consisting of n characters and or You perform several operations with it During one operation you choose the prefix of this string some amount of first characters of the string that is and remove it from the string The prefix is considered if one of the following two conditions is satisfied this prefix is a regular bracket sequence this prefix is a palindrome of length A bracket sequence is called regular if it is possible to obtain a correct arithmetic expression by inserting characters and into this sequence For example sequences and are regular while and are not The bracket sequence is called palindrome if it reads the same back and forth For example the bracket sequences and are palindromes while bracket sequences and are not palindromes You stop performing the operations when it s not possible to find a prefix Your task is to find the number of operations you will perform on the given string and the number of remaining characters in the string You have to answer t independent test cases ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Consider the first character of the string If it is then we can remove the first two characters of the string and continue because the prefix of length will be either a palindrome or a regular bracket sequence If the first character of the string is then this is a bad case Of course the regular bracket sequence can t start with so this prefix should be a palindrome And what is the shortest palindrome we can get with the first character It is the closing bracket then some possibly zero amount of opening brackets and another one closing bracket We can see that we can t find a palindrome shorter than this one because we have to find a pair for the first character So if the first character of the string is then we just remove anything until the next character inclusive To not remove any characters explicitly we can just use pointers instead And the last thing is to carefully handle cases when we can t do any operations "}
{"statement": "The great hero guards the country where Homer lives The hero has attack power A and initial health value B There are n monsters in front of the hero The i th monster has attack power a i and initial health value b i The hero or a monster is said to be living if his or its health value is positive greater than or equal to 1 and he or it is said to be dead if his or its health value is non positive less than or equal to 0 In order to protect people in the country the hero will fight with monsters until either the hero is dead or all the monsters are dead In each fight the hero can select an arbitrary living monster and fight with it Suppose the i th monster is selected and the health values of the hero and the i th monster are x and y before the fight respectively After the fight the health values of the hero and the i th monster become x a i and y A respectively For the safety of the people in the country please tell them whether the great hero can kill all the monsters even if the great hero himself is dead after killing the last monster ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "The hero needs lceil b i A rceil attacks to kill the i th monster and he will obtain lceil b i A rceil a i damage after that Suppose the k th monster is the last monster killed by the hero Then the health value of the hero before the last attack is h k B sum i 1 n left lceil frac b i A right rceil a i a k All monsters can be killed if and only if max k h k 0 This can be checked in O n time "}
{"statement": "You are given an array a 1 a 2 dots a n consisting of n integers You are also given an integer value x Let f k be the maximum sum of a contiguous subarray of a after applying the following operation add x to the elements on exactly k positions An empty subarray should also be considered it has sum 0 Note that the subarray doesn t have to include all of the increased elements Calculate the maximum value of f k for all k from 0 to n independently ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Consider the naive solution Iterate over Then iterate over the segment that will have the maximum sum Let its length be Since is non negative it s always optimal to increase the elements inside the segment So if then the sum of the segment increases by Otherwise only the elements inside the segment will affect the sum thus it will increase by That can be written as Notice that we only care about two parameters for each segment Its length and its sum Moreover if there are several segments with the same length we only care about the one with the greatest sum Thus the idea of the solution is the following For each length find the segment of this length with the greatest sum Then calculate in by iterating over the length of the segment Overall complexity per testcase "}
{"statement": "A balanced bracket sequence is defined as an integer sequence that can be built with the following rules The empty sequence is balanced If a 1 ldots a n and b 1 ldots b m are balanced then their concatenation a 1 ldots a n b 1 ldots b m is balanced If x is a positive integer and a 1 ldots a n is balanced then x a 1 ldots a n x is balanced The positive numbers can be imagined as opening brackets and the negative numbers as closing brackets where matching brackets must have the same type absolute value For example 1 2 2 1 and 1 3 3 2 2 1 are balanced but 1 2 1 2 and 1 1 are not balanced There are 2n cards Each card has a number on the front and a number on the back Each integer 1 1 2 2 ldots n n appears exactly once on the front of some card and exactly once on the back of some not necessarily the same card You can reorder the cards however you like You are allowed to flip cards so numbers cannot move between the front and back Your task is to order the cards so that the sequences given by the front numbers and the back numbers are both balanced or report that it is impossible ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3500", "problem_editorial": "Suppose we have a deck of cards where the front and back are both balanced bracket sequences Let s line the cards up horizontally and draw them as points For each pair of matching brackets on the front and back we will connect them with an edge For matched brackets on the front we add an edge as a semicircle lying above the points And for matched brackets on the back we add a similar edge below the points Since every point is incident to exactly two edges this graph decomposes into cycles Since the edges are non intersecting each cycle is a Jordan curve in the plane Imagine the curve as a track and a monorail makes one full trip clockwise around the track Each edge turns the monorail clockwise or counterclockwise by 180 degrees Since the overall effect must turn the monorail a full 360 degrees clockwise there are two more clockwise edges than counterclockwise edges in the cycle If a cycle has edges then there are clockwise edges and counterclockwise edges Now in the actual problem we are given a shuffled deck of cards If there exists a way to reorder them so that the front and back are both balanced then we know the above property must hold Even though the cards are shuffled we still have enough information to construct the edges and distinguish two edges in the same cycle by orientation clockwise and counterclockwise If there are edges of one orientation we should call them the clockwise edges Otherwise if the number of edges of both orientations are invalid we should report that no solution exists Now that we have restricted ourselves to the case where this important condition holds we should construct a solution We can do this by solving for all the cycles independently and concatenating them together Consider a cycle Let s make a binary string describing the sequence of orientations where denotes a clockwise turn and denotes a counterclockwise turn Since there are clockwise turns we can find two adjacent s in the string For consistency let s cyclically shift the string so that it begins and ends with and we can consider the curve to begin at the leftmost point Let s see how we can build the curve recursively First there is the base case where the string is Clearly we can build the curve with two points like this Now suppose we have constructed a curve corresponding to for some string We will hide the turns of in the drawing and just display it as a blue box From this we can build a curve corresponding to the string as shown on the right This requires us to add two new points and reverse the order of the points in the blue box Similarly if we have constructed a curve for we can build the curve for Suppose we have constructed the curves and for two strings and The turns of are displayed as a blue box and the turns of are displayed as a green box Then we can build the curve as shown on the right We take the last point in the blue box visited by the curve and replace it with the points in the green box in the same order It turns out that the base case and these three operations are enough to build any curve satisfying the required condition We can do it recursively as follows If the string is return the base case If the string is for some build the curve and apply operation 1 If the string is for some build the curve and apply operation 2 Otherwise there exist non empty strings and so that the string is and contains the same number of s and s and thus so does Recursively build the curves and and apply operation 3 How can we apply these operations efficiently When constructing a curve we only care about the list of points ignoring the leftmost one as they appear from left to right and which points are visited immediately before and after the leftmost point by the curve If we store the list in the form of a doubly linked list the operations of reversing and inserting in the middle can be done in constant time To build it recursively we also need an efficient way to find a splitting point in the case of If we just scan from one endpoint maintaining a prefix sum number of s minus number of s the algorithm will take time overall Instead we should scan from both endpoints in parallel and stop when one of them finds a splitting point If it splits into lengths and then the time is given by the recurrence Complexity is There is also an solution Scan the string ignoring the first and last from left to right maintaining a stack of linked lists When the prefix sum number of s minus number of s increases in absolute value we push the base case to the stack When the prefix sum decreases in absolute value we apply an operation or to the curve on the top of the stack then merge the top two curves with operation "}
{"statement": "It is known that there are fish species in the polar ocean numbered from to They are sorted by non decreasing order of their weight which is a positive number Let the weight of the th type of fish be then holds Polar bears Alice and Bob each have caught some fish and they are guessing who has the larger sum of weight of the fish he she s caught Given the type of the fish they ve caught determine whether it is possible that the fish caught by Alice has a total weight than Bob s In other words does there exist a sequence of weights not necessary integers such that the fish caught by Alice has a strictly larger total weight ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "First we sort and in non increasing order We claim that the answer is YES if and only if exists is lexicographically larger than If is not lexicographcally larger than that means for every That implies for every fish Alice has there is a corresponding fish Bob has and is as heavy as Alice s Let be the smallest index such that We can amplify the gap between and as large as we want to make Alice wins "}
{"statement": " A permutation of length n is an array of n integers such that every integer from 1 to n appears in it exactly once An element y of permutation p is reachable from element x if x y or p x y or p p x y and so on The of a permutation p is defined as follows firstly we have a permutation p all elements of which are and an empty list l Then we do the following while there is at least one element in p we find the leftmost such element list all elements that are reachable from it mark all of these elements then cyclically shift the list of those elements so that the maximum appears at the first position and add this list of l After all elements are marked l is the result of this decomposition For example if we want to build a decomposition of p 5 4 2 3 1 7 8 6 we do the following initially p 5 4 2 3 1 7 8 6 bold elements are marked l the leftmost unmarked element is 5 5 and 1 are reachable from it so the list we want to shift is 5 1 there is no need to shift it since maximum is already the first element p textbf 5 4 2 3 textbf 1 7 8 6 l 5 1 the leftmost unmarked element is 4 the list of reachable elements is 4 2 3 the maximum is already the first element so there s no need to shift it p textbf 5 textbf 4 textbf 2 textbf 3 textbf 1 7 8 6 l 5 1 4 2 3 the leftmost unmarked element is 7 the list of reachable elements is 7 8 6 we have to shift it so it becomes 8 6 7 p textbf 5 textbf 4 textbf 2 textbf 3 textbf 1 textbf 7 textbf 8 textbf 6 l 5 1 4 2 3 8 6 7 all elements are marked so 5 1 4 2 3 8 6 7 is the result The of a permutation is defined as follows we build the decomposition of this permutation then we sort all lists in decomposition in ascending order of the first elements we don t swap the elements in these lists only the lists themselves then we concatenate the lists into one list which becomes a new permutation For example the of p 5 4 2 3 1 7 8 6 is built as follows the decomposition is 5 1 4 2 3 8 6 7 after sorting the decomposition it becomes 4 2 3 5 1 8 6 7 4 2 3 5 1 8 6 7 is the result of the transformation We call a permutation if the result of its transformation is the same as the permutation itself For example 4 3 1 2 8 5 6 7 is a good permutation and 5 4 2 3 1 7 8 6 is bad since the result of transformation is 4 2 3 5 1 8 6 7 Your task is the following given n and k find the k th lexicographically good permutation of length n ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Let s calculate the number of permutations of length which have a maximum at the position and consist of exactly one cycle Each good permutation can be divided into such blocks so we ll need this value later It is easy to notice that Let s calculate the following dynamic programming the number of good permutations consisting of elements To calculate let s iterate over the maximum element of the first block it determines the length of this block Now let s use the standard method of lexicographic recovery We will iterate over which element to put next it immediately determines the size of the new block and all the elements in it If the number of permutations starting with such block is at least then you need to restore this block entirely and reduce the task to the one without this block Otherwise you need to subtract the number of permutations starting on such block from and proceed to the next option for the block We will also use lexicographic recovery to restore the block You must carefully maintain the current block so that it consists of exactly one cycle To do this you can use DSU or explicitly check for a cycle "}
{"statement": "Little Petya loves counting He wants to count the number of ways to paint a rectangular checkered board of size rows columns in colors Besides the coloring should have the following property for any vertical line that passes along the grid lines and divides the board in two non empty parts the number of distinct colors in both these parts should be the same Help Petya to count these colorings ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "One can notice that if m 1 then the answer is kn because all colorings are possible Now we ll assume that m 1 Let s look on the first column of the board i e the vertical cut will be made right next to the first column Suppose there are x distinct colors in this column Then in the rest of the board there are also x colors If we move the vertical line by one unit to the right the number of different colors to the left of it will not decrease and the number of colors to the right of it won t increase It means that the number of different colors in both parts of the board will be also x We can repeat this process until the line reaches the rightmost column which means that the number of distinct colors in it is also x It is easy to see that we can only use colors which belong to the intersection of sets of colors in the leftmost and rightmost columns in the rest of the board Let s iterate over all values of x and y where x is the number of colors in the leftmost column and y is the number of elements in intersection of sets of colors in the rightmost and leftmost columns It is easy to see that x is limited by the number of rows in the board and y can t be greater than x Let s find the answer for all such pairs of x and y and at the end we ll add them up together Suppose x and y are fixed We first need to choose 2x y colors from the given k colors which we will use which means that the answer for will be multiplied by C k 2x y After that we ll choose x y unique colors which will be used in the first column which means that the answer will be also multiplied by C 2x y x y Then we ll choose x y colors for the rightmost column and multiply the answer by C x x y Now all we need to know is how many ways of coloring n cells into x colors are there We ll use a dynamic programming approach to solve this sub problem Let d i j be the number of ways to color a rectangle of unit width and length i into colors numerated from 1 to j with the following restriction if a b then the first appearence of color a in the rectangle will be before the first appearence of color b Then we can calculate this function using the following recurrence d i j j d i 1 j d i 1 j 1 After we finish calculating d i j we need to multiply the answer by d n x 2 to color the first and the last columns Now we need to notice that we can reorder all colors in the first and the last columns in arbitrary way which means that the answer should be multiplied by x 2 Finally we need to multiply the answer by yn m 2 which correspond to coloring the rest of our board "}
{"statement": "You are given an array a of length n The array is called if for all distinct indices i j k the sum a i a j a k is an element of the array More formally a is 3SUM closed if for all integers 1 leq i j k leq n there exists some integer 1 leq l leq n such that a i a j a k a l Determine if a is 3SUM closed ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s consider some array which is 3SUM closed If the array has at least three positive elements consider the largest three and Notice that is strictly larger than and which means that is not an element of the array since were the largest elements Therefore the array has positive elements Similarly if the array has at least three negative elements consider the smallest three and Notice that is strictly smaller than and which means that is not an element of the array since were the smallest elements Therefore the array has negative elements Finally note that there is no point in having more than zeroes in the array since any additional zeroes won t change the sums that can be formed So if there are more than zeroes we can remove them until there are exactly It follows that the resulting array has at most elements This is small so we can brute force the condition in the problem in or time The time complexity is or depending on the implementation "}
{"statement": "You are given a string s You have to reverse it that is the first letter should become equal to the last letter before the reversal the second letter should become equal to the second to last letter before the reversal and so on For example if your goal is to reverse the string you should get the string To accomplish your goal you can swap the Your task is to calculate the minimum number of swaps you have to perform to reverse the given string ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "First of all let s find the resulting position for each character of the string It s easy to see that we don t need to swap equal adjacent characters it changes nothing so the first character in the original string is the first character in the resulting string the second character in the original string is the second character in the resulting string and so on Now let s build a permutation of elements where is the resulting position of the element that was on position in the original string For example for the string this permutation will be In one operation we may swap two elements in this permutation and our goal is to sort it since each character of the string has its own required position and when for every the condition holds each character is on the position it should be The required number of swaps of adjacent elements to sort a permutation is exactly the number of inversions in it since each swap changes the number of inversions by and this number can be calculated using many different techniques for example mergesort tree or Fenwick tree "}
{"statement": "You are given a rectangle grid That grid s size is Let s denote the coordinate system on the grid So each point on the grid will have coordinates a pair of integers Your task is to find a maximum sub rectangle on the grid so that it contains the given point and its length width ratio is exactly In other words the following conditions must hold The sides of this sub rectangle should be parallel to the axes And values should be integers If there are multiple solutions find the rectangle which is closest to Here closest means the Euclid distance between and the center of the rectangle is as small as possible If there are still multiple solutions find the lexicographically minimum one Here lexicographically minimum means that we should consider the sub rectangle as sequence of integers so we can choose the lexicographically minimum one ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Math Geometry Give you n m x y a b Find a maximum sub rectangle within 0 0 n m so that it contains the given point x y and its length width radio is exactly a b If there are multiple solutions find the rectangle which is closest to x y If there are still multiple solutions find the lexicographically minimum one Split the problem into x axis and y axis Then you can solve the sub tasks in O 1 d gcd a b a d b d t min n a m b a t b t Be careful when the length is outside the original rectangle "}
{"statement": "Vladimir wants to modernize partitions in his office To make the office more comfortable he decided to remove a partition and plant several bamboos in a row He thinks it would be nice if there are bamboos in a row and the th from the left is meters high Vladimir has just planted bamboos in a row each of which has height meters right now but they grow meter each day In order to make the partition nice Vladimir can cut each bamboo once at any height no greater that the height of the bamboo and then the bamboo will stop growing Vladimir wants to check the bamboos each days i e days after he planted then after days and so on and cut the bamboos that reached the required height Vladimir wants the total length of bamboo parts he will cut off to be no greater than meters What is the maximum value he can choose so that he can achieve what he wants without cutting off more than meters of bamboo ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "First fact The problem is asking to maximize such that Let then Second fact Number of possible values for is For let these values are and So there is at most segments for such that will not change Now generate all possible values and sort them and for each segment check if there is a in that segment satisfying the condition and update the answer My solution "}
{"statement": "There is a deck of n cards The i th card has a number a i on the front and a number b i on the back Every integer between 1 and 2n appears exactly once on the cards A deck is called sorted if the front values are in order and the back values are in order That is if a i a i 1 and b i b i 1 for all 1 le i n To flip a card i means swapping the values of a i and b i You must flip some subset of cards possibly none then put all the cards in any order you like What is the minimum number of cards you must flip in order to sort the deck ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Suppose there is a sorted deck where the i th card has ci on the front and di on the back That is it looks like this c1 c2 cnd1 d2 dn The values 1 n must appear in some prefix of ci and some suffix of di That is they must all appear on distinct cards So if two values between 1 and n appear on the same card we should report there is no solution Now we know that every card in the input has a value in 1 n and a value in n 1 2n Let f k denote the number matched with the value k Let s split the cards into two sets Set A will be the cards that will end with the smaller number on the front and B is the set of cards ending with the smaller number on the back In each set as the smaller numbers increase the larger numbers decrease Therefore it must be possible to decompose f 1 f n into two decreasing subsequences or there is no solution To decompose an array into two decreasing subsequences there is a standard greedy approach Also note that any decomposition of f 1 f n into two decreasing sequences corresponds to a solution In fact we can put all the cards of one subsequence in A and the rest in B and it will create a sorted deck But how can we find the decomposition that corresponds to the minimum number of card flips For every index i such that minj if j maxj if j let s add a divider between i and i 1 This splits the array f 1 f n into several segments We can independently choose how to decompose each segment into two subsequences and combining them is guaranteed to be a valid decomposition for the entire array Also there is a unique way to decompose each segment the only choice is in which one we call the first subsequence And so we can independently choose for each segment the choice that requires the smallest number of flips Complexity is O n "}
{"statement": "You have a description of a lever as string We ll represent the string length as record then the lever looks as a horizontal bar with weights of length with exactly one pivot We will assume that the bar is a segment on the axis between points and The decoding of the lever description is given below If the th character of the string equals that means that at coordinate there is the pivot under the bar If the th character of the string equals that means that at coordinate there is nothing lying on the bar If the th character of the string equals digit that means that at coordinate there is a weight of mass on the bar Your task is given the lever description print if it will be in balance or not Assume that the bar doesn t weight anything Assume that the bar initially is in balance then all weights are simultaneously put on it After that the bar either tilts to the left or tilts to the right or is in balance ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Let mid position of Let value x x if x is a digit 0 otherwise Let sum value i th char i mid If sum 0 then answer balance Else if sum 0 then answer left Else answer right "}
{"statement": "You are given sequences Each sequence consists of positive integers not exceeding All integers in one sequence are distinct but the same integer may appear in multiple sequences The length of the th sequence is Each second integers in each of the sequences are shifted by one to the left i e integers at positions go to positions while the first integers becomes the last Each second we take the first integer of each sequence and write it down to a new array Then for each value from to we compute the longest of the array consisting of element only The above operation is performed for seconds For each integer from to find out the longest segment found at this time ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Let s solve the problem for a particular number Without loss of generality we assume that appeared in each sequence If not then the whole sequence is divided into contigous subsegments for which above statement is true and the answer for the number is equal to the maximum of the answers for these subsegments Let s denote as the position from to 1 of in the th sequence Then the number occures in the new array at position in the seconds equal to This condition can be rewritten as follows the number occures at position on the th second if Thus to determine whether the number occurs at some point in all positions from to you need to determine whether there is a solution for a system of equations Suppose that we are able to quickly answer to such queries for arbitrary and Then the problem can be solved for example using two pointers We will move the left boundary of the subsegment and for fixed left boundary we will move the right boundary as far as possible until the solution of the corresponding system still exists We can solve a system of equations for any subsegment in time per query using precalculation in the following way To begin with we note that the set of solutions of this system is either empty or it itself can be represented in the same form where We will find the solutions of the systems for the following subsegments for each and for each we will take subsegment For each such subsegment we can find the solution of the corresponding system using time by solving a system consisting of two equations obtained from each of the halves of this subsegment We can solve a system consisting of two equations using the Chinese remainder theorem Now to find a solution for any subsegment it is enough to take two subsegments presented above that their union is equal to the initial subsegment and again solve a system of two equations The resulting complexity of the solution is Since the lengths of the sequences does not exceed 40 the resulting LCM can be upper bounded by 10 16 Since the total length of all sequences is the total complexity of the solution for all the numbers remains the same "}
{"statement": "Pasha loves to send strictly positive integers to his friends Pasha cares about security therefore when he wants to send an integer n he encrypts it in the following way he picks three integers a b and c such that l leq a b c leq r and then he computes the encrypted value m n cdot a b c Unfortunately an adversary intercepted the values l r and m Is it possible to recover the original values of a b and c from this information More formally you are asked to find values of a b and c such that a b and c are integers l leq a b c leq r there exists a strictly positive integer n such that n cdot a b c m ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "The task is to solve equation in integers where is some natural number and Note that the expression can take any value from and only these values Indeed if then if we denote we get A similar statement is true for So since it was necessary to solve the equation this is equivalent to solving the equation where Let s fix some arbitrary Then we find the maximum for which this will be equal to Let s check whether it is true that and If this is the case then restore and as indicated above This solution iterates over all possible values of and checks if such can be used in answer if the manner described above Thus this solution has complexity "}
{"statement": "Berland has cities connected by bidirectional roads No road connects a city to itself and each pair of cities is connected by no more than one road It is that you can get from any city to any other one using only the existing roads The President of Berland decided to make changes to the road system and instructed the Ministry of Transport to make this reform Now each road should be unidirectional only lead from one city to another In order not to cause great resentment among residents the reform needs to be conducted so that there can be as few separate cities as possible A city is considered if no road leads into it while it is allowed to have roads leading from this city Help the Ministry of Transport to find the minimum possible number of separate cities after the reform ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1600", "problem_editorial": "One should notice that for every connected component of the graph the problem could be solved independently so we just need to solve the problem for any connected graph Let this connected graph of vertices contain edge such is called a tree If one maintain a DFS from any of its vertex every edge will be oriented and each of them could given to its ending vertex this way every vertex except the one we launched DFS from that is the root will be satisfied by an edge In this case the answer is equal to Let s then deal with a case when the graph contains more than edges This graph contains at least one cycle Let s take arbitrary vertex from any of the cycles and launch a DFS as above from it All vertices except chosen will be satisfied so we are to give an edge to the chosen vertex As soon as chosen vertex belongs to a cycle at least one of its edge will not be taken to account in the DFS so it can be given to a root This way all the vertices will be satisfied Now we are able to solve the task for any connected graph so we are to divide the graph into a connected components this can be easily done by DFS or BFS The solution complexity is "}
{"statement": "There are n heroes fighting in the arena Initially the i th hero has a i health points The fight in the arena takes place in several rounds At the beginning of each round each alive hero deals 1 damage to all other heroes Hits of all heroes occur simultaneously Heroes whose health is less than 1 at the end of the round are considered killed If exactly 1 hero remains alive after a certain round then he is declared the winner Otherwise there is no winner Your task is to calculate the number of ways to choose the initial health points for each hero a i where 1 le a i le x so that there is no winner of the fight The number of ways can be very large so print it modulo 998244353 Two ways are considered different if at least one hero has a different amount of health For example 1 2 1 and 2 1 1 are different ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s calculate the following dynamic programming the number of ways to choose the initial health if there are heroes still alive and they already received damage Let s iterate over the number of heroes that will survive after the next round Then we have to make a transition to the state where the minimum of the maximum allowed health and plus the damage done in this round It remains to understand with what coefficient we should make this transition in dynamic programming This coefficient is equal to the number of ways to choose which of the living heroes will die in this round multiplied by the number of ways to choose health for these heroes because their health is greater than so that they are still alive at the moment but not more than so that they are guaranteed to die in this round Of course we don t make any transitions from the states where since they represent the fights that have already finished The answer is the sum of all for every "}
{"statement": "Piggy lives on an infinite plane with the Cartesian coordinate system on it There are n cities on the plane numbered from 1 to n and the first k cities are defined as The coordinates of the i th city are x i y i Piggy as a well experienced traveller wants to have a relaxing trip after Zhongkao examination Currently he is in city a and he wants to travel to city b by air You can fly between any two cities and you can visit several cities in any order while travelling but the final destination must be city b Because of active trade between major cities it s possible to travel by plane between them for free Formally the price of an air ticket f i j between two cities i and j is defined as follows f i j begin cases 0 text if cities i text and j text are both major cities x i x j y i y j text otherwise end cases Piggy doesn t want to save time but he wants to save money So you need to tell him the value of the total cost of all air tickets if he can take any number of flights ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "First of all it s easy to see that if there are no major cities the minimum value of the total cost should be the optimal choice is to fly directly from city to city Piggy will pass through a maximum of major cities If he passes through or more major cities in a row then he can fly directly from the first one to the last one If he passes through major cities and passes an ordinary city between them the cost must be higher than flying directly between these two major cities So the optimal choice always consists of no more than major cities and they are in a row Thus you can express the optimal choice as where and are both major cities If you naively enumerate and the total complexity of the solution will be But after seeing that and work independently we can enumerate them separately The total complexity decreases to "}
{"statement": "Mocha likes arrays and Serval gave her an array consisting of positive integers as a gift Mocha thinks that for an array of positive integers a it is iff the greatest common divisor of all the elements in a is no more than its length And for an array of at least 2 positive integers it is iff all of its prefixes whose length is no less than 2 are good For example 3 6 is not good because gcd 3 6 3 is greater than its length 2 1 2 4 is both good and beautiful because all of its prefixes whose length is no less than 2 which are 1 2 and 1 2 4 are both good 3 6 1 is good but not beautiful because 3 6 is not good Now Mocha gives you the gift array a of n positive integers and she wants to know whether array a could become beautiful by reordering the elements in a It is allowed to keep the array a unchanged ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Considering an array of positive integers the following inequality holds for Therefore when the prefix of is good we can show that all the prefixes of whose length is no less than are good then is beautiful It is obvious that is good when is beautiful So we get the conclusion that is beautiful if and only if the prefix is good We can check if there exist such that If so we can move to the front of to make it beautiful then the answer is Yes If not the answer is No Time complexity "}
{"statement": "On a random day Neko found n treasure chests and m keys The i th chest has an integer a i written on it and the j th key has an integer b j on it Neko knows those chests contain the powerful mysterious green Grapes thus Neko wants to open as many treasure chests as possible The j th key can be used to unlock the i th chest if and only if the sum of the key number and the chest number is an odd number Formally a i b j equiv 1 pmod 2 One key can be used to open at most one chest and one chest can be opened at most once Find the maximum number of chests Neko can open ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The most important observation is that Key with odd id can only be used to unlock chest with even id Key with even id can only be used to unlock chest with odd id Let be the number of chests with even and odd id respectively be the number of keys with even and odd id respectively With even id chests and odd id keys you can unlock at most chests With odd id chests and even id keys you can unlock at most chests Therefore the final answer is Complexity "}
{"statement": "A of length k is a sequence of k integers from 1 to k containing each integer exactly once For example the sequence 3 1 2 is a permutation of length 3 When Neko was five he thought of an array a of n positive integers and a permutation p of length n 1 Then he performed the following Constructed an array b of length n 1 where b i min a i a i 1 Constructed an array c of length n 1 where c i max a i a i 1 Constructed an array b of length n 1 where b i b p i Constructed an array c of length n 1 where c i c p i For example if the array a was 3 4 6 5 7 and permutation p was 2 4 1 3 then Neko would have constructed the following arrays b 3 4 5 5 c 4 6 6 7 b 4 5 3 5 c 6 7 4 6 Then he wrote two arrays b and c on a piece of paper and forgot about it 14 years later when he was cleaning up his room he discovered this old piece of paper with two arrays b and c written on it However he can t remember the array a and permutation p he used In case Neko made a mistake and there is no array a and permutation p resulting in such b and c print Otherwise help him recover any possible array a ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "Obviously if for some then the answer is 1 From the statement we have and For this to happen either one of the following must happen and and In order word one of the two following pairs or will match the pair From the statement we also have and Therefore one of the two following pairs or will match the pair Consider a graph with vertices For each from to we will add an undirected edge between and The following figure show such graph for the third example Consider the path Each edge will correspond to exactly one edge between and for some j In other word correspond to an Eulerian path on the graph The following figure show the path for the third example For implementation we need to do the following step For all elements of and we need to replace them with corresponding value from to where is the number of distinct value in and This part can be done using an balanced BST C map or Java TreeMap or by sorting in Build the graph as above Finding an Eulerian path in using Hierholzer s algorithm in or detect that such path does not exists Complexity "}
{"statement": "The Little Elephant enjoys recursive functions This time he enjoys the sorting function Let is a permutation of an integers from 1 to inclusive and denotes the th element of the permutation The Little Elephant s recursive function that sorts the first permutation s elements works as follows If exit the function Otherwise call and then make swap the th and th elements of The Little Elephant s teacher believes that this function does not work correctly But that be do not get an F the Little Elephant wants to show the performance of its function Help him find a permutation of numbers from 1 to such that after performing the Little Elephant s function that is call the permutation will be sorted in ascending order ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "In this problems you should notice that the answer for the problem is always of the following form 1 2 3 1 In such case array will be always sorted after the end of the algorithm "}
{"statement": "There are piles of pebbles on the table the th pile contains pebbles Your task is to paint each pebble using one of the given colors so that for each color and any two piles and the difference between the number of pebbles of color in pile and number of pebbles of color in pile is at most one In other words let s say that is the number of pebbles of color in the th pile Then for any the following condition must be satisfied It isn t necessary to use all colors if color hasn t been used in pile then is considered to be zero ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Suppose there are two piles with number of pebbles differed by more than then there is no solution Now let There s a way to construct correct coloring Now there are or pebbles of first color and 0 or 1 pebbles of any other color in each pile Prepared by KostromaAuthor of editorial riadwaw "}
{"statement": "Given a rooted tree with the root at vertex 1 For any vertex i 1 i leq n in the tree there is an edge connecting vertices i and p i 1 leq p i i with a weight equal to t i Iris does not know the values of t i but she knows that displaystyle sum i 2 n t i w and each of the t i is a The vertices of the tree are numbered in a special way the numbers of the vertices in each subtree are consecutive integers In other words the vertices of the tree are numbered in the order of a depth first search We define operatorname dist u v as the length of the simple path between vertices u and v in the tree Next there will be n 1 events Iris is given integers x and y indicating that t x y After each event Iris wants to know the maximum possible value of operatorname dist i i bmod n 1 for each i 1 le i le n She only needs to know the sum of these n values Please help Iris quickly get the answers Note that when calculating the maximum possible values of operatorname dist i i bmod n 1 and operatorname dist j j bmod n 1 for i ne j the unknown edge weights ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "The nodes are numbered by dfs order which tells us the vertex numbers in one subtree are always consecutive Let s consider an edge connecting vertex and Suppose the size of the subtree is so the vertices are numbered between Then for each that the path between node and is always in the subtree so it doesn t pass the edge The only two paths that passes edge is the path between and and between and Let s calculate the maximum value of First if all of the weights of its edges have been determined then it s already calculated Otherwise it s optimal to set one of the edges with undetermined weight with weight Then the answer is How to maintain the process Each time we know the weight of an edge we specially check whether the weights of the two paths that passes this edge are uniquely determined or not For all other paths that are not uniquely determined the contribution of the edge is is the weight We can use addition tags to handle this The time complexity is "}
{"statement": "You have a robot that can move along a number line At time moment 0 it stands at point 0 You give n commands to the robot at time t i seconds you command the robot to go to point x i Whenever the robot receives a command it starts moving towards the point x i with the speed of 1 unit per second and he stops when he reaches that point However while the robot is moving it all the other commands that you give him For example suppose you give three commands to the robot at time 1 move to point 5 at time 3 move to point 0 and at time 6 move to point 4 Then the robot stands at 0 until time 1 then starts moving towards 5 ignores the second command reaches 5 at time 6 and immediately starts moving to 4 to execute the third command At time 7 it reaches 4 and stops there You call the command i successful if there is a time moment in the range t i t i 1 i e after you give this command and before you give another one both bounds inclusive we consider t n 1 infty when the robot is at point x i Count the number of successful commands Note that it is possible that an ignored command is successful ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "The main idea in the problem is not how to solve it but how to code it neatly I ve come up with the following way Let s store three variables where is the robot now what direction does it move or and how much time is left until it stops moving The processing of the commands looks becomes pretty easy If there is no time left to move then the command is executed and we tell the robot the direction and the time left for the current command Then there are two cases either the robot stops before the next command or after it However they can be processed simultaneously Let be the minimum of the time left before the robot stops moving and the time before the next command We sure know that before the next command the robot will visit exactly the segment of positions between the current position and the current position plus direction multiplied by If the destination for the current command is in this segment then that command is successful After the command is processed subtract from the time left and increase the position by direction multiplied by Overall complexity per testcase "}
{"statement": "Alyona s mother wants to present an array of non negative integers to Alyona The array should be special Alyona is a capricious girl so after she gets the array she inspects of its subarrays Subarray is a set of some subsequent elements of the array The th subarray is described with two integers and and its elements are Alyona is going to find for each of the chosen subarrays Among these the girl is going to find the smallest She wants this minimum to be as large as possible You are to find an array of elements so that the minimum among those chosen by Alyona subarrays is as large as possible The of a set is a minimum possible non negative integer that is not in ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Obviously the answer to the problem can not be greater than the minimum length among the lengths of the sub arrays Suppose that the minimum length of all the sub arrays is equal to len Then the desired array is Not hard to make sure that mex of any subarray will be at least len "}
{"statement": "Given a string process queries each having one of the following forms Change the th character in the string to Consider the substring of starting at position and ending at position Output the number of times occurs as a substring in it ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "Divide the given string into blocks of size and use any suffix structure for each block Complexity To update a character in the string rebuild a suffix structure for that block This takes per update We answer queries as follows Remember that it s given that the total length of all the query strings is at most If the size of the query string is greater than then the number of such strings will be at most and hence we can directly use KMP in the string for the given range for all such strings Overall Complexity If the size of the query string is less than we proceed as follows For the occurrences of query string within a block we can calculate them using the suffix structures for each block This can be done in for each block for the given range For the occurrences that lie across two adjacent blocks we only need to consider a string of we can simply use KMP for finding such occurrences We need to choose the string carefully to avoid over counting for more details see the author s solution Its complexity will be For left and right blocks of the query range we can again use KMP The complexity would be The overall complexity for the small query strings is therefore Hence complexity over all such string would be Hence the overall complexity is So choose any optimal Any from to will fit in the time limit Expected Complexity "}
{"statement": "You are playing a game similar to Sokoban on an infinite number line The game is discrete so you only consider integer positions on the line You start on a position 0 There are n boxes the i th box is on a position a i All positions of the boxes are distinct There are also m special positions the j th position is b j All the special positions are also distinct In one move you can go one position to the left or to the right If there is a box in the direction of your move then you push the box to the next position in that direction If the next position is taken by another box then that box is also pushed to the next position and so on You are allowed to perform any number of moves possibly zero Your goal is to place as many boxes on special positions as possible Note that some boxes can be initially placed on special positions ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Since you can only push boxes you can t bring boxes from negative positions to positive ones and vice versa Thus negative boxes special positions and positive boxes special positions are two separate tasks You can solve them independently with the same algorithm and add up the answers So we will only consider the positive boxes special positions case Notice that it never makes sense to move left Thus the only thing that determines the answer is the maximum position to the right you reach For a naive algorithm we could iterate over that position push all boxes that we have encountered on our way ahead of us and calculate the number of boxes that are on special positions That works in where is maximum coordinate To improve that solution we can notice that the positions that are the most optimal are actually the ones such that the first box is pushed to some special position Consider the case the first box isn t on a special position and there is a special position somewhere to the right of it There are two types of boxes the ones that are in the pile you would push if you move right and the remaining suffix What happens if you move one step to the right The number of boxes from the suffix on special positions doesn t change The number of boxes from the pile on special positions doesn t decrease This number changes depending on if there is a special position immediately to the right of the pile and underneath the first box Since we considered the case where there is no special position underneath the first box the number can t decrease So we managed to improve the solution to Still slow Let s now learn to maintain the answer while moving the boxes Precalculate the number of boxes from the th to the last one that are already on special positions That can be done with two pointers Now iterate over the special position under the first box in the increasing order Maintain the size of the pile and the number of special positions under the pile The first value is just the index of the first box not in a pile The second value is easier to obtain if you keep the index of the first special position after the pile or if there are none Also achievable with two pointers The answer is the number of special positions under the pile plus the suffix answer for the boxes after the pile Take the maximum of all options The constraints are pretty free so you could replace two pointers with binary searches if you wanted to Overall complexity per testcase "}
{"statement": "It s well known that the best way to distract from something is to do one s favourite thing Job is such a thing for Leha So the hacker began to work hard in order to get rid of boredom It means that Leha began to hack computers all over the world For such zeal boss gave the hacker a vacation of exactly days You know the majority of people prefer to go somewhere for a vacation so Leha immediately went to the travel agency There he found out that vouchers left th voucher is characterized by three integers day of departure from Vi kopolis day of arriving back in Vi kopolis and cost of the voucher correspondingly The duration of the th voucher is a value At the same time Leha wants to split his own vocation into two parts Besides he wants to spend as little money as possible Formally Leha wants to choose exactly two vouchers and so that they don t intersect sum of their durations is and their total cost is as minimal as possible Two vouchers and don t intersect if only at least one of the following conditions is fulfilled or Help Leha to choose the necessary vouchers ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s sort all the vouchers by their left border Let s consider the vouchers in this sorted order Now we want to consider th one The duration of the th voucher is Consequentally only the vouchers with the duration can make a couple with the th one At the same time you shouldn t forget that the value of this expression may be negative You should check it Besides let s find a couple for the th voucher among all the vouchers for which To implement this solution let s keep an array denotes the minimal cost of the voucher with the duration equal to exactly on the considering prefix i e we should consider only such vouchers with in Thus it s enough to consider vouchers in order of increasing of their left borders and update the array Total complexity is "}
{"statement": "The famous store Second Food sells groceries only two days a month And the prices in each of days differ You wanted to buy n kilos of potatoes for a month You know that on the first day of the month 1 kilo of potatoes costs a coins and on the second day b coins In Second Food you can buy any kilograms of potatoes Fortunately Second Food has announced a promotion for potatoes which is valid only on the first day of the month for each m kilos of potatoes you buy you get 1 kilo as a gift In other words you can get m 1 kilograms by paying for m kilograms Find the minimum number of coins that you have to spend to buy n kilos of potatoes ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let Note that you need to use a promotion if In this case we will buy potatoes times for the promotion The remaining potatoes or all if the promotion is unprofitable can be bought at per kilogram Then the answer is Thus this solution works in Code "}
{"statement": "A competitive eater Alice is scheduling some practices for an eating contest on a magical calendar The calendar is unusual because a week contains not necessarily 7 days In detail she can choose any integer k which satisfies 1 leq k leq r and set k days as the number of days in a week Alice is going to paint some n consecutive days on this calendar On this calendar dates are written from the left cell to the right cell in a week If a date reaches the last day of a week the next day s cell is the leftmost cell in the next under row She wants to make It means that for any two painted cells there should exist at least one sequence of painted cells started in one of these cells and ended in another such that any two consecutive cells in this sequence are connected by side Alice is considering the shape of the painted cells Two shapes are the same if there exists a way to make them exactly overlapped For example in the picture a week has 4 days and Alice paints 5 consecutive days 1 and 2 are different shapes but 1 and 3 are equal shapes Alice wants to know exists As was said before she considers only shapes there all cells are connected by side ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "First let s consider in case of a week has exactly days If the length of painted cells is strictly more than one week So there are valid shapes The first week contains days The shapes have day width then if the value of are different the shapes are also different Otherwise there is only one valid liner pattern The shape is insensitive to the chosen value of We can sum up this for by using following well known formula Total complexity "}
{"statement": "There are integers written in a row For all from to values are defined by the crows performing the following procedure The crow sets initially The crow then adds to subtracts adds the number and so on until the th number Thus Memory gives you the values and he now wants you to find the initial numbers written in the row Can you do it ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Note that a i a i 1 b i Use the initial condition b n a n and we can figure out the entire array b "}
{"statement": "Nene is fighting with n monsters located in a circle These monsters are numbered from 1 to n and the i th 1 le i le n monster s current energy level is a i Since the monsters are too strong Nene decided to fight with them using the spell When Nene uses this spell the following actions happen in the following order The 1 st monster attacks the 2 nd monster The 2 nd monster attacks the 3 rd monster ldots The n 1 th monster attacks the n th monster The n th monster attacks the 1 st monster When the monster with energy level x attacks the monster with the energy level y the energy level of the defending monster becomes max 0 y x the energy level of the attacking monster remains equal to x Nene is going to use this spell 10 100 times and deal with the monsters that will still have a non zero energy level herself She wants you to determine which monsters will have a non zero energy level once she will use the described spell 10 100 times ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "If four consecutive monsters have energy level x y z w x y z w 0 and they did not die after t rounds of spells then y will receive at least t points of damage z will receive at least t 1 t 2 O t2 of damage and w will receive at least O t3 of damage That is to say let V maxni 1ai after O V 3 rounds at least one of x y z w will die So we can simulate the process by brute force until there are no four consecutive alive monsters and then the problem is reduced to the one described in Hint 2 If four consecutive monster have energy level 0 x y z x y z 0 x will remain alive y will die at last and sending D y x y 2x ymodx damage to z before that Therefore z will remain alive if and only if z D The time complexity is O nV 3 Bonus Actually it can be shown that after O V k rounds there will be no k consecutive alive monsters Making k bigger than 3 can further reduce the time complexity but it will be harder to implement and optimize little on actual performance "}
{"statement": "Imagine a game where you play as a character that has two attributes Strength and Intelligence that are at zero level initially During the game you ll acquire m attribute points that allow you to increase your attribute levels one point will increase one of the attributes by one level But sometimes you ll encounter a so called Attribute Checks if your corresponding attribute is high enough you ll pass it otherwise you ll fail it Spending some time you finally prepared a list which contains records of all points you got and all checks you ve met And now you re wondering what is the maximum number of attribute checks you can pass in a single run if you d spend points wisely Note that you can t change the order of records ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "For the start let s introduce a slow but correct solution Let be the answer to the task if we processed first records and the current Intelligence level is If we know Intelligence level then we also know the current Strength level where is just a total number of points in first records Since we want to use dp let s discuss transitions If the last record then it was a point and there are only two options we either raised Intelligence so the last state was or raised Strength coming from state In other words we can calculate If the last record then it s an Intelligence check and it doesn t affect the state only its answer For all otherwise it s If then it s a Strength check and affects the values in a similar way For all otherwise it s also OK we ve got a solution with time and memory but we can speed it up Note that the first case appears only times while the second and third cases are just range additions So if we can do addition in then processing the first case in linear time is enough to achieve complexity How to process range additions in time Let s use some difference array to do it lazily Instead of adding some value to the segment we ll only add value to and to And when we meet we ll push all accumulated operations all at once The total value you need to add to some position is So we can calculate all of them in just going from left to right maintaining the prefix sum The last question is reducing the space complexity As usual you can store only the last two layers for the current layer and previous layer But actually you can store only one layer and update it in place Let s store only one last layer of dp as Attribute checks don t change array at all In case you firstly push all data from to and then you need to recalc values in But since the formula is you can just iterate over in and everything works In total we have a solution with time and space complexity "}
{"statement": "Mike is trying rock climbing but he is awful at it There are holds on the wall th hold is at height off the ground Besides let the sequence increase that is for all from 1 to we will call such sequence a Mike thinks that the track has In other words difficulty equals the maximum distance between two holds that are adjacent in height Today Mike decided to cover the track with holds hanging on heights To make the problem harder Mike decided to remove one hold that is remove one element of the sequence for example if we take the sequence and remove the third element from it we obtain the sequence However as Mike is awful at climbing he wants the final difficulty i e the maximum difference of heights between adjacent holds after removing the hold to be as small as possible among all possible options of removing a hold The first and last holds stay at their positions Help Mike determine the minimum difficulty of the track after removing one hold ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "For every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones print the smallest found answer The solution has complexity It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element whatever is larger thus the difficulty for every option of removing an element can be found in for the total complexity of Any of these solutions or even less efficient ones could pass the tests Challenge suppose we now have to remove exactly arbitrary elements but the first and the last elements have to stay in their places How small the maximal difference between adjacent elements can become Solve this problem assuming the limitations are as follows "}
{"statement": "You are given a string s consisting of digits from 0 to 9 In one operation you can pick any digit in this string except for 0 or the leftmost digit decrease it by 1 and then swap it with the digit left to the picked For example in one operation from the string 1023 you can get 1103 or 1022 Find the lexicographically maximum string you can obtain after any number of operations ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s look at digit We can see that we can t move it to the left more than times because it will be after So we can say that only digits on indices from to can stand on index because the maximum digit can be moved to the left no more than times Thus for each we can brute force all digits from to and pick such that is maximum if we have multiple maximum options we will minimize After that we will move to the left until it is on index "}
{"statement": "Soon a school Olympiad in Informatics will be held in Berland schoolchildren will participate there At a meeting of the jury of the Olympiad it was decided that of the participants depending on the results will get a diploma of the first second or third degree Thus each student will receive exactly one diploma They also decided that there must be given at least and at most diplomas of the first degree at least and at most diplomas of the second degree and at least and at most diplomas of the third degree After some discussion it was decided to choose from all the options of distributing diplomas satisfying these limitations the one that maximizes the number of participants who receive diplomas of the first degree Of all these options they select the one which maximizes the number of the participants who receive diplomas of the second degree If there are multiple of these options they select the option that maximizes the number of diplomas of the third degree Choosing the best option of distributing certificates was entrusted to Ilya one of the best programmers of Berland However he found more important things to do so it is your task now to choose the best option of distributing of diplomas based on the described limitations It is guaranteed that the described limitations are such that there is a way to choose such an option of distributing diplomas that all participants of the Olympiad will receive a diploma of some degree ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "This problem can be solved in the different ways We consider one of them parsing cases If max1 min2 min3 n then the optimal solution is n min2 min3 min2 min3 Else if max1 max2 min3 n then the optimal solution is max1 n max1 min3 min3 Else the optimal solution is max1 max2 n max1 max2 This solution is correct because of statement It is guaranteed that min1 min2 min3 n max1 max2 max3 "}
{"statement": "You are given two integers n and k Find a sequence a of non negative integers of size at most 25 such that the following conditions hold There is no subsequence of a with a sum of k For all 1 le v le n where v ne k there is a subsequence of a with a sum of v A sequence b is a subsequence of a if b can be obtained from a by the deletion of several possibly zero or all elements without changing the order of the remaining elements For example 5 2 3 is a subsequence of 1 5 7 8 2 4 3 It can be shown that under the given constraints a solution always exists ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Notice that for a fixed a solution for is also a solution for all So we can ignore the value of and just assume it s always If we didn t have the restriction that no subsequence can add up to the most natural solution would be Every value from to appears as the sum of the subsequence given by its binary representation We will use a modified version of this array to solve the problem Let be the largest integer such that We will use this array of size To prove that no subsequence of adds up to consider the list of all elements in the array that are at most since these are the only ones that could be present in a subsequence adding to These areSince these add up to no subsequence can add up to To prove that for all where there is a subsequence adding up to we consider several cases If we can simply use the binary representation of If we can first take all of the elements that are at most as part of our subsequence We then need to remove elements with a sum equal to Because is less than so we can simply remove its binary representation If we can take along with the binary representation of The one edge case is when the bit is set in In this case we replace with So in all cases we can form a subsequence adding up to Complexity "}
{"statement": "Mike and some bears are playing a game just for fun Mike is the judge All bears except Mike are standing in an grid there s exactly one bear in each cell We denote the bear standing in column number of row number by Mike s hands are on his ears since he s the judge and each bear standing in the grid has hands either on his mouth or his eyes They play for rounds In each round Mike chooses a bear and tells him to change his state i e if his hands are on his mouth then he ll put his hands on his eyes or he ll put his hands on his mouth otherwise After that Mike wants to know the score of the bears Score of the bears is the maximum over all rows of number of consecutive bears with hands on their eyes in that row Since bears are lazy Mike asked you for help For each round tell him the score of these bears after changing the state of a bear selected in that round ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Consider this problem We have a binary sequence and want to find the maximum number of consecutive 1s in it How to solve this Easily Finally answer to this problem is ans For each row of the table let be the maximum number of consecutive 1s in it we know how to calculate it in right So after each query update in and then find in Time complexity C Code by PrinceOfPersia C Code by Haghani Python Code by Zlobober "}
{"statement": "Just in case somebody missed it this winter is totally cold in Nvodsk It is so cold that one gets funny thoughts For example let s say there are strings with the length exactly based on the alphabet of size Any its substring with length equal to is a palindrome How many such strings exist Your task is to find their quantity modulo Be careful and don t miss a string or two Let us remind you that a string is a palindrome if it can be read the same way in either direction from the left to the right and from the right to the left ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1600", "problem_editorial": "We can offer you two solitions You can build a graph with positions in sting as a nodes and equality in any substring of length as edges Lets denote the number of components in the graph The answer is Analyze four cases "}
{"statement": "This problem is interactive You should guess hidden number x which is between 1 and M 10004205361450474 inclusive You could use up to 5 queries In each query you can output an increasing sequence of k leq x integers each between 1 and M inclusive and you will obtain one of the following as an answer either the hidden number belongs to your query sequence in this case you immediately win or you will be given where the hidden number is located with respect to your query sequence that is either it is less than all numbers from the sequence greater than all numbers from the sequence or you will be given such an i that the hidden number x is between the i th and the i 1 st numbers of your sequence See the interaction section for clarity Be aware that the interactor is i e the hidden number can depend on queries the solution makes However it is guaranteed that for any solution the interactor works non distinguishable from the situation when the hidden number is fixed beforehand Hacks are allowed only with fixed hidden number A hack is represented by a single integer between 1 and M In all pretests the hidden number is fixed as well ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "Although it looks strange the bound on the number from the problem statement is actually tight for queries of length up to Let s find out how to obtain this number Let is the maximum such that we can guess the number which is known to be in using queries The number is the bound for the number of guesses in the next query except for the case then since from that time the bound for this number will be The following process calculates The guesses for the current query will be The complexity of the solution can be estimated as where and but actually it s much faster if we calculate only for reachable states "}
{"statement": "Polar bears like that is arrays without repeated elements You have got a unique array with length containing non negative integers Since you are good friends with Alice and Bob you decide to split the array in two Precisely you need to construct two arrays and that are also of length with the following conditions for all are non negative integers Ideally and should also be unique arrays However life in the Arctic is hard and this is not always possible Fortunately Alice and Bob are still happy if their arrays are We define an array of length to be almost unique if and only if it can be turned into a unique array by removing no more than entries For example the array is almost unique because after removing the first two entries it becomes The array is not almost unique because we need to remove at least entries to turn it into a unique array So your task is to split the given unique array into two almost unique arrays and ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "An equivalent definition for almost unique is an array with at least different elements The idea is to split into three parts In the first part we give uniqueness to In the second part we give uniqueness to In the third part we give uniqueness to both Lets assume is sorted Since is an unique array we know for all 0 based The image below will give some intuition on how we are going to split it is red is blue the length of the bar represent the magnitude of the number In the first and second part we do not care about the array that we are not giving uniqueness to For exampmle if assign do not care values of assign do not care values of assign and set From will have strictly increasing values starting from at least "}
{"statement": "There are cities numbered from 1 to in Berland Some of them are connected by two way roads Each road has its own length an integer number from 1 to 1000 It is known that from each city it is possible to get to any other city by existing roads Also for each pair of cities it is known the shortest distance between them Berland Government plans to build new roads For each of the planned road it is known its length and what cities it will connect To control the correctness of the construction of new roads after the opening of another road Berland government wants to check the sum of the shortest distances between all pairs of cities Help them for a given matrix of shortest distances on the old roads and plans of all new roads find out how the sum of the shortest distances between all pairs of cities changes after construction of each road ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1900", "problem_editorial": "Initially we are given a matrix D where D i j is the distance of shortest path between city i and city j Suppose we build a new road between a and b with length shorter than D a b How do we update the rest of the graph accordingly Define a new matrix D whose entries D i j are the minimum path distance between i and j while taking into account the new road ab There are three possibilities for each i j D i j remains unchanged by the new road In this case D i j D i j D i j is shorter if we use the new road ab This means that the new path i v1 v2 vn j must include the road a b If we connect the vertices i a b j together in a path then our new distance will be D i a length ab D b j Lastly we may have to use the road ba Note that this may not be the same as road ab In this case we have D i j D i b length ab D a j Thus for each new road that we build we must update each path i j within the graph Then we must sum shortest distances between cities Updating the matrix and summing the total distance are both O N2 so about 3002 operations Lastly there are at most 300 roads so in total there are about 3003 operations One thing to note is that the sum of all shortest distances between cities may be larger than an int thus we need to use a long when calculating the sum "}
{"statement": "You are given an array a 1 a 2 ldots a n Find the number of tuples x y z such that 1 leq x leq y leq z leq n and f x y oplus f y z f x z We define f l r a l oplus a l 1 oplus ldots oplus a r where oplus denotes the bitwise XOR operation ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s start by first solving the problem for and extend the idea to later To solve for we ll find the smallest value that occurs with different frequencies on the two paths We ll solve an easier version by solving for two static arrays instead of solving the problem of two paths To find the smallest value that has a different frequency between the two arrays we can have a segment tree on the frequency array for each static array Then we can store the hash of each segment tree node and perform a descent to find the first point at which the hashes in the two segment trees differ The hash of a node is the polynomial hash of the subarray it corresponds to Now in order to use the same technique on the path we want the frequency array of the path To achieve this we can use persistent segment trees We define to be the segment tree that corresponds to the frequency array of the values on the path With the idea of persistence we can quickly compute for all when we root at To compute we can use this for every node in the segment tree that we want Hence we are able to get the segment tree for the two paths we need to compare in a query In our solution with the static arrays we used the polynomial hash to find the first point of difference between the two frequency arrays So we need a way to quickly compute the hash of the pseudo node we computed for If we have two frequency arrays where the hash of a node is the polynomial hash of the subarray that corresponds to that node Hence we can say Hence we can perform the same descent that we talked about earlier on the derived segment tree Now to solve this for you can perform a dfs on and keep entering nodes of the segment tree which have differing hashes until we find values The total time complexity comes out to "}
{"statement": "There is a one dimensional grid of length n The i th cell of the grid contains a character s i which is either or When a pinball is placed on one of the cells it moves according to the following rules If the pinball is on the i th cell and s i is the pinball moves one cell to the left in the next second If s i is it moves one cell to the right After the pinball has moved the character s i is inverted i e if s i used to be it becomes and vice versa The pinball stops moving when it leaves the grid either from the left border or from the right one You need to answer n queries In the i th query a pinball will be placed on the i th cell Note that we always place a pinball on the initial grid For each query calculate how many seconds it takes the pinball to leave the grid It can be shown that the pinball will always leave the grid within a finite number of steps ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "We observe that in fact only the to the left of and the to the right of change the direction of the pinball placed at position initially For convenience let s assume is and the pinball leaves from the left boundary for other situations we can handle them in a similar way We can obtain and through prefix sum binary search where represents the indices of to the left of in decreasing order and represents the indices of to the right of in increasing order We use and to describe the trace of the pinball The first segment the pinball moves from to The second segment the pinball moves from to The third segment the pinball moves from to The th segment the pinball moves from to the left boundary It is not difficult to observe that we can use prefix sum to store the sum of indices and then quickly calculate the time when the pinball moves "}
{"statement": "Emuskald was hired to design an artificial waterfall according to the latest trends in landscape architecture A modern artificial waterfall consists of multiple horizontal panels affixed to a wide flat wall The water flows down the top of the wall from panel to panel until it reaches the bottom of the wall The wall has height and has panels on the wall Each panel is a horizontal segment at height which begins at and ends at The th panel connects the points and of the plane The top of the wall can be considered a panel connecting the points and Similarly the bottom of the wall can be considered a panel connecting the points and No two panels share a common point Emuskald knows that for the waterfall to be aesthetically pleasing it can flow from panel to panel only if the following conditions hold horizontal projections of the panels overlap panel is below panel there is no such panel that the first two conditions hold for the pairs and Then the for is equal to the length of their horizontal projection overlap Emuskald has decided that in his waterfall the water will flow in a single path from top to bottom If water flows to a panel except the bottom of the wall the water will fall further to lower panel The total amount of water flow in the waterfall is then defined as the minimum horizontal projection overlap between two consecutive panels in the path of the waterfall Formally the waterfall consists of a single path of panels the flow of the waterfall is the minimum flow in the path To make a truly great waterfall Emuskald must maximize this water flow but there are too many panels and he is having a hard time planning his creation Below is an example of a waterfall Emuskald wants Help Emuskald maintain his reputation and find the value of the maximum possible water flow ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 1, "problem_dificulty": "2600", "problem_editorial": "We will use a sweepline algorithm to solve this task This horizontal sweepline runs from bottom to top and holds the parts of the segments that are visible from the line this sweepline is currently at Each part also holds the reference to its original segment The sweepline itself is implemented with a binary search tree The events of the sweep are the segments When a new segment is found we want to find all the lower segments that we can direct the flow onto from this segment These can be only the original segments of the parts currently in the sweepline whose projections overlap with this segment Then we iterate over all such parts p finding the first such part is an operation How do we know that we can direct the flow onto p Observe that if there is some segment that prevents this there should be also a part q in the sweepline that also can be seen from the current segment And since the projections of all three segments overlap this part can only be directly to the left or to the right of p in the binary search tree So we just check whether the original segments of the two parts next to p prevent the flow from the current segment to the original segment of p Afterwards we remove all such parts from the sweepline and insert a new part corresponding to the new segment If the new segment only partially covered an existing part we reinsert the remaining portion of that part There are at most two such portions one on each side of the segment Thus each segment inserts at most 3 new parts and the size of the sweepline is O n Each part is handled just once before removal so the total time of such operations is Once we know we can direct the flow through we can immediately update the maximum downwards flow of a fa max fa min fb min ra rb max la lb When we reach the top ftop will be the answer "}
{"statement": "Luba needs your help again Luba has TV sets She knows that th TV set will be working from moment of time till moment inclusive Luba wants to switch off one of TV sets in order to free the socket Let s call some TV set if after switching it off the number of moments of time when at least one of TV sets is working won t decrease Luba will be very upset if she has to switch off a non TV set Help Luba by telling her the index of some TV set If there is no any print ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Firstly let s compress the moments of time Note that storing only and isn t enough consider pairs and you also should take Now moments of time are up to For every moment calculate the number of segments to cover it make and for each segment and take prefix sums over this array Then let be the number of moments of time covered by only one segment on some prefix up to th moment And finally if for some segment from the input is then you can safely delete this segment Overall complexity "}
{"statement": "Sakurako really loves She calls a string s of lowercase Latin letters an if characters in the even positions are the same if characters in the odd positions are the same and the length of the string is For example the strings and are while the strings and are not As a good friend you decided to gift such a string but you couldn t find one Luckily you can perform two types of operations on the string Choose an index i and delete the i th character from the string which will reduce the length of the string by 1 This type of operation can be performed Choose an index i and replace s i with any other letter Since you are in a hurry you need to determine the minimum number of operations required to make the string an one ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Firstly since first operation can be used at most 1 time we need to use it only when string has odd length Let s assume that the string has even length then we can look at characters on odd and even positions independently So if we change all characters on even positions to the character that which is occurs the most Same goes to the characters on the odd position Now we have case where we need to delete one character We can make prefix sum on even positions let s call number of on such even and prefix sum on odd position let s call it Definition same as for but with odd instead of even suffix sum on even positions let s call it and definition same as but with instead of and suffix sum on odd positions let s call it and definition same as but with instead of If we delete character on index our string after shift right and changes parity for all indeces bigger then so to find how many characters there are on even positions after deleting index is Using this we can try to delete each character independently and solve the task as it has even length "}
{"statement": "YunQian is standing on an infinite plane with the Cartesian coordinate system on it In one move she can move to the diagonally adjacent point on the top right or the adjacent point on the left That is if she is standing on point x y she can either move to point x 1 y 1 or point x 1 y YunQian initially stands at point a b and wants to move to point c d Find the minimum number of moves she needs to make or declare that it is impossible ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Hint 1 The value of is always non decreasing and the value of is always non increasing It is possible to move from to if and only if and since the value of is always non decreasing and the value of is always non increasing If it is possible the answer is One possible way is Another way to understand this is always a valid path if it is possible to move from to So first let and then the answer only depends on and "}
{"statement": "A ticket is a string consisting of six digits A ticket is considered lucky if the sum of the first three digits is equal to the sum of the last three digits Given a ticket output if it is lucky or not Note that a ticket can have leading zeroes ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "We need to check if the sum of the first three digits is equal to the sum of the last three digits This is doable by scanning the input as a string then comparing the sum of the first three characters with the sum of the last three characters using the if statement and the addition operation "}
{"statement": "Some company is going to hold a fair in Byteland There are n towns in Byteland and m two way roads between towns Of course you can reach any town from any other town using roads There are k types of goods produced in Byteland and every town produces only one type To hold a fair you have to bring at least s different types of goods It costs d u v coins to bring goods from town u to town v where d u v is the length of the shortest path from u to v Length of a path is the number of roads in this path The organizers will cover all travel expenses but they can choose the towns to bring goods from Now they want to calculate minimum expenses to hold a fair in each of n towns ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1600", "problem_editorial": "Let s find a cost to bring a good in each town To do this we will run BFS from all towns producing good at once Just add all that towns in queue and run usual BFS Complexity of BFS is so total complexity of BFSs will be Now for each town we should choose cheapest goods We can sort them in but we can use nth element instead It will put the th element in sorted order on place and all elements smaller will be to the left Since we are interested only in their sum we can just sum up first elements after calling nth element Another way to achieve complexity is to run all BFSs simultaneously then for each town first goods to reach it are the cheapest Bonus solve the problem in time "}
{"statement": "You have n sticks of the given lengths Your task is to choose exactly four of them in such a way that they can form a rectangle No sticks can be cut to pieces each side of the rectangle must be formed by a single stick No stick can be chosen multiple times It is guaranteed that it is always possible to choose such sticks Let S be the area of the rectangle and P be the perimeter of the rectangle The chosen rectangle should have the value frac P 2 S minimal possible The value is taken without any rounding If there are multiple answers print any of them Each testcase contains several lists of sticks for each of them you are required to solve the problem separately ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s work with the formula a bit Let then the formula becomes Considering thus is strictly increasing and has its minimum at So the solution will be to sort the list extract the pairs of sticks of equal length and check only neighbouring pairs in sorted order for the answer Overall complexity "}
{"statement": "Little C loves number very much He loves all things about it Now he is playing a game on a chessboard of size n times m The cell in the x th row and in the y th column is called x y Initially The chessboard is empty Each time he places two chessmen on two different empty cells the Manhattan distance between which is exactly 3 The Manhattan distance between two cells x i y i and x j y j is defined as x i x j y i y j He want to place as many chessmen as possible on the chessboard Please help him find the maximum number of chessmen he can place ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Following the rules in the problem the and grids full of chessmen can be easily constructed How to construct Let the number denote the time when the chessman placed Grids of 1 2 3 1 2 3Grids of 1 2 3 43 4 1 2Grids of 1 3 2 1 52 4 5 3 4Grids of 1 3 4 25 2 1 56 4 3 6Assume that Consider the following cases If obviously the answer is If only the and grids cannot be completely constructed The others can be constructed by using the and constructed by two grids girds How to prove that they cannot be constructed You can write a brute force or enumerate all the possibilities by yourself If you consider each grid from left to right and choose the grid it matched with there are only several possible conditions So I think it can be proved in several minutes If the following things we can consider We know that using the and grids we can construct the grid and using several grids we can construct the grid so using the and grids we can construct the grid while and is an even number Therefore we only need to consider the grid that and are both odd numbers Since is an odd integer we can place chessmen at most so we try to reach the maximum Then we can easily construct the and grids that have only one empty grid According to the above mentioned conclusions any grids can be reduce to one of the three grids by using some or is even grids The maximum is reached How to construct Grids of 1 2 33 0 44 1 2Grids of 1 3 4 6 72 5 1 0 53 4 2 7 6Grids of 1 2 3 1 23 4 5 6 45 6 7 8 910 8 9 12 711 12 10 11 0It seems that the chessboard is a little bit big but you can match them arbitrarily and get correct solution with a big possibility "}
{"statement": "Tokitsukaze has a permutation p of length n Let s call a segment l r beautiful if there exist i and j satisfying p i cdot p j max p l p l 1 ldots p r where l leq i j leq r Now Tokitsukaze has q queries in the i th query she wants to know how many beautiful subsegments x y there are in the segment l i r i i e l i leq x leq y leq r i ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "TutorialLet s sort the queries with in ascending order Let s move from to and answer queries when Use segment tree to solve this problem each leaf node in the segment tree maintenance the number that how many intervals are beautiful then answering queries is to get sum Use monotone stack to maintain the maximum number When moving one step right the monotone stack will pop some and push one Let s think about the number in monotone stack which means the maximum number of the intervals is If there exist a in which satisfies then before is poped intervals are beautiful So we can assume that will not be poped when it is pushed in the monotone stack and do something like difference algorithm in the segment tree by using the current as the time stamp Each node in the segment tree has to maintain which like a linear function So when moving right step let s enumerate the factor of to update old intervals in monotone stack enumerate the multiple of to update the new interval in monotone stack and update the intervals which are poped Time complexity "}
{"statement": "While playing yet another strategy game Mans has recruited n Swedish heroes whose powers which can be represented as an array a Unfortunately not all of those mighty heroes were created as capable as he wanted so that he decided to do something about it In order to accomplish his goal he can pick two consecutive heroes with powers a i and a i 1 remove them and insert a hero with power a i a i 1 back in the same position For example if the array contains the elements 5 6 7 8 he can pick 6 and 7 and get 5 6 7 8 5 13 8 After he will perform this operation n 1 times Mans will end up having only one hero He wants his power to be as big as possible What s the largest possible power he can achieve ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Idea and solution flaviu2001 Sneaky corner caseBefore you try to find patterns you should observe that there is one case that is impossible to reach You cannot assign alternating and to the array like or The reason is very simple the very first thing you do is apply the operation on two consecutive numbers and make them both and whenever you apply further operations on the both of them they remain the same sign In the end we decided to give this in the samples but we know from testing many would miss this case "}
{"statement": "There is a beautiful garden of stones in Innopolis Its most beautiful place is the n piles with stones numbered from 1 to n EJOI participants have visited this place twice When they first visited it the number of stones in piles was x 1 x 2 ldots x n correspondingly One of the participants wrote down this sequence in a notebook They visited it again the following day and the number of stones in piles was equal to y 1 y 2 ldots y n One of the participants also wrote it down in a notebook It is well known that every member of the EJOI jury during the night either sits in the room 108 or comes to the place with stones Each jury member who comes there either takes one stone for himself or moves one stone from one pile to another We can assume that there is an unlimited number of jury members No one except the jury goes to the place with stones at night Participants want to know whether their notes can be correct or they are sure to have made a mistake ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "It can be simply showed that the answer is if and only if the sum in the first visit is not less than the sum in the second visit "}
{"statement": "Mike received an array a of length n as a birthday present and decided to test how pretty it is An array would pass the i th prettiness test if there is a way to get an array with a sum of elements totaling s i using some number possibly zero of slicing operations An array slicing operation is conducted in the following way assume mid lfloor frac max array min array 2 rfloor where max and min are functions that find the maximum and the minimum array elements In other words mid is the sum of the maximum and the minimum element of array divided by 2 rounded down Then the array is split into two parts mathit left and right The mathit left array contains all elements which are less than or equal mid and the right array contains all elements which are greater than mid Elements in mathit left and right keep their relative order from array During the third step we choose which of the mathit left and right arrays we want to keep The chosen array replaces the current one and the other is permanently discarded You need to help Mike find out the results of q prettiness tests Note that you test the prettiness of the array a so you start each prettiness test with the primordial initial array a Thus the first slice if required is always performed on the array a ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "To begin with you can notice that the cut operation does not depend on the order of the array So we can sort it Now let s build a tree of transitions from the original array to all its possible states You can simply prove that the height of this tree does not exceed Since after each operation of the section is reduced at least twice Having understood this we can write a simple recursive search over the states The state will describe a sub segment of the array that is the current array For each state we can calculate the current amount on the segment from left to right and add it to any convenient collection set HashSet Next to respond to requests we can simply look at our collected collection "}
{"statement": "You are given a tree consisting of vertices numbered from to Initially all vertices are white You have to process queries of two different types change the color of vertex to black It is guaranteed that the first query will be of this type for the vertex find the minimum index such that the vertex with index belongs to the simple path from to some black vertex a simple path never visits any vertex more than once For each query of type print the answer to it ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2500", "problem_editorial": "After the first query make the vertex that we painted black the root of the tree and for each other vertex calculate the minimum index on the path to the root This can be done by simple DFS Then suppose we are painting some vertex black In can easily proved that for every vertex and every vertex that is on a path form to the root there exists a path from to some black vertex coming through So we have to store the minimum index among all vertices such that belongs to the path from the root to some black vertex it is a global value let s call it and the answer to every query of type is just the minimum of the value we calculated in DFS and To update quickly after painting vertex black we ascend from to the root until we arrive to some node that was visited during previous queries and we stop there because this node and all nodes on the path from it to the root were used to update in previous queries This solution works in time "}
{"statement": "Polycarp urgently needs a shovel He comes to the shop and chooses an appropriate one The shovel that Policarp chooses is sold for burles Assume that there is an unlimited number of such shovels in the shop In his pocket Polycarp has an unlimited number of 10 burle coins and exactly one coin of burles What is the minimum number of shovels Polycarp has to buy so that he can pay for the purchase without any change It is obvious that he can pay for 10 shovels without any change by paying the requied amount of 10 burle coins and not using the coin of burles But perhaps he can buy fewer shovels and pay without any change Note that Polycarp should buy at least one shovel ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "In this problem we have to find the minimal possible value of such that or It s easy to see that this always exists and it is not greater than because Let s iterate on and if its current value satisfies any of the requirements we print the answer Time complexity where "}
{"statement": "She is skilled in all kinds of magics and is keen on inventing new one Patchouli is making a magical talisman She initially has n magical tokens Their magical power can be represented with integers a 1 a 2 ldots a n Patchouli may perform the following two operations on the tokens Patchouli chooses two tokens removes them and creates a new token with magical power equal to the sum of the two chosen tokens Patchouli chooses a token with an value of magical power x removes it and creates a new token with magical power equal to frac x 2 Tokens are more effective when their magical powers are values Please help Patchouli to find the minimum number of operations she needs to make magical powers of all tokens values ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "SolutionLet be the maximum integer satisfying A greedy solution is to make one integer odd integer and plus it to other even integers Let be the answer of an sequence We can find that It can be shown that it is the optimal strategy We can prove that decreases by at most with one operation For the first operation assuming we choose and let Obviously holds so decreases by at most and does not decrease So decreases by at most For the second operation assuming we choose If decreases by and remains unchanged Otherwise does not change and decreases by at most So decreases by at most We can draw a conclusion that decreases by at most after one operation Since are odd integers the strategy is proved to be optimal The time complexity is "}
{"statement": "You are given a positive integer n greater or equal to 2 For every pair of integers a and b 2 le a b le n you can transform a into b if and only if there exists an integer x such that 1 x and a cdot x b or b cdot x a where x denotes the absolute value of x After such a transformation your score increases by x points and you are to transform a into b nor b into a anymore Initially you have a score of 0 You can start at any integer and transform it as many times as you like What is the maximum score you can achieve ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "For every integer let s call the set of integers that are able to be transformed into As you can see if could be transformed into then could also be transformed into Therefore is always even Let s build a graph consists of nodes numbered through except for and There is an weighted undirected edge between node and if and only if can be transformed into The weight of the edge is the score of the transformation Every node in the graph has an even degree so you can split the graph into some connected components so that each components is an Euler circuit a circuit that contains all the edges Therefore you just need to find all those Euler circuits and maximize your score Moreover you can see that if an integer can be transformed into then and are in the same component Proof Suppose there exists an integer If then it is proved otherwise there exists an integer and are in the same component so and are also in the same component Therefore if we ignore all the nodes that have no edges attached to it the graph will be connected So you need to simply get the sum of all the weights of the edges The complexity is since the number of edges can go up to "}
{"statement": "Little Vasya had boxes with balls in the room The boxes stood in a row and were numbered with numbers from 1 to from left to right Once Vasya chose one of the boxes let s assume that its number is took all balls out from it it is guaranteed that this box originally had at least one ball and began putting balls one at a time to the boxes with numbers and so on If Vasya puts a ball into the box number then the next ball goes to box the next one goes to box and so on He did it until he had no balls left in his hands It is possible that Vasya puts multiple balls to the same box and it is also possible that one or more balls will go to the box number If Vasya puts the first ball into the box number then the next ball goes to box and so on For example let s suppose that initially Vasya had four boxes and the first box had balls the second one had the third one had and the fourth one had balls Then if then Vasya will take all five balls out of the third box and put them in the boxes with numbers After all Vasya s actions the balls will lie in the boxes as follows in the first box there are balls in the second one in the third one and in the fourth one At this point Vasya has completely forgotten the original arrangement of the balls in the boxes but he knows how they are arranged now and the number the number of the box where he put the last of the taken out balls He asks you to help to find the initial arrangement of the balls in the boxes ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Firstly describe simple solution We will get by one ball from boxes we begin from box from right to left action back At some moment there will be balls in current box This box is the first box in our initial problem from which we took all balls and begun to put In this box we put all balls which we get from all boxes But we can t solve the problem in such a way because it is too long Note that before we meet the situation when in some box will be balls we will go through every element of array several times and subtract So we can make our solution faster We can subtract from every element of array where minimum in array After that you should do operations that were mentioned above "}
{"statement": "Phoenix is picking berries in his backyard There are n shrubs and each shrub has a i red berries and b i blue berries Each basket can contain k berries But Phoenix has decided that each basket may only contain berries from the same shrub or berries of the same color red or blue In other words all berries in a basket must be from the same shrub or and have the same color For example if there are two shrubs with 5 red and 2 blue berries in the first shrub and 2 red and 1 blue berries in the second shrub then Phoenix can fill 2 baskets of capacity 4 completely the first basket will contain 3 red and 1 blue berries from the first shrub the second basket will contain the 2 remaining red berries from the first shrub and 2 red berries from the second shrub Help Phoenix determine the maximum number of baskets he can ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "There is no obvious greedy solution so we will try dynamic programming Let be a boolean array that denotes whether we can have extra red berries after considering the first shrubs A berry is extra if it is not placed into a full basket of any kind Note that if we know that there are extra red berries we can also easily calculate how many extra blue berries there are Note that we can choose to never have more than extra red berries because otherwise we can fill some number of baskets with them To transition from shrub to shrub we loop over all possible values from to and check whether or not we can leave extra red berries from the current shrub For some and we can leave extra red berries and put the remaining red berries in baskets possibly with blue berries from the same shrub if The reasoning for this is as follows First of all we are leaving red berries or at least trying to We show that from this shrub there will be at most one basket containing both red and blue berries all from this shrub To place the remaining red berries into full baskets the more blue berries we have the better It is optimal to place the remaining red berries into their own separate baskets first before merging with the blue berries this way requires fewest blue berries to satisfy the condition Then if is at least we can fill some basket with the remaining red berries and possibly some blue berries Remember that we do not care about how many extra blue berries we leave because that is uniquely determined by the number of extra red berries Also note that we can always leave extra red berries Denote the total number of berries as The answer will be maximum over all such that is true Time Complexity We use dynamic programming Let be true if after considering the first shrubs is the number of red berries in heterogenous baskets modulo Heterogenous baskets contain berries from the same shrub and homogenous baskets contain berries of the same type Suppose we know the number of red berries in heterogeneous baskets modulo This determines the number of blue berries in heterogeneous baskets modulo Since the number of red berries in homogeneous baskets is a multiple of it also determines the number of red berries not in any baskets we can safely assume this to be less than since otherwise we can form another basket Similarly we can determine the number of blue berries not in any basket and thus deduce the number of baskets To compute the possible numbers of red berries in heterogeneous baskets modulo it suffices to look at each shrub separately and determine the possible numbers of red berries modulo in heterogeneous baskets for that shrub If there is more than one heterogeneous basket for one shrub we can rearrange the berries to leave at most one heterogeneous Now we have two cases If there are no heterogeneous baskets the number of red berries in those baskets is obviously zero If there is one heterogeneous basket let be the number of red berries in it and be the number of blue berries in it Clearly and Rearranging we get These correspond to the transitions for our DP There exists faster solutions like can you find it "}
{"statement": "You are given two huge binary integer numbers a and b of lengths n and m respectively You will repeat the following process if b 0 then add to the answer the value a b and divide b by 2 rounding down i e remove the last digit of b and repeat the process again otherwise stop the process The value a b means bitwise of a and b Your task is to calculate the answer modulo 998244353 Note that you should add the value a b to the answer in decimal notation not in binary So your task is to calculate the answer in decimal notation For example if a 1010 2 10 10 and b 1000 2 8 10 then the value a b will be equal to 8 not to 1000 ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "To solve this problem let s take a look which powers of in will be affected by powers of in Firstly let s reverse numbers Let s carry the current power of let it be the current sum of powers of in from the position to the current position inclusive let it be and the answer is Initially and Let s iterate over all bits of from to Let the current bit in have the number Firstly if and then set in other words we add to the sum of powers of in the current power of If then this bit will add to the answer all the powers of in from to inclusive in other words so if it is then set And after all we can set and go on to And don t forget to take all values modulo to avoid overflow "}
{"statement": "Shohag has a tree with n nodes Pebae has an integer m She wants to assign each node a value an integer from 1 to m So she asks Shohag to count the number modulo 998 244 353 of assignments such that following conditions are satisfied For each pair 1 le u lt v le n the least common multiple LCM of the values of the nodes in the unique simple path from u to v is divisible by the number of nodes in the path The greatest common divisor GCD of the values of all nodes from 1 to n is 1 But this problem is too hard for Shohag to solve As Shohag loves Pebae he has to solve the problem Please save Shohag ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "Let s say we assign to the node Let be the maximum length of a simple path that passes through Then a necessary condition is that can not be a multiple of any number Because if is a multiple of and is a node such that the unique simple path from to has length then the LCM of the values of the nodes from to is a multiple of which is a contradiction The condition also means that can not be a multiple of any prime number Is this a sufficient condition Yes and the proof is also simple So now the problem is to count the number of assignments such that for each node is not a multiple of any prime number and Let be the count of numbers from to that are not divisible by any prime be the diameter of the tree A number is good if is not divisible by any prime be the Mobius function be the number of primes Then the answer to our problem is As is a non decreasing function and has at most distinct values we can iterate over and calculate range sums of For calculating prefix sums of a multiplicative function like it s a standard task and can be solved using Dirichlet convolution Min25 sieve or multiple other methods Here we need a slight variant of the method as we need the prefix sums of This can be achieved using Dirichlet convolution in if we just imagine the prime numbers do not exist in the number system Refer to my code for more details But for each fixed how do we calculate fast enough Trivially doing it will make the total complexity around which is too slow The key observation is to not forget that the values of are not random they are the maximum length of a simple path that passes through the node So for all because from each node the endpoints of the diameter are at least away So now consider two cases In this case all for all So only primes or are the good numbers So instead of going with the mobius route we can just directly solve it by calculating the total number of ways and subtracting the number of ways where the gcd is a prime We can calculate the total number of ways by first calculating the number of primes and then is just And the number of ways where the gcd is a prime is just for all primes and otherwise Counting primes under is also a standard task and can be done in or faster We can convert each to the maximum prime and then group by their values Then the maximum number of groups will be So for each fixed if the sum of the mobius function in the range is non zero keep in mind that when all numbers in the range are bad numbers then the sum will definitely be then we can calculate the product of directly Then the upper bound of the complexity will be around The proof will be added later This works fast enough "}
{"statement": "Bob has a grid with 3 rows and n columns each of which contains either a i or a i for some integer 1 leq i leq n For example one possible grid for n 4 is shown below begin bmatrix a 1 a 2 a 3 a 2 a 4 a 4 a 1 a 3 a 1 a 2 a 2 a 4 end bmatrix Alice and Bob play a game as follows Bob shows Alice his grid Alice gives Bob an array a 1 a 2 dots a n of her choosing Bob substitutes these values into his grid to make a grid of 1s and 1s Bob the elements of each column in non decreasing order Alice wins if all the elements in the middle row are 1 otherwise Bob wins For example suppose Alice gives Bob the array 1 1 1 1 for the grid above Then the following will happen colors are added for clarity begin bmatrix color red a 1 color green a 2 color blue a 3 color green a 2 a 4 a 4 color red a 1 color blue a 3 color red a 1 color green a 2 color green a 2 a 4 end bmatrix xrightarrow color red 1 color green 1 color blue 1 1 begin bmatrix color red 1 color green 1 color blue 1 color green 1 1 1 color red 1 color blue 1 color red 1 color green 1 color green 1 1 end bmatrix xrightarrow text sort each column begin bmatrix 1 1 1 1 mathbf 1 mathbf 1 mathbf 1 mathbf 1 1 1 1 1 end bmatrix Since the middle row is all 1 Alice wins Given Bob s grid determine whether or not Alice can choose the array a to win the game ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "The problem statement is somewhat reminiscent of SAT Indeed treating as true and as false we have clauses of length and we need at least of the variables to be true We can reduce this to 2 SAT with the following observation at least of are true at least one of is true at least one of is true and at least one of is true That is for each column of the grid we make three 2 SAT clauses Then we just run 2 SAT on these clauses and output if there is a solution The time complexity is per test case It might be time consuming to code 2 SAT during the contest so we recommend using some standard library for example our solution uses AtCoder library "}
{"statement": "You came to a local shop and want to buy some chocolate bars There are n bars in the shop i th of them costs a i coins and you want to buy all of them You have m different coupons that allow you to buy chocolate bars i th coupon allows you to buy q i chocolate bars while you have to pay only for the q i 1 most expensive ones so the cheapest bar of those q i bars is for free You can use only one coupon if you use coupon i you have to choose q i bars and buy them using the coupon and buy all the remaining n q i bars without any discounts To decide which coupon to choose you want to know what will be the minimum total amount of money you have to pay if you use one of the coupons optimally ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "When using th coupon the bar we get for free should have at least bars not cheaper than it So if we consider sorted in non decreasing order then we cannot get discount greater than On the other hand we can always get such a discount if we pick most expensive bars to buy using the th coupon "}
{"statement": "You are given an array a of n numbers There are also q queries of the form s d k For each query q find the sum of elements a s a s d cdot 2 dots a s d cdot k 1 cdot k In other words for each query it is necessary to find the sum of k elements of the array with indices starting from the s th taking steps of size d multiplying it by the serial number of the element in the resulting sequence ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "The key idea is that we know how to calculate the sum for fast we need to calculate all prefix sums and for then take the difference between the th and th of and subtract the difference between the th and th multiplied by This way queries with step will be processed in time where is the total amount of queries with step 1 But this idea can be generalized to the following we can precalculate all the prefix sums and all the prefix sums with multiplication by index for every in time and then process all queries with step in time However for all other queries we can process a single query in time because the difference between consecutive elements in the resulting sequence is greater than Combining these two ideas we get a solution with a time complexity Setting we get a solution with a time complexity The model solution fixes the value of which is equal to Interestingly this solution can be generalized to calculate the sums "}
{"statement": "We ve got a rectangular cell maze Each cell is either passable or is a wall impassable A little boy found the maze and cyclically tiled a plane with it so that the plane became an infinite maze Now on this plane cell is a wall if and only if cell is a wall In this problem is a remainder of dividing number by number The little boy stood at some cell on the plane and he wondered whether he can walk infinitely far away from his starting position From cell he can go to one of the following cells and provided that the cell he goes to is not a wall ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2000", "problem_editorial": "Answer is Yes iff there are two distinct reachable from start position cells which correspond to same cell in initial labyrinth Proof If these cells exist move to first of them and infinitely repeat moves leading from first to second On the contrary if infinite far path exist on this path we obviously can find such cells How to find out if they exist Start DFS from initial cell For each cell visited let Now if DFS tries to go to cell contains something and we found these cells they are and Notice that DFS will visit no more than cells Dirichlet s principle So the asymptotic is "}
{"statement": "Barbara was late for her math class so as a punishment the teacher made her solve the task on a sheet of paper Barbara looked at the sheet of paper and only saw n numbers a 1 a 2 ldots a n without any mathematical symbols The teacher explained to Barbara that she has to place the available symbols between the numbers in a way that would make the resulting expression s value as large as possible To find out which symbols were available the teacher has given Barbara a string s which contained that information It s easy to notice that Barbara has to place n 1 symbols between numbers in total The expression must start with a number and all symbols must be allowed i e included in s Note that multiplication takes precedence over addition or subtraction addition and subtraction have the same priority and performed from left to right Help Barbara and create the required expression ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "First let s solve the problem without the multiplication sign It is always beneficial for us to put a plus or a minus if there is no plus sign Now we will solve the problem when there is a sign to multiply The case when the plus sign is missing is very easy to solve We put the sign to multiply to the first zero then we put a minus sign in front of the zero and after the multiplication signs Let s consider the case when there is a plus sign and multiply Note that it is never beneficial for us to use the minus sign If there are zeros in the expression then we simply put plus signs between them and the expressions are split into other independent expressions Now you need to be able to solve an expression that has no zeros To begin with we take out all units at the beginning and at the end separately with plus signs The following solution is now proposed If the product of numbers is greater than or equal to then it is beneficial for us to put the multiplication sign everywhere Otherwise we can use dynamic programming because the number of numbers greater than one is no more than Dynamic programming will be one dimension is the most profitable answer if you put signs on the prefix Let us now stand at and want to go to this means that between the numbers at the th and th positions there will be a sign to multiply and after the th position there will be a sign a plus "}
{"statement": "Misuki has chosen a secret tree with n nodes indexed from 1 to n and asked you to guess it by using queries of the following type Misuki will tell you which node x minimizes d a x d b x where d x y is the distance between nodes x and y If more than one such node exists Misuki will tell you the one which minimizes d a x Find out the structure of Misuki s secret tree using at most 15n queries ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "It s easy to verify that querying a and b will return the midpoint of the path between a and b In case the path has odd length the node closer to a of the two central nodes will be returned We will now construct the tree by expanding a connected component Let A 1 and B 2 ldots n While B is not empty choose any b in B and a in A Let P be the path between a and b By construction P will consist of a prefix contained in A and a suffix contained in B We can binary search for the first i such that P i in B This will take at most lceil log P rceil 2 queries Then P i 1 P i will be an edge of the tree so we will set A A cup P i and B B backslash P i The total number of queries will be smaller than n lceil log n rceil 2n 12000 "}
{"statement": "Eikooc and Sushi play a game The game is played on a tree having n nodes numbered 1 to n Recall that a tree having n nodes is an undirected connected graph with n 1 edges They take turns alternately moving a token on the tree on any node of her choice Sushi makes the next move followed by Eikooc followed by Sushi and so on In each turn after the first a player must move the token to a node u such that u is adjacent to the node v the token is currently on u has not been visited before u oplus v leq min u v Here x oplus y denotes the bitwise XOR operation on integers x and y Both the players play optimally The player who is unable to make a move loses The following are examples which demonstrate the rules of the game Before the game begins Eikooc decides to sneakily relabel the nodes of the tree in her favour Formally a relabeling is a permutation p of length n sequence of n integers wherein each integer from 1 to n occurs exactly once where p i denotes the new numbering of node i She wants to maximize the number of nodes she can choose in the first turn which will guarantee her a win Help Eikooc find any relabeling which will help her do so ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "If the most significant bits MSBs of two integers and are the same say then the th bit will be unset in Since will have this bit set it will be greater than Thus if then If a node in the tree is adjacent only to nodes whose MSB differs from its MSB then the player who plays this node will win It turns out that not only is it always possible to make it such that no two nodes sharing an edge have the same MSB it is also necessary to do so in order to maximize the number of winnning starting nodes for Eikooc Consequently starting at any node will guarantee a win for her Assume there exists at least two nodes in the tree that are adjacent to each other having the same MSB We prove that there will be at least one losing node for Eikooc to start on which is suboptimal Consider a connected component of nodes in the tree of size at least two all having the same MSB Since this connected component also forms a tree it must have at least one leaf node Any node in the component which is adjacent to at least one of these leaf nodes will be losing for Eikooc since Sushi can just move the token to a leaf node and Eikooc will have no moves to play We aim to relabel the nodes of the tree in such a way that for every node in the tree and all nodes adjacent to it Think bipartite In the bipartite colouring of a tree no two adjacent nodes have the same colour If we are able to relabel the nodes in such a way that all nodes with the same MSB belong to the same colour we are done There are occurrences of integers from to with the th bit as MSB 0 indexed for each from to and all such groups of integers are disjoint since each integer has exactly one MSB Let the number of white and black nodes be and respectively and WLOG let we can swap the colours otherwise Since all nodes are coloured either white or black Under these constraints it is then easy to show that Consequently Since can possibly only have those bits set which lie in the range Can you connect the dots Consider the binary representation of We can assign all integers from to having the th bit as MSB to a white node if the th bit is set in and assign all the remaining integers to black nodes In doing so no two nodes having the same MSB will belong to different colours This ensures that no such pair is adjacent This is also guaranteed to always be possible since the binary representation of only spans the first bits and we also have access to groups of sizes comprising all powers of two upto "}
{"statement": "Today at the lesson of mathematics Petya learns about the digital root The digital root of a non negative integer is the single digit value obtained by an iterative process of summing digits on each iteration using the result from the previous iteration to compute a digit sum The process continues until a single digit number is reached Let s denote the digital root of x as S x Then S 5 5 S 38 S 3 8 11 S 1 1 2 2 S 10 S 1 0 1 1 As a homework Petya got n tasks of the form find k th positive number whose digital root is x Petya has already solved all the problems but he doesn t know if it s right Your task is to solve all n tasks from Petya s homework ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "The key observation is that the digital root of an integer is the single digit number such that You can prove this by noticing that for all Once we observe this finding the th number is very simple see the code 48993705 "}
{"statement": "Given an integer find two permutations Permutation of numbers from 1 to such that and for all Permutation of numbers from 1 to such that and for all is the bitwise AND operation ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "If is odd the answer is NO Indeed any number in odd numbered position must be even otherwise the last bit of is 1 For odd there are less even numbers than odd numbered positions so at least one of the positions will hold an odd number thus it s impossible to construct a required permutation If is even the required permutation exists To build it first observe that For example for and so on We can use this fact to always match and with each other that is set and The full procedure for constructing the required permutation is as follows For a given even find the maximum power of two that is less than or equal to Match pairs of numbers and for each If we are not done yet numbers from to are still unmatched Repeat the process for For example for on the first step we set and match numbers 15 16 14 17 and 13 18 On the second step unmatched numbers are from 1 to 12 so we set and match numbers 7 8 6 9 5 10 4 11 and 3 12 On the third and the last step the remaining unmatched numbers are 1 and 2 so we set and match numbers 1 and 2 with each other After this no unmatched numbers are left and we are done We can do a simple case analysis for manually noticing that the answer is NO for a possible answer for is textbf 3 6 2 5 1 4 as given in problem statement and a possible answer for is textbf 7 3 6 5 1 2 4 If is a power of two then it is represented in binary as We must have therefore so the binary representation of is shorter than that of It follows that so the answer is NO in this case Finally if and is not a power of two the required permutation always exists and can be built in the following way Split all numbers from 1 to into the following groups is the largest power of two which is still less than 1 7 8 15 16 31 ldots For the first group use the permutation that we found manually For each of the remaining groups use any permutation of numbers in this group for example a cyclic permutation The numbers in each group have leading non zero bit at the same position which corresponds to the power of two at the beginning of the group so it is guaranteed that contains a non zero bit at least in that position "}
{"statement": "Every summer Vitya comes to visit his grandmother in the countryside This summer he got a huge wart Every grandma knows that one should treat warts when the moon goes down Thus Vitya has to catch the moment when the moon is down Moon cycle lasts 30 days The size of the visible part of the moon in Vitya s units for each day is and then cycle repeats thus after the second again goes As there is no internet in the countryside Vitya has been watching the moon for consecutive days and for each of these days he wrote down the size of the visible part of the moon Help him find out whether the moon will be up or down next day or this cannot be determined by the data he has ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "There are four cases that should be carefully considered an 15 the answer is always DOWN an 0 the answer is always UP If n 1 the answer is 1 If n 1 then if an 1 an answer is DOWN else UP "}
{"statement": "Recently Maxim has found an array of integers needed by no one He immediately come up with idea of changing it he invented positive integer and decided to add or subtract it from arbitrary array elements Formally by applying single operation Maxim chooses integer and replaces the th element of array either with or with Please note that the operation may be applied more than once to the same position Maxim is a curious minimalis thus he wants to know what is the minimum value that the product of all array elements i e can reach if Maxim would apply no more than operations to it Please help him in that ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Main idea we act greedily trying to make the best possible answer every action each time we choose an action with minimum possible product after it Detailed explanation While we have zeroes in our array we have to get rid of them changing each of them exactly one time Also we keep the quantity of negative numbers we need it to make the product negative after changing the last zero Let be the number of zeroes in the array If then we cannot make the product negative or positive it will always be equal to so any sequence of operations will lead to a correct answer However if then we are able to come to negative product if the number of negative elements was even then we subtract from one zero and add it to all other zeroes if the number of negative elements was odd then we can just add to all zeroes If current product is still positive then we want to change the sign of exactly one element Its absolute value has to be minimal suppose we have two elements and let s prove that if we change s sign then our answer is wrong Let be the minimum number of operations required to change s sign If we perform operations with then the absolute value of won t change and absolute value of will become If on the other hand we perform operations with this may not be optimal but now we need to prove that if we change then the result will be worse then the absolute value of will become the absolute value of won t change The product becomes negative so we need to maximize the product of absolute values And then and so if we change then the product of absolute values will be less than if we change Now until we have performed operations we choose a number with minimum absolute value and enlarge it add if this number if positive subtract if negative Let s prove that the answer will be optimal Suppose that this algorithm chooses on some iteration but we can t get optimal answer if we change This means that we can t change after this iteration at all we can reorder our operations in an arbitrary way and the answer won t change Suppose we have to change instead and Let s consider the sequence of operations leading to the optimal answer when we choose and replace change of with change of and let the product of all remaining numbers the whole array excluding and after all operations be If we change the total product will be and if we change we get is the number of times we change Now so so the absolute value of total product will be greater if we change This proves that we won t come to unoptimal answer if we change Time complexity if we use a data structure similar to or to get the number with minimal absolute value Memory complexity "}
{"statement": "There are cities on a two dimensional Cartesian plane The distance between two cities is equal to the Manhattan distance between them see the Notes for definition A Hamiltonian cycle of the cities is defined as a permutation of all cities The length of this Hamiltonian cycle is defined as the sum of the distances between adjacent cities in the permutation plus the distance between the first and final city in the permutation Please compute the longest possible length of a Hamiltonian cycle of the given cities ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "The solution to this problem is actually quite simple 4122927 This problem asks us to prove something very long the proof below is of 80 lines Assume that the number of cities is at least 4 The case where it s less than 4 is trivial First we will assume that no two cities will have same X or Y coordinates To get this assumption we can juxtapose every city very slightly that it will not change the answer The keys are A Manhattan Distance B the tour starts and ends at the same city Suppose we know a tour The total distance traveled will be X1 X2 Y1 Y2 X3 X2 Y3 Y2 Let s separate the X and Y coordinates for simplicity Note that each city will contribute twice to this value for example X2 was in X1 X2 and X3 X2 in the example above Manhattan distance implies that each of these values will either be multiplied by 1 or 1 depending on the other coordinate being compared in the absolute term Furthermore the number of values that are multiplied by 1 must equal the number of values that are multiplied by 1 since in each absolute term one is multiplied by 1 and the other by 1 This directly implies an upper bound on the maximum length of the tour If we list all the X coordinates of the cities and we put each of them twice in this list and sort them the maximum will be gained if we multiply the last half by 1 and the first half by 1 and finally summing them up Note that all of these reasoning applies to the Y coordinate and summing both maximum of X and Y we receive an upper bound on the length of the tour If we can find a tour with this length our job is done In some case it s possible Let s investigate First if we have the medians of the X and the Ys as in the list above we can separated the field like below The lines corresponds to the median for both X and Y At most one city will lie on each of the median lines recall our assumption that X and Ys are distinct Let s call each A B C and D as boxes Below we will refer box A as simply A applies to B C and D too To obtain the value above from a city in B we must go to a city in C Same reasoning yields B C C B A D D A Here pairs of cities become apparrent A and D are paired as well as B and C First if either A D is empty or B C is empty then we can obtain the upper bound above We simply alternates between the two remaining pair So let s assume that A D is not empty and B C is not empty First let s investigate the relationship between B and C A and B will also exhibits this relationship Theorem 1 B C 1 Why First if there are no cities in the medians or there is a single city in the center of the median A median divides the region into two areas with the same number of cities so we have substituting A from a to b yields And the theorem follows Next suppose there are two cities in the median one for each median line Let s suppose the median is one above and one on the right All other cases will be similar By definition of median Substituing a into b yields which also implies A D Applying the same technique to other cases will give And the theorem follows Note also that the one with the extra 1 city will be the one that is not adjacent to any median city adjacent being the city lies in the boundary of the box OK so in the following observations we will assume the upper bound that is the sorted list of both X and Ys have their first half multiplied by 1 while the rest by 1 and trying to find a solution that s as close as possible to this upper bound The following will be another case analysis Theorem 2 If there are two cities in the medians that is one in each median line then the upper bound can be achieved Why We use pair of boxes to denote either A and D or B and C From the second part of the proof for theorem 1 there will be a pair of boxes that contain different number of cities Let s pick this pair and start at the one with the most boxes We keep alternating with its pair until we end up back in our starting box Then we simply move to either of the median city From there we move to the other pair of box the farthest one of the two Alternate between the two go to the other median city and return to the starting city It s easy to see that this will be optimal and have the upper bound as its value Now let s see if there are no cities in the medians First of all this implies that the number of cities is even Second this implies that our upper bound which has the X and Y lists as 1 1 1 1 1 1 1 1 will not work since this implies we have to continuously alternate between the two pairs of boxes however we can t switch between the pair of boxes So at least a modification would be required The smallest possible modification is obtained by swapping the medians that is it becomes 1 1 1 1 1 1 1 1 1 1 1 1 This is sufficient Why So there are two cities that changes since the number of cities is even Furthermore these two cities will be the closest to the median line let s assume these coordinates are X that is they re the closest to the vertical median line and lies at two different boxes Then we proceed as follows We start at one of these two cities Alternate and end at the other side If the other city is at that box we make it so that we end at that city and in this case we can move to a city in the other box pair while respecting the list of X coordinates we can do so since this city is the closest to the median line Otherwise the city will be in the other pair of boxes We simply move there and it can be shown that we still respect the list of X coordinates Alternate and at the end go back to the starting city All of these can be shown to still respect the list above This is optimal since this is the next largest possible upper bound if upper bound cannot be achieved Now if there is a single city in the center of both medians then the upper bound cannot be achieved To see this the upper bound can only be achieved if from a city in a box we move to another city in its box pair or to the center city However since both pair of boxes contains a city we will need to move at least twice between them Since there s only one center city this is not possible Observe that this case implies an odd number of cities Hence we can t simply swap the median since it swaps the x coordinates of the same median city Instead we do this 1 1 1 1 1 1 1 1 1 1 or 1 1 1 1 1 1 1 1 1 1 That is we swap to either one of the neighboring city With the same reasoning as above we can show that we respect this list of X coordinates To achieve O N expected performance note that the only operations we need are grouping elements into boxes and median finding Both can be done in expected O N time expected since although there is a worst case O N selection algorithm it s ugly Thoughts Actually I intended to reword this into a three paragraph weird story but that seems a little too evil so it was left out "}
{"statement": "On vacations pupils decided to go on excursion and gather all together They need to overcome the path with the length meters Each of the pupils will go with the speed equal to To get to the excursion quickly it was decided to rent a bus which has seats for people it means that it can t fit more than people at the same time and the speed equal to In order to avoid seasick each of the pupils want to get into the bus Determine the minimum time required for all pupils to reach the place of excursion Consider that the embarkation and disembarkation of passengers as well as the reversal of the bus take place immediately and this time can be neglected ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "This problem can be solved with formula or with help of the binary search Let s describe the solution with binary search on the answer If the target function of the binary search returns true we need to move in mid the right end of the search else we need to move in mid the left end of the search The target function must works in the following way Let s divide all pupils on the groups the number of the groups equals to n k 1 k where n is the total number of pupils and k is the number of seats in the bus Then for the current mid we know the minimal time which the first group of the pupils is needed to ride on the bus to reach the finish point in the time mid Then we need to solve simple equation and get that this time equals to T v2 T l posM v2 v1 where for the first group T equals to mid posM equals to 0 in posM we will store the position of the pupils who did not already rode on the bus Than we need to accurate recalculate T and posM for every following group do not forget that the bus must returns back to get the other group If for some group v2 T became less than l posM or T became less than 0 the target function must return false If all groups of pupils will reach the finish point in time mid the target function must return true Also do not forget that the bus does not need to ride back after it took to the needed point the last group of the pupils "}
{"statement": "Little Vitaly loves different algorithms Today he has invented a new algorithm just for you Vitaly s algorithm works with string consisting of characters and and uses two following operations at runtime Find two consecutive characters in the string such that the first of them equals and the second one equals and swap them If there are several suitable pairs of characters we choose the pair of characters that is located closer to the beginning of the string Find in the string two consecutive characters such that the first of them equals and the second one equals Remove these characters from the string If there are several suitable pairs of characters we choose the pair of characters that is located closer to the beginning of the string The input for the new algorithm is string and the algorithm works as follows If you can apply at least one of the described operations to the string go to step 2 of the algorithm Otherwise stop executing the algorithm and print the current string If you can apply operation 1 then apply it Otherwise apply operation 2 After you apply the operation go to step 1 of the algorithm Now Vitaly wonders what is going to be printed as the result of the algorithm s work if the input receives string ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Not hard to see that after few operations of first type string will become x xy y After fer operations of second type there will be only letters of one type count of this letters will be count x count y "}
{"statement": "Dima is a beginner programmer During his working process he regularly has to repeat the following operation again and again to remove every second element from the array One day he has been bored with easy solutions of this problem and he has come up with the following extravagant algorithm Let s consider that initially array contains numbers from to and the number is located in the cell with the index Indices are numbered starting from one and other cells of the array are empty Each step Dima selects a non empty array cell with the maximum index and moves the number written in it to the nearest empty cell to the left of the selected one The process continues until all numbers will appear in the first cells of the array For example if the array is changing as follows You have to write a program that allows you to determine what number will be in the cell with index after Dima s algorithm finishes ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "In odd position value will be set For even position let s find out position from which value has arrived and iterate over such position until we will arrive to odd position for which we know answer At the moment of jumping to cell there are elements to the right of the position So there are elements to the right of this position and jump to cell was done from position During each such jump length of jump decreases at least by 2 times so there are no more than jumps and solution works in "}
{"statement": "There are one cat k mice and one hole on a coordinate line The cat is located at the point 0 the hole is located at the point n All mice are located between the cat and the hole the i th mouse is located at the point x i 0 x i n At each point many mice can be located In one second the following happens First mouse moves to the right by 1 If the mouse reaches the hole it hides i e the mouse will not any more move to any point and will not be eaten by the cat Then the mouse has finished its move the cat moves to the right by 1 If at the new cat s position some mice are located the cat eats them they will not be able to move after that The actions are performed until any mouse hasn t been hidden or isn t eaten In other words the first move is made by a mouse If the mouse has reached the hole it s saved Then the cat makes a move The cat eats the mice located at the pointed the cat has reached if the cat has reached the hole it eats nobody Each second you can select a mouse that will make a move What is the maximum number of mice that can reach the hole without being eaten ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Let s solve the problem using a linear search Let be the number of mice we are trying to save Then it is more efficient to save mice such that they are the closest ones to the hole Let be the distance from the th mouse to the hole Denote Let s prove that these mice will be saved if and only if The necessary condition Suppose we can save the mice and Since only one mouse can be moved in one second the following will happen of mice will already be saved and one mouse will have to be saved When it s been seconds then the distance from the cat to the hole will be equal to and the distance from the mouse to the hole will be equal to since all other mice are already in the hole their distances to the hole are equal to so the sum of the distances from all mice to the hole at the current time is exactly equal to the distance to the hole from one remaining mouse Since the distance from the mouse to the hole is greater than or equal to the distance from the cat to the hole But this cannot be because both the mice and the cat move only to the right and all mice met by the cat are eaten So Sufficient condition Suppose If then all the mice are already in the hole i e they are saved Suppose Let s move any mouse then the cat Suppose the cat ate at least one of the mice This mouse is definitely not the one that was moved Then the distance from it to the eaten mouse was equal to i e the distance from it to the hole was equal to the distance from the eaten mouse to the hole plus The distance from the moved mouse to the hole was at least So where is the distance from the eaten mouse to the hole is the distance from the moved mouse to the hole So but it s false Therefore none of the mice will be eaten on the first move Then the distance from the cat to the hole will be equal to the total distance from the mice to the hole will be equal to i e now we have to solve a similar problem for smaller and So will be gradually decreased to while no mouse will be eaten So if all the mice will be saved Thus to solve the problem we need to find the maximum such that the sum of the distances from the nearest mice to the hole is less than "}
{"statement": "You are given an array a of n positive integers You can use the following operation as many times as you like select any integer 1 le k le n and do one of two things decrement by one k of the first elements of the array decrement by one k of the last elements of the array For example if n 5 and a 3 2 2 1 4 then you can apply one of the following operations to it not all possible options are listed below decrement from the first two elements of the array After this operation a 2 1 2 1 4 decrement from the last three elements of the array After this operation a 3 2 1 0 3 decrement from the first five elements of the array After this operation a 2 1 1 0 3 Determine if it is possible to make all the elements of the array equal to zero by applying a certain number of operations ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "The problem sounds like this check that there are increasing and decreasing arrays the element wise sum of which is equal to the given array This problem can be solved greedily Let s maximize each element of the decreasing array let s call this array a and the increasing one b Suppose initial array is v and we have solved the problem on a prefix of length i 1 Then for the element a i a i a i 1 and v i a i b i 1 must be fulfilled Rewriting the second inequality and combining with the first one we get a i min a i 1 v i b i 1 It is clear that taking a i min a i 1 v i b i 1 is best by construction "}
{"statement": "It s holiday Mashmokh and his boss Bimokh are playing a game invented by Mashmokh In this game Mashmokh writes sequence of distinct integers on the board Then Bimokh makes several possibly zero moves On the first move he removes the first and the second integer from from the board on the second move he removes the first and the second integer of the remaining sequence from the board and so on Bimokh stops when the board contains less than two numbers When Bimokh removes numbers and from the board he gets points At the beginning of the game Bimokh has zero points Mashmokh wants to win in the game For this reason he wants his boss to get exactly points in total But the guy doesn t know how choose the initial sequence in the right way Please help him Find distinct integers such that his boss will score exactly points Also Mashmokh can t memorize too huge numbers Therefore each of these integers must be at most ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "In each turn Bimokh will at least get one point so the result is at lease So if the answer is 1 Let s denote Then you could output and as the first two integers in the sequence then output consecutive integers and also one random integer distinct from the others if is odd Based on the following fact Bimokh s point will equal to which is equal to Also you must consider some corner cases such as when "}
{"statement": "We decided to play a game with you and guess the number x 1 le x n where you know the number n You can make queries like this this command assigns x x c 1 le c n and then returns you the value lfloor frac x n rfloor x divide by n and round down You win if you guess the current number with no more than 10 queries ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "After each query we know the value then we need to find to find the current value To find it we will use a binary search Suppose is in the half interval in order to understand which half it is in we will make a query select the middle of the half interval and make a query After that will either change which means that was in the half interval or not then it was in the half interval Now you just need to properly shift the half interval to accommodate the query change "}
{"statement": "Parmida is a clever girl and she wants to participate in Olympiads this year Of course she wants her partner to be clever too although he s not Parmida has prepared the following test problem for Pashmak There is a sequence that consists of integers Let s denote the number of indices such that and His task is to calculate the number of pairs of indicies such that Help Pashmak with the test ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "First of all we can map the given numbers to integers of range Let be and let be we want to find the number of pairs such that and For computing s we can store an array named to show the number of occurence of any with To do this we can iterate from left to right and update s also would be equal to at position s can be computed in a similar way Beside that we get help from binary indexed trees We use a Fenwick tree and iterate from right to left In each state we add the number of elements less than to answer and add to the Fenwick tree Total complexity Also we can solve this problem using divide and conquer method You can see the second sample solution to find out how to do this exactly Sample solutions 7495225 7495225 "}
{"statement": "You have array that contains all integers from to twice You can arbitrary permute any numbers in Let number be in positions in the permuted array Let s define the value the distance between the positions of the number Permute the numbers in array to minimize the value of the sum ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "This problem was suggested by Aleksa Plavsic allllekssssa Let s build the answer with the sum equal to zero Let be even Let s place odd numbers in the first half of the array the number in the positions and the number in the positions and and so on Similarly let s place even numbers in the second half the number in the position and the number in the positions and and so on We can place the number in the leftover positions We can build the answer for odd in a similar way Easy to see that our construction will give zero sum C solution Complexity "}
{"statement": "Ridbit has a hidden array a of n integers which he wants Ashish to guess Note that n is a Ashish is allowed to ask three different types of queries They are of the form i j ask for the bitwise AND of elements a i and a j 1 leq i j le n i neq j i j ask for the bitwise OR of elements a i and a j 1 leq i j le n i neq j i j ask for the bitwise XOR of elements a i and a j 1 leq i j le n i neq j Can you help Ashish guess the elements of the array ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Pick and distinct and find and by querying their XOR and AND values queries This is a system of linear equation with three equations and three variables and thus us a unique solution Solving it you get the values of and You can then get the remaining values using more queries This uses a total of queries Realize that to reduce the number of initial queries from to for a total of queries Lets take a look at the properties of the 3 operations we have specifically what information we can recover from it AND lossy in information about bits that are on cant be used to recover the values OR lossy in information about bits that are off cant be used to recover the values XOR lossless a a b gives us b again So clearly xor operations are going to be the core of recovering the values If we can find one of the values we can find the remaining values using xor queries Lets try to think about this for a operation for which we know how to obtain the individual values addition If we had and we could just solve the three linear equations to obtain the answer If the th bit is off in both the numbers xor and addition both give 0 If the th bit is on in exactly oneof the numbers xor and addition will both give But what about if the th bit is on in the both the numbers Then addition contributes to the answer while xor contributes 0 Is there some way to recover this value Well if th bit is on in the both the numbers the AND will contribute to the answer So we can realize that can be rewritten as a a b So now if we just choose positions and we can obtain and using XOR and AND operations Furthermore we can realize that is just so we can save one more operation Now solving the above simultaneous equations we get Now for is just We already calculated and for the previous step and can calculate the remaining xor values in steps So in total we use exactly queries which is enough to get AC "}
{"statement": "You are given a table consisting of rows and columns Each cell of the table contains either or In one move you are allowed to pick any row or any column and invert all values that is replace by and vice versa What is the minimum number of cells with value 1 you can get after applying some number of operations ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "First let s examine a slow solution that works in O 2n m Since each row can be either inverted or not the set of options of how we can invert the rows may be encoded in a bitmask of length n an integer from 0 to 2n 1 where the i th bit is equal to 1 if and only if we invert the i th row Each column also represents a bitmask of length n the bits correspond to the values of that row in each of the n rows Let the bitmask of the i th column be coli and the bitmask of the inverted rows be mask After inverting the rows the i th column will become Suppose that contains ones Then we can obtain either k or n k ones in this column depending on whether we invert the i th column itself It follows that for a fixed bitmask mask the minimum possible number of ones that can be obtained is equal to Now we want to calculate this sum faster than O m Note that we are not interested in the value of the mask itself but only in the number of ones it contains from 0 to n Therefore we may group the columns by the value of Let dp k mask be the number of such i that then for a fixed bitmask mask we can calculate the sum in O n What remains is to calculate the value of dp k mask in a quick way As the name suggests we can use dynamic programming for this purpose The value of dp 0 mask can be found in O m for all bitmasks mask each column coli increases dp 0 coli by 1 For k 0 coli and mask differ in exactly k bits Suppose mask and coli differ in position p Then coli and differ in exactly k 1 bits The number of such columns is equal to except we counted in also the number of columns coli that differ with in bit p thus mask and coli have the same value in bit p Thus we need to subtract dp k 2 mask but again except the columns among these that differ with mask in bit p Let by expanding this inclusion exclusion type argument we get that the number of masks we are interested in can be expressed as dp k 1 next dp k 2 mask dp k 3 next dp k 4 mask dp k 5 next By summing all these expressions for each bit p from 0 to n we get dp k mask k since each column is counted in k times for each of the bits p where the column differs from mask Therefore we are now able to count the values of dp k mask in time O 2n n3 using the following recurrence This is still a tad slow but we can speed it up to O 2n n2 for example in a following fashion "}
{"statement": "In his spare time Vladik estimates beauty of the flags Every flag could be represented as the matrix which consists of positive integers Let s define the beauty of the flag as number of components in its matrix We call component a set of cells with same numbers and between any pair of cells from that set there exists a path through adjacent cells from same component Here is the example of the partitioning some flag matrix into components But this time he decided to change something in the process Now he wants to estimate not the entire flag but some segment Segment of flag can be described as a submatrix of the flag matrix with opposite corners at and where conditions are satisfied Help Vladik to calculate the beauty for some segments of the given flag ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2600", "problem_editorial": "Let s use interval tree maintaining in each vertex two arrays of numbers left and right profile of the interval corresponding to the vertex Each number in this arrays would be in range from to denoting component in which cell is For merging such structures we would iterate on splice of two vertices and unite components if two adjacent cells have same colors and than recalculate components of left and right profile of the new structure "}
{"statement": "You are given a description of a depot It is a rectangular checkered field of size Each cell in a field can be empty or it can be occupied by a wall You have one bomb If you lay the bomb at the cell then after triggering it will wipe out all walls in the row and all walls in the column You are to determine if it is possible to wipe out all walls in the depot by placing and triggering The bomb can be laid both in an empty cell or in a cell occupied by a wall ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "To solve this problem we need to calculate two arrays and where must be equal to the number of walls in the column number and must be equal to the number of walls in the row number Also let s store the total number of walls in the variable Now we need to look over the cells Let the current cell be Let s count the value how many walls will destroy the bomb planted in the cell If the cell has a wall we count it twice so we need to subtract from the If we found the answer and need to plant the bomb in the cell If there is no such cell we need to print "}
{"statement": "Vasya is currently at a car rental service and he wants to reach cinema The film he has bought a ticket for starts in minutes There is a straight road of length from the service to the cinema Let s introduce a coordinate system so that the car rental service is at the point and the cinema is at the point There are gas stations along the road and at each of them you can fill a car with any amount of fuel for free Consider that this operation doesn t take any time i e is carried out instantly There are cars in the rental service th of them is characterized with two integers and the price of this car rent and the capacity of its fuel tank in liters It s not allowed to fuel a car with more fuel than its tank capacity All cars are completely fueled at the car rental service Each of the cars can be driven in one of two speed modes normal or accelerated In the normal mode a car covers kilometer in minutes and consumes liter of fuel In the accelerated mode a car covers kilometer in minutes but consumes liters of fuel The driving mode can be changed at any moment and any number of times Your task is to choose a car with minimum price such that Vasya can reach the cinema before the show starts i e not later than in minutes Assume that all cars are completely fueled initially ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s note that there is a value for the fuel tank capacity call it w that if the car has the fuel tank capacity equal or more than w it will be able to reach the cinema if time else will not be able The value w can be found with help of binary search because the function can w it is possible and it has enough time for such cur is monotonic in the beginning all values of this function is false but after some moment the values of this function is always true After we found w it remain only to choose the cheapest car from the cars which fuel tank capacity equal or more than w The function can w can be realized with greedy algorithm It is easy to write down the formula for find the number of kilometers which we can ride in fast mode if the nearest gas station is on the distance x and we have f liters of fuel in fuel tank if x f then it is impossible to reach the nearest gas station and can w must return false if x f then it is possible to ride in the fast mode min x f x kilometers So now we know how to find the value can w in one iterate through the array of gas stations in the increasing order of their positions "}
{"statement": "Daenerys Targaryen has an army consisting of groups of soldiers the th group contains soldiers She wants to bring her army to the other side of the sea to get the Iron Throne She has recently bought an airplane to carry her army through the sea The airplane has rows each of them has seats We call two seats neighbor if they are in the same row and in seats or Daenerys Targaryen wants to place her army in the plane so that there are no two soldiers from different groups sitting on neighboring seats Your task is to determine if there is a possible arranging of her army in the airplane such that the condition above is satisfied ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Use greedy solution Consider a group with members put of them in seats 3 6 of some row and throw the row Now we have members in this group now Continue till all of the seats in the range become full continue with and Now handle groups with size For groups with size allocate seats in range or seats in range or For groups with size allocate seats in range or or seats in range If no seat found divide this group and make it two groups with size 1 Fill the other parts with groups with groups with size If in any part we ran out of seat the answer is otherwise "}
{"statement": "Along the railroad there are stations indexed from 1 to 10 9 An express train always travels along a route consisting of n stations with indices u 1 u 2 dots u n where 1 le u i le 10 9 The train travels along the route from left to right It starts at station u 1 then stops at station u 2 then at u 3 and so on Station u n the terminus It is possible that the train will visit the same station more than once That is there may be duplicates among the values u 1 u 2 dots u n You are given k queries each containing two different integers a j and b j 1 le a j b j le 10 9 For each query determine whether it is possible to travel by train from the station with index a j to the station with index b j For example let the train route consist of 6 of stations with indices 3 7 1 5 1 4 and give 3 of the following queries a 1 3 b 1 5It is possible to travel from station 3 to station 5 by taking a section of the route consisting of stations 3 7 1 5 Answer a 2 1 b 2 7You cannot travel from station 1 to station 7 because the train cannot travel in the opposite direction Answer a 3 3 b 3 10It is not possible to travel from station 3 to station 10 because station 10 is not part of the train s route Answer ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "To solve the problem we will use the dictionary Each station will be matched with a pair of integers the indices of its first and last entries in the route Then we will sequentially process queries If at least one of the stations or is missing in the dictionary the answer is Otherwise check If the index of the first entry of station in the route is strictly less than the index of the last entry of station in the route the answer is Otherwise the answer is "}
{"statement": "In the Main Berland Bank people stand in a queue at the cashier everyone knows his her height and the heights of the other people in the queue Each of them keeps in mind number how many people who are taller than him her and stand in queue in front of him After a while the cashier has a lunch break and the people in the queue seat on the chairs in the waiting room in a random order When the lunch break was over it turned out that nobody can remember the exact order of the people in the queue but everyone remembers his number Your task is to restore the order in which the people stood in the queue if it is possible There may be several acceptable orders but you need to find any of them Also you need to print a possible set of numbers the heights of people in the queue so that the numbers are correct ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Let s sort the pairs namei ai by ascending of ai If there is an index i 0 i n that ai i then answer is 1 Otherwise the answer exists We will iterate through the array of sorted pairs from left to right with supporting of vector of results res Let on the current iteration ai n i then we must transfer the current man in the position ai It can be done in C with one line res insert res begin a i man "}
{"statement": "Arpa has found a list containing numbers He calls a list bad if and only if it is not empty and see notes section for more information of numbers in the list is Arpa can perform two types of operations Choose a number and delete it with cost Choose a number and increase it by with cost Arpa can apply these operations to as many numbers as he wishes and he is allowed to apply the second operation arbitrarily many times on the same number Help Arpa to find the minimum possible cost to make the list good ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s define the cost if we want gcd of the array becomes The answer is for Now let s see how to calculate For each number like we can delete it with cost or we can add it till divides it So we must pay Let s iterate on possible values for Before entering the main part of the solution let s define two helper functions this function returns the number of s such that this function returns To implement this function define an array such that keeps the sum of values less than or equal to Then Now for each multiple of like let s find the cost of numbers in the range and sum up these values We must find the best and divide the range into two segments and and delete the numbers in the first range and add the numbers in second range till they become Now to find the best value for So the total cost for this range is Time complexity "}
{"statement": "You are given two sequences a 1 a 2 dots a n and b 1 b 2 dots b n Each element of both sequences is either 0 1 or 2 The number of elements 0 1 2 in the sequence a is x 1 y 1 z 1 respectively and the number of elements 0 1 2 in the sequence b is x 2 y 2 z 2 respectively You can rearrange the elements in both sequences a and b however you like After that let s define a sequence c as follows c i begin cases a i b i mbox if a i b i 0 mbox if a i b i a i b i mbox if a i b i end cases You d like to make sum i 1 n c i the sum of all elements of the sequence c as large as possible What is the maximum possible sum ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "We can find the kind of the value of is three And is only if is and is and is only if is and is Otherwise is So we have to make pair as little as possible and pair as much as possible To do this first we can make pair pair and pair as much as possible After that pairing the remaining values doesn t affect the sum of It in which value is and in which value is are all left we have to pair them although the sum decreases Time complexity "}
{"statement": "There have recently been elections in the zoo Overall there were main political parties one of them is the Little Elephant Political Party other parties have less catchy names Political parties find their number in the ballot highly important Overall there are possible numbers Each of these parties is going to be assigned in some way to exactly one number at that two distinct parties cannot receive the same number The Little Elephant Political Party members believe in the lucky digits and They want to evaluate their chances in the elections For that they need to find out how many correct assignments are there such that the number of lucky digits in the Little Elephant Political Party ballot number is strictly larger than the total number of lucky digits in the ballot numbers of 6 other parties Help the Little Elephant Political Party calculate this number As the answer can be rather large print the remainder from dividing it by ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "First of all lets think about the problem of finding array the number of integers from 1 to such that the number of lucky digits is equal to It s pretty standart dynamic programminc problem which can be solved with state position less count It can be solved directly using DP but to simplify a bit you can use brute force recursion to brute all possible assignments of numbers of lucky digits in for all paries up to 9 digits Now you can divide all parties in several indepentent groups each of which should contain the same number of lucky digits Consider that the party of Litte Elephant is with number 1 Than assignment for the first position should have more digits than the sum of the rest because of the statement Since all groups are indepented because there is no number that can have different number of lucky digits obviously you can find the number of resulting assignments for each group and find the final result by multiplying these all numbers and taking modulo Consider that you have group of size each number of which should contain lucky digits That it s pretty easy to understand that the number of assignment is equal to "}
{"statement": "Mahmoud has line segments the th of them has length Ehab challenged him to use line segments to form a non degenerate triangle Mahmoud doesn t accept challenges unless he is sure he can win so he asked you to tell him if he should accept the challenge Given the lengths of the line segments check if he can choose exactly of them to form a non degenerate triangle Mahmoud should use exactly line segments he can t concatenate two line segments or change any length A non degenerate triangle is a triangle with positive area ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Let x y and z be the lengths of 3 line segments such that x y z If they can t form a non degenerate triangle Line segments of lengths x 1 y and z or x y and z 1 can t form a non degenerate triangle So we don t need to try all the combinations If we try y as the middle one We need to try the maximum x that is less than or equal to y and the minimum z that is greater than or equal to y The easiest way to do so is to sort the line segments and try every consecutive 3 "}
{"statement": "A robot cleaner is placed on the floor of a rectangle room surrounded by walls The floor consists of n rows and m columns The rows of the floor are numbered from 1 to n from top to bottom and columns of the floor are numbered from 1 to m from left to right The cell on the intersection of the r th row and the c th column is denoted as r c The initial position of the robot is r b c b In one second the robot moves by dr rows and dc columns that is after one second the robot moves from the cell r c to r dr c dc Initially dr 1 dc 1 If there is a vertical wall the left or the right walls in the movement direction dc is before the movement so the new value of dc is dc And if there is a horizontal wall the upper or lower walls dr is before the movement so the new value of dr is dr Each second including the moment before the robot starts moving the robot cleans every cell lying in the same row the same column as its position There is only one dirty cell at r d c d The job of the robot is to clean that dirty cell Given the floor size n and m the robot s initial position r b c b and the dirty cell s position r d c d find the time for the robot to do its job ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s consider the 1 D problem of this problem there are cells lying in a row The robot is at the th cell and the dirty cell is at the th cell Each second the robot cleans the cell at its position The robot initially moves by 1 cell to the right each second If there is no cell in the movement direction its direction will be reflected What is the minimum time for the robot to clean the dirty cell There are two cases needed to be considered If then the answer is The robot just goes straight to the dirty cell Otherwise if then the robot needs to go to the right endpoint first and then go back to the dirty cell Going to the right endpoint takes seconds and going from that cell to the dirty cell takes seconds Therefore the answer for this case is Going back to our original problem we can solve it by dividing it into two 1 D versions This is done by projecting the position of the robot and the dirty cell onto the and axis as follows By doing so we can see that we can clean the dirty cell if and only if one of the projections of the robot can reach the dirty cell Therefore the answer is the minimum between the answers of the two sub problems "}
{"statement": "To stay woke and attentive during classes Karen needs some coffee Karen a coffee aficionado wants to know the optimal temperature for brewing the perfect cup of coffee Indeed she has spent some time reading several recipe books including the universally acclaimed The Art of the Covfefe She knows coffee recipes The th recipe suggests that coffee should be brewed between and degrees inclusive to achieve the optimal taste Karen thinks that a temperature is if at least recipes recommend it Karen has a rather fickle mind and so she asks questions In each question given that she only wants to prepare coffee with a temperature between and inclusive can you tell her how many admissible integer temperatures fall within the range ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "There are two separate tasks here Efficiently generate an array where is the number of recipes that recommend temperature Efficiently answer queries how many numbers are at least where is fixed across all queries There are some solutions to this task using advanced data structures or algorithms For example a conceptually straightforward idea is the following create a segment tree We can treat all recipes as range update queries which we can do efficiently in where is the largest or time using lazy propagation After all recipes we replace all by if it s at least and otherwise Afterwards each of the next queries is a basic range sum query which can be done simply in time Other solutions exist too Fenwick trees with range updates event sorting sqrt decomposition with binary search Mo s algorithm and so on These solutions all pass but they are all overkill for this task A very simple solution is as follows Initialize with all zeroes For recipe that recommends temperatures between and we should increment and decrement Cumulate all values That is set to This can be done with one pass through the array Now magically is now the number of recipes that recommend temperature If is at least set it to otherwise set it to Cumulate all values again Now every query that asks for the number of admissible temperatures between and can be answered simply as This runs in which is really fast Note that if your solution does this and still runs quite slow chances are your solution is using slower input methods We raised the time limit to 2 5 seconds in this problem in order to avoid failing slow input solutions "}
{"statement": "Tokitsukaze has a binary string s of length n consisting only of zeros and ones n is Now Tokitsukaze divides s into of subsegments and for each subsegment all bits in each subsegment are the same After that s is considered good if the lengths of all subsegments are even For example if s is it will be divided into and Their lengths are 2 2 4 respectively which are all even numbers so is good Another example if s is it will be divided into and and their lengths are 3 2 2 3 Obviously is not good Tokitsukaze wants to make s good by changing the values of some positions in s Specifically she can perform the operation any number of times change the value of s i to or 1 leq i leq n Can you tell her the minimum number of operations to make s good ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Tutorial greedy Obviously the operation is for each pair of adjacent and unequal characters change both of them to or In other words the string is divided into many adjacent binaries with length of If the binary is 01 or 10 it needs operation otherwise the operation is not required If you want to minimize the number of contiguous segments a simple greedy way is to change each binary requiring operation i e or into the form of the previous or next binary requiring no operation i e or For example 0010 change to 0000 and 1101 change to 1111 In this way this binary requiring operation has no contribution to the final number of contiguous segments We only need to count the number of contiguous 11 and 00 binaries In particular if all binaries are 01 or 10 the final contribution to the number of final contiguous segments is in total "}
{"statement": "You ve got a rectangular table with length and width and the infinite number of plates of radius Two players play the following game they take turns to put the plates on the table so that the plates don t lie on each other but they can touch each other and so that any point on any plate is located within the table s border During the game one cannot move the plates that already lie on the table The player who cannot make another move loses Determine which player wins the one who moves first or the one who moves second provided that both players play optimally well ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "If first player can t make first move table is too small and plate doesn t fit it i e second player wins Else first player wins Winning strategy for first player place first plate to the center of table After that he symmetrically reflects moves of second player with respect to center of table If second player has move first player has symmetrical move too If not first player won "}
{"statement": "Wheatley decided to try to make a test chamber He made a nice test chamber but there was only one detail absent cubes For completing the chamber Wheatley needs n cubes i th cube has a volume a i Wheatley has to place cubes in such a way that they would be sorted in a non decreasing order by their volume Formally for each i 1 a i 1 le a i must hold To achieve his goal Wheatley can exchange two cubes It means that for any i 1 you can exchange cubes on positions i 1 and i But there is a problem Wheatley is very impatient If Wheatley needs more than frac n cdot n 1 2 1 exchange operations he won t do this boring work Wheatly wants to know can cubes be sorted under this conditions ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "It is not difficult to see that the answer in this task is possible when and only when all are different and sorted in descending order In this case we need operations Otherwise the answer is always Why does this solution work Let s define as the number of pairs such as Note that if the number of inversions is zero the array is sorted in non decreasing order If the array is not sorted we can always choose two neighboring elements such that and swap them In this case the number of inversions is reduced by one In this case we cannot reduce the number of inversions by more than one so it is equal to the minimum number of operations we must perform Now all we have to do is notice that the number of inversions does not exceed and the maximum is only reached when for all pairs It follows that in this case the array must be strictly descending Thus we have a solution with a time of "}
{"statement": "You are given an array a 1 a 2 dots a n which is sorted in non descending order You decided to perform the following steps to create array b 1 b 2 dots b n Create an array d consisting of n arbitrary integers Set b i a i d i for each b i Sort the array b in non descending order You are given the resulting array b For each index i calculate what is the minimum and maximum possible value of d i you can choose in order to get the given array b Note that the minimum maximum d i s are of each other i e they can be obtained from different possible arrays d ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "For the start let s note that for each Otherwise there is no way to get from Firstly let s calculate for each Since all then is always greater or equal than you get it from So the minimum would come from lowest that still Since is sorted we can find such with in Let s prove that we can build such that transforms to we found earlier Let s just make for for and It s easy to see that all are non negative so such is valid Now let s calculate Suppose we transform to for some It s not hard to prove that the proving array may be constructed in the similar way for for and In order to build such array you need for each In other words if there is some position such that and you can t choose such that It means that we can iterate in descending order and just keep track of leftmost with Then is equal to or if there are no such The resulting complexity is because of the first part But it can be optimized to if we use two pointers instead of "}
{"statement": "Today as a friendship gift Bakry gave Badawy n integers a 1 a 2 dots a n and challenged him to choose an integer X such that the value underset 1 leq i leq n max a i oplus X is minimum possible where oplus denotes the bitwise XOR operation As always Badawy is too lazy so you decided to help him and find the minimum possible value of underset 1 leq i leq n max a i oplus X ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "We will solve this problem recursively starting from the most significant bit Let s split the elements into two groups one with the elements which have the current bit on and one with the elements which have the current bit off If either group is empty we can assign the current bit of accordingly so that we have the current bit off in our answer so we will just proceed to the next bit Otherwise both groups aren t empty so whatever value we assign to the current bit of we will have this bit on in our answer Now to decide which value to assign to the current bit of we will solve the same problem recursively for each of the groups for the next bit let and be the answers of the recursive calls for the on and the off groups respectively Note that if we assign to the current bit of the answer will be and if we assign to the current bit of the answer will be where is the current bit So simply we will choose the minimum of these two cases for our answer to be Time complexity "}
{"statement": "Sho has an array a consisting of n integers An operation consists of choosing two distinct indices i and j and removing a i and a j from the array For example for the array 2 3 4 2 5 Sho can choose to remove indices 1 and 3 After this operation the array becomes 3 2 5 Note that after any operation the length of the array is reduced by two After he made some operations Sho has an array that has only elements In addition he made operations such that the resulting array is the possible More formally the array after Sho has made his operations respects these criteria No pairs such that i j and a i a j exist The length of a is maximized Output the length of the final array ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Note that the size of the array doesn t change parity since it always decreases by Let s count the number of distinct elements call it If is the same parity as the length of the array then we can make sure all of these distinct elements stay in the array by removing two elements at a time Otherwise isn t the same parity as Then is the same parity as and we can make sure distinct elements stay in the array by removing two elements at a time So the answer is if and have the same parity and otherwise For example has So and have the same parity and we can get all distinct numbers by removing Time complexity or depending on the implementation "}
{"statement": "You have been invited as a production process optimization specialist to some very large company The company has n machines at its factory standing one behind another in the production chain Each machine can be described in one of the following two ways a i or a i If a workpiece with the value x is supplied to the machine of kind a i then the output workpiece has value x a i If a workpiece with the value x is supplied to the machine of kind a i then the output workpiece has value x cdot a i The whole production process is as follows The workpiece with the value 1 is supplied to the first machine then the workpiece obtained after the operation of the first machine is supplied to the second machine then the workpiece obtained after the operation of the second machine is supplied to the third machine and so on The company is not doing very well so now the value of the resulting product does not exceed 2 cdot 10 9 The directors of the company are not satisfied with the efficiency of the production process and have given you a budget of b coins to optimize it To optimize production you can change the order of machines in the chain Namely by spending p coins you can take any machine of kind a i and move it to any place in the chain without changing the order of other machines Also by spending m coins you can take any machine of kind a i and move it to any place in the chain What is the maximum value of the resulting product that can be achieved if the total cost of movements that are made should not exceed b coins ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "Let bi the maximum value of the resulting product before any movements The problem statement says that it is guaranteed that Observation 0 after each movements the value of the resulting product is not greater than Observation 1 each machine of kind should be moved to the end of the sequence and each machine of kind to the beginning of the sequence and the order of movements does not make sense Observation 2 there are at most non trivial machines of kind such machines that We will need some more strong observation for machines of kind but this will be useful too Observation 3 if there are two machines where and then in optimal answer machine may be moved if and only if machine is moved too It is true because we could increase the answer otherwise by moving machine instead of machine The last two observations says that there are not many subsets of machines of kind that satisfies the property from observation 3 Let s say that there are such subsets in the end of the editorial we will estimate this value Let s pick out subsegments of machines of kind between machines of kind sort them and count prefix sums There will be not more than such segments In the optimal answer some maximums will be moved from each of the segments Let s fix some subset of machines of kind that will be moved to the end and count the current value of the output product Consider some element in the array Let the product of machines to the left of it be and to the right of it to be Now if we move this element to the beginning of the array the value of the resulting product will increase by Let s call this Now we have to find the sum of some numbers of maximum values Let s use binary search to find some critical value such value that all elements will be moved to the beginning of each element is not greater than Inside binary search we have to iterate over all segments of elements and find the number of elements with inside this segment using binary search We have to check if we can to move the selected amount of elements to the beginning of the array to understand how to move borders of the external binary search After we find the critical value let s iterate over all segments and add the sum of elements that are to the answer Separately let s consider elements with We could move some of them to the beginning too Let s update the answer with this value Time complexity It should be noted that this estimate is actually higher than in fact Let s estimate the value now Consider some sequence such that and Sort it by ascending the product of elements will not change and the number of interesting subsets will not become smaller Replace all the smallest elements of the sequence with the second minimums with and so on If there are smaller number of elements equals to than elements equals to and let s swap their numbers Now the number of interesting subsets is not changed is not increased The sequence looks like now The number of interesting subsets in the new sequence equals to where is the number of elements if sequence equals to Let s run the code that will brute force over all sequences of such kind and see that the number of interesting subsets is which is achieved on sequence Let s continue estimating this value fairly the elements of the sequence do not exceed because Let s replace each number with a prime number corresponding to it by order and replace all elements with The product of elements will increate in at most times so the product will not exceed It is easy to check that the maximum is achieved in so the product is not greater than The number of interesting subsets of our sequence does not exceed the number of divisors of received numbers that can be estimated as "}
{"statement": "You and your n 1 friends have found an array of integers a 1 a 2 dots a n You have decided to share it in the following way All n of you stand in a line in a particular order Each minute the person at the front of the line chooses either the first or the last element of the array removes it and keeps it for himself He then gets out of line and the next person in line continues the process You are standing in the m th position in the line you may choose up to k different people in the line and persuade them to always take either the first or the last element in the array on their turn for each person his own choice not necessarily equal for all people no matter what the elements themselves are Suppose that you re doing your choices optimally What is the greatest integer x such that no matter what are the choices of the friends you didn t choose to control the element you will take from the array will be x Please note that the friends you don t control may do their choice and they will not necessarily take the biggest element available ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "People behind you are useless ignore them Let s assume that It s always optimal to control as many people as possible Your strategy can be summarized by a single integer the number of people you force to take the first element among the you control Similarly the strategy of your opponents can be summarized by a single integer integer the number of non controlled friends who choose to take the first element When it will be your turn the array will contain exactly elements You will be able to take the biggest element among the first element and the last element These observations lead to an obvious solution iterate over all strategies and for each strategy iterate over all cases which was sufficient to pass the tests However the second iteration can be easily optimized with a data structure Let s note The final answer is Note that it can be rewritten as It can be computed in using segment tree or in using monotonic deque "}
{"statement": "Given an undirected graph G we say that a is an ordered list of all the neighbours of a vertex for each of the vertices of G Consider a given neighbour ordering of G and three vertices u v and w such that v is a neighbor of u and w We write u v w if u comes after w in v s neighbor list A neighbour ordering is said to be if for each simple cycle v 1 v 2 ldots v c of the graph one of the following is satisfied v 1 v 2 v 3 v 2 v 3 v 4 ldots v c 2 v c 1 v c v c 1 v c v 1 v c v 1 v 2 v 1 v 2 v 3 v 2 v 3 v 4 ldots v c 2 v c 1 v c v c 1 v c v 1 v c v 1 v 2 Given a graph G determine whether there exists a good neighbour ordering for it and construct one if it does ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3500", "problem_editorial": "First note that for each vertex the relative order between neighbours that belong to different biconnected components i e neighbours and so that the edges and belong to different biconnected components is irrelevant since there can not be any vertex disjoint cycle using edges from different biconnected components Therefore a good ordering for the entire graph will be possible if and only if a good ordering for each of the biconnected components is possible and if so the ordering for the entire graph can be obtained from the orderings for each of the components by arbitrarily merging the lists of each component for each vertex preserving the relative order for the lists of each component Therefore from now on we will assume that the graph is biconnected Also we assume that the graph has at least 3 vertices to avoid trivialities If the graph has a cycle and there are two vertices not adjacent in the cycle such that there is a path from to that passes through a vertex then the graph can not have a good ordering Assume the graph has a good ordering and label the vertices of the cycle so that and and with Let the path between and be where and we can assume that all lie outside the cycle Considering the cycle we can see that since it must happen too that Now considering the cycle we see that since with possibly we must have Since we can t have the inequality both ways and we reach a contradiction If the biconnected graph has a good ordering then it has a hamiltonian cycle Assume it doesn t have a hamiltonian cycle Since it is biconnected with at least 3 vertices it must have some cycle Let be a longest cycle of the graph Because the cycle does not visit all the vertices of the graph and the graph is connected there must be some vertex not in the cycle which is a neighbour of a vertex in the cycle Because the graph is biconnected there must be some path not passing through with and a vertex in the cycle We can choose the path so that vertices are not in the cycle since we can just finish the path at the first vertex that is in the cycle Now we consider two cases Case 1 and are adjacent in the cycle i e or where we admit taking indices modulo Now we can consider the cycle which is strictly longer than the original cycle but we said it was a longest cycle contradiction Case 2 and are not adjacent in the cycle Assume and consider the cycle We have a path that passes through vertices not in the cycle so by the first lemma it is not possible to have a good ordering contradiction Now let s see how we can compute this hamiltonian cycle efficiently The argument we used in the proof already gives a good algorithm we find a cycle and repeatedly find paths that go out of the cycle and then return to it We will either find a path which returns to an adjacent vertex and therefore we can use it to augment the cycle Case 1 or we will find that it is impossible to have a good ordering and halt Case 2 However implementing this directly is in worst case We will find a way to implement this idea in time using properties of the DFS tree In a DFS tree of a biconnected graph with a good ordering each vertex can have at most two children Suppose that some vertex has more than two children Because the graph is biconnected we have can not be the root and that from each of the child subtrees there is a back edge to a proper ancestor of Let be three children of that have back edges in their respective subtrees to three vertices with where is the depth in the DFS tree Consider the cycle goes back to and the path between and two non adjacent vertices in the cycle This contradicts lemma 1 In a DFS tree of a biconnected graph with a good ordering consider a vertex that is not the root and whose parent is not the root either with two children and and let be the vertex with least depth that can be reached with a back edge from the subtree of Then there is exactly one such that Assume that and are both proper ancestors of they can not be descendants of since the graph is biconnected Then if we consider the cycle which includes the path and then cycles back using back edges without passing through we have a contradiction with lemma 1 considering the path from some vertex in the cycle which is a proper ancestor of to going down the DFS tree Therefore at least one of or is equal to Now let s see that it can not happen that Assume that it is the case Since the graph is biconnected we must have that since it must be a proper ancestor of note that here we are using that is not the root Therefore since the two children subtrees don t have back edges to vertices higher than must have a back edge to Consider the cycle Now with the path lemma 1 is violated In a DFS tree of a biconnected graph with a good ordering consider a vertex that is not the root with parent and with only one child If then Consider the cycle If and are not adjacent the path violates lemma 1 In a DFS tree of a biconnected graph with a good ordering we can partition the front edges into One path of the form where is the parent of for and is the root and there is a back edge between and Some paths of the form where is the parent of for and there is a back edge between and Let be a vertex which is not the root We say that the associated with vertex is the back edge from s subtree that goes to if there are multiple such back edges we choose the one that has as the other vertex the one that has a highest DFS visitation number We partition the front edges into groups with the same representative edge associated with We have to prove that this partition has the desired properties Let be vertices with the same representative edge One vertex must be an ancestor of the other otherwise their subtrees would be disjoint and they can not have the same back edges and every vertex in the path going from one to the other in the tree has the same representative edge if there was some better edge the higher vertex would have it as a representative This proves that the groups form paths of the form where is the parent of for note that here would be the vertices with the same representative edge but wouldn t is in the path because the partition is of edges not vertices and is an edge in the group Now let s see the other property It is clear that the vertex with most depth of the path has the representative edge of the path as one of its back edges Now consider We have multiple cases is not the root and it has only one child Then since it doesn t have the same representative edge necessarily it must have a back edge and By lemma 4 we must have and the back edge from goes to the parent of as desired is not the root its parent is not the root either and it has two children one of which is Then by lemma 3 exactly one of the two children has its Low value equal to the parent of If it were not then would have the same representative edge as which is not possible since it is the endpoint of the path Therefore again we have and the back edge from goes to the parent of is the child of the root and it has two children Now we must have once again once again because there is no other vertex with least depth than the parent of and the back from goes to the parent of is the root This happens for only for one path and clearly there must be a back edge from to This is just what we wanted doing just one DFS we can get one initial cycle and a series of paths we can use to successively augment our cycle until we have a hamiltonian cycle One way to implement this is the following first we partition the graph into paths as in the previous theorem we can mantain the representative back edge during the DFS if a violation of the properties proven in the lemmas is detected we halt Then we begin exploring the initial path the one that forms a cycle with the root in a downwards direction that is first we visit then its child until we visit which has a edge back to When we visit one vertex we push it into a vector that will contain the hamiltonian cycle at the end If at some point we visit a vertex that is the parent of the endpoint of another path we recursively visit that path and after visiting it we continue with our original path But when recursively visiting the new path we traverse it upwards that is we start with and go up to the parent of the vertex If at some point we visit the endpoint of some other path we again do a recursive visit of that path this time in downwards direction This way we end up visiting all paths in a DFS like way and since we alternate between upward and downward traversals we end up having all the vertices of the graph in the vector ordered in a way that they form a hamiltonian cycle Now that we have found how to compute that hamiltonian cycle in linear time or halt if we find that some of the necessary conditions for a good ordering are violated let s see an additional necessary condition for a good ordering In a biconnected graph with a good ordering for any hamiltonian cycle then there can not be any pair of edges that cross that is if we draw the graph with vertices placed in a circle in the hamiltonian cycle order and with non cycle edges drawn as chords no two chords intersect Assume that two edges cross We can label the vertices so that forms the hamiltonian cycle in that order and the endpoints of the chords are and with Consider the cycle Because of the orientation of the hamiltonian cycle note that there are at least three consecutive vertices from the hamiltonian cycle in this cycle we have that Similarly for the cycle we see that But now consider the cycle Because we must also have contradiction Once we have found the hamiltonian cycle this property can be checked in linear time And now the properties we have checked are not only necessary but also sufficient A biconnected graph with a hamiltonian cycle such that non cycle edges do not cross admits a good ordering We assign an ordering by choosing one orientation of the cycle and ordering the edges of each vertex by how far is the endpoint of the edge traversing the cycle in that orientation We have to prove that this is a good ordering Let be any cycle and label the vertices so that and according to the orientation If we show that we will have shown that the cycle is consistent with the ordering We already have by the labelling choice Note that is is the first index to break the inequality then if the edge between and crosses some previous edge and if then the cycle from then onwards be contained in the interval between vertices and which is not possible since vertex lies outside This ordering can be reconstructed in time by applying any standard sorting algorithm to the adjacency lists of the vertices the comparison function is different for each vertex and it can be improved to linear time by making an array of pairs consisting on the information of all the adjacency lists each edge is included two times in the array one for each end sorting the array in linear time using counting sort and then for each of the vertices the sorted adjacency list can be restored by applying one splice operation to the list given in the order in which the array was sorted "}
{"statement": "You are given an undirected graph with n vertices and 3m edges The graph may contain multi edges but does not contain self loops The graph satisfies the following property the given edges can be divided into m groups of 3 such that each group is a triangle A triangle is defined as three edges a b b c and c a for some three distinct vertices a b c 1 leq a b c leq n Initially each vertex v has a non negative integer weight a v For every edge u v in the graph you perform the following operation Choose an integer x between 1 and 4 Then increase both a u and a v by x After performing all operations the following requirement should be satisfied if u and v are connected by an edge then a u ne a v It can be proven this is always possible under the constraints of the task Output a way to do so by outputting the choice of x for each edge It is easy to see that the order of operations does not matter If there are multiple valid answers output any ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3500", "problem_editorial": "Key Idea 1Go through from vertex through and decided their final weights in this order When deciding the weights for make sure it is different from if and is adjacent to Ignore vertices where is adjacent to but have "}
{"statement": "You are given a sequence of positive integers and two non negative integers and Your task is to transform into To do that you can perform the following moves subtract 1 from the current subtract mod from the current Operation mod means taking the remainder after division of number by number Now you want to know the minimum number of moves needed to transform into ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Brief description You have a number b and want to minus it to a what you can do in each step is weather subtract 1 or b mod xi from b And we ask what is the minimum number of steps you need Analysis I bet there is a few people know the greedy method even if he she have solved the early version before Codeforces 153 Div 1 Problem C Number Transformation Let dp k denotes the minimum number of steps to transform b k to b In each step you could only choose i which makes b k b k mod x i minimal to calc dp k It works bacause dp 0 k 1 is a monotone increasing function Proof Say dp k dp k t 1 If t 1 then dp 0 k is monotone increasing obviously Otherwise dp k 1 dp k t 1 dp k there must exist a x i makes b k 1 also transform to b k t and it is not necessarily the optimal decision of dp k 1 So dp k is a monotone increasing function we can greedily calc dp a b In the first glance it looks like something which will run in square complexity But actually is linear That is because we could cut exactly max xi in each 2 step It can be proof by induction So the remians work is to delete those same xi and watch out some situation could cause degeneration Many of us failed in this last step and got TLE"}
{"statement": "Dima has a hamsters farm Soon hamsters will grow up on it and Dima will sell them in a city nearby Hamsters should be transported in boxes If some box is not completely full the hamsters in it are bored that s why each box should be completely full with hamsters Dima can buy boxes at a factory The factory produces boxes of kinds boxes of the th kind can contain in themselves hamsters Dima can buy any amount of boxes but he should buy boxes of only one kind to get a wholesale discount Of course Dima would buy boxes in such a way that each box can be completely filled with hamsters and transported to the city If there is no place for some hamsters Dima will leave them on the farm Find out how many boxes and of which type should Dima buy to transport maximum number of hamsters ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "The easies way to solve this problem is to find the minimum number of hamsters that can be left on the farm If Dima byes boxes of the th type there are hamsters left on the farm So we should find such a type that the value is minimum among all The number of boxes to buy is then equal to "}
{"statement": "You are given an array consisting of integers You have to process queries to this array each query is given as four numbers and denoting that for every such that and you have to set equal to Print the array after all queries are processed ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "We can represent a query as a function if If we want to apply two functions then we can calculate a composition of these functions in time in this problem is So we can do the following Use scanline technique Build a segment tree over queries where we store a composition of functions on segment in each vertex Initially all transformations are When a segment where we apply a query begins we update the segment tree we change the transformations on this query s index to the following if When a segment ends we revert the transformation on this index to The trick is that the composition of all current transformations is stored in the root of the segment tree so we can easily calculate the result of transformation "}
{"statement": "You have r red and b blue beans You d like to distribute them among several maybe one packets in such a way that each packet has at least one red bean or the number of red beans r i ge 1 has at least one blue bean or the number of blue beans b i ge 1 the number of red and blue beans should differ in no more than d or r i b i le d Can you distribute all beans ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Without loss of generality let s say otherwise we can swap them Note that you can t use more than packets at least one red bean in each packet so can t exceed at most blue beans in each packet So if then asnwer is Otherwise we can form exactly packets "}
{"statement": "You have a large electronic screen which can display up to 998244353 decimal digits The digits are displayed in the same way as on different electronic alarm clocks each place for a digit consists of 7 segments which can be turned on and off to compose different digits The following picture describes how you can display all 10 decimal digits As you can see different digits may require different number of segments to be turned on For example if you want to display 1 you have to turn on 2 segments of the screen and if you want to display 8 all 7 segments of some place to display a digit should be turned on You want to display a really large integer on the screen Unfortunately the screen is bugged no more than n segments can be turned on simultaneously So now you wonder what is the greatest integer that can be displayed by turning on no more than n segments Your program should be able to process t different test cases ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "First of all we don t need to use any digits other than and If we use any other digit it consists of or more segments so it can be replaced by two s and the number will become greater For the same reason we don t need to use more than one if we have two we can replace them with three s Obviously it is always optimal to place before So our number is either a sequence of s or a and a sequence of s We should use only if is odd because if is even it will decrease the number of digits in the result "}
{"statement": "Once upon a time in the Kingdom of Far Far Away lived Sir Lancelot the chief Royal General He was very proud of his men and he liked to invite the King to come and watch drill exercises which demonstrated the fighting techniques and tactics of the squad he was in charge of But time went by and one day Sir Lancelot had a major argument with the Fairy Godmother there were rumors that the argument occurred after the general spoke badly of the Godmother s flying techniques That seemed to hurt the Fairy Godmother very deeply As the result of the argument the Godmother put a rather strange curse upon the general It sounded all complicated and quite harmless The drill exercises are held on a rectangular field split into square segments for each soldier Thus the square of the distance between the soldiers that stand on squares and equals exactly Now not all squad soldiers can participate in the drill exercises as it was before the Fairy Godmother s curse Unless of course the general wants the soldiers to fight with each other or even worse For example if he puts a soldier in the square then he cannot put soldiers in the squares and each of them will conflict with the soldier in the square Your task is to help the general You are given the size of the drill exercise field You are asked to calculate the maximum number of soldiers that can be simultaneously positioned on this field so that no two soldiers fall under the Fairy Godmother s curse ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "This problem was not on derivation of the general formula m n m n 2 only this would be too simple for the second fourth problem isn t it but rather on accurate investigation of several cases Unfortunately many participants were very eager to submit the formula above that s why there were so many hacks I would say this is not jury fault pretests were made very weak intentionally partially to give you some space for hacks but jury didn t presume there would be so many hacks This is your fault of submitting unproven solutions This is large risk given Codeforces rules and this time risk lovers were not lucky Ok let s come to the solution Without loss of generality let s assume m n Then we have the following cases 1 m 1 x n fields It is obvious that here the answer is n 2 m 2 x n 2 fields Here the correct formula is 2 2 n 4 min n 4 2 Why so To see this draw the board for arbitrary n and draw all possible knight moves on it In general you ll see four not overlapping chains Since you cannot place soldiers in the neighboring cells of any chain then for a chain of length L the answer doesn t exceed L L 2 On the other hand it is clear that the answer L L 2 is always possible since soldiers on different chains never hurt each other If you consider fields with different remainders n 4 the formula above becomes clear 3 m 3 x n 3 fields except the cases 3 x 3 3 x 5 3 x 6 and 4 x 4 Here one may use general formula m n m n 2 Why so It is known or becomes known with google that for all such fields knight tours exists Any knight tour is just a chain of lenght m n so by the logic above one cannot place more than m n m n 2 soldiers on it On the other hand if one makes chessboard coloring of the field it is clear that the answer above is always achievable if one chooses cells of one color as places for soldiers So formula above is proved 4 Cases 3 x 3 3 x 5 3 x 6 and 4 x 4 Here we can t use the logic above to prove that the above formula is also right here The easiest way is to verify it using brute force or pen and paper This concludes the solution "}
{"statement": "You are walking with your dog and now you are at the promenade The promenade can be represented as an infinite line Initially you are in the point 0 with your dog You decided to give some freedom to your dog so you untied her and let her run for a while Also you watched what your dog is doing so you have some writings about how she ran During the i th minute the dog position changed from her previous position by the value a i it means that the dog ran for a i meters during the i th minute If a i is positive the dog ran a i meters to the right otherwise if a i is negative she ran a i meters to the left During some minutes you were chatting with your friend so you don t have writings about your dog movement during these minutes These values a i equal zero You want your dog to return to you after the end of the walk so the destination point of the dog after n minutes 0 Now you are wondering what is the maximum possible number of different of the line your dog could visit on her way if you replace every 0 with some integer from k to k and your dog return to 0 after the walk The dog visits an integer point if she runs through that point or reaches in it at the end of any minute Point 0 is always visited by the dog since she is initially there If the dog cannot return to the point 0 after n minutes regardless of the integers you place print ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Consider every cyclic shift of the array Suppose that now the array starts from the position the first element is and the last element is Assume that before the position our dog reached her minimum possible position and now the minimum position will not change So our problem is to fill all zeros in the array in such a way that the maximum prefix sum of is the maximum possible and the total sum of is zero For simplicity consider the array which is the th cyclic shift of i e the first element is the second element is and so on Let s iterate from left to right and maintain the current sum of the array Let this variable be Now when we meet we should replace it with the maximum possible value we can because in such a way we will increase the maximum number of prefix sums Let be the number of zeros in starting from the position This value can be calculated in advance in for every cyclic shift using suffix sums Then the segment of positions we can have at the end is and we want to place the maximum possible value in in such a way that this remaining segment with addition of our current element will cover This maximum value equals If becomes less than then this cyclic shift is invalid and we should skip it Otherwise let s add to and proceed If there are no values then we placed anything correctly Now can just simulate the movements of our dog to find the answer for the current cyclic shift But there are cases when do not contain zeros so these cases should be handled somehow I just checked that after simulation we returned to If we returned to we can update the answer as the difference between the maximum and the minimum positions plus one If there is no valid cyclic shift then the answer is Time complexity "}
{"statement": "You re given a string s of length n consisting of only lowercase English letters You must do the following operation exactly once Choose any two indices i and j 1 le i j le n You can choose i j Set s i s j You need to minimize the number of distinct permutations dagger of s Output any string with the smallest number of distinct permutations after performing operation dagger A permutation of the string is an arrangement of its characters into any order For example is a permutation of but is not ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Find the character which appears the lowest number of times if tied take the earlier character in the alphabet Find the character which appears the highest number of times if tied take the later character in the alphabet Then replace any of the lowest occurrence characters with the highest occurrence character "}
{"statement": "NN is an experienced internet user and that means he spends a lot of time on the social media Once he found the following image on the Net which asked him to compare the sizes of inner circles It turned out that the circles are equal NN was very surprised by this fact so he decided to create a similar picture himself He managed to calculate the number of outer circles n and the radius of the inner circle r NN thinks that using this information you can exactly determine the radius of the outer circles R so that the inner circle touches all of the outer ones externally and each pair of neighboring outer circles also touches each other While NN tried very hard to guess the required radius he didn t manage to do that Help NN find the required radius for building the required picture ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Consider three circles inner and two outer Since all the circles are tangent the sides of the triangle constructed on the centers of the circles pass through the tangency points of the circles Denote by the angle in an equilateral gon Then On the other hand It can be noted that i e the function increases with On this basis a binary search can be used to find the answer or explicitly derive the formula The complexity is or "}
{"statement": "A correct expression of the form was written and are non negative integers without leading zeros In this expression the plus and equally signs were lost The task is to restore the expression In other words one character and one character should be inserted into given sequence of digits so that character is placed on the left of character characters and split the sequence into three non empty subsequences consisting of digits let s call the left part the middle part and the right part all the three parts and do not contain leading zeros it is true that It is guaranteed that in given tests answer always exists ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "At first we should calculate hash by big prime module from the given string and the base must be equal to because we work with numbers We can use prime module about if we will use multiple of long longs by module with help of long doubles After that we will brute the length of the result of summation let this value is Because when two numbers are added the result may have the same length as the larger term or may have a length one greater than the length of the larger term it is enough to check the following cases the length of the first term the length of the second term For each case the check algorithm is the same At first we should check that all parts have positive length that the length satisfies the conditions described at the beginning of the tutorial and that it part has no trailing spaces Now we should divide each part on in the needed power to bring the value of the calculated hash to the desired degree To make it we can multiply each part on element which is reverse to by the used module in the desired power To find which is reverse to be the prime module we should raising to the power with help of binary power raising If after the described operations the sum of first to parts by used module equals to the value of third part we found the answer and we should print corresponding parts You could also perform calculations on several smaller modules "}
{"statement": "You are given n times m grid Some cells are filled and some are empty A is a maximal by inclusion set of filled cells such that it is possible to get from any cell in the set to any other cell in the set by moving to adjacent by side cells without moving into any cells not in the set In other words a city is a connected component of filled cells with edges between adjacent by side cells Initially there are on the grid You want to change some empty cells into filled cells so that both of the following are satisfied There is on the resulting grid The shortest path between any two filled cells achievable only by moving onto filled cells is equal to the Manhattan distance between them The between two cells a b and c d is equal to a c b d Find a way to add filled cells that satisfies these conditions and minimizes the total number of filled cells ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Let s note that the resulting grid is correct if and only if filled cells form continious segment in each row and column condition and there is one city So we can define a filling operation given a grid fill all cells between the most left and most right cells in each row and the most up and most down cells in each column Doing this operation times we get that condition is satisfied and we filled cells that definitely should be filled If now there is one city we solved the problem But if there are still two cities their projections to horisontal and vertical axes do not intersect So we need to connect them with some path Let s consider the case when one city is upper left than the other city otherwise we can apply rotation and get this case Let s define the lowest row of the first city as the right column of the first city as the upper row of the second city as and the left column of the second city as We can fill cells on any Manhattan shortest path between cells After that again using filling operation we will fill cells that should be filled It is easy to see that by this solution we will get the smallest possible number of filled cells Time complexity "}
{"statement": "On a permutation p of length n we define a bully swap as follows Let i be the index of the largest element p i such that p i neq i Let j be the index of the smallest element p j such that i j Swap p i and p j We define f p as the number of bully swaps we need to perform until p becomes sorted Note that if p is the identity permutation f p 0 You are given n and a permutation p of length n You need to process the following q updates In each update you are given two integers x and y You will swap p x and p y and then find the value of f p Note that the updates are persistent Changes made to the permutation p will apply when processing future updates ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "Solution First of all we notice that if some element moves left it will never move right ProofProving this is not hard imagine to be the set of suffix minimas Then if an element is in we know that Since after every bully swap an element cannot disappear from and after each bully swap the swapped elements can only get closer to their desired position we conclude the proof Obviously if an element moves right it will never move left since it will continue to move right until it reaches its final position By the claims above we conclude that left and right movers are distinct Now suppose we swap indicies and and note that such swap kills inversions and the left mover moves steps Now the magic is that if we let be the sum over for all left movers we have thus our answer is just Now to handle the data structure part we just need to be able to calculate inversions while being able to perform point updates There are many ways to do this for example for using a fenwick tree and a bitwise trie ordered set in "}
{"statement": "You may use in C in Java in Python or in Pascal to flush the output If you use some other programming language consult its documentation You may also refer to the guide on interactive problems https codeforces com blog entry 45307 The jury picked an integer x not less than 0 and not greater than 2 14 1 You have to guess this integer To do so you may ask no more than 2 queries Each query should consist of 100 integer numbers a 1 a 2 a 100 each integer should be not less than 0 and not greater than 2 14 1 In response to your query the jury will pick one integer i 1 le i le 100 and tell you the value of a i oplus x the bitwise XOR of a i and x There is an additional constraint on the queries all 200 integers you use in the queries should be distinct ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Suppose all integers we input in some query have the same value in the th bit Then no matter which is chosen by the jury we can always deduce whether the th bit in is or This leads us to a simple solution divide bits of into two groups of size In the first query submit integers having the same values in the bits from the first group and deduce the values of these bits in In the second query do the same for the second group Be careful to avoid submitting the same integer twice "}
{"statement": "For a vector vec v x y define v sqrt x 2 y 2 Allen had a bit too much to drink at the bar which is at the origin There are n vectors vec v 1 vec v 2 cdots vec v n Allen will make n moves As Allen s sense of direction is impaired during the i th move he will either move in the direction vec v i or vec v i In other words if his position is currently p x y he will either move to p vec v i or p vec v i Allen doesn t want to wander too far from home which happens to also be the bar You need to help him figure out a sequence of moves a sequence of signs for the vectors such that his final position p satisfies p le 1 5 cdot 10 6 so that he can stay safe ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "We first prove a claim which will help us significantly The claim is that among any three vectors of lengths at most then some sum or difference has at length at most Draw a circle with radius centered at the origin If we plot the vectors from the origin two of these will lie in the same sector Any two points in this sector will have distance at most Therefore as long as there are at least vectors two of them can be combined and the input constraints will still be satisfied In the final step we can combine two vectors of length at most into one of length at most Implementation can be done in a number of ways for example constructing a binary tree with the input vectors as leaves or maintaining sets of signed vectors and merging small sets to large sets These approaches can take or "}
{"statement": "Wabbit is playing a game with n bosses numbered from 1 to n The bosses can be fought in any order Each boss needs to be defeated There is a parameter called which is initially 0 When the i th boss is defeated the current is added to Wabbit s score and then the value of the increases by the point increment c i Note that c i can be negative which means that other bosses now give fewer points However Wabbit has found a glitch in the game At any point in time he can reset the playthrough and start a New Game Plus playthrough This will set the current to 0 while all defeated bosses remain defeated The current score is also saved and does reset to zero after this operation This glitch can be used k times He can reset after defeating any number of bosses including before or after defeating all of them and he also can reset the game several times in a row without defeating any boss Help Wabbit determine the maximum score he can obtain if he has to defeat n bosses ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "We see that each playthrough whether it is the first one or any of the playthroughs after the reset is completely independent of any other playthrough Thus we should instead think of the problem as partitioning the n bosses into k 1 playthroughs Consider a playthrough with x bosses which have point increments a1 a2 ax when fought in order Then the number of points that we will get is x 1 a1 x 2 a2 1 ax 1 0 ax A simple greedy argument tell us that within a single playthrough we should always fight the bosses in non increasing order of point increments i e a1 a2 ax We can visualize this with k 1 stacks each representing a playthrough Each stack contains all of the bosses that will be fought in that playthrough and the stack is non increasing from top to bottom meaning we fight the bosses from top to bottom We now see that k 0 is a fairly trivial case just fight the bosses in non increasing order of point increments For the rest of the tutorial we will assume k 1 For simplicity we say that a boss is in position p of a playthrough if there are p more bosses below this one on its playthrough stack Notice that if we have two bosses in two different playthroughs with point increments a and b with positions i and j in their respective playthroughs then the total points gained from the two bosses is ia jb We now see that if a b then i j and vice versa For example the configuration below is not optimal because swapping the 5 and 3 gives a better answer Therefore all bosses in lower numbered positions should have point increments that are less than any boss in a higher numbered position This means that we can place the bosses on the stacks one at a time in non decreasing order of point increments to reach an optimal configuration Call a boss good if it has a non negative point increment and bad otherwise Let s fix the arrangement of bad bosses and try to place the good bosses in non decreasing order of point increments We can see that placing a boss with point increment a on a stack with height h will add ah to the total so we should always pick the stack with maximum height Thus all of the good bosses will always end up on the same stack and that stack will be the stack of maximum height Call this stack the main stack the other k stacks are the side stacks If there exists two side stacks whose heights differ by at least 2 then we can always move the top most bad boss of the taller side stack to the shorter side stack and decrease the loss in points In the example below the 10 on the left stack of height 5 can be moved down to the top of the right stack of height 3 Thus the maximum and minimum heights of these k side stacks cannot differ by more than 1 Let the minimum height of these k stacks be h If we consider the bottom h bosses of all k 1 stacks we see that they still must have the property that all bosses in lower positions have point increments that are less than any boss in higher positions Thus they must consist of the h k 1 bosses with smallest point increments "}
{"statement": "In the world of Compfestnesia Pak Chanek discovers a secret underground dungeon Inside it there is a treasure chest that is surrounded by n statues that are arranged in a circular manner The statues are numbered from 0 to n 1 with statue i being to the left of statue i 1 and statue n 1 being to the left of statue 0 Pak Chanek observes that each statue is holding a crystal ball with an integer between 0 and m 1 inclusive Let s say the integer in the crystal ball of statue i is a i The dungeon provides instructions that every integer in the crystal balls must be 0 in order to open the treasure chest To achieve that Pak Chanek is given an integer k and he can do zero or more operations In a single operation Pak Chanek does the following Choose exactly k consecutive statues In other words choose the statues p p 1 bmod n p 2 bmod n p 3 bmod n ldots p k 1 bmod n for some chosen index p Do one of the following For all chosen statues change their values of a i into a i 1 bmod m For all chosen statues change their values of a i into a i 1 bmod m Help Pak Chanek find the minimum possible number of operations to open the treasure chest ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3500", "problem_editorial": "Let s simplify the problem such that the only possible operation for each chosen statues is To solve this we first define as the number of times we do that operation for the statues We can see that in the optimal configuration must hold For it to make each element of to be must hold The number of operations is equal to In order to extend to the original problem we can see that for a given array the number of operations that can be made to be equal to So we need to find an array satisfying the conditions above such that is as small as possible We can see that That means if we have determined the value of the value of is forced If we form an edge for each pair of indices we will get connected components This means if we have determined the value of one vertex for each connected component the values of the entire array are forced However we must also consider possibility that at least one connected component cannot have assigned values that satisfy all of its edges In that case it is impossible to finish the objective of the problem Define For each we can find the difference relationship between it and Therefore to answer the problem we must find the values of such that and if all the other values of are calculated is as small as possible For the condition using simple modular algebra we can calculate one or more values such that if and only if is equal to one of the values of Let s consider the connected component It must have elements Define as the sum of for all elements of in that connected component if We can easily calculate all values of for all connected components in After this we must the minimum value of such that is equal to one of the values of This can be solved using modular knapsack dynamic programming but the time complexity is We must optimise it further Consider the contribution of a single element to the values of of its connected component Let s say the difference relationship is that must hold Notice that It adds to all values of for each going up modularly from to It adds to all values of for each going up modularly from to We can see it as changing slope at most three times namely in and This means if we add up all contributions of each element the number of points the slope changes in one connected component is at most We will call these points as special points Consider an array satisfying the condition that is equal to one of the values of Consider the case if there exists at least two different indices such that the value of is not a special point in Suppose the indices are and Since both of them are not special points the slope between and is the same as the slope between and The same is true for Let s say is the increase in value of the final answer if we do and and is the increase in value of the final answer if we do and From the observation above we can see that which means one of them is non positive This means if this is the case we can always change the array into another array with an equal or smaller final answer This means we can always do that operation to get an array such that there is at most one non special point Therefore we can just consider those cases to find the minimum answer We can solve this using divide and conquer We first call the recursive function The moment we call the function we have made the modular knapsack dynamic programming array if we have only considered the indices with or and only considering their special points recurses into and Once we will consider that index as the one that can have a non special point then we can just iterate the array and take the answer from the knapsack array The depth of the recursion is at most Each depth has insertions of indices to the knapsack Because each connected component only has special points each depth does dynamic programming transitions with each transition having time complexity Time complexity "}
{"statement": "Let s call a string if its letters can be realigned in such a way that they form two consequent groups of equal symbols note that different groups must contain different symbols For example is you can transform it to where the first three letters form a group of s and others a group of s but is not since in each possible consequent partition letters in these two groups coincide You re given a string Check whether it can be split into two non empty subsequences such that the strings formed by these subsequences are Here a subsequence is an arbitrary set of indexes of the string ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Since order of letters in strings doesn t matter it doesn t matter in the initial string as well Let be the number of distinct letters in Consider the following cases one after another If answer is since lengths of strings cannot be less than two If is more than answer is also since strings contain two distinct letters If is equal to answer is always we give two types of letters to string one and other two to string two If is equal to three answer is also based on the fact that length of is no less than If is equal to two answer depends on whether there s a letter occuring only once because that means that one of the strings will consist of letters of the same kind If all letters are the same answer is same as the previous case "}
{"statement": "Polycarp is an experienced participant in Codehorses programming contests Now he wants to become a problemsetter He sent to the coordinator a set of problems Each problem has it s quality the quality of the th problem is can be positive negative or equal to zero The problems are ordered by expected difficulty but the difficulty is not related to the quality in any way The easiest problem has index the hardest problem has index The coordinator s mood is equal to now After reading a problem the mood changes by it s quality It means that after the coordinator reads a problem with quality the value is added to his mood The coordinator always reads problems one by one from the easiest to the hardest it s impossible to change the order of the problems If after reading some problem the coordinator s mood becomes negative he immediately stops reading and rejects the problemset Polycarp wants to remove the minimum number of problems from his problemset to make the coordinator s mood non negative at any moment of time Polycarp is not sure about the current coordinator s mood but he has guesses the current coordinator s mood For each of guesses find the minimum number of problems Polycarp needs to remove so that the coordinator s mood will always be greater or equal to while he reads problems from the easiest of the remaining problems to the hardest ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "At first let s solve the problem for one value of It is easy to show that optimal solution is the following add to the set of tasks next task with quality equals to While the value of mood the sum of qualities and is less than 0 delete from the set of remaining task the task with worst quality The quality of such task will be less than 0 because we will not spoil the mood on previous tasks This solution can be implement with help of structures or Described solution helps us to find answer on the query in but does not fill in time limit Note that while we increase the number of deleted problems does not increase and the possible number of such numbers is only So we need to solve the following task for calculate minimum value of that the number of deleted problems does not exceed This problem can be easily solved for each with help of binary search in in sum for all we got Also we have an interest only values of we can make the binary search only on this values and in total we got For each answer with help of stored values we need to find the first answer which minimum value of does not more than in the query We can do it easy in or with binary search in because the values for the answers does not increase In total we will get or in sum The best asymptotic behavior is but solutions which work in also passed all tests "}
{"statement": "You are an upcoming movie director and you have just released your first movie You have also launched a simple review site with two buttons to press upvote and downvote However the site is not so simple on the inside There are two servers each with its separate counts for the upvotes and the downvotes n reviewers enter the site one by one Each reviewer is one of the following types type 1 a reviewer has watched the movie and they like it they press the upvote button type 2 a reviewer has watched the movie and they dislike it they press the downvote button type 3 a reviewer hasn t watched the movie they look at the current number of upvotes and downvotes of the movie on the server they are in and decide what button to press If there are more downvotes than upvotes then a reviewer downvotes the movie Otherwise they upvote the movie Each reviewer votes on the movie exactly once Since you have two servers you can actually manipulate the votes so that your movie gets as many upvotes as possible When a reviewer enters a site you know their type and you can send them either to the first server or to the second one What is the maximum total number of upvotes you can gather over both servers if you decide which server to send each reviewer to ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Notice that the answer depends only on the number of the reviewers of the third type who upvote the movie Optimally we would want every single reviewer of the third type to upvote We can achieve it with the following construction send all reviewers of the first type to the first server all reviewers of the second type to the second server and all reviewers of the third type to the first server Since there are no downvotes on the first server all reviewers of the third type will upvote Thus the answer is the total number of reviewers of the first and the third type Overall complexity per testcase "}
{"statement": "The winter in Berland lasts days For each day we know the forecast for the average air temperature that day Vasya has a new set of winter tires which allows him to drive safely no more than days at any average air temperature After days of using it regardless of the temperature of these days the set of winter tires wears down and cannot be used more It is not necessary that these days form a continuous segment of days Before the first winter day Vasya still uses It is possible to drive safely on summer tires any number of days when the average air temperature is It is impossible to drive on summer tires at days when the average air temperature is negative Vasya can change summer tires to winter tires and vice versa at the beginning of any day Find the minimum number of times Vasya needs to change summer tires to winter tires and vice versa to drive safely during the winter At the end of the winter the car can be with any set of tires ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "At first let s process the case when there is no solution when the number of days with negative temperature more than Now we need to subtract from the number of days If we will use winter rubber only in days with negative temperature we will get the maximum value of answer it is the number of segments where all days have negative temperature multiply by 2 Between the segments with negative temperatures there are segments which we ride on the summer rubber Let s put in the lengths of this segments not include the segments with first and last days if th y have non negative temperatures this cases we need to process separately from the main solution After that we need to delete from the smallest lengths of segments one by one decrease on this value and decrease answer on 2 We can make it until and the is not empty Now we only need to check if we can ride on winter rubber the last segment of days with non negative temperature If it is possible we need decrease the answer on 1 in the other case the answer remains unchanged "}
{"statement": "Alice and Bob are playing an infinite game consisting of Each set consists of In each round one of the players wins The first player to win two rounds in a set wins this set Thus a set always ends with the score of 2 0 or 2 1 in favor of one of the players Let s call a a finite string s consisting of characters and Consider an infinite string formed with repetitions of string s sss ldots Suppose that Alice and Bob play rounds according to this infinite string left to right If a character of the string sss ldots is then Alice wins the round if it s Bob wins the round As soon as one of the players wins two rounds the set ends in their favor and a new set starts from the next round Let s define a i as the number of sets won by Alice among the first i sets while playing according to the given scenario Let s also define r as the limit of ratio frac a i i as i rightarrow infty If r frac 1 2 we ll say that scenario s is If r frac 1 2 we ll say that scenario s is If r frac 1 2 we ll say that scenario s is You are given a string s consisting of characters and Consider all possible ways of replacing every with or to obtain a string consisting only of characters and Count how many of them result in a scenario winning for Alice how many result in a tied scenario and how many result in a scenario winning for Bob Print these three numbers modulo 998 244 353 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "For a fixed game scenario let s build a weighted functional graph on vertices that correspond to set scores and For each score traverse the scenario from left to right changing the score after each letter and starting a new set whenever necessary If the set score by the end of the scenario is add a directed edge from to The weight of this edge is the number of sets Alice wins during the process minus the number of sets Bob wins When we have built such a graph for a game scenario we can easily decide whether is winning for Alice tied or winning for Bob Starting from vertex move by the outgoing edges until you arrive at a cycle In the cycle find the sum the edge weights If the sum is positive the scenario is winning for Alice if the sum is the scenario is tied if the sum is negative the scenario is winning for Bob Now we can use dynamic programming Let be the number of ways to choose so that edges from vertices go to vertices and have weights respectively Even though this DP has states it might be possible to get this solution accepted if you only visit reachable states and optimize your solution s constant factor However here s an idea that drastically improves the time complexity Note that in the end we are only interested in the sum of some and not in every value separately Outside of our DP let s fix the mask of vertices that will lie on the cycle reachable from In the DP state we can just store the sum of over belonging to this mask In the end we will look at the values of and check if the cycle in our graph is indeed the one we want only if that s true we will add the DP value to the overall answer This way at the cost of running the DP times we have cut the number of states to The overall time complexity of this solution is too although the constant factor is huge "}
{"statement": "Vitalik the philatelist has a birthday today As he is a regular customer in a stamp store called Robin Bobin the store management decided to make him a gift Vitalik wants to buy one stamp and the store will give him a non empty set of the remaining stamps such that the greatest common divisor GCD of the price of the stamps they give to him is more than one If the GCD of prices of the purchased stamp and prices of present stamps set will be equal to then Vitalik will leave the store completely happy The store management asks you to count the number of different situations in which Vitalik will leave the store completely happy Since the required number of situations can be very large you need to find the remainder of this number modulo The situations are different if the stamps purchased by Vitalik are different or if one of the present sets contains a stamp that the other present does not contain ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "The problem has been prepared by gridnevvvit Let s calculate the number of subsets with gcd equal to value A Let s do that using principle of inclusions exclusions firstly we say that all subsets is good The total number of subsets is equal to Now let s subtract subsets with gcd divisible by The number of that subsets is equal to is the number of numbers that is divisable by Next we should subtract Subsets with gcd divisible by we already counted with number two Next we should subtract Now we should notice that subsets with gcd divisible by we already processed twice firstly with number then with so let s add the number of these subsets If we continue this process we will get that for all numbers we should add the value where is equals to if is divisible by square of some prime if the number of primes in factorization of is even and in other case So the numbers that is divisible by square of some prime we can ignore because they have coefficient To calculate values we should factorize all numbers and iterate over divisors with value Now it s easy to see that the number of subsets with gcd greater than equals to To solve the problem let s fix the stamp that Vitaliy will buy Let s recalculate the number for array a without element To do that we should only subtract those terms that was affected by number We can do that in where is the number of primes in factorization of the number It s easy to see that only the subsets with gcd greater than but not divisible by any divisor of should we counted in answer To calculate number of those subsets let s again use the principle of inclusions exclusions For every divisor of let s subtract the value from So now we got the number of subsets with gcd greater than but coprime with The answer to problem is the sum over all The maximum number of primes in factorization of number not greater than is equal to We can factorize all numbers from to in linear time by algorithm for finding the smallest divisors for all intergers from to or by sieve of Eratosthenes in time Complexity where is the largest number of primes in factorization of "}
{"statement": "Arkady and Masha want to choose decorations for thier aquarium in Fishdom game They have decorations to choose from each of them has some cost To complete a task Arkady and Masha need to choose decorations from given and they want to spend as little money as possible There is one difficulty Masha likes some of the given decorations Arkady likes some of the given decorations Some decorations may be liked by both Arkady and Masha or not be liked by both The friends want to choose such decorations so that each of them likes decorations among the chosen Help Masha and Arkady find the minimum sum of money they need to spend ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Let s divide the decorations in four groups that aren t liked by anybody group 0 that are liked only by Masha group 1 that are liked only by Arkady group 2 that are liked by both group 3 Sort each group by the cost Then it s obvious that in optimal solution we should take several or 0 first elements in each group Take a look at the group 3 It s easy to see that if we take decorations from it then we should take first decorations from each of the groups 1 and 2 Let s call these decorations from the group 3 and from each of the groups 1 and 2 and let s call the other decorations If the number of obligatory decorations is less than we need to take several cheapest free decorations It s easy to construct an solution then for each we can construct the answer described in linear time and then choose minimum among these answers To speed up the algorithm let s try all from the minimum possible it s easy to get it from integers and groups 1 and 2 sizes making transfers from to We should maintain the set of costs of free decorations and let s also keep integer which is the number of free decorations that we should add to the current answer and also the sum of the cheapest free decorations When we increase by 1 in groups 1 and 2 the most expensive obligatory decoration becomes free because the value decreases by one 1 These decorations if any we should add to our free set We should also add one obligatory decoration from the group 3 so the number of free decorations could change by one So we need at most operations of adding an integer to a set and an operation that changes with the corresponding change of the sum We can perform these operations in for example using two objects in or its analogues in other languages one set for the smallest integers and one for the others The overall complexity to change to is now so the overall complexity is "}
{"statement": "Catherine received an array of integers as a gift for March 8 Eventually she grew bored with it and she started calculated various useless characteristics for it She succeeded to do it for each one she came up with But when she came up with another one of all pairwise sums of elements in the array she realized that she couldn t compute it for a very large array thus she asked for your help Can you do it Formally you need to compute a 1 a 2 oplus a 1 a 3 oplus ldots oplus a 1 a n oplus a 2 a 3 oplus ldots oplus a 2 a n ldots oplus a n 1 a n Here x oplus y is a bitwise XOR operation i e x y in many modern programming languages You can read about it in Wikipedia https en wikipedia org wiki Exclusive or Bitwise operation ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s calculate each bit in the answer separately Suppose we want to know the value of th in 0 indexation bit in the answer Then we can notice that we are only interested in bits from th to th which means that we can take all numbers modulo After that the sum of the two numbers can t exceed th bit is 1 if and only if sum belongs to or So we have to count the number of pairs of numbers that give a sum that belongs to these segments Let s sort all numbers taken by modulo and make a pass with two pointers or do binary searches for each number Total complexity Bonus can you do it in "}
{"statement": "Let s call some positive integer if its decimal representation contains no more than 3 non zero digits For example numbers 4 200000 10203 are and numbers 4231 102306 7277420000 are not You are given a segment L R Count the number of integers x such that L le x le R Each testcase contains several segments for each of them you are required to solve the problem separately ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "There are quite a few approaches to the problem I ll describe the two of them which I actually implemented First approach combinatoric one Problems of the form count the number of beautiful numbers from to usually require counting the numbers on and or not inclusively and and subtracting one from another Let s try this thing here counting not inclusively Let s fix some prefix of the upper border number We want to calculate the amount of numbers having the same prefix but being smaller in the next digit If we count it for all prefixes including the empty one we will get the answer And that is pretty easy Let the prefix include non zero digits the length of the suffix be and the digit after the chosen prefix is If is zero then there the result is obviously zero Otherwise we can either put or any of the non zero digits Then the formula is We choose positions from the suffix to put non zero digits in them any digit from to and fill the rest with zeros Overall complexity Second approach precalc one This is a bit easier to implement Actually there are just about 700000 valid numbers you can generate them all put them into the array in sorted order and binary search for the given queries Overall complexity "}
{"statement": "Given an array a of n integers find a range of values x y x le y and split a into k 1 le k le n subarrays in such a way that Each subarray is formed by several continuous elements of a that is it is equal to a l a l 1 ldots a r for some l and r 1 leq l leq r leq n Each element from a belongs to exactly one subarray In each subarray the number of elements inside the range x y inclusive is than the number of elements outside the range An element with index i is inside the range x y if and only if x le a i le y Print any solution that minimizes y x ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Solution Focus on how to solve the problem for a fixed interval Let us define an array such that if or otherwise for all Let s define as We need to find a partition on subarrays with positive sum of The sum of a subarray is Then a subarray is valid if We need to find an increasing sequence of of length starting at and ending at Let s define to be the first occurrence of the integer in If there will be no valid sequence otherwise the sequence will satisfy all constraints Note that since for then exists and for This solves the problem for a fixed interval It remains to find the smallest interval such that For a given interval since will be equal to the number of elements of inside the interval minus the number of elements outside Then for each it is possible to find the smallest such that using binary search or two pointers It is also possible to note that We need to find the smallest interval with at least inside let be the array sorted the answer is the minimum interval among all intervals for Complexity if solved with the previous formula or binary search or is solved with two pointers Code with the previous formula "}
{"statement": "In Berland each high school student is characterized by integer value between and In high school there are two groups of pupils the group and the group Each group consists of exactly students An academic performance of each student is known integer value between and The school director wants to redistribute students between groups so that each of the two groups has the same number of students whose academic performance is equal to the same number of students whose academic performance is and so on In other words the purpose of the school director is to change the composition of groups so that for each value of academic performance the numbers of students in both groups are equal To achieve this there is a plan to produce a series of exchanges of students between groups During the single exchange the director selects one student from the class and one student of class After that they both change their groups Print the least number of exchanges in order to achieve the desired equal numbers of students for each academic performance ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "To solve this problem let s use array We need to iterate through first array with academic performances and for current performance let s increase on one In the same way we need to iterate through the second array and decrease on one If after that at least one element of array is odd the answer is it means that there are odd number of student with such performance and it is impossible to divide them in two If all elements are even the answer is the sum of absolute values of array divided by 2 In the end we need to divide the answer on 2 because each change will be counted twice with this way of finding the answer "}
{"statement": "You are given one integer number n Find three a b c such that 2 le a b c and a cdot b cdot c n or say that it is impossible to do it If there are several answers you can print any You have to answer t independent test cases ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Suppose Let s try to minimize and maximize Let be the minimum divisor of greater than Then let be the minimum divisor of that isn t equal and If isn t equal and then the answer is otherwise the answer is Time complexity per query "}
{"statement": "There are n block towers numbered from 1 to n The i th tower consists of a i blocks In one move you can move one block from tower i to tower j but only if a i a j That move increases a j by 1 and decreases a i by 1 You can perform as many moves as you would like possibly zero What s the largest amount of blocks you can have on the tower 1 after the moves ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Notice that it never makes sense to move blocks between the towers such that neither of them is tower as that can only decrease the heights Moreover it never makes sense to move blocks away from the tower Thus all operations will be moving blocks from some towers to tower At the start which towers can move at least one block to tower Well only such that What happens after you move a block Tower becomes higher some tower becomes lower Thus the set of towers that can share a block can t become larger Let s order the towers by the number of blocks in them At the start the towers that can share a block are at the end on some suffix in this order After one move is made the towers get reordered and the suffix can only shrink Ok but if that suffix shrinks what s the first tower that will become too low The leftmost one that was available before So regardless of what the move is the first tower that might become unavailable is the leftmost available tower Thus let s attempt using it until it s not too late The algorithm then is the following Find the lowest tower that can move the block to tower move a block repeat When there are no more towers higher than tower the process stops However the constraints don t allow us to do exactly that We ll have to make at most moves per testcase Ok let s move the blocks in bulk every time Since the lowest available tower will remain the lowest until you can t use it anymore make all the moves from it at the same time If the current number of blocks in tower is and the current number of blocks in that tower is blocks can be moved You can also avoid maintaining the available towers by just iterating over the towers in the increasing order of their height Overall complexity per testcase "}
{"statement": "You are given a tree of n nodes with node 1 as its root node There is a hidden mole in one of the nodes To find its position you can pick an integer x 1 le x le n to make an inquiry to the jury Next the jury will return 1 when the mole is in subtree x Otherwise the judge will return 0 If the judge returns 0 and the mole is not in root node 1 the mole will move to the parent node of the node it is currently on Use at most 300 operations to find the node where the mole is located ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Read hints first For easy version we can pick a vertex v such that maxdepv depv 1 50 if the jury returns 0 we can delete the entire subtree otherwise make queries until it is out and answer fav a special case is v 1 if there is no such vertex then make 100 queries and answer the root node 1 This costs about 200 queries which can not pass hard version But we can optimize it The bottleneck is the step 2 when we drive away this mole once we need to immediately check if it is still in the subtree v which can be optimized In fact we can drive the mole 50 times and then perform a binary search on the chain from v to the root node Number of queries O 2sqrt n log n "}
{"statement": "A positive integer is called if it can be represented as a product of two positive integers both greater than 1 For example the following numbers are composite 6 4 120 27 The following numbers aren t 1 2 3 17 97 Alice is given a sequence of n composite numbers a 1 a 2 ldots a n She wants to choose an integer m le 11 and color each element one of m colors from 1 to m so that for each color from 1 to m there is at least one element of this color each element is colored and colored exactly one color the greatest common divisor of any two elements that are colored the same color is greater than 1 i e gcd a i a j 1 for each pair i j if these elements are colored the same color Note that equal elements can be colored different colors you just have to choose one of m colors for each of the indices from 1 to n Alice showed already that if all a i le 1000 then she can always solve the task by choosing some m le 11 Help Alice to find the required coloring Note that you don t have to minimize or maximize the number of colors you just have to find the solution with some m from 1 to 11 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "The solution is obvious once one note that for any composite number there exists a prime such that and is divisible by Coincidentally there are exactly primes below Thus one can color balls according to their smallest divisor That works because if all numbers of the same color have the same divisor then each pair has at least this divisor in their GCD "}
{"statement": "As we all know Max is the best video game player among her friends Her friends were so jealous of hers that they created an actual game just to prove that she s not the best at games The game is played on a directed acyclic graph a DAG with vertices and edges There s a character written on each edge a lowercase English letter Max and Lucas are playing the game Max goes first then Lucas then Max again and so on Each player has a marble initially located at some vertex Each player in his her turn should move his her marble along some edge a player can move the marble from vertex to vertex if there s an outgoing edge from to If the player moves his her marble from vertex to vertex the character of that round is the character written on the edge from to There s one additional rule the ASCII code of character of round should be to the ASCII code of character of round for The rounds are numbered for both players together i e Max goes in odd numbers Lucas goes in even numbers The player that can t make a move loses the game The marbles may be at the same vertex at the same time Since the game could take a while and Lucas and Max have to focus on finding Dart they don t have time to play So they asked you if they both play optimally who wins the game You have to determine the winner of the game for all initial positions of the marbles ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1700", "problem_editorial": "Denote as the winner of the game the person that starts it or the other one a boolean true if first person wins if the first person s marble is initially at vertex and the second one s initially at and our set of letters is if is an integer Denote and as the character written on edge from to Now if there s some in such that and then the first person can move his her marble to vertex and win the game thus otherwise it s false Because the graph is a DAG there s no loop in this dp thus we can use memoization The answer for is Total time complexity "}
{"statement": "You are given an array a of length n and array b of length m both consisting of only integers 0 and 1 Consider a matrix c of size n times m formed by following rule c i j a i cdot b j i e a i multiplied by b j It s easy to see that c consists of only zeroes and ones too How many of size area k consisting only of ones are there in c A is an intersection of a consecutive subsequent segment of rows and a consecutive subsequent segment of columns I e consider four integers x 1 x 2 y 1 y 2 1 le x 1 le x 2 le n 1 le y 1 le y 2 le m a subrectangle c x 1 dots x 2 y 1 dots y 2 is an intersection of the rows x 1 x 1 1 x 1 2 dots x 2 and the columns y 1 y 1 1 y 1 2 dots y 2 The size area of a subrectangle is the total number of cells in it ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Rectangle consists of only ones iff subsegment consists of only ones in and subsegment consists of only ones in Let s iterate over divisors of Let the current divisor be i e so we are interested in number of subsegments consisting of ones of length in and number of subsegments consisting of ones of length in It s possible to precalculate number of segments consisting of ones in and of each length Let s find all maximal subsegments consisting of ones in and Consider subsegment of length It adds for amount of subsegments of length "}
{"statement": "When Masha came to math classes today she saw two integer sequences of length n 1 on the blackboard Let s denote the elements of the first sequence as a i 0 le a i le 3 and the elements of the second sequence as b i 0 le b i le 3 Masha became interested if or not there is an integer sequence of length n which elements we will denote as t i 0 le t i le 3 so that for every i 1 le i le n 1 the following is true a i t i t i 1 where denotes the bitwise OR operation and b i t i t i 1 where denotes the bitwise AND operation The question appeared to be too difficult for Masha so now she asked you to check whether such a sequence t i of length n exists If it exists find such a sequence If there are multiple such sequences find any of them ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Let s solve the problem for 0 ai bi ti 1 that is for binary sequences There are two options for t1 the remaining part can be determined one number by one after this If t1 0 and a1 0 and b1 0 then t2 0 If t1 0 and a1 0 and b1 1 then there is no such t2 If t1 0 and a1 1 and b1 0 then t2 1 If t1 0 and a1 1 and b1 1 then t2 1 If t1 1 and a1 0 and b1 0 then there is no such t2 If t1 1 and a1 0 and b1 1 then there is no such t2 If t1 1 and a1 1 and b1 0 then t2 0 If t1 1 and a1 1 and b1 1 then t2 1 One can similarly find all other ti s 3 i n or get a contradiction For bitwise operations from the statement one can solve the problem independently for every bit and restore the original sequence t1 t2 tn "}
{"statement": "There are n squares arranged in a row and each of them can be painted either red or blue Among these squares some of them have been painted already and the others are blank You can decide which color to paint on each blank square Some pairs of adjacent squares may have the same color which is imperfect We define the as the number of pairs of adjacent squares that share the same color For example the imperfectness of is 3 with occurred once and occurred twice Your goal is to minimize the imperfectness and print out the colors of the squares after painting ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "For a longest period of it is optimized to paint either or so the imperfectness it made is only related to the colors of both sides of it Choose the one with the lower imperfectness for each longest period of in is acceptable More elegantly if the square on the left or on the right of a is painted simply paint with the different color from it This can be proved to reach the minimum imperfectness by considering the parity "}
{"statement": "Tokitsukaze has a permutation p of length n Recall that a permutation p of length n is a sequence p 1 p 2 ldots p n consisting of n distinct integers each of which from 1 to n 1 leq p i leq n She wants to know how many different indices tuples a b c d 1 leq a b c d leq n in this permutation satisfy the following two inequalities p a p c and p b p d Note that two tuples a 1 b 1 c 1 d 1 and a 2 b 2 c 2 d 2 are considered to be different if a 1 ne a 2 or b 1 ne b 2 or c 1 ne c 2 or d 1 ne d 2 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "We can calculate the answer in two steps The first step for each let represents the number of where in the interval We can calculate in The second step calculate the answer First we enumerate from to and then enumerate from to When add in the interval to the answer Before enumerating we can calculate the prefix sum of first so we can add the in the interval to the answer in The time complexity of this step is However this will add the result of in the interval to the answer which is illegal because is required So we need to maintain while enumerating enumerate from to if minus is actually regarded as that is subtract the case where is equal to so as to subtract the illegal case The time complexity of this step is also Time complexity By the way use Fenwick Tree or Segment Tree can also pass the time complexity is "}
{"statement": "Rudolf has prepared a set of n problems with complexities a 1 a 2 a 3 dots a n He is not entirely satisfied with the balance so he wants to add problem to fix it For this Rudolf came up with m models of problems and k functions The complexity of the i th model is d i and the complexity of the j th function is f j To create a problem he selects values i and j 1 le i le m 1 le j le k and by combining the i th model with the j th function he obtains a new problem with complexity d i f j a new element is inserted into the array a To determine the of the set Rudolf sorts the complexities of the problems in ascending order and finds the largest value of a i a i 1 i 1 What is the minimum value of that Rudolf can achieve by adding at most one problem created according to the described rules ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Let s consider the differences Since we can only insert one problem we can reduce the difference in difficulty in only one place If we insert a problem not between the tasks whose difference in difficulty is maximum denote them as and then the will not change The best way to insert a problem in this way is to choose the middle between these tasks so the larger of the differences and will be minimal We also cannot forget about the other tasks Let s find the second maximum among the values Since we insert a problem in another place this difference will not decrease and therefore the answer cannot be less than it To understand what answer we can achieve let s sort the functions and iterate through all the models For the model using binary search we will find the maximum index such that For inserting with the selected model the best fit will be either a problem of difficulty or a problem of difficulty if since it is the closest problems to the middle We will check both options and update the answer "}
{"statement": "Shrek and the Donkey as you can guess they also live in the far away kingdom decided to play a card game called YAGame The rules are very simple initially Shrek holds cards and the Donkey holds cards the players do not see each other s cards and one more card lies on the table face down so that both players cannot see it as well Thus at the beginning of the game there are overall cards Besides the players know which cards the pack of cards consists of and their own cards but they do not know which card lies on the table and which ones the other player has The players move in turn and Shrek starts During a move a player can Try to guess which card is lying on the table If he guesses correctly the game ends and he wins If his guess is wrong the game also ends but this time the other player wins Name any card from the pack If the other player has such card he must show it and put it aside so that this card is no longer used in the game If the other player doesn t have such card he says about that Recently Donkey started taking some yellow pills and winning over Shrek Now Shrek wants to evaluate his chances to win if he too starts taking the pills Help Shrek assuming the pills are good in quality and that both players using them start playing in the optimal manner ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "This problem was about optimally playing this simple at first glance game The key thing to recognize in the statement was that it is not always optimal to name card which you don t have Sometimes it is optimal to confuse the opponent by naming card which you have on hand In this case yes he may think that the card you named is card on the table and lose during the next turn Now the problem is to understand when to use the strategy of reduction of opponent s cards when to bluff in the abovementioned sense and when to try to determine which card is on the table But instead of when the right question is how frequently since we have nothing else but usual constant sum matrix game and optimal strategy is the mixture of these three Let s construct a matrix first Player 1 has three pure strategies playing when he plays the game and really tries to determine opponent s cards and card on the table guessing when he guesses which card is lying on the table and bluffing when he tries to confuse his opponent to force him to lose by naming card in his own hand In turn if the first player used bluffing strategy or during the playing strategy named card on the table his opponent has two strategies check i e to believe the first player that he doesn t own the card he named and guess it as the card on the table and move on i e to decide that it was a bluffing strategy and the game should be continued but with notice that the first player has named card on hands Let s denote P m n probability to win the game when the first player has m cards and the second player has n cards Then P m n is the value of the matrix game with the following matrix rows strategies of the first player two numbers in the rows probabilities to win when the second player uses strategies check and move on correspondingly check move on playing n n 1 1 P n 1 m 1 n 1 n n 1 1 P n 1 m guessing 1 n 1 1 n 1 bluffing 1 1 P n m 1 How to get these numbers in the matrix Consider the first row playing strategy of the first player check strategy of the second First just names one of the n 1 cards With probability 1 n 1 he names card on the table seconds checks it and wins so probability to with for the first is 0 with probability n n 1 the first names one of the cards on hands of the second player so the game continues second wins with prob P n 1 m in this case Then the overall probability for the first to win with such combination of pure strategies is n n 1 1 P n 1 m In the same manner we fill other cells of the matrix Finally we solve the game this can be done straightforwardly or with one formula if one notices that the guessing strategy is suboptimal everywhere when m 1 and n 1 and that the game doesn t have saddle points and get answer to the problem P m n And the last thing to note when m 0 it is clear that during his move the second wins so the first should guess and P 0 n 1 n 1 When n 0 P m 0 1 sinse we just do one rightguessing "}
{"statement": "You are given two binary strings a and b of length n In each move the string a is modified in the following way An index i 1 leq i leq n is chosen uniformly at random The character a i will be flipped That is if a i is 0 it becomes 1 and if a i is 1 it becomes 0 What is the expected number of moves required to make both strings equal A binary string is a string in which the character is either tt 0 or tt 1 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "At first we can think of another problem Given an array You need to find the maximum subset How can we solve it We can solve this problem very efficiently using a technique called Basis You can read about it from here In problem E at first we can fix any node as the root of the tree Let s call this rooted tree the base tree After that start an Euler tour from the root and assign discovery time and finishing time to each node In each query three types of cases can occur node and node are from the query format In this case we need to calculate the maximum subset of the whole tree Node is an ancestor of node in the base tree So the subtree of node will remain the same Node is an ancestor of node in the base tree What will be the new subtree of node in this case This is a bit tricky Let s denote such a node that is a child of node and an ancestor of node in the base tree Then the new subtree of node will contain the whole tree except the subtree in the base tree of node Let s say is the basis of all the values in node s subtree in the base tree We can build by inserting the value to and merging it with all of its children s basis Two basis can be merged in complexity where is their dimension If we can build the basis for each node we are able to answer the case and case To answer case we need to find the maximum subset in the corresponding basis To answer case we need to do a similar thing in the basis where is the root node of the base tree For case let s say is the basis of all the values of the base tree except the node s subtree in the base tree Then the answer of the case will be the maximum subset in the basis To build the basis for each node we can utilize the properties of the discovery time and finishing time Which nodes will be outside the subtree of node The nodes that have either or To merge their basis easily we can pre calculate two basis arrays and where the basis includes all the values of the nodes such that and the basis includes all the values of the nodes such that To find the node in the case we can perform a binary search on the children of node We can use the fact that the order of the discovery times follows the order of the children and a node is only an ancestor of a node iff Time complexity where "}
{"statement": "You are given an undirected unweighted tree consisting of n vertices An undirected tree is a connected undirected graph with n 1 edges Your task is to choose two pairs of vertices of this tree all the chosen vertices x 1 y 1 and x 2 y 2 in such a way that neither x 1 nor y 1 belong to the simple path from x 2 to y 2 and vice versa neither x 2 nor y 2 should not belong to the simple path from x 1 to y 1 Among all possible ways to choose such pairs you have to choose one with the between paths from x 1 to y 1 and from x 2 to y 2 And among all such pairs you have to choose one with the of these two paths The length of the path is the number of edges in it The simple path is the path that visits each vertex at most once ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Firstly let s call a path from to if is a leaf is a vertex of degree at least the number of their neighbors is at least and there are no other vertices of degree at least on this path expect the vertex The first step of the solution is to remove all the paths from to but we should not remove the vertex and remember for each vertex the sum of two maximum lengths of paths which end in the vertex Let this value for the vertex be For example if for some vertex there are good paths with end in it of lengths and correspondingly then will be Okay it is easy to see that the maximum intersection of two paths in the answer will be equal to the length of the diameter of the obtained tree But we can not take diameter of this tree and call it the answer because of the second constraint we need to find some diameter from to such that the sum is maximum possible How do we do that There is such an awesome and well known fact that the center of a tree belongs to all diameters of this tree Let s root the tree by the center of a tree if the length of the diameter is odd the center of a tree is an edge then let s root the tree by any end of this edge it does not matter There is one case when the length of the diameter is but it is pretty trivial to handle it Now our problem is to find two neighbors of the root of the new tree such that in their subtrees are vertices which form some diameter of this tree and the sum of values of these vertices is maximum possible Let s calculate the vertex with the maximum distance from a root and with the maximum possible for equals distances by simple for each neighbor of a root It can be done in and the last part is to find two maximums of this list it also can be done in or depends on implementation "}
{"statement": "Today Alex was brought array a 1 a 2 dots a n of length n He can apply as many operations as he wants including zero operations to change the array elements In 1 operation Alex can choose any l and r such that 1 leq l leq r leq n and multiply all elements of the array from l to r inclusive by 1 In other words Alex can replace the subarray a l a l 1 dots a r by a l a l 1 dots a r in 1 operation For example let n 5 the array is 1 2 0 3 1 l 2 and r 4 then after the operation the array will be 1 2 0 3 1 Alex is late for school so you should help him find the maximum possible sum of numbers in the array which can be obtained by making any number of operations as well as the minimum number of operations that must be done for this ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "We can delete all zeros from the array and it won t affect on answer Maximum sum is Minimum number of operations we should do number of continuous subsequences with negative values of elements Total complexity "}
{"statement": "You are given an array a of length n consisting of positive integers and an array x of length q also consisting of positive integers There are q modification On the i th modification 1 leq i leq q for each j 1 leq j leq n such that a j is divisible by 2 x i you add 2 x i 1 to a j x i 1 leq x i leq 30 is After modification queries you need to output the final array ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let a number be divisible by Then after applying the operation it is no longer divisible by From this we can conclude that if we apply the operation and there is such an operation that then the operation does not change the array So it is useless and can be simply not processed Then we will maintain the minimum of the processed If the new operation is smaller than the minimum processed one we will process the operation and update it Otherwise we just won t do anything Since the minimum processed will decrease at most times the time complexity is "}
{"statement": "Tanechka is shopping in the toy shop There are exactly n toys in the shop for sale the cost of the i th toy is i burles She wants to choose two toys in such a way that their total cost is k burles How many ways to do that does she have Each toy appears in the shop exactly once Pairs a b and b a are considered equal Pairs a b where a b are not allowed ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "The problem is to calculate the number of ways to choose two distinct integers from to with sum equals If then the answer is because this is the number of ways to choose two distinct integers from to with the sum equals Otherwise let will be the minimum possible term in the correct pair of integers Also let will be the maximum possible term in the correct pair of integers Then the answer is because this is the number of ways to choose two distinct integers from to with the sum equals "}
{"statement": "An array b of length k is called good if its arithmetic mean is equal to 1 More formally if frac b 1 cdots b k k 1 Note that the value frac b 1 cdots b k k is not rounded up or down For example the array 1 1 1 2 has an arithmetic mean of 1 25 which is not equal to 1 You are given an integer array a of length n In an operation you can append a integer to the end of the array What s the minimum number of operations required to make the array good We have a proof that it is always possible with finitely many operations ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "We can notice that the optimal strategy is to put the yoyos in the corners of the board One solution may be checking the best distance for all pairs of corners But if we think a bit more we can notice that placing the yoyos in opposite corners the distance will always be maximum possible the distance always being So one possible answer is to always place the first yoyo in the top left cell and the second one in the bottom right cell This is always optimal because for any initial position of Anton the distance will still be the same this being the largest possible distance The distance can not get larger than that because if we move one of the yoyos it will get closer to the other yoyo and the distance will decrease by or won t decrease but it s impossible for it to increase "}
{"statement": "Paprika loves permutations She has an array a 1 a 2 dots a n She wants to make the array a of integers 1 to n In order to achieve this goal she can perform operations on the array In each operation she can choose two integers i 1 le i le n and x x 0 then perform a i a i bmod x that is replace a i by the remainder of a i divided by x In different operations the chosen i and x Determine the minimum number of operations needed to make the array a permutation of integers 1 to n If it is impossible output 1 A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "SolutionKey observation if and if Notice that the bigger the the bigger the range of values that can be obtained after one operation So intuitively we want to assign smaller to smaller numbers in the resulting permutation However if satisfies we can just leave it there and use it in the resulting permutation if multiple satisfy and have the same value just choose one Let s suppose in the optimal solution we change to and change to for some are values not indices Then changing to i e doing nothing and changing to uses less operation And if it is possible to change to then it must be possible to change to However if it is not possible to change to it might still be possible to change to Therefore the solution is as follows Sort the array For each element in the sorted array If and it is the first occurrence of element with value leave it there Else let the current least unassigned value in the resulting permutation be if we can assign the current element to value and add the number of operations by Else output directly The solution works in "}
{"statement": "Recently your friend discovered one special operation on an integer array a Choose two indices i and j i neq j Set a i a j a i a j After playing with this operation for a while he came to the next conclusion For every array a of n integers where 1 le a i le 10 9 you can find a pair of indices i j such that the total sum of a will after performing the operation This statement sounds fishy to you so you want to find a counterexample for a given integer n Can you find such counterexample and prove him wrong In other words find an array a consisting of n integers a 1 a 2 dots a n 1 le a i le 10 9 such that for all pairs of indices i j performing the operation won t decrease the total sum it will increase or not change the sum ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Suppose the initial sum of is equal to If we perform the operation the new sum will be equal to We want the sum not to decrease or If we will get If we ll get analogically In other words array you need if sorted will have and so on And one of the variants and obviously an optimal one is just As a result since we just need to check if then we found an answer otherwise there is no counterexample "}
{"statement": "The project of a data center of a Big Software Company consists of computers connected by cables Simply speaking each computer can be considered as a box with multiple cables going out of the box Very Important Information is transmitted along each cable in one of the two directions As the data center plan is not yet approved it wasn t determined yet in which direction information will go along each cable The cables are put so that each computer is connected with each one perhaps through some other computers The person in charge of the cleaning the data center will be Claudia Ivanova the janitor She loves to tie cables into bundles using cable ties For some reasons she groups the cables sticking out of a computer into groups of two and if it isn t possible then she gets furious and attacks the computer with the water from the bucket It should also be noted that due to the specific physical characteristics of the Very Important Information it is strictly forbidden to connect in one bundle two cables where information flows in different directions The management of the data center wants to determine how to send information along each cable so that Claudia Ivanova is able to group all the cables coming out of each computer into groups of two observing the condition above Since it may not be possible with the existing connections plan you are allowed to add the minimum possible number of cables to the scheme and then you need to determine the direction of the information flow for each cable yes sometimes data centers are designed based on the janitors convenience ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2600", "problem_editorial": "Problem legend asks you to add minimum number of edges to the given connected undirected graph possibly with loops and duplicating edges and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even First idea is that the resulting graph before we choose the direction but after we added some edges will contain Euler circuit since all degrees are even That s almost what we need if we have an Euler circuit that contains even number of edges we may direct them like following a b c d e It s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree so the resulting degrees will be even But if the Euler circuit is odd meaning that there is odd number of edges in the graph we must add some extra edge to the graph before we continue the easiest way is to add a loop from vertex 0 to itself since it doesn t affect the Euler tour but now tour length is even so everything is ok Now we should think how to add edges optimally It s easy to see that the optimal way is to first fix all odd degrees of vertices i e combine all odd vertices by pairs and put an edge in each pair and then possibly add an extra loop as described above The last part is to actually find an Euler circuit and to print the answer There were issues with this task Intended constraints were actually and the intended solution was using Fast Fourier Transformation that leads to running time But unfortunately the statement contained wrong constraints so we reduced input size during the tour Nevertheless we will add the harder version of this task and you will be able to submit it shortly Key idea is to reduce this task to a polynomial multiplication Let s solve the task in following manner For each position i of the S for each character c from ATGC we will calculate match c i that is equal to the number of c characters that have matching symbol in S if we put string T in position i Then the criteria for us to have an occurrence at position i is that match A i match T i match G i match C i T that means exactly that each character from T being put at position i has a corresponding character in S Now let s find out how to calculate match c i Let s keep only c characters and not c characters in both strings and denote them by 1 and 0 respectively Let s also spread each 1 in string S by the distance k to the left and to the right For example k 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111 and for the character C it will be 0111001110 This bitvector can be calculated in by putting two events 1 and 1 in string S in positions and for each in original string S and then sweeping from left to right over the string S and processing those events Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S In constraints this can be done by using bitsets in Nevertheless this task can be seen as calculation of polynomials S and reversed T product We will keep this as an exercise for those who decide to submit the harder version of this task Let s draw a bounding box that contains all intersection points Let s fix a triangle and consider three angles shown on the picture Calculate area of intersection of those area with the bounding box and call this area to be the area of an angle Then it s easy to see that those three angles are complement to the triangle itself in the bounding box i e triangle area is bounding box area minus three angle areas This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane how much times does it appear in total answer if we sum all values like over all triples of lines Actually the angle is considered as many times as many lines there are that intersect both sides of its right adjacent angle So our task is reduced to calculate for each angle on plane how much lines intersect its sides i e its rays This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right Key idea is that the exact of four angles formed by the pair of lines that is crossed by some third line c can be determined by two numbers its polar angle alpha and its crossing with a coordinate x Further details are shown on the picture below There is also a nice short solution from enot110 here "}
{"statement": "Anton likes to listen to fairy tales especially when Danik Anton s best friend tells them Right now Danik tells Anton a fairy tale Once upon a time there lived an emperor He was very rich and had much grain One day he ordered to build a huge barn to put there all his grain Best builders were building that barn for three days and three nights But they overlooked and there remained a little hole in the barn from which every day sparrows came through Here flew a sparrow took a grain and flew away More formally the following takes place in the fairy tale At the beginning of the first day the barn with the capacity of grains was full Then every day starting with the first day the following happens grains are brought to the barn If grains doesn t fit to the barn the barn becomes full and the grains that doesn t fit are brought back in this problem we can assume that the grains that doesn t fit to the barn are not taken into account Sparrows come and eat grain In the th day sparrows come that is on the first day one sparrow come on the second day two sparrows come and so on Every sparrow eats one grain If the barn is empty a sparrow eats nothing Anton is tired of listening how Danik describes every sparrow that eats grain from the barn Anton doesn t know when the fairy tale ends so he asked you to determine by the end of which day the barn will become empty for the first time Help Anton and write a program that will determine the number of that day ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "At first let s make the following assumption if a sparrow cannot eat a grain because the barn is empty the number of grains in the barn becomes negative It s easy to see that the answer doesn t change because of this Now let s observe the number of grains before sparrows come At first the barn remains full for days because sparrows eat less grains than it s added to the barn Then the number of grains is decreased by one by two and so on So on the th day there are grains in the barn before sparrows come remember that for any positive integer the equality is always true How can we determine if the barn is empty It s reasonable that if there are grains on the th day after grain is brought then at the end of the th day there are grains in the barn So if on the th day the barn becomes empty then there must be grains on the th day after grain is brought So we must find such minimal day in which there are or less grains after grain is brought That is using the formula above we must find such minimal thatIt can be easily done using binary search It s not hard to observe that the answer in this case is if in the th day before sparrows come there are less or equal than grains then in the th day the barn is empty The corner case in this problem is In this case the barn becomes full every day and it becomes empty only in the th day when sparrows eat all the grain Also notice that can be found using a formula but such solutions could fail by accuracy because the formula is using the square root function Time complexity is "}
{"statement": "Vasya had a sequence of positive integers Vasya used it to build a new sequence where is the sum of digits of s decimal representation Then sequence got lost and all that remained is sequence Vasya wonders what the numbers could be like Of all the possible options he likes the one sequence with the minimum possible last number Help Vasya restore the initial sequence It is guaranteed that such a sequence always exists ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "The algorithm is greedy first take the minimal number with sum of digits call it Then on the th step take as the minimal number with sum of digits which is more than It can be easily proven that this algorithm gives an optimal answer But how to solve the subproblem given and find the minimal number with sum of digits which is more than We use a standard approach iterate through the digits of from right to left trying to increase the current digit and somehow change the digits to the right in order to reach the sum of digits equal to Note that if we are considering the th digit from the right and increase it we can make the sum of least significant digits to be any number between and When we find such position that increasing a digit in it and changing the least significant digits gives us a number with sum of digits we stop the process and obtain the answer Note that if least significant digits should have sum where we should obtain the answer greedily going from the right to the left and putting to the position the largest digit we can Let us bound the maximal length of the answer i e of If some has at least digits than we take the minimal such that Than between and there exist numbers with any sum of digits between and If than which is the upper bound of all So in the constraints of the problem will be less than Than similarly and so on So the length of the answer increases by no more than one after reaching the length of Consequently the maximal length of the answer can t be more than The complexity of solution is Since the solution runs much faster the time limit Prepared by EndagorionAuthor of editorial Kostroma "}
{"statement": "It is Borya s eleventh birthday and he has got a great present cards with numbers The th card has the number written on it Borya wants to put his cards in a row to get one greater number For example if Borya has cards with numbers and and he puts them in a row in this order he would get a number He is only 11 but he already knows that there are ways to put his cards in a row But today is a special day so he is only interested in such ways that the resulting big number is divisible by eleven So the way from the previous paragraph is good because but if he puts the cards in the following order he would get a number it is not divisible by so this way is not good for Borya Help Borya to find out how many good ways to put the cards are there Borya considers all cards different even if some of them contain the same number For example if Borya has two cards with 1 on it there are two good ways Help Borya find the number of good ways to put the cards This number can be large so output it modulo ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Let us use divisibility rule for eleven The number is divisible by eleven if the sum of digits at odd positions is equal to the sum of digits at even positions modulo 11 So for each number on a card there are only two parameters that we care about the sign interchanging sum of its digits with digits at odd positions positive and digits at even position negative and the parity of its digit count Let us divide all cards to two groups with even digit count and with odd digit count Let us first put cards with numbers that have odd count of digits Half of them rounded up will have their sign interchanging sum used as positive other half as negative Let us use dynamic programming to find the number of ways to sum them up to have a given sum modulo 11 The state includes the number of cards considered the number of cards that are used as positive and the current sum modulo 11 There are two transitions take the current card as positive and take it as negative If there are no cards with odd digit count no matter how you order even digit count cards the result modulo 11 is the same So the answer is either 0 or n In the other case each even digit count card can be used either as positive or as negative independent of the other cards Use analogous dynamic programming to count the number of ways to get each possible sum modulo 11 Finally combine results for even and odd digit count cards getting the total sum modulo 11 equal to 0 "}
{"statement": "You are given an integer array a of length n A subarray of a is one of its contiguous subsequences i e an array a l a l 1 dots a r for some integers l and r such that 1 le l r le n Let s call a subarray if there is an integer that occurs exactly once in the subarray You can perform the following operation any number of times possibly zero choose an element of the array and replace it with any integer Your task is to calculate the minimum number of aforementioned operation in order for all the subarrays of the array a to be unique ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "When we replace an element we can always choose an integer that is not present in the array So if we replace the th element every subarray containing it becomes unique and the problem can be reformulated as follows consider all non unique subarrays of the array and calculate the minimum number of elements you have to choose so that for every non unique subarray at least one of its elements is chosen We can use the following greedy strategy to do it go through the array from left to right maintaining the index of the last element we replaced When we consider the th element of the array if there is a non unique subarray with we replace the th element otherwise we don t replace anything Why is it optimal Essentially this greedy approach always finds a non unique subarray with the lowest value of and replaces the th element We obviously have to replace at least one element from the subarray but replacing the th element is optimal since we picked the lowest value of so every non unique subarray which contains any element from also contains the th element Okay but we need to make this greedy solution work fast When we consider the th element how do we check that there s a non unique subarray starting after the element and ending at the th element Suppose we go from the th element to the left and maintain a counter when we meet an element for the first time we increase this counter when we meet an element for the second time we decrease this counter If this counter is equal to then the current subarray is non unique every element appears at least twice Otherwise at least one element has exactly one occurrence Suppose we maintain an array where for each integer present in the original array we put in the last position we ve seen this element and in the second to last position we ve seen this element i e for every element we consider its two last occurrences among the first positions in the array put in the last of them and in the second to last of them Then if we go from to and maintain the counter in the same way as we described in the previous paragraph the value of this counter will be equal to the sum of the corresponding segment in this array So we want to check if there s a segment in the array such that its left border is greater than the last position where we made a replacement the right border is and the sum is We can show that the sum on any segment ending in the th position is currently non negative so we actually want to find the segment with the minimum sum We can store a segment tree that for every position from to maintains the sum on segment then changing an element is just performing the query add on segment and finding the minimum sum is just performing the query minimum on segment This allows us to get a solution with complexity of "}
{"statement": "Serval soon said goodbye to Japari kindergarten and began his life in Japari Primary School In his favorite math class the teacher taught him the following interesting definitions A is a string containing only characters and A is a parenthesis sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example parenthesis sequences are correct the resulting expressions are while and are not Note that the empty string is a correct parenthesis sequence by definition We define that s as the length of string s A s 1 dots l 1 leq l s of a string s s 1s 2 dots s s is string s 1s 2 dots s l Note that the empty string and the whole string are not strict prefixes of any string by the definition Having learned these definitions he comes up with a new problem He writes down a string s containing only characters and And what he is going to do is to replace each of the in s independently by one of and to make all strict prefixes of the new sequence not a correct parenthesis sequence while the new sequence should be a correct parenthesis sequence After all he is just a primary school student so this problem is too hard for him to solve As his best friend can you help him to replace the question marks If there are many solutions any of them is acceptable ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "First let be be and be a missing place so we will replace all the missing places in the new sequence by and Obviously for each prefix of a correct parenthesis sequence the sum of the new sequence is not less than And for the correct parenthesis sequence itself the sum of the new sequence should be So we can calculate how many let denotes it and how many let denotes it that we should fill in the missing places According to the problem our goal is to fill the missing place with and to make sure there is no strict prefix prefixes except the whole sequence itself exists with the sum equal to This can be solved in greedy We want the sum of prefixes as large as possible to avoid the sum touching So let the first missing places be filled with and the last missing places be filled with Check it whether it is a correct parenthesis sequence or not at last The complexity is "}
{"statement": "You are given two strings s and t both consisting only of lowercase Latin letters The substring s l r is the string which is obtained by taking characters s l s l 1 dots s r without changing the order Each of the occurrences of string a in a string b is a position i 1 le i le b a 1 such that b i i a 1 a a is the length of string a You are asked q queries for the i th query you are required to calculate the number of occurrences of string t in a substring s l i r i ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s take a look at a naive approach for each query you iterate over positions and check if Okay this is obviously Now we notice that there are only positions for to start from we can calculate if there is an occurrence of starting in this position beforehand in Thus we transition to solution Finally we calculate a partial sum array over this occurrence check array and answer each query in Overall complexity "}
{"statement": "My name is James diGriz I m the most clever robber and treasure hunter in the whole galaxy There are books written about my adventures and songs about my operations though you were able to catch me up in a pretty awkward moment I was able to hide from cameras outsmart all the guards and pass numerous traps but when I finally reached the treasure box and opened it I have accidentally started the clockwork bomb Luckily I have met such kind of bombs before and I know that the clockwork mechanism can be stopped by connecting contacts with wires on the control panel of the bomb in a certain manner I see contacts connected by wires Contacts are numbered with integers from to Bomb has a security mechanism that ensures the following condition if there exist contacts forming a circuit i e there exist wires between contacts and and and then the bomb immediately explodes and my story ends here In particular if two contacts are connected by more than one wire they form a circuit of length It is also prohibited to connect a contact with itself On the other hand if I disconnect more than one wire i e at some moment there will be no more than wires in the scheme then the other security check fails and the bomb also explodes So the only thing I can do is to unplug some wire and plug it into a new place ensuring the fact that no circuits appear I know how I should put the wires in order to stop the clockwork But my time is running out Help me get out of this alive find the sequence of operations each of which consists of unplugging some wire and putting it into another place so that the bomb is defused ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3200", "problem_editorial": "First idea is that answer is always equals to the number of edges from the first tree which are not in the second one This means that if we have an edge in both trees we will never touch it So if we have such edge we can remove this edge and merge its two vertices together nothing will change Second idea that if we will take any edge from the first tree there always exists some edge from the second tree which we can swap otherwise second graph is not connected but the tree is always connected So the order of adding edges from the first tree can be arbitrary Third idea is that if we will select leaf node in the first tree then cut its only edge then we can add instead of it any edge going from this vertex in the second tree Overall algorithm we store linked lists of edges in vertices when edge is in both trees we use disjoint set union to merge vertices and join their lists We can simply traverse first tree to get any order of edges in which the current edge will always contain leaf as one of its vertices Complexity is which in practice is almost linear "}
{"statement": "You are given a string s consisting of lowercase English letters In one operation you are allowed to swap any two characters of the string s A string s of length n is called an if s i ne s n i 1 for every i 1 le i le n For example the strings are but the strings are not Determine the minimum number of operations required to make the string s an or output 1 if this is not possible ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "If is odd then there is no solution since If is even then all symbols are split into pairs Let s denote the number of occurrences of the symbol as Note that if for some then after applying the operations there will be a pair where both characters are equal to then it is impossible to make the string Otherwise we will calculate the number of pairs where we will also find the maximum number of pairs where for all characters Let be a symbol for which the number of such pairs is equal to Note that because in one operation the number of pairs where cannot decrease by more than Also note that because for each operation we reduce the number of pairs where by no more than It turns out that to show this you can act greedily until If then we find a pair since then there is a pair where and Then swap and Otherwise find the pair and the pair Then swap and It is not difficult to check that in both cases will decrease by exactly which means is achieved with this algorithm "}
{"statement": "Ray lost his array and needs to find it by asking Omkar Omkar is willing to disclose that the array has the following qualities The array has n 1 le n le 2 cdot 10 5 elements Every element in the array a i is an integer in the range 1 le a i le 10 9 The array is sorted in nondecreasing order Ray is allowed to send Omkar a series of queries A query consists of two integers l and r such that 1 le l le r le n Omkar will respond with two integers x and f x is the mode of the subarray from index l to index r inclusive The mode of an array is defined by the number that appears the most frequently If there are multiple numbers that appear the most number of times the smallest such number is considered to be the mode f is the amount of times that x appears in the queried subarray The array has k 1 le k le min 25000 n distinct elements However due to Ray s sins Omkar will not tell Ray what k is Ray is allowed to send at most 4k queries Help Ray find his lost array ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "For both solutions we must first make the critical observation that because the array is sorted all occurrences of a value occur as a single contiguous block We will define a recursive function which will use queries to determine the array We will also store an auxiliary list of previously returned query values not the queries themselves but only the values returned so that we know that if is in the list then some previous query revealed that there were instances of in some query and that we haven t already determined exactly where in the array those instances of are The execution of will proceed as follows first query the interval and let the result be If there exists some previous query result in our auxiliary list then we will guarantee by details yet to be explained of that the interval that produced that result contained and that no part of those occurrences of occurred to the left of This allows us to exactly determine the location of those occurrences of We mark these occurrences in our answer and then remove from our auxiliary list and add If is not entirely composed of occurrences of then the remaineder of the interval must be for some and in that case we then call If there does not exist some previous query result in our auxiliary list then we add to the list and do as follows while the exact locations of those occurrences of have not been determined call where is the leftmost index in which has not yet been determined Once those locations have been determined call To determine the entire array we simply call It is clear that this will correctly determine the array We can see that it uses at most queries as follows for each block of integers of the same value represented by a query result that we add to our auxiliary list we use queries to determine the exact location of those integers one when added to the list and one when removing from the list This does not guarantee that the algorithm uses queries because some calls of can split a block of integers of the same value into two blocks However we can show that any blocks formed by splitting a single block into two cannot be further split as they occur either at the beginning or end of a queried interval the full proof is left as an exercise to the reader so each distinct value in the array will produce at most blocks each of which will be determined in queries meaning that the algorithm uses at most queries Side note you can in fact further show that the algorithm always uses at most queries and that there exists an array for all which forces the algorithm to use queries Again we will define a recursive function but this time we will only additionally maintain the currently known values in the answer The execution of will proceed as follows first query the interval and let the result be Then find the largest integer such that and then for all in that are multiples of determine the value located at index either by querying or by using already known values By the definition of there will be either one or two such indexes such that the values at those indexes are equal to If there is only one such index let this index be Make two queries and and let the results of these queries be and respectively We can show that at least one of and must be equal to If then we see that the occurrences of must be precisely the interval If then we see that the occurrences of must be precisely the interval If there are two such indexes let these indexes be and so that Note that it must be true that Make a single query and let the result be We can show that must be equal to so we can then conclude that the occurrences fo must be precisely the interval After the interval containing the occurrences of has been determined mark these occurrences in our answer and then call on the remaining not fully determined interval to the left if it exists and the remaining not fully determined interval to the right if it exists To determine the entire array we simply call It is clear that this will correctly determine the array We can see that it uses at most queries as follows Each call to finds all occurrences of a distinct value We will refer to the queries of single indexes that were multiples of some as queries For each we perform the following queries other than queries the first query in and then either two additional queries if only one query was found to equal or a single additional query if two queries were found to equal This means that if we group each query with the value that it equaled then we will have performed exactly queries for each and so the algorithm must therefore use exactly queries "}
{"statement": "Dawid has four bags of candies The i th of them contains a i candies Also Dawid has two friends He wants to give each bag to one of his two friends Is it possible to distribute the bags in such a way that each friend receives the same amount of candies in total Note that you can t keep bags for yourself or throw them away each bag should be given to one of the friends ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s firstly sort all the bags in non decreasing order of capacities As the order of friends doesn t matter it turns out that one of them should take only the biggest bag or the biggest and the smallest bag It s easy to check if any of these possibilities works "}
{"statement": "You are given a keyboard that consists of 26 keys The keys are arranged sequentially in one row in a certain order Each key corresponds to a unique lowercase Latin letter You have to type the word s on this keyboard It also consists only of lowercase Latin letters To type a word you need to type all its letters consecutively one by one To type each letter you must position your hand exactly over the corresponding key and press it Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys the keys are numbered from left to right No time is spent on pressing the keys and on placing your hand over the first letter of the word For example consider a keyboard where the letters from to are arranged in consecutive alphabetical order The letters and then are on the positions 8 5 12 and 15 respectively Therefore it will take 5 8 12 5 12 12 15 12 13 units of time to type the word Determine how long it will take to print the word s ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Since it does not take time to place your hand over the first letter you need to calculate the sum of the distances between the keyboard keys corresponding to each pair of adjacent letters of the word that is where is the position of the keyboard key corresponding to the letter In order to calculate this sum let s just iterate through the word with the loop and find the differences between the positions of and on the keyboard To find the position of a character on the keyboard you could either use the built in strings functions such as in Python or in C or precalculate each letter s position on the keyboard into a separate array using another loop over a keyboard "}
{"statement": "Rudolf and Bernard decided to play a game with their friends n people stand in a circle and start throwing a ball to each other They are numbered from 1 to n in the clockwise order Let s call a transition a movement of the ball from one player to his neighbor The transition can be made clockwise or counterclockwise Let s call the clockwise counterclockwise distance from player y 1 to player y 2 the number of transitions clockwise counterclockwise that need to be made to move from player y 1 to player y 2 For example if n 7 then the clockwise distance from 2 to 5 is 3 and the counterclockwise distance from 2 to 5 is 4 Initially the ball is with the player number x players are numbered clockwise On the i th move the person with the ball throws it at a distance of r i 1 le r i le n 1 clockwise or counterclockwise For example if there are 7 players and the 2nd player after receiving the ball throws it a distance of 5 then the ball will be caught by either the 7th player throwing clockwise or the 4th player throwing counterclockwise An illustration of this example is shown below The game was interrupted after m throws due to unexpected rain When the rain stopped the guys gathered again to continue However no one could remember who had the ball As it turned out Bernard remembered the distances for each of the throws and the direction for of the throws clockwise or counterclockwise Rudolf asks you to help him and based on the information from Bernard calculate the numbers of the players who could have the ball after m throws ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let s introduce a set of unique elements initially containing a single element the index of the first player who started the game For each from to we will update in such a way as to maintain the set of players who could have the ball after the th throw For each element of the set we will remove from and also if or add to the element the index of the player who will receive the ball in case of a clockwise throw if or add to the element the index of the player who will receive the ball in case of a counterclockwise throw The term before the operation is necessary to obtain a positive argument of this operation Otherwise in some programming languages the function will return a negative result which does not correspond to the semantics of the problem The operation denotes the remainder of the division of by It should be noted that it is not needed to store duplicates in one index of the thrower is sufficient for the correct calculation of the players who could have received their throw After the th iteration of the described cyclic process the set will contain the desired indices of all players who could have the ball at the end of the game At each iteration of the loop the power of does not exceed and a total of exactly iterations will be performed Thus the asymptotic complexity of the algorithm is of the order "}
{"statement": "Leha plays a computer game where is on each level is given a connected graph with vertices and edges Graph can contain multiple edges but can not contain self loops Each vertex has an integer which can be equal to or To pass the level he needs to find a good subset of edges of the graph or say that it doesn t exist Subset is called good if by by leaving only edges from this subset in the original graph we obtain the following for every vertex i 1 or it s degree modulo 2 is equal to Leha wants to pass the game as soon as possible and ask you to help him In case of multiple correct answers print any of them ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "Model solution uses the fact that the graph is connected We ll prove that good subset exists iff 1 values among di can be changed to 0 1 so that is even If the sum can only be odd there is no solution obviously every single valid graph has even sum of degrees Now we ll show how to build the answer for any case with even sum First of all change all 1 values so that the sum becomes even Then let s find any spanning tree and denote any vertex as the root The problem is actually much easier now Let s process vertices one by one by depth from leaves to root Let s denote current vertex as cur There are two cases 1 dcur 0 In this case we ignore the edge from cur to parentcur and forget about cur Sum remains even 2 dcur 1 In this case we add the edge from cur to parentcur to the answer change dparentcur to the opposite value and forget about cur As you can see sum changed its parity when we changed dparentcur but then it changed back when we discarded cur So again sum remains even Using this simple manipulations we come up with final answer "}
{"statement": "The town has n buildings numbered from 1 to n Some buildings have roads between them and there is exactly 1 simple path from any building to any other building Each road has a certain meteor danger level The buildings all have grocery stores but Mihai only cares about the open ones of course Initially all the grocery stores are closed You are given q queries of three types Given the integers l and r the buildings numbered from l to r open their grocery stores nothing happens to buildings in the range that already have an open grocery store Given the integers l and r the buildings numbered from l to r close their grocery stores nothing happens to buildings in the range that didn t have an open grocery store Given the integer x find the maximum meteor danger level on the simple path from x to open grocery store or 1 if there is no edge on any simple path to an open store ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "Consider the edge with the greatest weight Any path going through that edge will have weight equal to the weight of that edge If we delete that edge from the tree a path going through that edge in the original tree has one endpoint in each component that results from the removal of the edge Consider some query with some set of open stores If the component not including has an open store then the answer is the deleted edge If it does not have an open store then we recursively solve the problem for the component of Observe that the structure of this is the same as for finding of a set of nodes in a tree When asking for the of some set we can pick an in order traversal ignore all nodes except the leftmost and rightmost ones and still get the same The solution outline then looks like this Create the binary tree that arises from making a node representing the edge with the greatest weight and then doing the same for the two components resulting from deleting the greatest weight making them left and right subtrees of the above tree Order the nodes by in order traversal in this tree Use a segment tree or another data structure to maintain what is the leftmost and rightmost open store in the in order traversal Find the LCA of the leftmost and rightmost open store in the created tree "}
{"statement": "Suppose you have an array b Initially you also have a set S that contains all distinct elements of b The array b is called if it can be by repeatedly performing the following operation In one operation select indices l and r 1 leq l leq r leq b such that v b l b l 1 ldots b r and v is present in S Remove v from S and simultaneously remove all b i such that l leq i leq r Then reindex the elements b r 1 b r 2 ldots as b l b l 1 ldots accordingly You are given an array a of length n and q queries Each query consists of two indices l and r 1 le l le r le n and you need to determine whether or not the subarray a l a l 1 ldots a r is ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Problem Credits Proof by QED satyam343 Analysis Proof by QED Solution First let s try to find whether a single array is orangutan approved or not Claim The array of size is not orangutan approved if and only if there exists indices such that and Proof Let s prove this with strong induction For the claim is true because the empty array is orangutan approved Now let s suppose that the claim is true for all Now let be a sorted sequence such that is in if and only if Suppose is length We can split the array into disjoint subarrays such that is the subarray for all and That is is the subarray that lies between each occurrence of in the array First we note that the set of unique elements of and cannot contain any elements in common for all This is because suppose that there exists and such that and the set of unique values in and both contain Then in the original array there must exist a subsequence This makes our premise false By our inductive claim each of the arrays must be orangutan approved Since there are no overlapping elements we may delete each of the arrays separately Finally the array is left with copies of and we can use one operation to delete all remaining elements in the array Now how do we solve for all queries First precompute the array which is the array containing for each the largest index such that Let s then use two pointers to compute the last element such that is orangutan approved but is not and store this in an array called Let s also keep a maximum segment tree such that is the first element such that As we sweep from to we do the following Set Otherwise while and increment by Set When the array is fully calculated we can solve each query in "}
{"statement": "The cinema theater hall in Sereja s city is seats lined up in front of one large screen There are slots for personal possessions to the left and to the right of each seat Any two adjacent seats have exactly one shared slot The figure below shows the arrangement of seats and slots for Today it s the premiere of a movie called Dry Hard The tickets for all the seats have been sold There is a very strict controller at the entrance to the theater so all people will come into the hall one by one As soon as a person enters a cinema hall he immediately momentarily takes his seat and occupies all empty slots to the left and to the right from him If there are no empty slots the man gets really upset and leaves People are not very constant so it s hard to predict the order in which the viewers will enter the hall For some seats Sereja knows the number of the viewer his number in the entering queue of the viewers that will come and take this seat For others it can be any order Being a programmer and a mathematician Sereja wonders how many ways are there for the people to enter the hall such that nobody gets upset As the number can be quite large print it modulo ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "In order that no one would be upset every person except first should sitdown near someone else Now when any human comes we know that for one side of him there will not be any people Will use it We will support the interval exactly occupied seats If the first person is not known it is possible that we have 2 such intervals Now only remains to consider carefully all the cases that could be because at each iteration we know exactly how many people will sit on some certain place "}
{"statement": "You are given a sequence of n integers a 1 a 2 a n Let us call an index j 2 le j le n 1 a if a j a j 1 and a j a j 1 and let us call it a if a j a j 1 and a j a j 1 Let us define the of a sequence as the sum of the number of hills and the number of valleys in the sequence You can change integer in the sequence to any number that you want or let the sequence remain unchanged What is the minimum that you can achieve ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Changing the value of affects the hill valley status of only elements We claim that it is optimal to change to either or for valid Let be a value of such that the number of hills valleys among elements is minimised Now if we can set without changing any non hill non valley element to a hill valley Similarly if we can set Hence proved The final solution is as follows Precompute the number of hills and valleys in the original array Then for every valid index calculate the change in the number of hills valleys of the elements on setting and and update the minimum answer accordingly "}
{"statement": "Inna and Dima bought a table of size in the shop Each cell of the table contains a single letter Inna loves Dima so she wants to go through his name as many times as possible as she moves through the table For that Inna acts as follows initially Inna chooses some cell of the table where letter is written then Inna can move to some side adjacent table cell that contains letter then from this cell she can go to one of the side adjacent table cells that contains the written letter then she can go to a side adjacent cell that contains letter Then Inna assumes that she has gone through her sweetheart s name Inna s next move can be going to one of the side adjacent table cells that contains letter and then walk on through name DIMA in the similar manner Inna never skips a letter So from the letter she always goes to the letter from the letter she always goes the to letter from the letter she always goes to the letter and from the letter she always goes to the letter Depending on the choice of the initial table cell Inna can go through name DIMA either an infinite number of times or some positive finite number of times or she can t go through his name once Help Inna find out what maximum number of times she can go through name DIMA ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1900", "problem_editorial": "Our task is tranformed to the task of finding cycle or maximal way but lets solve it without any graphs Lets run dfs from each digit memorizing all already calculated tasks If we come into the cell we have already been in one of the previous than we should simply add the maximal way length to our current length Way length is increased not in each cell but only when we come into If we come into the cell we have already been on current step in our dfs running this is the cycle and we should stop the algorithm Don t forget to change the color of cell after droping from recursiong because you will receive false cycle Simply set the colour to current when come into the cell but decrease it before end of recursion for this cell "}
{"statement": "You are given two strings s and t consisting of lowercase Latin letters The length of t is 2 i e this string consists only of two characters In one move you can choose character of s and replace it with lowercase Latin letter More formally you choose some i and replace s i the character at the position i with some character from to You want to do k replacements in such a way that the number of occurrences of t in s as a Recall that a subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "I m almost sure this problem can be solved faster and with greater constraints but this version is fine for the last problem Consider both strings indexed and let s do the dynamic programming It means the maximum number of occurrences of if we considered first characters of did moves and the number of characters is The answer to the problem is Initially all states are and is What about transitions There are essentially three types of them don t change the current character change the current character to and change the current character to Let s create three additional variables to make our life easier if that were true is if and otherwise is if and otherwise and is if and otherwise Now let s make and describe our transitions Don t change the th character The expression is just ternary if statement if is true return otherwise return So the number of characters increases if equals and the answer increases if the th character equals because we added all occurrences that end in the th character Change the th character to possible only when The number of characters always increases and the answer increases if equals by the same reason as in the previous transition Change the th character to possible only when The number of characters increases only if and the answer always increases Note that we always increase the number of moves in the second and the third transitions even when equals or because this case is handled in the first transition so we don t care Time complexity There are also some greedy approaches which work in with pretty small constant and can be optimized even further "}
{"statement": "Levko has an array that consists of integers But he doesn t like this array at all Levko thinks that the beauty of the array directly depends on value which can be calculated by the formula The less value is the more beautiful the array is It s time to change the world and Levko is going to change his array for the better To be exact Levko wants to change the values of at most array elements it is allowed to replace the values by any integers Of course the changes should make the array as beautiful as possible Help Levko and calculate what minimum number he can reach ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Let s solve this problem using binary search We need to check whether we can achieve an array when will be at most Lets make dp means minimal number of elements with indeces less than which we need to change but we don t change th element Let s iterate next element which we don t change Then we know that we can change all elements between and It is equivalent to such condition Difference between neighboring elements can be at most The maximal possible difference increases by exactly times between elements and so this inequality is correct "}
{"statement": "For a permutation of integers from to function is defined as follows Let be the minimum positive integer such that We can show such always exists For given find a permutation of integers from to such that for equals either or ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "For and there must exist a cycle of length beginning from index and ending at the same index of permutation While generating a permutation we are constrained to generate cycles of length either or as for all must be equal to either of them Let us try to generate a cycle of length for indices till using only the integers till each once If and for all we in turn get a cycle of length for each of the indices till that is for all So if there exists a solution where and for we can in turn generate a permutation satisfying our needs Otherwise no such permutation is possible So now for any one of the solution generate cycles of length beginning from indices and then beginning from indices generate cycles of length "}
{"statement": "There are n segments on a Ox axis l 1 r 1 l 2 r 2 l n r n Segment l r covers all points from l to r inclusive so all x such that l le x le r Segments can be placed be inside each other coincide and so on Segments can degenerate into points that is l i r i is possible of the set of segments is such a set of segments which covers exactly the same set of points as the original set For example if n 3 and there are segments 3 6 100 100 5 8 then their union is 2 segments 3 8 and 100 100 if n 5 and there are segments 1 2 2 3 4 5 4 6 6 6 then their union is 2 segments 1 3 and 4 6 Obviously a union is a set of pairwise non intersecting segments You are asked to erase exactly one segment of the given n so that the number of segments in the union of the rest n 1 segments is maximum possible For example if n 4 and there are segments 1 4 2 3 3 6 5 7 then erasing the first segment will lead to 2 3 3 6 5 7 remaining which have 1 segment in their union erasing the second segment will lead to 1 4 3 6 5 7 remaining which have 1 segment in their union erasing the third segment will lead to 1 4 2 3 5 7 remaining which have 2 segments in their union erasing the fourth segment will lead to 1 4 2 3 3 6 remaining which have 1 segment in their union Thus you are required to erase the third segment to get answer 2 Write a program that will find the maximum number of segments in the union of n 1 segments if you erase any of the given n segments ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 1, "problem_dificulty": "2300", "problem_editorial": "Ok looking for a new number of segments in a union is actually hard Let be the union of segments after erasing the th one Obviously each of the segments in has its left and right borders Let me show you how to calculate the number of any of these two kinds Let s choose left borders I will call the set of left borders of the set of segments Build the initial union of all segments that is a standart algorithm google it if you want Call it We are asked to find but let s instead find that is the difference of sizes of the initial union and the new one for Surely adding to this value will be the answer Moreover and that s what we are going to calculate Call that difference Let s do the following sweep line Add queries of form and Process them in sorted order Maintain the set of the open segments This sweepline will add segment on a query of the first type and remove segment on a query of the second type Initialize all the with zeroes this sweepline will help us to calculate all the values altogether Look at the all updates on the same coordinate The only case we care about is the current set of open segments contain exactly one segment and there is at least one adding update Let this currently open segment be Consider what happens with is not in the because at least that segment covers it is also in because after erasing segment becomes a left border of some segment of the union you are adding a segment with the left border and points slightly to the left of are no longer covered by segment Thus increases by The other possible cases are there are no open segments currently this is not important because was a left border and stays as a left border there are more than two open segments not important because will still be covered by at least one of them after erasing some other there are no adding updates was a left border but doesn t become a new one Thus we handled all the left border count increasing cases But there are also a decreasing case Left border can get removed if the segment you are erasing had its left border in the initial union and was the only segment with such left border You can get while getting Then for each of you can count how many segments start in it Finally iterate over and decrease by one if the value for the left border of the segment is exactly Finally is obtained is the answer Overall complexity "}
{"statement": "The teachers of the Summer Informatics School decided to plant n trees in a row and it was decided to plant only oaks and firs To do this they made a plan which can be represented as a binary string s of length n If s i 0 then the i th tree in the row should be an oak and if s i 1 then the i th tree in the row should be a fir The day of tree planting is tomorrow and the day after tomorrow an inspector will come to the School The inspector loves nature very much and he will evaluate the beauty of the row as follows First he will calculate l 0 as the maximum number of consecutive oaks in the row the maximum substring consisting of zeros in the plan s If there are no oaks in the row then l 0 0 Then he will calculate l 1 as the maximum number of consecutive firs in the row the maximum substring consisting of ones in the plan s If there are no firs in the row then l 1 0 Finally he will calculate the of the row as a cdot l 0 l 1 for some a the inspector s favourite number The teachers know the value of the parameter a but for security reasons they cannot tell it to you They only told you that a is an integer from 1 to n Since the trees have not yet been planted the teachers decided to change the type of no more than k trees to the opposite i e change s i from 0 to 1 or from 1 to 0 in the plan in order to maximize the beauty of the row of trees according to the inspector For each integer j from 1 to n answer the following question What is the maximum beauty of the row of trees that the teachers can achieve by changing the type of no more than k trees if the inspector s favourite number a is equal to j ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "There are many various dynamic programming solutions of this problem We will describe one of them Let s calculate the dynamics the length of the longest subsegment of zeros that can be obtained on the prefix up to which ends at index and costs exactly operations Similarly is the length of the longest subsegment of zeros on the suffix starting at which starts at index and costs exactly operations Such dynamics can be easily computed In the first case we simply prolong the existing subsegment of zeros in the second case we change the current to spending one operation on it so if have operations left we cannot do anything and the value of the dynamics is meaning the segment has ended can be calculated similarly Let s update both dynamics in such a way that will mean the maximum length of a subsegment of zeros that ends no later than and costs no more than operations This can be easily done by updating with the value of and then with Similarly we update the second dynamics Now let s consider a subsegment that we want to convert into a segment of ones We can easily calculate the number of operations that we will need we ll just need to calculate the number of zeros in such a segment Now calculate the new dynamics for the length of the segment of ones which equals the maximum length of a subsegment of zeros that we can obtain Update this value with Then to answer the question for a fixed number we can iterate over the length of the segment of ones that will be in our answer and update the answer with the value if there exists a value for in the dynamics The complexity is Solutions with complexity and using various optimizations of the dynamics also exist "}
{"statement": "There s a table of n times m cells n rows and m columns The value of n cdot m is even A domino is a figure that consists of two cells having a common side It may be horizontal one of the cells is to the right of the other or vertical one of the cells is above the other You need to place frac nm 2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical The dominoes cannot overlap and must fill the whole table ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Suppose and are even A necessary and sufficient condition of existence of the answer is that is even Let s prove the sufficient condition If the count of the horizontal dominoes is even then we can combine them and vertical dominoes to blocks of size the number of the vertical dominoes is even too if is even If and are even we can fill the table with these blocks The description of the locations of the dominoes may be printed as follows consider the table is a chessboard where a cell is a block of two dominoes Consider the leftmost topmost cell of the board is black If a cell of the board is black let s mark one of the dominoes of the block with the letter and the other one with the letter If a cell of the board is white let s mark one of the dominoes of the block with the letter and the other one with the letter There will be no situation that some two cells of the table are marked with one letter but belong to different dominoes Let s prove the necessary condition The number of cells in a column is even so the number of cells that belong to vertical dominoes is even because cells of each vertical domino may be either belong to the column or not belong at the same time So the number of cells that belong to horizontal dominoes is even Let s cross out all cells that belong to vertical dominoes and let s find the leftmost column having cells that haven t been crossed out It s the leftmost column with such cells so the pairwise cells of the non crossed out cells belong to the column to the right of the found one The number of such cells in the right column is equal to the number of found cells so it s even and the number of found horizontal dominoes is even too Let s cross out the found cells and the pairwise cells The number of non crossed out cells in the right column will be even The number of crossed out horizontal dominoes will be even too Let s repeat this procedure until all the dominoes will be crossed out In every step we have crossed out the even number of horizontal dominoes hence the total count of horizontal dominoes is even Suppose is odd hence is even In this case every column contains an odd number of cells whereas the number of cells that belong to vertical dominoes is even So the number of cells that belong to horizontal dominoes is odd Consider the leftmost column and find a cell of it that belongs to a horizontal domino it must be found because the number of such cells is odd so it isn t equal to Let s find the pairwise cell and cross out both cells Currently the two columns will have an even number of non crossed out cells Let s repeat the procedure until all columns will have even non crossed out cells We will cross out cells and dominoes So the necessary condition is that the number of horizontal dominoes is at least Let s extend the necessary condition with the following condition the value of is even Consider the table that we ve become after the previous procedure where each column has exactly one crossed out cell Let s start the procedure we ve done in the case of even both and The procedure can be started on our table because each column of the table has an even number of non crossed out cells As a result of the procedure we will cross out an even count of horizontal dominoes so the value of is even Let s build an answer if the conditions and is even are met Let s place in the topmost row horizontal dominoes and mark their cells as follows the first domino will be marked with the second one with the third one with and so on As the result the region of rows and columns will be unfilled Both values are even and the value of is even too So let s fill the region as if it s a separate table having even numbers of rows and columns As it was proved above it s possible to do The set of letters used for the region and set of the letters used for the topmost row don t have common elements so there will be no cells that are marked with one letter but belong to different dominoes The case of odd hence is even is similar to the previous one let s transpose the table it will have rows and columns swap the values of and solve the case above and transpose the table back to have rows and columns "}
{"statement": "William is hosting a party for n of his trader friends They started a discussion on various currencies they trade but there s an issue not all of his trader friends like every currency They like some currencies but not others For each William s friend i it is known whether he likes currency j There are m currencies in total It is also known that a trader may not like more than p currencies Because friends need to have some common topic for discussions they need to find the largest by cardinality possibly empty subset of currencies such that there are at least lceil frac n 2 rceil friends rounded up who like each currency in this subset ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Notice that the final answer will be a submask of one of friends Knowing this random generation may be used to pick a random mask If we check a randomly generated index 50 times then the probability of not hitting a single index of a friend from the required group is This probability is 1125899906 times smaller than the probability of the contestant being hit by a falling meteorite i e insignificant Now that we have some basis mask we can calculate the maximal answer for it To do this let s compress each mask for each friend to a size no larger than by only keeping those true bits which are also true in Now for each mask of length we can calculate which is the number of friends that like this mask For each mask is the sum of all such that s is a submask of We can brute force all submasks in by using an algorithm found Now all we have to do is to pick the mask for which and which has the largest number of true bits in its uncompressed state Final complexity or depending on the implementation "}
{"statement": "Little Paul wants to learn how to play piano He already has a melody he wants to start with For simplicity he represented this melody as a sequence a 1 a 2 ldots a n of key numbers the more a number is the closer it is to the right end of the piano keyboard Paul is very clever and knows that the essential thing is to properly assign fingers to notes he s going to play If he chooses an inconvenient fingering he will then waste a lot of time trying to learn how to play the melody by these fingers and he will probably not succeed Let s denote the fingers of hand by numbers from 1 to 5 We call a any sequence b 1 ldots b n of fingers numbers A fingering is if for all 1 leq i leq n 1 the following holds if a i a i 1 then b i b i 1 because otherwise Paul needs to take his hand off the keyboard to play the i 1 st note if a i a i 1 then b i b i 1 because of the same if a i a i 1 then b i neq b i 1 because using the same finger twice in a row is dumb Please provide any convenient fingering or find out that there is none ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let dp i j be 1 if we cannot play the first i notes in such a way that the i th note is played by the j th finger otherwise let this be the number of the previous finger in any of possible fingerings This dp can be easily calculated for about 5n 5 operations "}
{"statement": "You are given a string s consisting of n lowercase Latin letters A substring of string s is a continuous segment of letters from s For example is a substring of and is not The length of the substring is the number of letters in it Let s call some string of length n if and only if there is no letter to appear strictly more than frac n 2 times For example strings and are and strings and are not Your task is to find substring of string s or report that there is none Note that it is not required to maximize or minimize the length of the resulting substring ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Notice that the string of two distinct letter is already diverse That implies that the answer is if and only if all the letters in the string are the same Otherwise you can check all pairs of adjacent letters in Overall complexity "}
{"statement": "Emily s birthday is next week and Jack has decided to buy a present for her He knows she loves books so he goes to the local bookshop where there are books on sale from one of genres In the bookshop Jack decides to buy Based on the genre of books on sale in the shop find the number of options available to Jack for choosing two books of different genres for Emily Options are considered different if they differ in at least one book The books are given by indices of their genres The genres are numbered from to ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s denote the number of books of th genre The answer to problem is equals to In first sum we are calculating the number of good pairs while in second we are subtracting the number of bad pairs from the number of all pairs Complexity or "}
{"statement": "A company of n people is planning a visit to the cinema Every person can either go to the cinema or not That depends on how many other people will go Specifically every person i said I want to go to the cinema if and only if at least a i other people will go That means that person i will become sad if they go to the cinema and strictly less than a i other people go or they don t go to the cinema and at least a i other people go In how many ways can a set of people going to the cinema be chosen so that nobody becomes sad ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Let s fix the number of people going to the cinema and try to choose a set of this exact size What happens to people with different If person definitely wants to go If person definitely does not want to go If there is actually no good outcome for person If person goes to the cinema there are only people going so person will be sad since If person does not go there are people going so person will be sad too since Thus for a set of size to exist there must be no people with and the number of people with must be exactly We can easily check these conditions if we use an auxiliary array such that is equal to the number of people with Notice that if a set of people can go to the cinema it must always be a set of people with the smallest Thus we can start with sorting the array in non decreasing order Then for each length of a prefix of this array we can check whether the first elements are all smaller than and the remaining elements are all greater than However since the array is sorted it is enough to check that the th element is smaller than and the th element is greater than "}
{"statement": "Once upon a time an old man and his wife lived by the great blue sea One day the old man went fishing and caught a real live gold fish The fish said Oh ye old fisherman Pray set me free to the ocean and I will grant you with gifts any gifts you wish Then the fish gave the old man a list of gifts and their prices Some gifts on the list can have the same names but distinct prices However there can t be two gifts with the same names and the same prices Also there can be gifts with distinct names and the same prices The old man can ask for names of items from the list If the fish s list has occurrences of the given name then the old man can t ask for this name of item more than times The old man knows that if he asks for gifts of the same name the fish will randomly i e uniformly amongst all possible choices choose gifts of distinct prices with such name from the list The old man wants to please his greedy wife so he will choose the names in such a way that he can get gifts with the maximum price Besides he isn t the brightest of fishermen so if there are several such ways he chooses one of them uniformly The old man wondered what is the probability that he can get most expensive gifts As the old man isn t good at probability theory he asks you to help him ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "First let s establish some facts that we will use in the solution With how much probability can the fisherman get a particular set of gifts among which there are gifts of th name In total there are such sets since there are exactly subsets of gifts with th name of size and two different names are independent during the gold fish s choice Then the described particular set of gifts we can get with the probability of by asking gifts of th name Now we know the probability of obtaining one particular gift set Now observe that from we can calculate the probabiltity of obtaining the set along with some one other gift of th name in constant time Say there are already elements of th name in Using the formula from the first paragraph we can deduce that Let s solve the main problem now We sort all the gifts in descending order of their prices It is clear that the fisherman will definitely ask the names of all the gifts among the first ones whose prices are not equal to the price of the th gift in the list Let s say that this set of gifts is the base and it has elements Then there is still unchosen gifts and we know that all of them will have the price equal to the price of the th gift in the list Say the price of the th gift is and there are exactly gifts with the price keep in mind that each of them has a different name also call these gifts dubious We can also deduce that the fisherman can make different decisions where So now we have some dubious gifts with the price of let s enumerate them in any order We calculate the dynamics the cumulative probability of obtaining most valuable gifts if there are chosen from the first in the list It is clear that and contains the answer to the problem Using the coefficients we have deduced earlier we get two transitions in the dynamics The complexity of the solution is Sample solution http pastie org 4897519 archived copy "}
{"statement": "A total of n depots are located on a number line Depot i lies at the point x i for 1 le i le n You are a salesman with n bags of goods attempting to deliver one bag to each of the n depots You and the n bags are initially at the origin 0 You can carry up to k bags at a time You must collect the required number of goods from the origin deliver them to the respective depots and then return to the origin to collect your next batch of goods Calculate the minimum distance you need to cover to deliver all the bags of goods to the depots You do have to return to the origin after you have delivered all the bags ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "This problem can be solved with a greedy approach First we note that it makes sense to solve positive points xp and negative points xn separately since we would like the minimize the number of times we move across the origin Second when we move to the farthest depot to which we haven t delivered a bag yet we can cover k 1 other depots Thus we can also deliver bags to the k 1 next farthest depots from the origin Thus to solve the positive set we can just sort the positive points and take the sum of the distance of points starting from the farthest point jumping k points at each step Thus we can sort xp and xn and find the answer through the following equations sumpos i 0 pos ki 0xp pos ki sumneg i 0 neg ki 0xn neg ki The final answer will be 2 sumpos sumneg minus the maximum distance of a positive or negative depot since we do not have to return to the origin in the end "}
{"statement": "Vlad has n friends for each of whom he wants to buy gift for the New Year There are m shops in the city in each of which he can buy a gift for any of his friends If the j th friend 1 le j le n receives a gift bought in the shop with the number i 1 le i le m then the friend receives p ij units of joy The rectangular table p ij is given in the input Vlad has time to visit at most n 1 shops where n is the number of He chooses which shops he will visit and for which friends he will buy gifts in each of them Let the j th friend receive a j units of joy from Vlad s gift Let s find the value alpha min a 1 a 2 dots a n Vlad s goal is to buy gifts so that the value of alpha is as large as possible In other words Vlad wants to maximize the minimum of the joys of his friends For example let m 2 n 2 Let the joy from the gifts that we can buy in the first shop p 11 1 p 12 2 in the second shop p 21 3 p 22 4 Then it is enough for Vlad to go only to the second shop and buy a gift for the first friend bringing joy 3 and for the second bringing joy 4 In this case the value alpha will be equal to min 3 4 3Help Vlad choose gifts for his friends so that the value of alpha is as high as possible Please note that each friend must receive one gift Vlad can visit at most n 1 shops where n is the number of In the shop he can buy any number of gifts ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Note that if we cannot get joy then we cannot get and if we can get at least then we can get at least These facts allow us to use binary search to find the answer Now we need to understand how exactly we can recognize whether we can gain joy at least or not We can enter at most shops so we always need to take two gifts from some store which means there must be a store in which we can find two or more gifts with pleasure at least Also each friend should receive a gift which means that we should be able to buy each gift with pleasure at least It takes O nm to check that both of these conditions are met The total solution works in O nm log nm "}
{"statement": "During the archaeological research in the Middle East you found the traces of three ancient religions First religion Second religion and Third religion You compiled the information on the evolution of each of these beliefs and you now wonder if the followers of each religion could coexist in peace The is a long word containing the lowercase English characters only At each moment of time each of the religion beliefs could be described by a word consisting of lowercase English characters The three religions can coexist in peace if their descriptions form disjoint subsequences of the More formally one can paint some of the characters of the in three colors 1 2 3 so that each character is painted in one color and the description of the i th religion can be constructed from the by removing all characters that aren t painted in color i The religions however evolve In the beginning each religion description is empty Every once in a while either a character is appended to the end of the description of a single religion or the last character is dropped from the description After each change determine if the religions could coexist in peace ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "For our convenience construct a two dimensional helper array where is the location of the first occurrence of character in the on position or later or if no such character exists This array can be created in a straightforward in time by iterating the word from the end to the beginning Consider the equal to The helper array looks as follows Actually for our purposes it s easier to set in our example and also consider additional links from indices and to index Why We ll later need the index of the first occurrence of some character some location If this already happens to be as we already established we can easily see that no requested occurrence exists Let s now try to answer each query in time We can do it using dynamic programming let be the length of the shortest prefix of the that contains the disjoint occurrences of the prefix of length of the first religion s description the prefix of length of the second religion s description and the prefix of length of the third religion s description Each state can be evaluated in constant time by checking for each religion what the prefix length would be if the last character of the prefix is a part of the th religion s description We use the helper array to speed up the search How to write the state transitions For each chop the last character of the th description s prefix find the shortest prefix of the containing all three descriptions and then reappend this last character We can do that using our helper array Now if the lengths of the descriptions are and respectively then the embedding of these descriptions as distinct subsequences exists if and only if However due to the nature of queries we can do a single update in time if we drop a character we don t need to recompute any states if we add a character to the th description we only need to recompute the states with equal to the length of the description and there are at most of them This allows us to solve the problem in time "}
{"statement": "In this sad world full of imperfections ugly segment trees exist A segment tree is a tree where each node represents a segment and has its number A segment tree for an array of n elements can be built in a recursive manner Let s say function operatorname build v l r builds the segment tree rooted in the node with number v and it corresponds to the segment l r Now let s define operatorname build v l r If l r this node v is a leaf so we stop adding more edges Else we add the edges v 2v and v 2v 1 Let m lfloor frac l r 2 rfloor Then we call operatorname build 2v l m and operatorname build 2v 1 m 1 r So the whole tree is built by calling operatorname build 1 1 n Now Ibti will construct a segment tree for an array with n elements He wants to find the sum of operatorname lca dagger S where S is a non empty subset of Notice that there are exactly 2 n 1 possible subsets Since this sum can be very large output it modulo 998 244 353 dagger operatorname lca S is the number of the least common ancestor for the nodes that are in S ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "SolutionLet s try to solve a slightly easier problem first changing the coefficient of the label to be the msb of the label We can note that at each depth every label will have the same number of digits in base 2 thus the same msb And we can notice that for each depth there are at most different interval lengths Combining the former with the latter we can solve this case in time complexity since the maximum depth is bounded by We can find an easy generalization to this for the th most significant bit of each label to be we have to go right from a node whose depth is Thus the above solution can be extended to find the contribution of the th most significant bit of each label Doing this for all bits gives us a time complexity of which is sufficient to pass the given constraints "}
{"statement": "For an array of integers a let s define a as the number of elements in it Let s denote two functions F a k is a function that takes an array of integers a and a positive integer k The result of this function is the array containing a first elements of the array that you get by replacing each element of a with exactly k copies of that element For example F 2 2 1 3 5 6 8 2 is calculated as follows first you replace each element of the array with 2 copies of it so you obtain 2 2 2 2 1 1 3 3 5 5 6 6 8 8 Then you take the first 7 elements of the array you obtained so the result of the function is 2 2 2 2 1 1 3 G a x y is a function that takes an array of integers a and two integers x and y The result of this function is the array a with every element equal to x replaced by y and every element equal to y replaced by x For example G 1 1 2 3 5 3 1 3 3 2 1 5 An array a is a of the array b if either there exists a positive integer k such that F a k b or there exist two different integers x and y such that G a x y b An array a is an of the array b if there exists a finite sequence of arrays c 0 c 1 dots c m m ge 0 such that c 0 is a c m is b and for every i in 1 m c i 1 is a parent of c i You are given two integers n and k Your goal is to construct a sequence of arrays s 1 s 2 dots s m in such a way that every array s i contains exactly n elements and all elements are integers from 1 to k for every array a consisting of exactly n integers from 1 to k the sequence contains at least one array s i such that s i is an ancestor of a Print the minimum number of arrays in such sequence ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "First of all since the second operation changes all occurrences of some number to other number and vice versa then by using it we can convert an array into another array if there exists a bijection between elements in the first array and elements in the second array It can also be shown that so we can consider that if we want to transform an array into another array then we first apply the function then the function Another relation that helps us is that it means that every time we apply the function we can easily rollback the changes Considering that we have already shown that a sequence of transformations can be reordered so that we apply only after we ve made all operations with the function let s try to rollback the second part of transformations i e for each array find some which can be obtained by using the function Since applying the second operation several times is equal to applying some bijective function to the array we can treat each array as a partition of the set into several subsets So if we are not allowed to perform the first operation the answer to the problem is equal to where is the number of ways to partition a set of objects into non empty sets these are known as There are many ways to calculate Stirling numbers of the second kind but in this problem we will have to use some FFT related approach which allows getting all Stirling numbers for some value of in time For example you can use the following relation If we substitute and we can see that the sequence of Stirling numbers for some fixed is just the convolution of sequences and For simplicity in the following formulas let s denote We now know that this value can be calculated in Okay now back to the original problem Unfortunately we didn t take the operation into account Let s analyze it The result of function consists of several blocks of equal elements and it s easy to see that the lengths of these blocks except for maybe the last one should be divisible by The opposite is also true if the lengths of all blocks except maybe for the last one are divisible by some integer then the array can be produced as for some array What does it mean If the greatest common divisor of the lengths of the blocks except for the last one is not the array that we consider can be obtained by applying the function to some other array Otherwise it cannot be obtained in such a way Now inclusion exclusion principle comes to the rescue Let s define as the number of arrays that we consider which have the lengths of all their blocks except maybe for the last one divisible by It s easy to see that we can compress every consecutive elements into one Then using inclusion exclusion principle we can see that the answer is where is the Mobius function Using this formula we can calculate the answer in This inclusion exclusion principle handles the arrays according to the GCD of the blocks that they consist of except for the last one But what if the array consists only of one block These arrays can be counted wrongly so we should exclude them i e use instead of just and count the arrays consisting of the same element if we need any of them in the answer separately Depending on the way you implement this or or both may be a corner case "}
{"statement": "There are n kids numbered from 1 to n dancing in a circle around the Christmas tree Let s enumerate them in a clockwise direction as p 1 p 2 p n all these numbers are from 1 to n and are distinct so p is a permutation Let the next kid for a kid p i be kid p i 1 if i n and p 1 otherwise After the dance each kid remembered two kids the next kid let s call him x and the next kid for x Each kid told you which kids he she remembered the kid i remembered kids a i 1 and a i 2 However the order of a i 1 and a i 2 can differ from their order in the circle You have to restore the order of the kids in the circle using this information If there are several answers you may print any It is guaranteed that at least one solution exists ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s write a function which will try to restore the circle if kid with number comes right after kid with number If comes right after then we can determine the number of kid who is next to kid So now we have comes right after comes right after Let s determine kid who is next to kid If we repeat this operation times then we can the answer if comes right after But it can be wrong so we have to check that our answer corresponds to the input So if we have this function we can apply it two times to determine the correct answer Just call and "}
{"statement": "You are given two arrays a and b of length n You can perform the following operation some possibly zero times choose l and r such that 1 leq l leq r leq n let x max a l a l 1 ldots a r for all l leq i leq r set a i x Determine if you can make array a equal to array b ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "If for any then it is clearly impossible In order for to become must be contained by an interval that also contains a where Note that if there is a triple where then it is never optimal to apply the operation on interval since applying the operation on interval will be sufficient Thus for we only need to consider the closest to the right or left of Lets find the necessary conditions for us to apply an operation on the interval First of all for Second for all Turns out these conditions are also sufficient since we can apply these operations in increasing order of without them interfering with each other If we check for every there exists an interval or that satisfies the necessary conditions then there will exist a sequence of operations to transform into Checking for the conditions can be done with brute force for D1 or using monotonic stacks or segment trees for D2 "}
{"statement": "There is a piece of paper in the shape of a simple polygon with n vertices The polygon may be non convex but we all know that proper origami paper has the property that If you fold the paper along the vertical line x f what will be the area of the resulting shape When you fold the part of the paper to the left of the line is symmetrically reflected on the right side Your task is to answer q independent queries for values f 1 ldots f q ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "First let s imagine the problem in one dimension And let s see how the length of the folded segment changes as we sweep the fold line from left to right If the fold line is to the left of the paper it s just the length of the segment Then as the fold line enters the left side of the paper we subtract the length of paper to the left of the fold line since it gets folded onto the right half Then as the fold line passes the midpoint of the segment we should add back the length we passed after the midpoint since the left half gets folded past the right end of the paper Finally after the line exits the paper the answer stays constant again Now let s advance to the two dimensional setting Imagine the process described above applied to all horizontal segments of the polygon simultaneously We see that the answer is the integral of the answers for all the segments Now let s split the polygon into two halves by the midpoints of each horizontal segment For a fold line the answer is the total area minus the area left of the sweep line belonging to the first polygon plus the area left of the sweep line belonging to the second polygon We can sort all line segments and queries and answer all queries in a sweep line To simplify the process it helps to know the standard algorithm to compute the area of a polygon by considering a trapezoid for each line segment and combining their areas with inclusion exclusion Essentially we have to sweep the integral of a piecewise linear function Complexity is "}
{"statement": "Pasha has two hamsters Arthur and Alexander Pasha put apples in front of them Pasha knows which apples Arthur likes Similarly Pasha knows which apples Alexander likes Pasha doesn t want any conflict between the hamsters as they may like the same apple so he decided to distribute the apples between the hamsters on his own He is going to give some apples to Arthur and some apples to Alexander It doesn t matter how many apples each hamster gets but it is important that each hamster gets only the apples he likes It is possible that somebody doesn t get any apples Help Pasha distribute all the apples between the hamsters Note that Pasha wants to distribute all the apples not just some of them ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "For each apple you just need to determine who like it If Alexander likes apple then he should eat it if Artur likes the apple then he should eat it If they both like the apply anyone can eat the apple "}
{"statement": "Consider an array a of length n with elements numbered from 1 to n It is possible to remove the i th element of a if gcd a i i 1 where gcd denotes the greatest common divisor After an element is removed the elements to the right are shifted to the left by one position An array b with n integers such that 1 le b i le n i 1 is a if it is possible to remove all elements of a if you remove the b 1 th element then the b 2 th then the b n th element For example let a 42 314 1 1 is a removal sequence when you remove the 1 st element of the array the condition gcd 42 1 1 holds and the array becomes 314 when you remove the 1 st element again the condition gcd 314 1 1 holds and the array becomes empty 2 1 is not a removal sequence when you try to remove the 2 nd element the condition gcd 314 2 1 is false An array is if it has removal sequences For example the array 1 2 5 is ambiguous it has removal sequences 3 1 1 and 1 2 1 The array 42 314 is not ambiguous the only removal sequence it has is 1 1 You are given two integers n and m You have to calculate the number of arrays a such that the length of a is from 1 to n and each a i is an integer from 1 to m ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "We will calculate the answer by subtracting the number of arrays which have only one removal sequence from the total number of arrays The latter is very simple it s just How do we calculate the number of unambiguous arrays We can always delete the st element of an array so is a removal sequence for each array So we have to calculate the number of arrays which have no other removal sequences How do we check if the array has no removal sequences other than If at any time it s possible to remove some element other than the st from the array it creates another removal sequence since we can always complete that sequence Let s analyze the constraints on each element of the array can be any integer from to should be divisible by otherwise we can remove it on the first step should be divisible by otherwise we can remove it on the first step and by otherwise we can remove it on the second step should be divisible by and but not necessarily by since an element which is divisible by already has a common divisor with And so on using induction we can show that the th element should be divisible by where are all of the primes in Obviously the number of such elements is So we can easily calculate the number of possible elements for each index of the array and that allows us to count all unambiguous arrays "}
{"statement": "There are n monsters standing in a row The i th monster has a i health points Every second you can choose one monster and launch a chain lightning at it The lightning deals k damage to it and also spreads to the left towards decreasing i and to the right towards increasing i to monsters dealing k damage to each When the lightning reaches a dead monster or the beginning end of the row it stops A monster is considered alive if its health points are strictly greater than 0 For example consider the following scenario there are three monsters with health equal to 5 2 7 and k 3 You can kill them all in 4 seconds launch a chain lightning at the 3 rd monster then their health values are 2 1 4 launch a chain lightning at the 1 st monster then their health values are 1 1 4 launch a chain lightning at the 3 rd monster then their health values are 1 1 1 launch a chain lightning at the 3 th monster then their health values are 1 1 2 For each k from 1 to max a 1 a 2 dots a n calculate the minimum number of seconds it takes to kill all the monsters ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Let s solve the problem for a single We ll start with for simplicity The first lightning can be launched at any monster as it will always spread to all of them We will continue launching lightnings until a monster dies When one or more monsters die the problem breaks down into several independent subproblems because no lightning will pass through dead monsters This means that there is no concept of minimum number of seconds the answer does not depend on the choice of monsters to launch the lightnings Great so how do we calculate this answer The idea is as follows We will attack the first monster until it dies This will take seconds We then move on to the second monster If it has more health than the first one we need to launch an additional lightnings to kill it Otherwise it will already be dead How much damage will the third monster receive in both cases Let s say it has a lot of health In the first case it will receive damage because all the lightnings will reach it But in the second case it will also receive damage because the lightnings launched at the first monster after the death of the second one will not reach the third one This means that we now need to compare the health of the second monster with the third one in the same way And so on This means that the th monster needs to be hit with lightnings Then the answer for is equal to How to calculate the answer for any In fact the difference is not very significant It is sufficient to change the health of each monster from to and the entire process described earlier will remain the same Therefore the answer for any is equal to To further optimize this solution another transformation is needed Ideally we would like each to contribute to the answer independently of other values And this can almost be achieved Notice that the maximum returns only if for any not just for This may require proof but it is quite obvious This means that the coefficient for in the answer depends on two conditions it is increased by if or it is decreased by if and Let s call this coefficient for the th monster Therefore we need to calculate There are two ways to optimize the solution further The first option is to notice that doesn t take a lot of different values for different More precisely it is This can be shown as follows Consider Either or Therefore takes no more than different values Then the solution can be implemented as follows For each we will identify all possible values that the rounding result takes For each of them we will find the range of for which the result is equal to that And we will add the contribution of the th monster within this range of values to the result This can be done using a difference array to achieve a complexity of The second option is a bit smarter Let s take another look at the formula for calculating the answer for a fixed Let s group the terms by equal values of What do they look like Numbers from to give the value Numbers from to give the value and so on This means that for a certain there are segments on each of which we need to calculate the sum of for those for which fall into this segment The total number of segments for all is The complexity of the solution will then be "}
{"statement": "You are given a permutation of the numbers and pairs of positions At each step you can choose a pair from the given positions and swap the numbers in that positions What is the lexicographically maximal permutation one can get Let and be two permutations of the numbers is lexicographically smaller than the if a number exists so for and ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "The problem was suggested by Zi Song Yeoh zscoder Consider a graph with vertices whose edges is the pairs from the input It s possible to swap any two values with the positions in some connected component in that graph So we can sort the values from any component in decreasing order Easy to see that after sorting the values of each component we will get the lexicographically maximal permutation C solution "}
{"statement": "You are given n of integers a 1 a 2 ldots a n Process q queries of two types query of the form add the value x j to all even elements of the array a query of the form add the value x j to all odd elements of the array a Note that when processing the query we look specifically at the odd even value of a i not its index After processing each query print the sum of the elements of the array a Please note that the answer for some test cases won t fit into 32 bit integer type so you should use at least 64 bit integer type in your programming language like for C ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let the initial sum in the array the number of even numbers the number of odd numbers Let s see how these values change with each action In fact we can consider four main options Add an even number to all even numbers Then will increase by and the number of even and odd numbers will remain the same Add an odd number to all even numbers Then will increase by the number of even numbers will become all numbers will become odd so Add an even number to all odd numbers Then will increase by and the number of even and odd numbers will remain the same Add an odd number to all odd numbers Then will increase by the number of odd numbers will become all numbers will become even so "}
{"statement": "Monocarp has a tree consisting of n vertices He is going to select some vertex r and perform the following operations on each vertex v from 1 to n set d v equal to the distance from v to r the number of edges on the shortest path color v some color A coloring satisfies two conditions for each pair of vertices of the same color v u there exists a path from v to u that only visits vertices of the same color for each pair of vertices of the same color v u d v neq d u Note that Monocarp can choose any amount of different colors he wants to use For each used color he then counts the number of vertices of this color The of the tree is the minimum of these numbers What can be the maximum cost of the tree ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Let s start by choosing a vertex naively Iterate over all vertices and try each of them Root the tree by and observe what the conditions become for each is just the depth of each vertex Well then the only case when the connected subgraph of vertices of the same color has all values of distinct is when they form a vertical path in the tree So the problem becomes the following Split the tree into some vertical paths in such a way that the shortest path is as long as possible Let s try greedy I guess Start the paths from the leaves and propagate them up Consider some vertex with at least two children All children have some paths leading up to them We d love to continue them all with but we can t do that We can only continue one path and cut the rest Pretty easy to see that the path to continue is the shortest path available It s at least as optimal as any other path Do that from the lowest vertices up and you got yourself a working greedy Also don t forget to stop all paths in root since you can t continue any of them further up Let s make this greedy more formal Every time we update the answer is with a path that is the shortest in every vertex lower than the current one not the shortest in the current one So we want to propagate the shortest child up and update the answer with the remaining children Updating the answer means just taking the minimum of values Thus we can actually ignore all children except the second shortest in each vertex Just don t forget to treat the root properly Now we can actually solve the problem in for a fixed You can just find two minimums in each vertex Well now that we can solve the problem for a single root let s try rerooting to solve for all of them There are solutions in but I found the solution in the neatest The constraints are low enough to allow it For each vertex maintain a multiset of lengths of vertical paths from its children I chose to store nothing in the leaves that only makes the implementation cleaner In order to update the vertex from its child you can take the minimum element in the child s set and add to it If it s empty the child is a leaf return Additionally store a multiset of the second minimums of all vertices that have at least two children In order to update the answer with the current root find the minimum of that multiset and the shortest path from the root To achieve you will probably have to either store prefix and suffix second minimums over children of each vertex or store three shortest paths in it It is kind of messy but it should still perform better Overall complexity or per testcase "}
{"statement": "You are given an array a 1 a 2 dots a n of integers positive negative or 0 You can perform multiple operations on the array possibly 0 operations In one operation you choose i j 1 leq i j leq n they can be equal and set a i a i a j i e add a j to a i Make the array non decreasing i e a i leq a i 1 for 1 leq i leq n 1 in at most 31 operations You do not need to minimize the number of operations ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "If you either make everything positive or make everything negative you can win in moves by making prefix sums or suffix sums respectively So you have to reach one of these configurations in moves How to make everything positive First you create a big element with the maximum absolute value this requires moves then you add it to every negative element this requires moves and are defined similarly in the negative case So one of and is because the element with the maximum absolute value at the beginning is either positive or negative and the other one is because you can make in moves is the number of negative elements is the number of positive elements So Therefore you need additional moves Since as we wanted Now you can simulate the process in both cases positive and negative and choose one that requires moves in total Complexity "}
{"statement": " You are given a string s consisting of n lowercase Latin letters You have to color its characters each character to exactly one color the same letters can be colored the same or different colors i e you can choose exactly one color for each index in s After coloring you can swap two neighboring characters of the string that are colored colors You can perform such an operation arbitrary possibly zero number of times The goal is to make the string sorted i e all characters should be in alphabetical order Your task is to say if it is possible to color the given string so that after coloring it can become sorted by sequence of swaps Note that you have to restore only coloring not the sequence of swaps ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "Note that the actual problem is to divide the string into two subsequences that both of them are non decreasing You can note that this is true because you cannot the relative order of the elements colored in the same color but you can write down subsequences of different colors in any order you want In this problem you can write the following dynamic programming is if you can split the prefix of the string into two non decreasing sequences such that the first one ends with the character and the second one with characters are numbered from to otherwise is zero Initially only other values are zeros Transitions are very easy if the current value of dp is then we can make a transition to if and to if Then you can restore the answer by carrying parent values But there is another very interesting solution Let s go from left to right and carry two sequences and If the current character is not less than the last character of then let s append it to otherwise if this character is not less than the last character of then append it to otherwise the answer is If the answer isn t then and are required sequences The proof and other stuff will be in the editorial of the hard version Time complexity or or "}
{"statement": "Companies always have a lot of equipment furniture and other things All of them should be tracked To do this there is an inventory number assigned with each item It is much easier to create a database by using those numbers and keep the track of everything During an audit you were surprised to find out that the items are not numbered sequentially and some items even share the same inventory number There is an urgent need to fix it You have chosen to make the numbers of the items sequential starting with Changing a number is quite a time consuming process and you would like to make maximum use of the current numbering You have been given information on current inventory numbers for items in the company Renumber items so that their inventory numbers form a of numbers from to by changing the number of as few items as possible Let us remind you that a set of numbers forms a if all the numbers are in the range from to and no two numbers are equal ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let s look at the problem from another side how many numbers can we leave unchanged to get permutation It is obvious these numbers must be from to and they are must be pairwise distinct This condition is necessary and sufficient This problem can be solved with greedy algorithm If me meet the number we have never met before and this number is between and we will leave this number unchanged To implement this we can use array where we will mark used numbers After that we will look over the array again and allocate numbers that weren t used Complexity "}
{"statement": "Polycarp lives on a coordinate line at the point x 0 He goes to his friend that lives at the point x a Polycarp can move only from left to right he can pass one unit of length each second Now it s raining so some segments of his way are in the rain Formally it s raining on n non intersecting segments the i th segment which is in the rain is represented as l i r i 0 le l i r i le a There are m umbrellas lying on the line the i th umbrella is located at point x i 0 le x i le a and has weight p i When Polycarp begins his journey he doesn t have any umbrellas During his journey from x 0 to x a Polycarp can pick up and throw away umbrellas Polycarp picks up and throws down any umbrella instantly He can carry any number of umbrellas at any moment of time Because Polycarp doesn t want to get wet he must carry at least one umbrella while he moves from x to x 1 if a segment x x 1 is in the rain i e if there exists some i such that l i le x and x 1 le r i The condition above is the only requirement For example it is possible to go without any umbrellas to a point where some rain segment starts pick up an umbrella at this point and move along with an umbrella Polycarp can swap umbrellas while he is in the rain Each unit of length passed increases Polycarp s fatigue by the sum of the weights of umbrellas he carries while moving Can Polycarp make his way from point x 0 to point x a If yes find the minimum total fatigue after reaching x a if Polycarp picks up and throws away umbrellas optimally ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Any experienced contestant can easily guess that the problem can be solved with dynamic programming Coordinates are not really large so you can precalculate the array where is a boolean value if there exists some segment of rain to cover the segment between positions and and otherwise This can be done in with the most straightforward algorithm You can also precalculate another array where is the index of the umbrella of minimal weight at position or if there is no such umbrella Now let be the minimal total fatigue you can take if you are holding umbrella number on the end of the walk up to position If then you hold no umbrella Initially all the values are and is You can either hold your umbrella drop it or pick up the best one lying there and drop the current one if any when going from some position to So here are the transitions for these cases if if if The answer is equal to If it is then there is no answer So you have states and all the transitions are Overall complexity There is also a solution in with Convex Hull Trick using Li Chao tree You can probably even achieve with some coordinate compression Obviously this wasn t required for the problem as the constraints are small enough "}
{"statement": "Wilbur the pig is tinkering with arrays again He has the array initially consisting of zeros At one step he can choose any index and either add to all elements or subtract from all elements His goal is to end up with the array Of course Wilbur wants to achieve this goal in the minimum number of steps and asks you to compute this value ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "No matter what we make operations to make equal to Once this is done Then no matter what we must make operations to make equal to In general to make we need to make operations so in total we make operations Complexity Code Solution Note that if there is an integer so that the number of equal to differs from the number of the given squares whose weight equals then the answer is automatically NO This can be easily checked by using a map for the and the weights of the squares and checking if the maps are the same This step takes time Let be an integer and let be the set of all so that Let be the set of all special points so that the weight of is Note that and have the same number of elements Suppose that are the elements of Let if or and Suppose that are the elements of Note that the point has to be labeled by for Now each special point is labeled It remains to check if this is a valid labeling This can be done by taking an array of vectors The vector will denote the points with coordinate This vector can be easily made from the points given in time and since the points are already labeled will denote the label for the point Now for all points the point if it is special and the point if it is special must have a greater number than This step takes a total of time Complexity Code Solution Bonus Can you do this problem in time Comments This problem was inspired by the representation theory of the group of permutations Representation theory of the Symmetric Group Essential objects in the study of are Young diagrams and standard Young tableau Young Tableau The weight of a point as defined by the problem is basically the same thing as the content of a square in a standard Young tableaux If you have questions feel free to message me Let us solve this problem using dynamic programming First let us reindex the trees by sorting them by coordinate Let where we would like to consider the problem of if we only have trees standing where indicates that tree falls right and if it falls left and indicates that tree falls right and if it falls left We start with the case that Wilbur chooses the left tree and it falls right The plan is to calculate the expected length in this scenario and multiply by the chance of this case occurring which is We can easily calculate what is the farthest right tree that falls as a result of this and call it Then if this means the entire segment falls from which the length of the ground covered by trees in can be calculated However be careful when as there may be overlapping covered regions when the tree falls right but the tree falls left If only then we just consider adding the length of ground covered by trees falling right and add to the value of the subproblem There is another interesting case where Wilbur chooses the left tree and it falls left In this case we calculate the expected length and multiply by the chance of this occurring which is The expected length of ground covered by the trees here is just the length contributed by tree falling left which we must be careful calculating as there might be overlapping covered regions with the th tree falling left and the th tree falling right Then we also add the value of subproblem Doing this naively would take time but this can be lowered to by precalculating what happens when tree falls left or right We should also consider the cases that Wilbur chooses the right tree but these cases are analogous by symmetry Complexity Code Solution Solution 1 Suppose that is a string in the query Reverse and the direction of all the moves that can be made on the table Note that starting at any point that is part of a cycle there is a loop and then edges that go out of the loop So for every point it can be checked by dfs whether the can be made by starting at that point by storing what is in the cycle Moreover note that in the reversed graph each point can only be a part of one cycle Therefore the total time for the dfs in a query is This is good enough for queries to run in time Complexity where is the number of distinct characters in the table and is the query string for the th query Code Solution Solution 2 Actually too slow see comment by waterfalls below for more details For each string dfs from every node that has in degree equal to in the original graph There will be a path which leads into a cycle after which anything in the cycle can be used any number of times in Only every node with in degree equal to has to be checked because every path which leads to a cycle is part of a larger path which starts with a vertex of in degree that leads into a cycle This solution is slower but it works in practice since it is really hard for a string to match so many times in the table Each query will take time but it is much faster in practice Complexity where is the number of distinct characters in the table and is the query string of the th query "}
{"statement": "In a certain video game the player controls a hero characterized by a single integer value The hero will have to beat monsters that are also characterized by a single integer value On the current level the hero is facing n caves To pass the level the hero must enter all the caves in some order each cave exactly once and exit every cave safe and sound When the hero enters cave i he will have to fight k i monsters in a row first a monster with armor a i 1 then a monster with armor a i 2 and so on finally a monster with armor a i k i The hero can beat a monster if and only if the hero s power is strictly greater than the monster s armor If the hero can t beat the monster he s fighting the game ends and the player loses Note that once the hero enters a cave he can t exit it before he fights all the monsters in it strictly in the given order Each time the hero beats a monster the hero s power increases by 1 Find the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Consider a single cave Suppose that the hero enters the cave with power To beat the first monster has to be greater than After that the hero s power will increase to and to beat the second monster has to be greater than Continuing this reasoning we can write down inequalities Let The system of inequalities above is equivalent to a single inequality Thus the hero can enter cave with power if and only if and the hero s power will increase by Armed with this knowledge can we determine the best order to visit the caves for the hero It turns out it s always best to enter the caves in non decreasing order of Indeed if the hero can enter cave he should always do that because entering a cave never makes things worse If the hero enters a cave with greater right before a cave with smaller he might enter these caves in reverse order as well Let s sort the caves accordingly and assume What is the smallest power the hero can start the level with We can use the same reasoning that we used for a single cave Suppose the hero starts the level with power To enter the first cave has to be greater than After that the hero s power will increase to and to enter the second cave has to be greater than Continuing this reasoning we can write down inequalities Let The system of inequalities above is equivalent to a single inequality Thus the answer to the problem is Alternatively instead of solving the inequalities one can use binary search on "}
{"statement": "Let s define the of a string s as the number of index pairs i and j 1 le i j s such that s i s j and s i 1 s j 1 You are given two positive integers n and k Among all strings with length n that contain only the first k characters of the Latin alphabet find a string with minimum possible If there are multiple such strings with minimum find any of them ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1600", "problem_editorial": "Consider all possible strings of length on the alphabet of size there are of them Let be the number of occurrences of the th of them in the string The cost of the string by definition is Now let s suppose there are two strings and such that Then if we somehow reduce the number of occurrences of the string by and increase the number of occurrences of the string by the cost will decrease So in the optimal answer all the strings of length should appear the same number of times and if it s impossible the difference in the number of appearances should not be greater than Let s suppose that then our goal is to build a string where each string of length on the alphabet of characters appears exactly once The construction of this string can be modeled using Eulerian cycles build a directed graph with vertices where each vertex represents a character each arc represents a string of length and for every pair of vertices there is an arc from to it s possible that Then by finding the Eulerian cycle in this graph it always exists since the graph is strongly connected and for each vertex its in degree is equal to its out degree we find a string of length such that all its substrings are different so each string of length appears there once as a substring Okay what about the cases and Since the string we build for the case represents a cycle we can make it cyclical and repeat the required number of times then cut last several characters if it s too big For example if then the string for is it s not the only one but we can use it We can expand this string to by repeating the last characters and delete the last character so its length is By the way in this problem you don t have to implement the algorithm that finds Eulerian cycles The graph where we want to find the Eulerian cycle has a very special structure and there are many different constructive ways to find the cycle in it But if you can t use them you always can rely on the straightforward solution that explicitly searches for the Eulerian cycle "}
{"statement": "You are given an array a of n integers You want to make all elements of a equal to zero by doing the following operation times Select a segment for each number in this segment we can add a multiple of len to it where len is the length of this segment added integers can be different It can be proven that it is always possible to make all elements of a equal to zero ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let denote a rectangle with opposite corners and For convenience assume and Let s try solving the problem if coordinates are in range We could easily do this by coordinates compression First let s look at the problem with fixed We define to be the smallest integer such that and is a rectangle If there is no such integer let It can be proven that is non decreasing i e if then Now let s see how changes when we iterate over a fixed It is hard to add points to the set so we will try to support deleting points operation For point we have the following definitions Let set Let with the largest Let set Let with the smallest Note that or might represent empty set With these two functions we could see how changes after we delete point It looks something like this For every such that We could support this operation using segment tree with lazy propagation The total time complexity is "}
{"statement": "Nauuo is a girl who loves drawing circles One day she has drawn a circle and wanted to draw a tree on it The tree is a connected undirected graph consisting of n nodes and n 1 edges The nodes are numbered from 1 to n Nauuo wants to draw a tree on the circle the nodes of the tree should be in n points on the circle and the edges should be straight without crossing each other Without crossing each other means that every two edges have no common point or the only common point is an endpoint of both edges Nauuo wants to draw the tree using a permutation of n elements A permutation of n elements is a sequence of integers p 1 p 2 ldots p n in which every integer from 1 to n appears exactly once After a permutation is chosen Nauuo draws the i th node in the p i th point on the circle then draws the edges connecting the nodes The tree is given Nauuo wants to know how many permutations are there so that the tree drawn satisfies the rule the edges are straight without crossing each other She only wants to know the answer modulo 998244353 can you help her It is obvious that whether a permutation is valid or not does not depend on which n points on the circle are chosen ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "First if we choose a node as the root then each subtree must be in a continuous arc on the circle Then we can use DP to solve this problem Let be the number of plans to draw the subtree of then choose a position for each subtree and then itself then draw the subtrees However instead of choosing the position of the root we suppose the root is on a certain point on the circle then rotate the circle thus get the answer In fact we don t have to write a DP the answer is times the product of the factorial of each node s degree "}
{"statement": "A sequence of integers b 1 b 2 ldots b m is called if max b 1 b 2 ldots b m cdot min b 1 b 2 ldots b m ge b 1 b 2 ldots b m A sequence of integers a 1 a 2 ldots a n is called if every non empty subsequence of a is YouKn0wWho has two integers n and M M is prime Help him find the number modulo M of sequences a 1 a 2 ldots a n such that 1 le a i le n 1 for each integer i from 1 to n A sequence d is a subsequence of a sequence c if d can be obtained from c by deletion of several possibly zero or all elements ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3200", "problem_editorial": "Let s go deeper into the properties of sequences If a sorted sequence is then all its permutations are also Actually it s very easy to see that as the order doesn t matter So we will work on the sorted version of the sequence The sorted sequence is iff all its subarrays are Let s fix the and of a subsequence As is fixed the worst case happens when we insert as many elements as possible in this subsequence which are in between and as we are comparing with the sum and the worst case is a subarray of this sorted sequence Now we will go one step further The sorted sequence is iff all its prefixes are The condition essentially means that for all Imagine that its true Now we will prove that the sequence is Consider a subarray That means all subarrays are And following observation it indicates that the sequence is And it is necessary that all the prefixes should be because they are subarrays after all which proves the iff condition Now let s exploit the fact that all are Let s remind again that we are considering the sorted sequences for now is required for any If as which violates the condition If then all for This means But as all this can only happen when all But as consequently all should be So can be either or If then according to observation there is only one such sequence From now on let s consider So But this formulation is a bit hard to work on So now we will make a move which I would like to call a programmer move That is the equation is equivalent to Following observation its necessary that for all if and then the prefix is automatically if the whole sorted sequence is If the whole sequence is good then Now So So the prefix is Let s recap that is required observation if then is automatically observation and is only possible when observation So the necessary and sufficient conditions for the sorted sequence to be assuming are For For Notice that we need the answer considering all such sequences not only sorted sequences but it is not hard to track that using basic combinatorics So let s fix the smallest number and subtract from everything So we need to count the number of sequences such that There is at least number at least numbers at least numbers this condition is basically the intuition of when and when Let s formulate a dp in top down manner We will choose going from to Let number of sequences when we already chose elements the total sum of the selected elements and we will select now So if we choose numbers of then the transition is something like And at the base case when return The factorial terms are easy to make sense of because we are considering all sequences not only sorted ones Check my solution for more clarity This dp will take for each term is for harmonic series sum as yielding a total of If then no sequences are possible Assume that or or But because of the condition there will be at least at least number at least numbers at least numbers But that clearly means that which is a contradiction So we need to traverse s which also means in the dp is also So the total time complexity will be or faster but with very low constant that it will work instantly Phew such a long editorial I need to take a break and explore the world sometimes "}
{"statement": "You are given integers and There is a number which is initially equal to You are allowed to perform two types of operations Subtract 1 from This operation costs you coins Divide by Can be performed only if is divisible by This operation costs you coins What is the minimum amount of coins you have to pay to make equal to ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "If then answer is obvious otherwise we will greedily decrease number During each moment of time we should consider following three cases If we can only decrease number by 1 paying coins each time It can be done in using formula If and is not divisible by we can only decrease number times by 1 paying coins each time This case can be also handled in using formula If is divisible by it s always optimal to make number equals paying coins If then optimality is obvious Otherwise assume we didn t make decreasing to t now but did it on interval from number In this case we paid coins It equals or with is not more optimal then decreasing to and decreasing to after that Each case should be handled at most times so complexity of the solution is "}
{"statement": "You are given an array a of length n consisting of zeros You perform n actions with this array during the i th action the following sequence of operations appears Choose the maximum by length subarray consisting of zeros among all such segments choose the one Let this segment be l r If r l 1 is odd not divisible by 2 then assign set a frac l r 2 i where i is the number of the current action otherwise if r l 1 is even assign set a frac l r 1 2 i Consider the array a of length 5 initially a 0 0 0 0 0 Then it changes as follows Firstly we choose the segment 1 5 and assign a 3 1 so a becomes 0 0 1 0 0 then we choose the segment 1 2 and assign a 1 2 so a becomes 2 0 1 0 0 then we choose the segment 4 5 and assign a 4 3 so a becomes 2 0 1 3 0 then we choose the segment 2 2 and assign a 2 4 so a becomes 2 4 1 3 0 and at last we choose the segment 5 5 and assign a 5 5 so a becomes 2 4 1 3 5 Your task is to find the array a of length n after performing all n actions You have to answer t independent test cases ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "This is just an implementation problem We can use some kind of heap or ordered set to store all segments we need in order we need To solve this problem on C with we can just rewrite the comparator for like this And then just write the like this Now the minimum element of the set will be the segment that we need to choose Initially the set will contain only one segment Suppose we choose the segment during the th action Let where is divided by rounded down Assign set then if the segment has positive greater than zero length push this segment to the set and the same with the segment After such actions we get the answer Time complexity "}
{"statement": "Seryozha has a very changeable character This time he refused to leave the room to Dima and his girlfriend her hame is Inna by the way However the two lovebirds can always find a way to communicate Today they are writing text messages to each other Dima and Inna are using a secret code in their text messages When Dima wants to send Inna some sentence he writes out all words inserting a heart before each word and after the last word A heart is a sequence of two characters the less characters and the digit three After applying the code a test message looks like that 3 3 3 3 Encoding doesn t end here Then Dima inserts a random number of small English characters digits signs more and less into any places of the message Inna knows Dima perfectly well so she knows what phrase Dima is going to send her beforehand Inna has just got a text message Help her find out if Dima encoded the message correctly In other words find out if a text message could have been received by encoding in the manner that is described above ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "It s clear that adding new random symbols means that we can simply omit them they don t change the structure of the phrase Let s determine the phrase before inserting random elements Lets is an index in we are waiting for At the beginning we will iterate though the sms and when we will meet the symbol which equals to we will simply increment if at some moment we found all needed symbols and answer is yes otherwise no "}
{"statement": " Let s call a positive integer if its decimal representation without leading zeroes contains even number of digits and there exists a permutation of this representation which is palindromic For example is a beautiful number since it contains digits and there exists a palindromic permutation Given a positive integer find the largest beautiful number which is less than ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "This is pretty typical problem on greedy construction you are asked to build lexicographically maximal string In the majority of cases it s done like this Imagine you ve built some prefix of length with all numbers equal to the prefix of length of the original string You are also sure there exists some suffix for it that will give proper beautiful number Now you have two options you either put if possible and proceed to the same task of longer prefix or you put the smaller number and fill the entire suffix with the maximum possible beautiful number you can obtain Now you should learn how to check if any valid suffix exists It means at least the smallest possible beautiful number with current prefix is smaller than It s built like this Let be the number of digits which currently have odd number of occurences You put all zeroes but the last digits and then output these odd occurence number digits in increasing order The first part can be checked with partial sums on the number of zeroes on segment in the original string and the second part has its length not greater than and can be checked naively Overall complexity "}
{"statement": "Allen having graduated from the MOO Institute of Techcowlogy MIT has started a startup Allen is the president of his startup He also hires n 1 other employees each of which is assigned a direct superior If u is a superior of v and v is a superior of w then also u is a superior of w Additionally there are no u and v such that u is the superior of v and v is the superior of u Allen himself has no superior Allen is employee number 1 and the others are employee numbers 2 through n Finally Allen must assign salaries to each employee in the company including himself Due to budget constraints each employee s salary is an integer between 1 and D Additionally no employee can make strictly more than his superior Help Allen find the number of ways to assign salaries As this number may be large output it modulo 10 9 7 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "A immediate simple observation is that we can compute the answer in with a simple dynamic program How to speed it up though To speed it up we need the following lemma Lemma 1 For a tree with vertices the answer is a polynomial in of degree at most We can prove this via induction and the fact that for any polynomial of degree the sum is a polynomial in of degree Now the solution is easy compute the answer for and use interpolation to compute the answer for The complexity is for the initial dp and for the interpolation step "}
{"statement": "Ostap Bender recently visited frog farm and was inspired to create his own frog game Number of frogs are places on a cyclic gameboard divided into cells Cells are numbered from to but the board is cyclic so cell number goes right after the cell number in the direction of movement th frog during its turn can jump for cells Frogs move in turns game starts with a move by frog On its turn th frog moves cells forward knocking out all the frogs on its way If there is a frog in the last cell of the path of the th frog that frog is also knocked out After this the value is decreased by the number of frogs that were knocked out during this turn If is zero or goes negative then th frog doesn t make moves anymore After frog number finishes its turn frog number starts to move then frog number and so on After the frog number makes its move frog starts to move again then frog and so on this process goes forever If some frog was already knocked out from the board we consider that it skips all its moves Help Ostap to identify what frogs will stay on the board at the end of a game ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "We want to efficiently simulate the process from the problem statement Lets have a data structure with times of key events that could ve happened during simulation some frog removed other frog from the board Lets remove earliest event from our data structure and apply it to the board make a critical jump After that the speed of the first frog will decrease and we will be forced to recount times of collision of this frog this its 2 neighbors This data structure could be set from C TreeSet from Java or self written Segment Tree To quickly find out who are we gonna remove from the board after the jump lets store double linked list of all frogs sorted by their positions Technical part is to calculate time of the collision but it can be easily done with the simple notion of linear movement of two points on a line There could be at max collisions so whole solution will be "}
{"statement": "In Homer s country there are n cities numbered 1 to n and they form a tree That is there are n 1 undirected roads between these n cities and every two cities can reach each other through these roads Homer s country is an industrial country and each of the n cities in it contains some mineral resource The mineral resource of city i is labeled a i Homer is given the plans of the country in the following q years The plan of the i th year is described by four parameters u i v i l i and r i and he is asked to find any mineral resource c i such that the following two conditions hold mineral resource c i appears an number of times between city u i and city v i and l i leq c i leq r i As the best friend of Homer he asks you for help For every plan find any such mineral resource c i or tell him that there doesn t exist one ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Let denote the number of cities between city and city whose mineral resource is We restate the problem that for each query find an integer such that and We give a randomized algorithm with success probability extremely high For every kind of mineral resources we assign a random variable to it Those random variables are independent and identically uniformly distributed from For every city we assign its weight to be For every query Let be the bitwise XOR of all weights of all cities between city and city whose mineral resources are in We claim that which means that if a suitable does not exist then for certainty and which means that if a suitable does exist then with high probability Let s consider the reverse that which implies with high probability no suitable mineral resource exists if and which implies with certainty at least one suitable mineral resource exists According to the above discussion our strategy is to report no solution if and to find a such that if Our strategy will succeed with probability Now consider there are queries Let denote the event that the th query succeeds The th query will succeed with probability however they may not be independent Then we have which means all queries succeed simultaneously with probability at least if which is high enough under constraints of the problem To this end we shall compute and find a such that This can be solved by consistent segment trees Let s root the tree by any vertex say vertex For every vertex we maintain a consistent segment tree that for each interval computes Let be the father of vertex and be the least common ancestor of vertex and vertex Then For more details please according to SPOJ COT Therefore we have solved this problem with high enough probability in time and space "}
{"statement": "In a galaxy far far away Lesha the student has just got to know that he has an exam in two days As always he hasn t attended any single class during the previous year so he decided to spend the remaining time wisely Lesha knows that today he can study for at most a hours and he will have b hours to study tomorrow Note that it is possible that on his planet there are more hours in a day than on Earth Lesha knows that the quality of his knowledge will only depend on the number of lecture notes he will read He has access to an infinite number of notes that are enumerated with positive integers but he knows that he can read the first note in one hour the second note in two hours and so on In other words Lesha can read the note with number k in k hours Lesha can read the notes in arbitrary order however he can t start reading a note in the first day and finish its reading in the second day Thus the student has to fully read several lecture notes today spending at most a hours in total and fully read several lecture notes tomorrow spending at most b hours in total What is the maximum number of notes Lesha can read in the remaining time Which notes should he read in the first day and which in the second ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Consider any answer with maximal n m If we used numbers d1 d2 dk di n m then we didn t use some numbers h1 h2 hk hi n m Replacing all di by hi 1 i k doesn t violate the restriction That means that we can assume that the answer consists of all numbers from 1 to x and x n m The sum of all numbers from 1 to x equals x x 1 2 It s clear that the following inequality must hold x x 1 2 a b Let s find the maximal x for which it s true The answer can t exceed x and we can build the answer for x iteratively Let s iterate over all lecture notes from x to 1 and on each step we put it into the first day if we can otherwise if in the first day we have w 0 free time then we put the lecture note w x to the first day All other lecture notes can be read during the second day since the either there are none of them or the first day is full and hence the second day contains a sufficient amount of hours to read em all "}
{"statement": "A number is a positive integer that has exactly two different positive divisors 1 and the integer itself For example 2 3 13 and 101 are prime numbers 1 4 6 and 42 are not You are given a sequence of digits from 1 to 9 in which You are allowed to do the following operation choose any digit from the sequence and delete it Your goal is to obtain a sequence which represents a prime number Note that you cannot reorder the digits in the sequence Print the resulting sequence or report that it is impossible to perform the operations so that the resulting sequence is a prime number ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "There are many possible approaches to this problem For example you could use brute force to solve it iterate on every integer from check that it is a prime number by iterating on its divisors and check that it appears as a subsequence in the given digit sequence If you find the answer break the loop and print the number you found But that s a bit lengthy to code Let s try something different We can try looking for a small set of primes such that at least one of the primes from that set appears in the given sequence Let s try short primes they are easier to work with If there exist two prime numbers of length consisting of digits and one of them is and the other of them is then one of them will definitely appear in our sequence If comes earlier than then appears in the sequence otherwise it s Thankfully it s possible to find these two primes For example you can use and one of them will definitely appear in the sequence So the easiest solution is to find whether is earlier than in the sequence If is earlier then is the answer otherwise it s "}
{"statement": "Vitaly is a diligent student who never missed a lesson in his five years of studying in the university He always does his homework on time and passes his exams in time During the last lesson the teacher has provided two strings and to Vitaly The strings have the same length they consist of lowercase English letters string is lexicographically smaller than string Vitaly wondered if there is such string that is lexicographically larger than string and at the same is lexicographically smaller than string This string should also consist of lowercase English letters and have the length equal to the lengths of strings and Let s help Vitaly solve this easy problem ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "To solve this problem we can for example find string next which lexicographically next to string s and check that string next is lexicographically less than string t If string next is lexicographically smaller than string t print string next and finish algorithm If string next is equal to string t print No such string To find string next which lexicographically next to string s at first we need to find maximal suffix of string s consisting from letters z change all letters z in this suffix on letters a and then letter before this suffix increase on one I e if before suffix was letter for example d we need to change it on letter e "}
{"statement": "You are given an array of integers a 1 a 2 dots a n 1 le a i le n You can perform the following operation several possibly zero times pick an arbitrary i and perform a i a a i How many distinct arrays is it possible to attain Output the answer modulo 10 9 7 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2800", "problem_editorial": "Consider a directed graph with vertices where for each vertex there is an edge This is a functional graph that is every vertex has exactly one edge outgoing from it Let s see how our operations affect the graph We will write to illustrate the fact that Call the operation vertex We can assume that we never picked such that the operation didn t change the permutation that is We will mark some edges in the graph as Initially no edge is bold When we pick vertex one of the following can happen If no bold edges pass into go along the bold edges until we can Let s say the vertex we reached is Then mark the edge from bold If has an incoming bold edge do nothing At every moment of time the graph corresponds to the permutation in the following way if has an incoming bold edge then otherwise if is the vertex we reach by going from along the bold edges and then Also one can see that according to the algorithm of making edges bold no vertex ever has more than one incoming bold edge It is clear that each valid subset of bold edges corresponds to a unique permutation However one can see that the same permutation can correspond to multiple subsets In particular for a component of the graph if for all vertices of the cycle in this component then the boldness of all edges outside the cycle is uniquely determined but for the edges of the cycle any subset of these edges that doesn t include exactly one of them corresponds to this permutation To avoid this uncertainty we say that this permutation will correspond to the subset of bold edges where all the edges from the cycle are bold this is an invalid subset because there is no sequence of operations that would mark it bold Now we want to calculate the number of possible subsets of bold edges Each vertex can have either no incoming bold edges there is way to do this or any one of them can be bold ways to do this for vertex So the answer could be just However since some of the configurations are invalid we need to modify the answer In particular consider any cycle All excluded subsets of edges correspond to exactly one of having either no bold edge incoming or any edge except Therefore the number of ways to choose the bold edges among the ones incoming to this cycle isThus the final answer is "}
{"statement": "You are given n numbers a 1 a 2 dots a n In one operation we can add to any one of those numbers a nonnegative integer power of 2 What is the smallest number of operations we need to perform to make all n numbers equal It can be proved that under given constraints it doesn t exceed 10 18 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "We will suppose that array is sorted Let x be the final number Than x an Also if we define bits c as number of ones in binary notation of c than to get x from ai we will spend at least bits x ai moves it follows from the fact that minumum number of powers of two which in sum are equal to the number corresponds to it binary notation Let t x an than x ai t an ai So we need the following task Minimize sum bits t an a1 bits t an a2 bits t an an where t is some nonnegative integer Also let s define bi as an ai We will solve this task using dp value which we want to minimize is sum bits t bi taken over bits up to k 1 Then suppose we want to decide something about k th bit Let s understand which information from the previous bits is needed for us Imagine that we sum t bi in vertical format Clearly to find k th bit in number t bi it s sufficient to know k th bit in number t and do we have carry from previous digit Furthermore if we know this information for the previous bit we can get it for the next carry in new digit will occur iff bitk bi bitk t didwehavecarry 2 But we should save information about carry for all numbers t bi so at first sight for one bit we have at least 2n different states of dp To reduce the number of states we need to note key fact Let t t mod 2k c c mod 2k Than carry in k th bit will occur t c iff t c 2k Indeed carry corresponds to the fact that the sum of cutoff numbers is at least 2k Using this fact we understand that if we sort numbers b i bi mod 2k than carry in k th bit will happen only for some suffix of b i That s why we get n 1 different states for one bit which is good So we only need to learn how to make transitions fast It s useful to note that we don t need to know numbers bi it s sufficient to know do we have a carry and value of k th bit of bi Then transition reduces to count the number of 1 and 0 in k th bit on some segment of the array sorted by b i This can be easily done in constant time if we precalculated prefix sums for better understanding you can read attached code So we can solve the task in nlog n F time where F is bit up to which we ll write dp So it left to show or to believe that there is no sense to consider big F "}
{"statement": "Some time ago Mister B detected a strange signal from the space which he started to study After some transformation the signal turned out to be a permutation of length or its cyclic shift For the further investigation Mister B need some basis that s why he decided to choose cyclic shift of this permutation which has the minimum possible deviation Let s define the deviation of a permutation as Find a cyclic shift of permutation with minimum possible deviation If there are multiple solutions print any of them Let s denote id of a cyclic shift of permutation as the number of right shifts needed to reach this shift for example shift shift shift ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s see how affects different shifts Let s denote is deviation of the shift At first all Then affects it in following way Then there are 2 cases or not If after removing modules we will get 3 query to add to where to add to where and to add to where Else if we need to perform next operation to add to where to add to where and to add to where But in both cases we must add 3 arithmetic progression to the segment of array Or make operation of adding to segment Its known task which can be done by adding subtracting values in start and end of segment offline To make such operation we need to remember how to add value to segment of array offline We can just do next operations and Now value in position So what is adding progression with coef it s only adding to array value to all positions in segment That s why we need other array for example and making and In result So algorithm to add to segment is next After all queries we need recover array with formula And after that get answer with formula So complexity is "}
{"statement": "You have a coins of value n and b coins of value 1 You always pay in exact change so you want to know if there exist such x and y that if you take x 0 le x le a coins of value n and y 0 le y le b coins of value 1 then the total value of taken coins will be S You have to answer q independent test cases ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Firstly we obviously need to take at least coins of value If we cannot do it the answer it Otherwise we always can obtain the required sum if "}
{"statement": "Welcome to Codeforces Stock Exchange We re pretty limited now as we currently allow trading on one stock Codeforces Ltd We hope you ll still be able to make profit from the market In the morning there are n opportunities to buy shares The i th of them allows to buy as many shares as you want each at the price of s i bourles In the evening there are m opportunities to sell shares The i th of them allows to sell as many shares as you want each at the price of b i bourles You can t sell more shares than you have It s morning now and you possess r bourles and no shares What is the maximum number of bourles you can hold after the evening ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The main observation is that we always want to buy shares as cheaply as possible and sell them as expensively as possible Therefore we should pick the lowest price at which we can buy shares and the highest price at which we can sell the shares Now we have two cases If it s optimal to buy as many shares and possible in the morning and sell them all in the evening We can buy as many as shares and gain bourles profit on each of them Therefore the final balance is If we re not gaining any profit on the shares and therefore we shouldn t care about trading stocks at all The final balance is then The solution can be therefore implemented in time However the constraints even allowed brute forcing the seller the buyer and the amount of stock we re buying in time Note that many programming languages have routines for finding the minima maxima of the collections of integers e g in C in Java or in Python This should make the code shorter and quicker to write "}
{"statement": "In the pet store on sale there are a packs of dog food b packs of cat food c packs of universal food such food is suitable for both dogs and cats Polycarp has x dogs and y cats Is it possible that he will be able to buy food for all his animals in the store Each of his dogs and each of his cats should receive one pack of suitable food for it ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Obviously the best way to buy food for every pet is to buy maximum possible food for dogs and cats then dogs and cats will not get food We will buy universal food for these dogs and cats Then the answer is if and else "}
{"statement": "Alexandra has a paper strip with numbers on it Let s call them from left to right Now Alexandra wants to split it into some pieces possibly For each piece of strip it must satisfy Each piece should contain at least numbers The difference between the maximal and the minimal number on the piece should be at most Please help Alexandra to find the minimal number of pieces meeting the condition above ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "We can use dynamic programming to solve this problem Let denote the minimal number of pieces that the first numbers can be split into denote the maximal length of substrip whose right border is included and it satisfy the condition Then where We can use monotonic queue to calculate g i and f i And this can be implemented in We can also use sparse table or segment tree to solve the problem the time complexity is or It should be well implemented For more details about monotonic queue you can see here "}
{"statement": "Alexander is learning how to convert numbers from the decimal system to any other however he doesn t know English letters so he writes any number only as a decimal number it means that instead of the letter he will write the number Thus by converting the number from decimal to hexadecimal system he gets Alexander lived calmly until he tried to convert the number back to the decimal number system Alexander remembers that he worked with little numbers so he asks to find the minimum decimal number so that by converting it to the system with the base he will get the number ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Let s compare answers for numbers and that is without the rightmost digit Note that for any number is either contains less substrings valid digits in base numeric system or it s possible to decrease value of the last substring of number That proves that partition of number without the rightmost digit isn t worse than partition of the number itself Thus greedy strategy will work On each step take the longest suffix of a string as the last base digit and proceed to same task for string with this suffix excluded Repeat until the string isn t empty Check carefully that the suffix is a number less than and also doesn t have any leading zeros except for the case when it s equal to zero Overall complexity where length of input string "}
{"statement": "You are given a bracket sequence s consisting of n opening and closing brackets A bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are and and are not You can change the type of some bracket s i It means that if s i then you can change it to and vice versa Your task is to calculate the number of positions i such that if you change the type of the i th bracket then the resulting bracket sequence becomes ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "In this problem we have to calculate the number of positions such that if we change the type of the bracket at this position then the obtained bracket sequence will become regular Let s calculate the balance of each prefix of the bracket sequence and store it in the array Just iterate from left to right over the string and if the current bracket is opening then increase the current balance by one otherwise decrease it by one For each prefix let s also calculate whether it can be a prefix of a regular bracket sequence RBS and store it in the array The prefix of length can be the prefix of RBS if and only if the prefix of length can be the prefix of RBS and Let s calculate the same arrays for all suffixes and call they and correspondingly but now the closing bracket will increase the balance by one and the opening will decrease it by one and we consider the characters from right to left Now if we have these arrays let s iterate over all positions in the initial bracket sequence If we now at the position then let s do the following things firstly if or then skip this position Otherwise if the current bracket is opening then we have to increase the answer if and only in this case the bracket sequence will become regular And if the current bracket is closing then we have to increase the answer if "}
{"statement": "Two painters Amin and Benj are repainting Gregor s living room ceiling The ceiling can be modeled as an n times m grid For each i between 1 and n inclusive painter Amin applies a i layers of paint to the entire i th row For each j between 1 and m inclusive painter Benj applies b j layers of paint to the entire j th column Therefore the cell i j ends up with a i b j layers of paint Gregor considers the cell i j to be if a i b j le x Define a to be a connected component of badly painted cells i e a connected component of badly painted cells such that all adjacent to the component cells are not badly painted Two cells are considered adjacent if they share a side Gregor is appalled by the state of the finished ceiling and wants to know the number of badly painted regions ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3400", "problem_editorial": "SolutionThis editorial was written by enq and inspired by 1392I For simplicity let s assume that all are distinct and similarly all If this is not the case we may break ties arbitrarily Say that two badly painted cells are directly reachable from each other if they are in the same row or column and all cells in between them are also badly painted Also define the value of the cell at to be Call a badly painted cell a if no cell directly reachable from it has a smaller value than it Every connected component of badly painted cells contains exactly one representative Clearly every connected component contains at least one representative consider the cell s with the minimum value contained within it To show that every connected component contains textit exactly one representative suppose that we are given a representative that is directly reachable from for all and for all where and Then the connected component containing is completely contained within the rectangle and is the unique cell with the minimum value within that rectangle This implies that a representative is always the unique cell with the minimum value within its connected component It remains to count the number of representatives For each let be the maximum index less than such that and be the minimum index greater than such that Then define to be Any path from a cell in row to a cell in the same column with lower value must pass through a row with value at least Define for each similarly It can be shown that is a representative if and only if the following conditions hold Computing and can be done in with any data structure supporting range min max queries e g sparse tables or in with a stack It remains to count the number of pairs that satisfy these conditions given and First initialize two binary indexed trees and Then sort the pairs in decreasing order Now for every pair in the order if it is of the form then add to the answer the number of elements of that are in the range and add to The reasoning for the case is similar query update The time complexity is for sorting the pairs and working with the two BITs "}
{"statement": "String is an of string if we can rearrange the letters in string and get exact string For example strings and are anagrams so are strings and but strings and are not You are given two strings and of the same length consisting of uppercase English letters You need to get the anagram of string from string You are permitted to perform the replacing operation every operation is replacing some character from the string by any other character Get the anagram of string in the least number of replacing operations If you can get multiple anagrams of string in the least number of operations get the lexicographically minimal one The lexicographic order of strings is the familiar to us dictionary order Formally the string of length is lexicographically smaller than string of the same length if for some Here characters in the strings are numbered from 1 The characters of the strings are compared in the alphabetic order ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Lets denote the number of character in by Similarly is defined Then the minimum number of changes required to get anagram of from is equal to Now we need to obtain lexicographically minimum solution Lets iterate through the positions in from the left to the right For a fixed position look through all characters from a to z and for each character decide whether the optimal answer can contain this character in that position If it can put this character in that position and continue with the next position To check if the given character is suitable quickly we maintain the values and while iterating through positions "}
{"statement": "You are given a grid with n rows and m columns Rows and columns are numbered from 1 to n and from 1 to m The intersection of the a th row and b th column is denoted by a b Initially you are standing in the top left corner 1 1 Your goal is to reach the bottom right corner n m You can move in four directions from a b up to a 1 b down to a 1 b left to a b 1 or right to a b 1 You cannot move in the same direction in two consecutive moves and you cannot leave the grid What is the minimum number of moves to reach n m ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Solution The moves are symmetrical so we can assume that There is no solution if and because one can only move up and down but two consecutive down moves is required to reach Otherwise there is a solution One should move downwards at least times and it is forbidden to do that twice in a row so another move is necessary between each pair So at least moves required If is even then one more because the parity of changes after every move and the parity is even before the first and after the last move so the total number of moves should be even There is a construction for that lower bound Move alternately down and right After reaching the th column repeat the following sequence of moves down left down right With this move long sequence one can move down two times So we will reach then one more move is required or we will reach If we add all of these moves we get the formula if is even then and if is odd then "}
{"statement": "Furik loves math lessons very much so he doesn t attend them unlike Rubik But now Furik wants to get a good mark for math For that Ms Ivanova his math teacher gave him a new task Furik solved the task immediately Can you You are given a set of digits your task is to find the maximum integer that you can make from these digits The made number must be divisible by without a residue It is permitted to use not all digits from the set it is forbidden to use leading zeroes Each digit is allowed to occur in the number the same number of times it occurs in the set ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Nuber is divisible by 2 3 5 only if sum of the digits is divisible by 3 and last digit is 0 so if we havent 0 in our set answer is 1 otherwise solution exists we can return 0 as solution A further solution analysis of the cases Lets sort all didgits in nonincreasing order If sum of all digits is divisible by 3 answer is our set of digits without spaces ofcourse If modulo equals 1 we must delete minimum digit from out set with modulo after division by 3 equals 1 if we haven t such we must delete 2 minimal digits with modulo after division by 3 equals 2 If we have modulo equals 2 we have identical case Also we must remember that we cannot use leading zeros In case when we have more then one 0 and no another digit we must print only one zero "}
{"statement": " Vlad built a maze out of n rooms and n 1 bidirectional corridors From any room u any other room v can be reached through a sequence of corridors Thus the room system forms an undirected tree Vlad invited k friends to play a game with them Vlad starts the game in the room 1 and wins if he reaches a room other than 1 into which exactly one corridor leads Friends are placed in the maze the friend with number i is in the room x i and no two friends are in the same room that is x i neq x j for all i neq j Friends win if one of them meets Vlad in any room or corridor before he wins For one unit of time each participant of the game can go through one corridor All participants move at the same time Participants may not move Each room can fit all participants at the same time Friends know the plan of a maze and intend to win Vlad is a bit afraid of their ardor Determine if he can guarantee victory i e can he win in any way friends play In other words determine if there is such a sequence of Vlad s moves that lets Vlad win in any way friends play ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "First we need to understand when it is not possible to get to some exit Let s fix a friend who is at the vertex and try to understand if he can interfere with us The paths from to and from to have a common part let it start at the vertex Then if the path from to is not more than from to it can prevent us from reaching this exit by blocking the vertex Since the path from to is common the previous condition is equivalent to the condition that the path from to is not greater than from to Note that if there is more than one such vertex then can overlap each of them simply by going as close to the root as possible Thus Vlad can win if there is such a leaf which by condition exits for which the distance to the root is less than the distance to any of the friends By running a breadth first search at the same time from each vertex with a friend we can find the shortest distance to any friend from each vertex and by running from the root the distance to the root Now let s just go through all the leaves and check if there is one among them that the distance to the root is less We can also run from the vertices with friends and from the root at the same time assigning them different colors then the color will correspond to what is closer the root or some friend this solution is attached to the tutorial There is also another solution which is a simplified version of the one we will use in E2 "}
{"statement": "Recently Tokitsukaze found an interesting game Tokitsukaze had n items at the beginning of this game However she thought there were too many items so now she wants to discard m 1 le m le n special items of them These n items are marked with indices from 1 to n In the beginning the item with index i is placed on the i th position Items are divided into several pages orderly such that each page contains exactly k positions and the last positions on the last page may be left empty Tokitsukaze would do the following operation focus on the first special page that contains at least one special item and at one time Tokitsukaze would discard all special items on this page After an item is discarded or moved its old position would be empty and then the item below it if exists would move up to this empty position The movement may bring many items forward and even into previous pages so Tokitsukaze would keep waiting until all the items stop moving and then do the operation i e check the special page and discard the special items repeatedly until there is no item need to be discarded Tokitsukaze wants to know the number of operations she would do in total ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "The order of discarding is given so we can simulate the process of discarding In each time we can calculate the page that contains the first special item that has not been discarded and then locate all the special items that need to be discarded at one time Repeat this process until all special items are discarded Each time at least one item would be discarded so the time complexity is "}
{"statement": "Ivan has n songs on his phone The size of the i th song is a i bytes Ivan also has a flash drive which can hold at most m bytes in total Initially his flash drive is empty Ivan wants to copy all n songs to the flash drive He can compress the songs If he compresses the i th song the size of the i th song reduces from a i to b i bytes b i a i Ivan can compress any subset of the songs possibly empty and copy all the songs to his flash drive if the sum of their sizes is at most m He can compress subset of the songs not necessarily contiguous Ivan wants to find the minimum number of songs he needs to compress in such a way that all his songs fit on the drive i e the sum of their sizes is less than or equal to m If it is impossible to copy all the songs even if Ivan compresses all the songs print Otherwise print the minimum number of songs Ivan needs to compress ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "If we will no compress songs the sum of the sizes will be equal Let it be Now if we will compress the th song how do will change It will decrease by This suggests that the optimal way to compress the songs is the compress it in non increasing order of Let s create the array of size where Let s sort it in non increasing order and then iterate over all from to If at the current step we print and terminate the program Otherwise we set After all we have to check again if then print otherwise print Time complexity is because of sorting "}
{"statement": "Alice and Bob are playing a game They have two strings S and T of the same length n consisting of lowercase latin letters Players take turns alternately with Alice going first On her turn Alice chooses an integer i from 1 to n one of the strings S or T and any lowercase latin letter c and replaces the i th symbol in the chosen string with the character c On his turn Bob chooses one of the strings S or T and reverses it More formally Bob makes the replacement S operatorname rev S or T operatorname rev T where operatorname rev P P n P n 1 ldots P 1 The game lasts until the strings S and T are equal As soon as the strings become equal the game Define as the total number of moves made by both players during the game For example if Alice made 2 moves in total and Bob made 1 move then the duration of this game is 3 Alice s goal is to minimize the duration of the game and Bob s goal is to maximize the duration of the game What will be the duration of the game if both players play optimally It can be shown that the game will end in a finite number of turns ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let s show that the specific choice of a turn by Bob which of the strings to reverse does not affect Alice s strategy and therefore the answer to the problem Reversing the string does not change anything we are only interested in the parity of the number of reverses for both strings If Bob made an even number of moves in total then the parity of the number of moves made by Bob with string coincides with the parity of the number of moves made by Bob with string pairs of characters at the same indices after all reverses will be possibly in reverse order but it doesn t matter Here and are the original indices of the strings which do not change with reversing If Bob made an odd number of moves then exactly one of the strings will be reversed and the pairs of characters in the same indices will be or in reverse order That is the specific pairs of corresponding characters are determined only by the parity of the total number of moves made by Bob and it does not matter which specific moves were made Therefore Alice can choose one of two strategies Make and fix the end of the game when the number of moves made by Bob is even Make and fix the end of the game when the number of moves made by Bob is odd Let s count the number of indices where and differ and the number of indices where and differ For the first strategy Alice must make at least moves herself and it is also necessary that the number of moves made by Bob is even it is easy to see that for this strategy the game will last moves For the second strategy everything is roughly similar the game will last moves but the case needs to be handled separately And the answer to the problem will be the minimum of these two values Asymptotic "}
{"statement": "A binary string is a string where each character is either or Two binary strings a and b of equal length are if they have the same character in some position there exists an integer i such that a i b i For example and are they have the same character in position 4 and are and are and are not You are given an integer n and a binary string s consisting of 2n 1 characters Let s denote s l r as the contiguous substring of s starting with l th character and ending with r th character in other words s l r s l s l 1 s l 2 dots s r You have to construct a binary string w of length n which is to s 1 n s 2 n 1 s 3 n 2 s n 2n 1 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "We just need to make sure our string of characters matches each of the substrings in at least one spot The easiest way to do this is to take every other character from Code 90908018 Another fun solution we can generate random strings and check them until we find one that matches everything This works because the probability of failing to match any particular substring is so as gets bigger the probability of failing gets extremely low Code 90999219 "}
{"statement": "Burenka is the crown princess of Buryatia and soon she will become the n th queen of the country There is an ancient tradition in Buryatia before the coronation the ruler must show their strength to the inhabitants To determine the strength of the n th ruler the inhabitants of the country give them an array of a of exactly n numbers after which the ruler must turn all the elements of the array into zeros in the shortest time The ruler can do the following two step operation any number of times select two indices l and r so that 1 le l le r le n and a non negative integer x then for all l leq i leq r assign a i a i oplus x where oplus denotes the bitwise XOR operation It takes left lceil frac r l 1 2 right rceil seconds to do this operation where lceil y rceil denotes y rounded up to the nearest integer Help Burenka calculate how much time she will need ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "There is an answer where the time spent is minimal and the lengths of all the segments taken are 1 and 2 because of the segment l r x can be replaced to r l 12 of segments of length 2 and 1 or rather l l 1 x l 2 l 3 x r r x or r 1 r x if l r 1 even Note that if al al 1 ar 0 is executed for l r then we can fill the l r subsections with zeros for r l seconds with queries l l 1 al l 1 l 2 al al 1 r 1 r al al 1 ar Note that if a segment of length 2 intersects with a segment of length 1 they can be changed to 2 segments of length 1 It follows from all this that the answer consists of segments of length 1 and cover with segments of length 2 Then it is easy to see that the answer is n minus the maximum number of disjoint sub segments with a xor of 0 because in every sub segments with a xor of 0 we can spend 1 second less as I waited before this amount can be calculated by dynamic programming or greedily Our solution goes greedy with a set and if it finds two equal prefix xors prefixl prefixr means that al 1 al 2 ar 0 it clears the set 168724728 The complexity of the solution is O nlog n "}
{"statement": "You are given array a 1 a 2 ldots a n consisting of non negative integers Let s define operation of elimination with integer parameter k 1 leq k leq n as follows Choose k distinct array indices 1 leq i 1 i 2 ldots i k le n Calculate x a i 1 a i 2 ldots a i k where denotes the bitwise AND operation notes section contains formal definition Subtract x from each of a i 1 a i 2 ldots a i k all other elements remain untouched Find all possible values of k such that it s possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k It can be proven that exists at least one possible k for any array a Note that you ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s note that in one destruction for any bit we either change all th non zero bits into zero bits or nothing changes So the number of th non zero bits in the array either decreases by or doesn t change In the end all these numbers will be equal to So to be able to destruct the array the number of th non zero bits in the array should be divisible by for all bits Let s prove that it is enough to destruct the array Let s make operations with non zero AND while we can make them In the end there is at least one non zero element if we have not destructed the array So there is at least one bit for which the number of th non zero bits in the array is non zero so this number is at least because it is divisible by So we can select numbers with th non zero bit to the next operation and make the new destruction which is impossible So the resulting solution is for each bit let s find the number of array s elements with non zero th bit Let s find all common divisors of these numbers Time complexity is where upper limit on all numbers in the array "}
{"statement": "Valera loves segments He has recently come up with one interesting problem The axis of coordinates has segments the th segment starts in position and ends in position we will mark it as Your task is to process queries each consists of number and a set of coordinates of points located on the axis The answer to the query is the number of segments such that each of them contains at least one point from the query Segment point if Valera found the solution of this problem too difficult So he asked you to help him Help Valera ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Let s calculate sets all segments whose right borders are exactly equal to Now we reduce our task to another For each query we will count the number of segments that doesn t belong to any one point Let s it will be the value Then the answer to the query is We add to our request the point and a point where Let points request have the form Consider the and Let is the number of segments that lie strictly inside and Then We will use following algorithm to find the values Let consider all such pairs for all requests and to add them to a second set all pairs whose right boundary is equal to Then to find the values of pairs we will iterate ascending the right border Additionally we will support Fenwick s tree which can make at the point and can calculate sum of the prefix Let the current right border Then we can find out the value for all pairs with the right border is equal to the Let left border of the pair Then the answer for the pair is the value of where all added to the Fenwick s left borders and sum of the prefix After that for the current coordinate we need to consider all segments in the set Let left boundary of the segment Then we need to make at the point in our Fenwick s tree The total solution complexity is Authors solution 5306535 "}
{"statement": "The Fair Nut got stacked in planar world He should solve this task to get out You are given n rectangles with vertexes in 0 0 x i 0 x i y i 0 y i For each rectangle you are also given a number a i Choose some of them that the area of union minus sum of a i of the chosen ones is maximum It is guaranteed that there are no nested rectangles Nut has no idea how to find the answer so he asked for your help ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Let s order rectangles by so will be increasing If the is increasing is decreasing because there are no nested rectangles Then lets define as the maximum value which can be acheived by choosing some subset of first rectangles which contains the th rectangle It can be calculated by where is the previous chosen rectangle we subtract because it is common square of the subset for and th rectangle This formula can be optimized using convex hull trick and calculated in or in if rectangles are already sorted "}
{"statement": "Little Artem is a very smart programmer He knows many different difficult algorithms Recently he has mastered in one In computer science 2 satisfiability abbreviated as is the special case of the problem of determining whether a conjunction logical of disjunctions logical have a solution in which all disjunctions consist of no more than two arguments variables For the purpose of this problem we consider only formulas where each disjunction consists of exactly two arguments Consider the following problem as an example Note that there might be negations in formula like for and for Artem now tries to solve as many problems with as possible He found a very interesting one which he can not solve yet Of course he asks you to help him The problem is given two formulas and determine whether their sets of possible solutions are the same Otherwise find any variables assignment such that ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3000", "problem_editorial": "Let s build for both 2 SAT formulas implication graph and let s find strong connected components in this graph If both of the formulas are not satisfiable then the answer is SIMILAR If only one formula is not satisfiable then we can find an answer for the second one and output it Now let s assume both formulas are satisfiable Let s have a transitive closure for both of the graphs Let s call the variable X fixed in the formula F if there is a path x or x If there is a fixed variable in one formula but not fixed in the other or fixed but has other value we can find the solution for that second formula with opposite value of that fixed variable that will be an answer If we could not find these variables we can remove all of them There is no fixed variables in the rest of them Let s find an edge u v presented in one graph but not presented in the other Let s find the solution for formula without the edge with u 1 and v 0 we always can find it That is the answer "}
{"statement": "A boy Bob likes to draw Not long ago he bought a rectangular graph checked sheet with rows and columns Bob shaded some of the squares on the sheet Having seen his masterpiece he decided to share it with his elder brother who lives in Flatland Now Bob has to send his picture by post but because of the world economic crisis and high oil prices he wants to send his creation but to spend as little money as possible For each sent square of paper no matter whether it is shaded or not Bob has to pay 3 14 burles Please help Bob cut out of his masterpiece a rectangle of the minimum cost that will contain all the shaded squares The rectangle s sides should be parallel to the sheet s sides ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "To find the smallest rectangle containing the picture iterate through the pairs i j such that the j th symbol in i th line is find the minimum and maximum values of i and j from these pairs The rectangle to output is imin imax jmin jmax "}
{"statement": "Gerald has a friend Pollard Pollard is interested in lucky tickets ticket is a sequence of digits At first he thought that a ticket is lucky if between some its digits we can add arithmetic signs and brackets so that the result obtained by the arithmetic expression was number 100 But he quickly analyzed all such tickets and moved on to a more general question Now he explores lucky tickets Pollard sais that a ticket is lucky if we can add arithmetic operation signs between its digits to the left or right of them i e and brackets so as to obtain the correct arithmetic expression whose value would equal For example ticket 224201016 is 1000 lucky as Pollard was so carried away by the lucky tickets that he signed up for a seminar on lucky tickets and as far as Gerald knows Pollard will attend it daily at 7 pm in some famous institute and will commute to it in the same tram for days In this tram tickets have eight digits And Gerald wants to make a surprise for Pollard each day Pollard will receive a tram lucky ticket The conductor has already agreed to give Pollard certain tickets during all these days and he only wants Gerald to tell him what kind of tickets to give out In this regard help Gerald pick exactly distinct lucky tickets ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "In this problem we can find the right amount of lucky tickets Lets consider amount of different numbers we can get from one four digit ticket number It is easy to iterate all this tickets since it amount only It happened that we can get almost 60 numbers from ticket on the average Suppose we can get number from ticket It is clearly that either or If we can write eight digit ticket number who will have in the first four digits and in the last four digits It is clearly that such ticket is lucky This method allows us to get almost lucky tickets and it is enough "}
{"statement": "Ntarsis has come up with an array a of n non negative integers Call an array b of n integers if it satisfies the following n le b i le n b i ne 0 there are no two indices i j 1 le i j le n such that b i b j 0 for each 1 leq i leq n there are a i indices j 1 le j le n such that b i b j 0 where i and j are not necessarily distinct Given the array a Ntarsis wants you to construct some imbalanced array Help him solve this task or determine it is impossible ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "Analysis buffering nsqrtlog SolutionAt the start let be an index such that has the greatest absolute value If is negative we have and else Moreover we can t have for any indices and because that implies is both positive and negative contradiction Hence the necessary and sufficient condition to check if we can determine an element in array with maximum absolute value is there exists an element of array equal to xor there exists an element of array equal to Then we can remove that element and re calculate the array leading to an solution If the check fails at any moment there is no valid solution To optimize it further note that we can sort array at the start and keep track of them in a deque like structure We only need to check the front and end of the deque to see if our key condition holds Finally we can use a variable to record the number of positive elements deleted so far and subtract it from the front and end of the deque when checking our condition so that each check is The overall complexity becomes due to sorting "}
{"statement": "In some country live wizards They love to build cities and roads The country used to have cities the th city was located at a point It was decided to create another cities And the th one was created at a point with coordinates Here are primes Also After the construction of all cities the wizards have noticed something surprising It turned out that for every two different cities and and holds The cities are built it s time to build roads It was decided to use the most difficult and of course the most powerful spell for the construction of roads Using this spell creates a road between the towns of if and only if for any city which lies strictly inside the corner at the point see below there is a city that does not lie in the corner which is located along the coordinate strictly between and and simultaneously A on the points is the set of points for which at least one of the two conditions is fulfilled and and In order to test the spell the wizards will apply it to all the cities that lie on the coordinate in the interval After the construction of roads the national government wants to choose the maximum number of pairs of cities connected by the road so that no city occurs in two or more pairs Your task is for each offered variants of values to calculate the maximum number of such pairs after the construction of the roads Please note that the cities that do not lie in the interval on the coordinate do not affect the construction of roads in any way ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3000", "problem_editorial": "This was the first really hard problem in the contest One of the challenges was to understand the statement I hope that we had written the statement as clear as it possible in this problem Consider this graph In particular we consider more closely the point with the largest y 1 It is connected with the highest points on the left and right of it 2 It is not connected to all other points 3 It is inside all corners on points from different sides of it All three of these properties are seen quite clearly in the pictures So 1 Building roads on the left and right sides are independent 2 The graph is a tree Once a graph is a tree the maximum matching in it can be found greedy or with a simple dynamic But it works in linear time which clearly is not enough to answer all of queries But this is not just a tree Those who know what it is probably already noticed that it is Cartesian tree also known as treep This allows to get a tree for the subsegments in time which is counting all the necessary dynamics where h is the height of the tree Well since the city built at random points the method for the construction of cities guarantees this the height of the tree "}
{"statement": "Petya brought home string with the length of The string only consists of lucky digits The digits are numbered from the left to the right starting with Now Petya should execute queries of the following form switch digits i e replace them with their opposites at all positions with indexes from to inclusive each digit is replaced with and each digit is replaced with find and print on the screen the length of the longest non decreasing subsequence of string Subsequence of a string is a string that can be obtained from by removing zero or more of its elements A string is called non decreasing if each successive digit is not less than the previous one Help Petya process the requests ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "To solve this problem you need to handle segment tree with following information n4 number of 4 digits in node range n7 number of 7 digits in node range n47 maximum non decreasing subsequence in range n74 maximum non increasing subsequence in range When we reverse digits in some node we just swap n4 n7 swap n47 n74 When we update node we keep n4 father n4 left son n4 right son n47 father max n47 left son n7 right son n4 left son n47 right son n4 left son n7 right son Then for each count query result is n47 "}
{"statement": "A is a string that reads the same backward as forward For example the strings texttt z texttt aaa texttt aba and texttt abccba are palindromes but texttt codeforces and texttt ab are not The of a string s is obtained by writing each character twice For example the double of texttt seeing is texttt sseeeeiinngg Given a string s rearrange its double to form a palindrome Output the rearranged string It can be proven that such a rearrangement always exists ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Output It works since each character in occurs exactly twice once in once in and the result is a palindrome "}
{"statement": "Berland National Library has recently been built in the capital of Berland In addition in the library you can take any of the collected works of Berland leaders the library has a Today was the pilot launch of an automated reading room visitors accounting system The scanner of the system is installed at the entrance to the reading room It records the events of the form reader entered room reader left room Every reader is assigned a during the registration procedure at the library it s a unique integer from to Thus the system logs events of two forms the reader with registration number entered the room the reader with registration number left the room The first launch of the system was a success it functioned for some period of time and at the time of its launch and at the time of its shutdown the reading room may already have visitors Significant funds of the budget of Berland have been spent on the design and installation of the system Therefore some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring Now the developers of the system need to urgently come up with reasons for its existence Help the system developers to find the minimum possible capacity of the reading room in visitors using the log of the system available to you ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "To answer the queries correct we need to know if the person is still in the library For that purpose we will use array of type Also we will store two variables for the answer and current state it will store the current number of people in the library Let s call them and respectively Thus if we are given query then we should increase by one mark that this person entered the library and try to update the answer Otherwise we are given query If the person who leaves the library was in there we should just decrease by one Otherwise if this person was not in the library and leaves now he entered the library before we started counting It means we should increase the answer by one anyway Also one should not forget that it is needed to mark that the person has left the library Author solution "}
{"statement": "To quickly hire highly skilled specialists one of the new IT City companies made an unprecedented move Every employee was granted a car and an employee can choose one of four different car makes The parking lot before the office consists of one line of parking spaces Unfortunately the total number of cars is greater than the parking lot capacity Furthermore even amount of cars of each make is greater than the amount of parking spaces That s why there are no free spaces on the parking lot ever Looking on the straight line of cars the company CEO thought that parking lot would be more beautiful if it contained exactly successive cars of the same make Help the CEO determine the number of ways to fill the parking lot this way ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "There are the following ways to place n cars of the same make They can be the first n the last n or they can be somewhere in the middle of the parking lot When n cars of the same make are the first or the last there are 4 ways to choose the make of these n cars then there are 3 ways to choose the make of one car adjacent to them the make should be different from the make of n cars and there are 4 ways to choose the make of each of the remaining n 3 cars So the formula for the case of n cars of the same make on either end of the parking lot is 4 3 4n 3 When n cars of the same make are situated somewhere in the middle there are 4 ways to choose the make of these n cars then there are 3 ways to choose the make of each of two cars adjacent to them the makes of these two cars should be different from the make of n cars and there are 4 ways to choose the make of each of the remaining n 4 cars So the formula for the case of n cars of the same make on a given position somewhere in the middle of the parking lot is 4 32 4n 4 There are 2 positions of n cars of the same make in the end of the parking lot and there are n 3 positions of n cars of the same make somewhere in the middle of the parking lot So the final formula is 2 4 3 4n 3 n 3 4 32 4n 4 "}
{"statement": "Ayrat is looking for the perfect code He decided to start his search from an infinite field tiled by hexagons For convenience the coordinate system is introduced take a look at the picture to see how the coordinates of hexagon are defined Ayrat is searching through the field He started at point and is moving along the spiral see second picture Sometimes he forgets where he is now Help Ayrat determine his location after moves ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s see how the coordinates are changing while we move from current cell to one of the 6 adjacent cells let s call this 6 typed of moves If we know the number of moves of each type on our way then we know the coordinates of the end of the way We will divide the way into rings Let s count the number of moves of each type for the first ring Next ring will have one more move of each type Length of each ring length of previous 6 It is an arithmetic progression Using well known formulas and binary search we calculate the number of the last ring and overall length of previous rings Now we have to brute force 6 types of the last move and calculate the answer code 15260879 "}
{"statement": "DZY has chemicals and pairs of them will react He wants to pour these chemicals into a test tube and he needs to pour them in one by one in any order Let s consider the danger of a test tube Danger of an empty test tube is And every time when DZY pours a chemical if there are already one or more chemicals in the test tube that can react with it the danger of the test tube will be multiplied by Otherwise the danger remains as it is Find the maximum possible danger after pouring all the chemicals one by one in optimal order ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "It s easy to find that answer is equal to where is the number of connected components check the C code here "}
{"statement": "Qingshan and Daniel are going to play a card game But it will be so boring if only two persons play this So they will make n robots in total to play this game automatically Robots made by Qingshan belong to the team 1 and robots made by Daniel belong to the team 2 Robot i belongs to team t i Before the game starts a i cards are given for robot i The rules for this card game are simple Before the start the robots are arranged in a circle in the order or their indices The robots will discard cards in some order in each step one robot discards a single card When the game starts robot 1 will discard one of its cards After that robots will follow the following rules If robot i discards the card last the nearest robot whose team is opposite from i s will discard the card next In another word j will discard a card right after i if and only if among all j that satisfy t i ne t j dist i j definition is below is minimum The robot who has no cards should quit the game immediately This robot won t be considered in the next steps When no robot can discard the card next the game ends We define the distance from robot x to robot y as dist x y y x n bmod n It is similar to the oriented distance on the circle For example when n 5 the distance from 1 to 3 is dist 1 3 3 1 5 bmod 5 2 the distance from 3 to 1 is dist 3 1 1 3 5 bmod 5 3 Later Qingshan finds out that it will take so much time to see how robots play She wants to know the result as quickly as possible You as Qingshan s fan are asked to calculate an array ans 1 ans 2 ldots ans n ans i is equal to the number of cards that i th robot will discard during the game You need to hurry To avoid the large size of the input the team and the number of cards of each robot will be generated in your code with some auxiliary arrays ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3200", "problem_editorial": "We can consider that the robots are standing on a cycle The game ends up with at least one team having no cards Let the team having no cards in the end be team and let the other be team If two teams both use up their cards the first robot s team is For team we ve already known how many cards will its robots discard because they will discard all their cards But how to calculate the answer for team Let s look at the process of the game Obviously robots in and robots in will discard cards alternatively In another word if we write down the team of robots who discard cards in time order it will form a sequence or For the second type starting with we can just use brute force to discard the first card and then find the next So there is only one circumstance Note that in the sequence every is followed by exactly one So the length of the sequence is the number of cards of team multiplying Currently we are not able to figure out which robot is exactly represented by a particular or in the sequence Luckily we don t need to know it What we care about is only how many cards the robot in team discards You can consider every is the sequence as a query and change operation In the current game some robot in team will find the first robot in team on its right and change to It s a very important limit here because some robot will quit the game halfway according to the statement But on the contrary an interesting fact is that the important limit is not important at all We can make the query and the change in any order and it won t change the answer So you just need to iterate the array and maintain a variable the number of operations that are visited but not performed If the team of the current robot is assign to Otherwise you can perform operations now and assign to Since robots are standing on a cycle you need to iterate the array times So the time complexity is "}
{"statement": "Monocarp and Bicarp live in Berland where every bus ticket consists of n digits n is an even number During the evening walk Monocarp and Bicarp found a ticket where some of the digits have been erased Monocarp and Bicarp have decided to play a game with this ticket Monocarp hates happy tickets while Bicarp collects them A ticket is considered happy if the sum of the first frac n 2 digits of this ticket is equal to the sum of the last frac n 2 digits Monocarp and Bicarp take turns and Monocarp performs the first of them During each turn the current player must replace any erased digit with any digit from 0 to 9 The game ends when there are no erased digits in the ticket If the ticket is happy after all erased digits are replaced with decimal digits then Bicarp wins Otherwise Monocarp wins You have to determine who will win if both players play optimally ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s denote the balance as the difference between the sum of digits in the left half and the sum of digits in the right half Also let be the minimum possible balance it can be calculated if we replace all question marks in the left half with s and all the question marks in the right half with s and let be the maximum possible balance The second player wins if and only if Let s prove it by induction on the number of question marks left in the ticket If all characters are digits the second player wins only if the ticket is happy and that is when Okay now suppose the number of question marks is even and now it s first player s turn Each turn decreases the value of by and may set to any number from current to If then the first player can make as large as possible and set it to The best thing the second player can do on his turn is to set to and leave as it is and the value of will be the same as it was two turns earlier The case can be analyzed similarly And in the case the second player has a symmetric strategy "}
{"statement": "You are given an integer k and n distinct points with integer coordinates on the Euclidean plane the i th point has coordinates x i y i Consider a list of all the frac n n 1 2 pairs of points x i y i x j y j 1 le i j le n For every such pair write out the distance from the line through these two points to the origin 0 0 Your goal is to calculate the k th smallest number among these distances ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3200", "problem_editorial": "Stupid hintBinary search is your friend To determine if the answer is bigger or smaller than we need to count the number of pairs of points such that "}
{"statement": "Given a tree with n nodes numbered from 1 to n Each node i has an associated value V i If the simple path from u 1 to u m consists of m nodes namely u 1 rightarrow u 2 rightarrow u 3 rightarrow dots u m 1 rightarrow u m then its alternating function A u 1 u m is defined as A u 1 u m sum limits i 1 m 1 i 1 cdot V u i A path can also have 0 edges i e u 1 u m Compute the sum of alternating functions of all unique simple paths Note that the paths are directed two paths are considered different if the starting vertices differ or the ending vertices differ The answer may be large so compute it modulo 10 9 7 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "An important observation for the question is if there are even number of nodes on the simple path from to if there are odd number of nodes on the simple path from to Hence for paths with even number of nodes Hence the task has been reduced to finding the total sum of alternating function of paths with odd number of nodes Also we can make use of the fact that but this does not hold true when hence we must handle this case by subtracting from the final answer Now with the help of a single dfs we can calculate the number of paths in the subtree of with odd number of nodes ending at node the number of paths in the subtree of with even number of nodes ending at node In the first part of the solution for each node we calculate its contribution to the alternating function for paths passing through this node but strictly lying within its subtree For doing this we can merge two paths with either both having even or both having odd number of nodes ending at its children to create odd length paths For the case where both the paths have even number of nodes the current node s contribution to the summation is because its position in the sequence of nodes is odd Similarly we add for the other case This can be done using a single dfs in time as we have and for all the nodes Now for the second part of the question we have to consider the paths which end up outside the subtree We have the information and We have to merge these paths with those ending at How do we get this information Note that and just represent paths strictly lying within the subtree of but not the entire tree An important observation for this computation is If node has a total of odd and even length paths ending at it then if is the neighbour of then has a total of odd and even length paths ending at it It is fairly simple to observe We know and and since the subtree of is the entire tree we can use these values for our requirement Now let s represent the total number of odd and even length paths ending at by and respectively From our previous observation if is odd number of nodes away from the node if is even number of nodes away from the node The number of paths ending at but lying strictly outside the subtree of can be calculated odd length paths even length paths Now we have to construct odd length paths by merging paths in the subtree of ending at node with paths ending at but strictly lying outside the subtree of For paths with odd length component ending at we must add to the summation and otherwise Finally the summation of contributions of each node yields you the total summation of alternating functions for all pair of nodes This can be done for each node in time The overall time complexity of the solution is "}
{"statement": "Consider a segment 0 d of the coordinate line There are n lanterns and m points of interest in this segment For each lantern you can choose its power an integer between 0 and d inclusive A lantern with coordinate x illuminates the point of interest with coordinate y if x y is less than or equal to the power of the lantern A way to choose the power values for all lanterns is considered if every point of interest is illuminated by at least one lantern You have to process q queries Each query is represented by one integer f i To answer the i th query you have to add a lantern on coordinate f i calculate the number of valid ways to assign power values to all lanterns and print it modulo 998244353 remove the lantern you just added ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Let s start without the queries How to calculate the number of ways for the given lanterns First it s much easier to calculate the number of bad ways some point of interest is not illuminated If at least one point of interest is not illuminated then all lanterns have power lower than the distance from them to this point of interest More importantly it s less than Thus the number of good ways is minus the number of bad ways Let s use inclusion exclusion For a mask of non illuminated points of interest let s calculate the number of ways to assign the powers to the lanterns in such a way that at least these points of interest are not illuminated All other points can be either illuminated or not Let s call it With the values for all masks the answer is the sum of over all masks How to calculate the value for the mask First let s do it in for each mask Each lantern can have any power from to the distance to the closest point of interest inside the mask non inclusive Thus we can iterate over the lanterns and find the closest point to each of them then multiply the number of ways for all lanterns Let s calculate it the other way around Initialize the answers for the masks with Then iterate over the lantern and the point of interest that will be the closest non illuminated one to this lantern Let the distance between them be some value Which masks will this pair affect Let the lantern be to the right of that point of interest The opposite can be handled similarly All points to the left of the chosen point can be in either state All points between the chosen one and the lantern must be illuminated All points to the right of the lantern and with distance smaller than must also be illumunated All point to the right of these can be in either state Thus the masks look like 1000 000 where 1 denotes the chosen non illuminated point All masks that correspond to this template will be multiplied by You have to be careful when there are two points of interest with the same distance to some lantern one to the left of it and one to the right of it In particular in one case you should force illumination on all points with distance In another case you should force illumination on all points with distance How to multiply fast enough We ll use a technique called sum over subsets Let s express the template in terms of submasks For a template 100000 all submasks of 111100000111 will be multiplied by However we accidentally multiplied masks of form 000000 too Let s cancel them by dividing the submasks of 111000000111 by Record all multiplications for all pairs them force push them into submasks with sum over subsets well product over subsets in this case Now we have the values of for all masks in basically give or take the time to find the points that must be forced illuminated extra from lower bound or two pointers which is not really faster Now for the queries How does the answer change after an extra lantern is added Again let s iterate over the closest point of interest and find the mask template All masks corresponding to this template will get multiplied by Thus the answer will change by the sum of values of these masks multiplied by including the inclusion exclusion coefficient How to handle that Well yet another sum over subsets Just collect the sum of values over the submasks beforehand and use these during the query That gives us an per query Overall complexity "}
{"statement": "A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array For a positive integer n we call a permutation p of length n if the following condition holds for every pair i and j 1 le i le j le n p i text OR p i 1 text OR ldots text OR p j 1 text OR p j ge j i 1 where text OR denotes the bitwise OR operation In other words a permutation p is if for every subarray of p the text OR of all elements in it is not less than the number of elements in that subarray Given a positive integer n output any permutation of length n We can show that for the given constraints such a permutation always exists ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Every permutation is good Proof We use the fact that for any set of numbers it s bitwise OR is at least the maximum value in it Now we just need to show that any subarray of length has at least one element greater than or equal to If the maximum element is then we have elements all with values in the range By the pigeonhole principle at least of them must be the same contradicting the fact the it s a permutation Time Complexity "}
{"statement": "A positive integer a is given Baron Munchausen claims that he knows such a positive integer n that if one multiplies n by a the sum of its digits decreases a times In other words S an S n a where S x denotes the sum of digits of the number x Find out if what Baron told can be true ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Define the of a number as By the balance of a digit string we mean the balance of the corresponding number We are gonna do the following Find out if the solution exists If no print and exit Find any string with negative balance Find any string with positive balance Take their linear combination with zero balance maybe we pad the numbers we found by leading zeroes before this By linear combination of several strings we mean their concatenation where each of them can occur several times It is quite clear how to perform the last step To perform the initial step it s convenient to introduce some lemmas It s obvious more or less since if we write both numbers one under another and start calculating their sum then the result will have sum of digits being equal to minus times the number of carries Here the inequality holds according to Lemma 1 Let Then Now consider two cases Let One can see thatThat means that if then the answer doesn t exist otherwise the number has non positive balance One can easily see that the number always has non negative balance so in this case the problem is solved has a prime divisor which is not and not It turns out that in this case the answer always exists Indeed the decimal fraction is infinite that means that in nondecreasing and can be sufficiently large and so can be since the number of trailing s of is bounded Meanwhile is bounded by say so we always can find a string with negative balance and as we mentioned above the number always has nonnegative balance We know two ways to perform the second step Divide by and find the period Let s say that the period can be represented as a string and the part before it by a string possibly empty Let have the same length as and equal when being treated as an integer We are looking for a string of type with negative balance One can calculate the impact on balance of strings and and therefore find the minimal required number of stings Construct a weighted directed graph Its vertices are numbers from to and for each pair of numbers with and there is an edge from to with weight and label Informally if we traverse through some path from and labels of the edges on this path are digits of some number from right to left then the sum of weights are the current balance of that is if we consider only last digits when calculating the balance and the last vertex represents the current carry Now we can find a negative cycle in this graph via Ford Bellman algorithm and then construct a path from to this cycle go through the cycle required number of times so that the final sum of weights is negative and then return to the zero vertex This solution has a disadvantage the final answer can have a length up to One workaround is to find say different possibilities of negative balance by taking more periods negative cycles and find the positive balance string by trying all numbers from to and constructing a string with a small balance divisible by any of negative balances It can be done by a sort of knapsack on found positive balances The idea is to get a big gcd of the two found balances so that we don t need to repeat the negative balance string too many times because among the two found strings it is the one which can have a superlinear length Imagine we have infinite time and memory Then we can say that we have states of kind similar to the states of the graph from solution 1 where for each state and each digit except state and digit at the same time there is a transition to Our goal is to reach again One can bfs over this infinite graph with creating new states when needed However traversing over this graph consume too much memory It turns out that if we don t consider states with then there always is a solution and this is relatively easy to come up with and definitely easier to pass than the previous one "}
{"statement": "There are n piles of sand where the i th pile has a i blocks of sand The i th pile is called if 1 i n and a i a i 1 a i 1 That is a pile is too tall if it has more sand than its two neighbours combined Note that piles on the ends of the array cannot be too tall You are given an integer k An operation consists of picking k consecutive piles of sand and adding one unit of sand to them all Formally pick 1 leq l r leq n such that r l 1 k Then for all l leq i leq r update a i gets a i 1 What is the number of piles that can simultaneously be too tall after some possibly zero operations ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Note that two piles in a row can t be too tall since a pile that is too tall has strictly more sand than its neighbours If then we can make every other pile too tall excluding the ends of the array For example if we can make piles and too tall by performing some large number of operations on them say by making it into The answer is If then note that for any pile if we perform the operation on it then we perform on one of its neighbours as well Therefore if the pile is not too tall initially then it will never become too tall as a result of these operations since both a pile and at least one of its neighbours will gain sand So in this case doing operations never improves the answer and so the answer is the number of too tall piles initially The time complexity is "}
{"statement": "As for the technology in the outside world it is really too advanced for Gensokyo to even look up to Yasaka Kanako Under the direct supervision of Kanako and the Moriya Shrine the railway system of Gensokyo is finally finished GSKR Gensokyo Railways consists of n stations with m bidirectional tracks connecting them The i th track has length l i 1 le l i le 10 6 Due to budget limits the railway system though there may be more than one track between two stations The of a railway system is defined as the total length of its all tracks The of a railway system is defined as the maximum or minimum value among all of the currently functional system s full spanning forest In brief full spanning forest of a graph is a spanning forest with the same connectivity as the given graph Kanako has a simulator only able to process no more than 2m queries The input of the simulator is a string s of length m consisting of characters and or The simulator will assume the i th track functional if s i The device will then tell Kanako the maximum capacity of the system in the simulated state Kanako wants to know the the minimum capacity of the system with all tracks functional with the help of the simulator The structure of the railway system is fixed in advance In other words the interactor is not adaptive ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 1, "problem_dificulty": "1700", "problem_editorial": "Solution We can get the lengths of each edge using queries by asking the maximum capacity of each edge separately Then sort the edges in non decreasing order represented by and ask the maximum capacity of all prefixes represented by using the rest queries Consider the process of Kruskal s algorithm The th edge being in the minimum full spanning forest is equivalent to there being no path between and in the graph consisting of former edges which is equivalent to Then we know whether each edge exists in the minimum full spanning forest The time complexity is "}
{"statement": "You are given an grid some of its nodes are black the others are white Moreover it s not an ordinary grid each unit square of the grid has painted diagonals The figure below is an example of such grid of size Four nodes of this grid are black the other nodes are white Your task is to count the number of such triangles on the given grid that the corners match the white nodes and the area is positive all sides go along the grid lines horizontal vertical or diagonal no side contains black nodes ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Values and are not so large so the solution with complexity should pass It means that you should consider all triangles and check all conditions in To make this check you should precalc arrays of partial sums on all diagonals rows and columns After that you could check that there is no black nodes on the side using one sum query Some hints about this problem and the implementation "}
{"statement": "You are a game designer and want to make an obstacle course The player will walk from left to right You have n heights of mountains already selected and want to arrange them so that the absolute difference of the heights of the first and last mountains is as small as possible In addition you want to make the game difficult and since walking uphill or flat is harder than walking downhill the difficulty of the level will be the number of mountains i 1 leq i n such that h i leq h i 1 where h i is the height of the i th mountain You don t want to waste any of the mountains you modelled so you have to use all of them From all the arrangements that minimize h 1 h n find one that is the most difficult If there are multiple orders that satisfy these requirements you may find any ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "We claim that the maximum difficulty is at least Assume the array is sorted We first need to find the two mountains which go on the ends To do this we can iterate through every mountain in the sorted array and check the difference between a mountain and its neighbours in the array Let and be the mountains with the smallest height difference We can achieve at least a difficulty of by arranging the mountains as To get difficulty we need to be the shortest mountain and to be the tallest mountain This will only happen if "}
{"statement": "Mehrdad wants to become minister of Arpa s land Arpa has prepared an exam Exam has only one question given print the last digit of Mehrdad has become quite confused and wants you to help him Please help although it s a naive cheat ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "You know If answer is 1 otherwise you can prove with induction that if then answer is 6 then answer is 8 then answer is 4 then answer is 2 Time complexity Corner case Solutions that forget to add case got failed system testing "}
{"statement": "Now elections are held in Berland and you want to win them More precisely you want everyone to vote for you There are n voters and two ways to convince each of them to vote for you The first way to convince the i th voter is to pay him p i coins The second way is to make m i other voters vote for you and the i th voter will vote for free Moreover the process of such voting takes place in several steps For example if there are five voters with m 1 1 m 2 2 m 3 2 m 4 4 m 5 5 then you can buy the vote of the fifth voter and eventually everyone will vote for you Set of people voting for you will change as follows 5 rightarrow 1 5 rightarrow 1 2 3 5 rightarrow 1 2 3 4 5 Calculate the minimum number of coins you have to spend so that everyone votes for you ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Denote the number of voters with as Also denote i e is equal to number of voters with Let s group all voters by value We ll consider all these group in decreasing value of Assume that now we consider group with Then there are two cases if then all these voters will vote for you for free is equal to the number of votes bought in previous steps if then we have to buy additional votes Moreover the value of this bought voter must be greater than or equal to Since these voters indistinguishable we have to buy cheapest voter with a minimal value of So all we have to do it maintain values not yet bought voters in some data structure for example in "}
{"statement": "You are given a rooted tree consisting of n vertices The vertices are numbered from 1 to n the root is the vertex 1 You can perform the following operation k times choose an edge v u of the tree such that v is a parent of u remove the edge v u add an edge 1 u i e make u with its subtree a child of the root of a tree is the maximum depth of its vertices and the depth of a vertex is the number of edges on the path from the root to it For example the depth of vertex 1 is 0 since it s the root and the depth of all its children is 1 What s the smallest height of the tree that can be achieved ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 1, "problem_dificulty": "1900", "problem_editorial": "Start with the following Let s look at the input format and consider what the operation actually does to it Since it only changes the parent of some vertex it modifies only one value in it Moreover it just assigns it to Thus the goal is to assign at most values of parents to to minimize the resulting height of the tree In particular that implies that we can freely rearrange the operations since the assignments don t depend on each other One more conclusion Imagine we have already built some answer One by one we moved some subtrees to be children of the root It could happen that we first moved some subtree of a vertex and then applied the operation to an edge inside the subtree of Let s show that it s always possible to rearrange the operations in the answer to avoid that Just apply the operations in order of decreasing the depth of the vertex If we knew what height we want to get we could have been making sure that cut subtree has height at most since it gets increased by when glueing it to the root then pretending that that subtree doesn t exist anymore Moreover it s always required to cut subtrees with height at most If you cut a higher subtree then the answer can t be smaller than since we rearranged the operation to not touch that subtree anymore Well let s fix that height if we wanted that Let s try the solve the opposite problem How many operations will it require to make the tree height at most Obviously the values for this problem are non increasing the greater we allow the height to be the less operations it will require Thus we will be able to apply binary search to it to find the smallest height we can achieve with at most operations Now we want to be choosing the subtrees of height at most repeatedly and cutting them off until the height of the tree becomes at most Let s think greedily If the height of the tree is not at most yet then there exists a vertex with the depth greater than Let s look at the deepest of them That leaf has to be cut in some subtree Otherwise the tree won t become any less higher What subtree is the best for it What options do we have That vertex itself and all its parents up until above It s always optimal to cut the highest of them the st parent since it will remove at least all the vertices of any other cut and some other vertices along with them It s also always possible to remove the st parent since it will always have height exactly The vertex we are looking at is the deepest in the entire tree there are no deeper vertices in the subtree of the st parent Thus the strategy is to keep cutting the st parent of the deepest vertex until the tree becomes at most height Now about the implementation details First we can process the vertices from the deepest upwards in their order in the original tree The operation only removes some vertices but doesn t change the depth of the remaining ones For example you can do a bfs from the root to find the order Now the st parent Let s find it for each vertex before starting the process Run a dfs and maintain the stack of the ascendants When going down the child append it to the stack What exiting pop from the stack Now you can just look at the st element from the top of the stack To be able to do that simulate the stack with a vector C or a list Python Finally we would have to determine if the current vertex in the order is removed or not For that we could maintain a boolean array for the removed vertices Once you apply the operation run the dfs from the removed vertex and mark all the newly removed descendants of it in If you don t go into already marked vertices there will be no more than calls of the dfs The number of cut vertices is the answer for the fixed height Overall complexity per testcase "}
{"statement": "You are given a problemset consisting of n problems The difficulty of the i th problem is a i It is guaranteed that all difficulties are distinct and are given in the increasing order You have to assemble the contest which consists of some problems of the given problemset In other words There is only one condition that should be satisfied for each problem but the hardest one the problem with the maximum difficulty there should be a problem with the difficulty greater than the difficulty of this problem but not greater than twice the difficulty of this problem In other words let a i 1 a i 2 dots a i p be the difficulties of the selected problems in increasing order Then for each j from 1 to p 1 a i j 1 le a i j cdot 2 should hold Among all contests satisfying the condition above you have to assemble one with the maximum number of problems Your task is to find this number of problems ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "The answer is always a segment of the initial array The authors solution uses two pointers technique let s iterate over all left bounds of the correct contests and try to search maximum by inclusion correct contest Let s iterate over all from to and let the current left bound be Let be the maximum right bound of the correct contest starting from the position Initially Now while and let s increase Try to update the answer with the value It is obvious that all positions from to cannot be left bounds of the maximum by inclusion correct contests so let s set and go on Because each element will be processed once time complexity is "}
{"statement": "Consider the points 0 1 dots n 1 on the number line There is a teleporter located on each of the points 1 2 dots n At point i you can do the following Move left one unit it costs 1 coin Move right one unit it costs 1 coin Use a teleporter at point i if it exists it costs a i coins As a result you can choose whether to teleport to point 0 or point n 1 Once you use a teleporter you use it again You have c coins and you start at point 0 What s the most number of teleporters you can use ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Please also refer to the tutorial for the easy version If we are not at the first taken portal the problem is still independent for each portal but this time the cost of a portal is since we can come to a portal either from point or point So we again sort the portals by their costs But this time we need to make sure that the first taken portal is taken from point so we will iterate over all portals and check the maximum amount of portals we can take if we use it as the first one We can check this using prefix sums over the minimum cost array and binary searching checking if the amount of considered portals taken doesn t exceed the number of coins we initially have we also have to deal with the case when the portal we are considering is included both times as the initial portal and in the minimum cost prefix "}
{"statement": "Thor is getting used to the Earth As a gift Loki gave him a smartphone There are applications on this phone Thor is fascinated by this phone He has only one minor issue he can t count the number of unread notifications generated by those applications maybe Loki put a curse on it so he can t events are about to happen in chronological order They are of three types Application generates a notification this new notification is unread Thor reads all notifications generated so far by application he may re read some notifications Thor reads the first notifications generated by phone applications notifications generated in first events of the first type It s guaranteed that there were at least events of the first type before this event Please note that he doesn t read first unread notifications he just reads the very first notifications generated on his phone and he may re read some of them in this operation Please help Thor and tell him the number of unread notifications after each event You may assume that initially there are no notifications in the phone ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Consider a queue e for every application and also a queue Q for the notification bar When an event of the first type happens increase the number of unread notifications by 1 and push pair i x to Q where i is the index of this event among events of the first type and also push number i to queue e x When a second type event happens mark all numbers in queue e x and clear this queue also decreese the number of unread notifications by the number of elements in this queue before clearing "}
{"statement": "One day little Vasya found himself in a maze consisting of rooms numbered from to Initially Vasya is at the first room and to get out of the maze he needs to get to the th one The maze is organized as follows Each room of the maze has two one way portals Let s consider room number someone can use the first portal to move from it to room number also someone can use the second portal to move from it to room number where In order not to get lost Vasya decided to act as follows Each time Vasya enters some room he paints a cross on its ceiling Initially Vasya paints a cross at the ceiling of room Let s assume that Vasya is in room and has already painted a cross on its ceiling Then if the ceiling now contains an odd number of crosses Vasya uses the second portal it leads to room otherwise Vasya uses the first portal Help Vasya determine the number of times he needs to use portals to get to room in the end ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "In this problem you had to simulate route of character in graph Note that if you are in vertice then edges in all vertices with numbers less than are turned to It gives us opportunity to see a recurrence formula let be number of steps needed to get from vertice to vertice if all edges are rotated back into Then Answer will be BONUS Can you solve this task without statement I don t know the solution it seems difficult "}
{"statement": "There is a pool of length l where n swimmers plan to swim People start swimming at the same time at the time moment 0 but you can assume that they take different lanes so they don t interfere with each other Each person swims along the following route they start at point 0 and swim to point l with constant speed which is equal to v i units per second for the i th swimmer After reaching the point l the swimmer instantly in negligible time turns back and starts swimming to the point 0 with the same constant speed After returning to the point 0 the swimmer starts swimming to the point l and so on Let s say that some moment of time is a if there are swimmers that are in the same point of the pool at that moment of time that point may be 0 or l as well as any other real point inside the pool The pool will be open for t seconds You have to calculate the number of meeting moments while the pool is open Since the answer may be very large print it modulo 10 9 7 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Firstly note that there are two different situations when some two swimmers meet they either move in the same direction or in opposite directions Suppose swimmers and meet while moving in the same direction We can write some easy system of equation and get that they will meet each seconds Analogically if they meet while moving in the opposite directions they will meet each seconds Let s create array that will contain all possible values exactly once If then values and we can calculate all of them using FFT fast multiplication two times for sums and for differences Okay we got all possible how to calculate the answer For a fixed value meeting moments are for all in segment is the upper bound and can be calculated as We found that for each there are exactly meeting points but since in one meeting moment more than two swimmers may meet we need to calculate each value exactly once Note that iff And we can rephrase our task as following calculate the number of unique fractions where The key idea here is to calculate only irreducible fractions Suppose we have fractions Let s add to the answer only irreducible fractions among them we will discuss how to do it later For any other fraction and is a divisor of If we fix some divisor of there will be exactly fractions with Moreover numerators will also form a segment So instead of calculating them now we will just pass that task to In total we iterate in decreasing order add only the number of irreducible fractions to the answer Then iterate over all divisors of and update value for with value How to calculate the number of irreducible fractions with With M bius function of course since for each divisor of there are exactly fractions where by Both passing calculations and M bius inversion works in And since we iterate over all the total complexity is Both FFT and next part works in so the total complexity is P S If you note that if then is always equal to then you can not only simplify the part with passing down calculations but get rid of M bius inversion at all replacing it with Sieve like two for s iterations "}
{"statement": "You are given a string s made up of characters texttt A and texttt B Initially you have no coins You can perform two types of operations Pick a substring dagger texttt AB change it to texttt BC and get a coin Pick a substring dagger texttt BA change it to texttt CB and get a coin What is the most number of coins you can obtain dagger A of length 2 is a sequence of two adjacent characters of a string ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Before we get into the editorial I want to make a note that this type of problem is not traditional for Div 4 on purpose and is a lot more ad hoc than usual My goal was to make a sort of introductory ad hoc problem and I hope you enjoyed it The editorial is a bit long mainly because I want to go into a lot of detail regarding how to approach such ad hoc problems since usually most Div 4 problems are unlike this and instead focused on noticing and implementing the correct algorithm I don t think anyone solving the problem will actually go through all this detail explicitly but I wanted to provide a very explicit walk through for anyone not knowing how to start But I think ad hoc skills are important for Codeforces especially hence this problem Maybe you ll see more soon Let s think about how we can repeatedly use the operations first If we have a string then we can do the operations Similarly if we have a string then we can do the operations In a sense it s useful to think of the as eating the s in a sense whenever a is next to an it eats covers it and eats it and then it moves on Note that cannot eat s Let s replace the characters as follows replace with and with Then it s much clear what is going on Here is a series of moves on the string which becomes after the replacing Now you can see how each is eating all the dots in one direction it can t travel over blank spaces represented by Okay we have this intuition how to solve the problem now We need to eat the maximum number of dots s in the original string since s cannot eat anything else Note that for each it can eat all the s to its left or to its right but one it leaves its original spot it is stuck on that side but the cannot reach the rightmost dot ever This small example actually gives us a clue for each let s count the number of s on either side and pick the largest one This might work but note that multiple s may be able to reach the same dot This is where our original string comes into play Suppose our original string starts with so it must be of the form Then each can simply eat all the s after it and so our answer is just the total number of s Similarly if our string ends with then it must be of the form Then each can simply eat all the s before it and so our answer is just the total number of s So we only have to look at the case where our string starts and ends with meaning our string looks something like If any of the s are next to each other like then note that we can split the string into two strings both of which either start or end with and so we can eat all the s So in this case too it is possible to get all the s What s the only other case Start and end with and there are no two s next to each other In this case you can see there is one more group of s than there are s but each can only get one group of s So we won t be able to get all of them What s the best we can do Note that each can only get one group if it goes left or right so we can get all s except one group Now the answer is simply greedy it is the total number of s minus the smallest group since we want to get the most number of coins we will take groups as large as possible You can also envision this as a sort of greedy each takes the largest group available and we stop once no more s are free The time complexity for finding groups is so the whole solution runs in that time as well "}
{"statement": "We guessed a permutation p consisting of n integers The permutation of length n is the array of length n where each element from 1 to n appears exactly once This permutation is a secret for you For each position r from 2 to n we chose some other index l l r and gave you the segment p l p l 1 dots p r in order i e we rearranged the elements of this segment in a way that the elements of this segment are sorted Thus you are given exactly n 1 segments of the initial permutation but elements inside each segment are sorted The segments are given to you in random order For example if the secret permutation is p 3 1 4 6 2 5 then the possible given set of segments can be 2 5 6 4 6 1 3 4 1 3 1 2 4 6 Your task is to find suitable permutation i e any permutation corresponding to the given input data It is guaranteed that the input data corresponds to some permutation i e such permutation exists You have to answer t independent test cases ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Let s fix the first element and then try to restore permutation using this information One interesting fact if such permutation exists with this first element then it can be restored uniquely Let s remove the first element from all segments containing it we can use some logarithmic data structure for it Then we just have a smaller problem but with one important condition there is a segment consisting of one element again if such permutation exists So if the number of segments of length is zero or more than one by some reason then there is no answer for this first element Otherwise let s place this segment a single element in second place remove it from all segments containing it and just solve a smaller problem again If we succeed with restoring the permutation then we need to check if this permutation really satisfies the given input segments see the first test case of the example to understand why this case appears Let s just iterate over all from to and then over all from to If the segment is in the list remove it and go to the next If we can t find the segment for some then this permutation is wrong Time complexity or less maybe "}
{"statement": "Constanze is the smartest girl in her village but she has bad eyesight One day she was able to invent an incredible machine When you pronounce letters the machine will inscribe them onto a piece of paper For example if you pronounce c o d and e in that order then the machine will inscribe onto the paper Thanks to this machine she can finally write messages without using her glasses However her dumb friend Akko decided to play a prank on her Akko tinkered with the machine so that if you pronounce w it will inscribe instead of and if you pronounce m it will inscribe instead of Since Constanze had bad eyesight she was not able to realize what Akko did The rest of the letters behave the same as before if you pronounce any letter besides w and m the machine will just inscribe it onto a piece of paper The next day I received a letter in my mailbox I can t understand it so I think it s either just some gibberish from Akko or Constanze made it using her machine But since I know what Akko did I can just list down all possible strings that Constanze s machine would have turned into the message I got and see if anything makes sense But I need to know how much paper I will need and that s why I m asking you for help Tell me the number of strings that Constanze s machine would ve turned into the message I got But since this number can be quite large tell me instead its remainder when divided by 10 9 7 If there are no strings that Constanze s machine would ve turned into the message I got then print 0 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "If has any or the answer is 0 Otherwise we can do dp Define to be the number of strings that Constanze s machine would ve turned into the first characters of Then For transition is if both and is either or and simply otherwise Answer is Alternatively notice that the maximum cardinality segment consisiting of letters or multiplies the answer by the th term of Fibonacci sequence Thus you can precalculate it and some sort of two iterators "}
{"statement": "For an arbitrary array b Yunli can perform the following operation any number of times Select an index i Set b i x where x is any integer she desires x is not limited to the interval 1 n Denote f b as the minimum number of operations she needs to perform until there exists a consecutive subarray text of length at least k in b Yunli is given an array a of size n and asks you q queries In each query you must output sum j l k 1 r f a l a l 1 ldots a j Note that in this version you are only required to output f a l a l 1 ldots a l k 1 text If there exists a consecutive subarray of length k that starts at index i 1 leq i leq b k 1 then b j b j 1 1 for all i j leq i k 1 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Problem Credits cry Proof by QED Analysis Proof by QED Solution We first make the sequence for all Now if then and are in correct relative order Now to solve the problem we precompute the answer for every window of and then each query is a lookup We use a sliding window maintaining a multiset of frequencies of values of in the current window To move from the window to we lower the frequency of by and increase the frequency of by "}
{"statement": "Jeevan has two arrays a and b of size n He is fond of performing weird operations on arrays This time he comes up with two types of operations Choose any i 1 le i le n and increment a j by 1 for every j which is a multiple of i and 1 le j le n Choose any i 1 le i le n and decrement a j by 1 for every j which is a multiple of i and 1 le j le n He wants to convert array a into an array b using the minimum total number of operations However Jeevan seems to have forgotten the value of b 1 So he makes some guesses He will ask you q questions corresponding to his q guesses the i th of which is of the form If b 1 x i what is the minimum number of operations required to convert a to b Help him by answering each question ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Firstly let s observe that only the differences matter and not the individual values of and So let us create two more arrays and where initially and for all The problem reduces to making equal to Let s have a few definitions for ease of explanation We define operation add to as perform the increment operation at and multiples of times if otherwise perform the decrement operation at and multiples of times In both cases the number of operations performed is Let s first solve the problem for only one value of We notice that problem can be solved using a simple greedy approach We iterate over the elements from left to right Let the index of the current element be Initial arrays 123456add At Applying the operation at alone can change the value of Thereby we add at to make The remaining array also gets modified accordingly Resulting arrays 123456add At Applying the operation at and only can change the value of But since we have already made we will only apply operations at We add at Resulting arrays 123456add At Applying the operation at and only can change the value of But since we have already made we will only apply operations at We add at Resulting arrays 123456add At Applying the operation at and only can change the value of But since we have already made and B 2 we will only apply operations at We add at Resulting arrays 123456add And so on So we iterate from left to right and at every index we add current value of at The final answer will be summation of absolute value of these values i e the values written in the add row However in the original problem we have to solve the problem for multiple values of So let us assume the value of to be equal to some variable say Let us try to use the same approach with the variable Initial arrays 123456add At We add at Resulting arrays 123456add At We add at Resulting arrays 123456add At We add at Resulting arrays 123456add At We add at Resulting arrays 123456add And so on Every cell in the add row here will be of the form The final answer will be the summation of absolute values of these values written in the add row Also we know Note that the above equalities hold only when So if is negative in any term then we can multiply the entire term with to make it positive since Now we can store the values of for each index in sorted order And for each query we can find out using binary search which of the absolute value terms will have a positive sign and which of those will have a negative sign So we can finally calculate the answer using prefix and suffix sums Bonus It turns out that the value of coefficient of in the add value for the th index is where is the mobious function So "}
{"statement": "At the store the salespeople want to make all prices In this problem a number that is a power of 10 is called a number For example the numbers 10 0 1 10 1 10 10 2 100 are numbers but 20 110 and 256 are not numbers So if an item is worth m bourles the value of the item is not greater than 10 9 the sellers want to change its value to the nearest number that is not greater than m They ask you by how many bourles should you the value of the item to make it worth exactly 10 k bourles where the value of k is the maximum possible k any non negative integer For example let the item have a value of 178 bourles Then the new price of the item will be 100 and the answer will be 178 100 78 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Note that the number and the nearest round number not exceeding have the same size consist of the same number of digits in the record Denote the size of by Then we can construct the nearest round number It will consist of one and zeros "}
{"statement": "A binary string s of length n is given A binary string is a string consisting only of the characters and You can choose an integer k 1 le k le n and then apply the following operation any number of times choose k consecutive characters of the string and invert them i e replace all with and vice versa Using these operations you need to make all the characters in the string equal to For example if n 5 s 00100 you can choose k 3 and proceed as follows choose the substring from the 1 st to the 3 rd character and obtain s color blue 110 00 choose the substring from the 3 rd to the 5 th character and obtain s 11 color blue 111 Find the maximum value of k for which it is possible to make all the characters in the string equal to using the described operations Note that the number of operations required to achieve this is not important ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "No substring of the string needs to be inverted twice as it does not change the string in any way Let s fix and try to check if all the characters of the string can be made equal to Suppose the first characters are already equal to and Then we need to invert all the bits starting from the th to the th inclusive i e not invert the first characters If we invert any of the first characters then we will have to invert it again Either we will invert again so it will become equal to or we will invert the characters to the left and come to the same situation but for a smaller prefix Naive checking for a fixed takes time if we honestly invert characters every time we encounter We will maintain an inversion counter how many times we need to invert a character of the string Getting the actual value of a character is simple if the counter is odd invert the character If add to the counter and remember that we need to subtract from the counter after position forming a segment This way the complexity of the check will be It remains to iterate over and find the maximum for which it was possible to bring the string to all s The complexity of the solution is "}
{"statement": "You play the game with your friend The description of this game is listed below Your friend creates distinct strings of the same length and tells you all the strings Then he randomly chooses one of them He chooses strings equiprobably i e the probability of choosing each of the strings equals You want to guess which string was chosen by your friend In order to guess what string your friend has chosen you are allowed to ask him questions Each question has the following form What character stands on position in the string you have chosen A string is considered guessed when the answers to the given questions uniquely identify the string After the string is guessed you stop asking questions You do not have a particular strategy so as each question you equiprobably ask about a position that hasn t been yet mentioned Your task is to determine the expected number of questions needed to guess the string chosen by your friend ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Let s handle all string pairs and calculate the mask which will have 1 bits only in positions in which that strings have the same characters In other words we could not distinguish these strings using positions with submask of mask then we must add in 1 bits in positions This way in we store mask of strings which we could not distinguish using only positions given in mask Using information described above we can easily calculate this dynamics Now when we have array calculated it is not hard to calculate the answer Let s handle some mask Now we should try to make one more question in position which is equal to adding one more 1 bit in in position After that we may guess some strings they are 1 bits in mask s d mask d mask 1 pos Then you have to calculate number of bits in quickly and update the answer Jury s solution 8394918 "}
{"statement": "Iris has just learned multiplication in her Maths lessons However since her brain is unable to withstand too complex calculations she could not multiply two integers with the product greater than k together Otherwise her brain may explode Her teacher sets a difficult task every day as her daily summer holiday homework Now she is given an array a consisting of n elements and she needs to calculate the product of each two adjacent elements that is a 1 cdot a 2 a 2 cdot a 3 and so on Iris wants her brain to work safely and in order to do that she would like to modify the array a in such a way that a i cdot a i 1 leq k holds for every 1 leq i n There are two types of operations she can perform She can rearrange the elements of the array a in an arbitrary way She can select an arbitrary element of the array a and change its value to an arbitrary integer from 1 to k Iris wants to minimize the number of operations of that she uses However that s completely not the end of the summer holiday Summer holiday lasts for q days and on the i th day Iris is asked to solve the Math homework for the subarray b l i b l i 1 ldots b r i Help Iris and tell her the minimum number of type 2 operations she needs to perform for each day Note that the operations are for each day i e the array b is not changed ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Read the hints Let s consider how to reorder the array Let the sorted array be We can prove that it is optimal to reorder it like this You can find the proof at the end of the tutorial From the proof or anything we can discover the restriction is for all that Let denote the number of elements with values in range We can rewrite the restrictions into for each that it must satisfy that This means that the number of that cannot fit must not be greater than the number of and only numbers should be considered Note that there re only range sums on the value range to consider which is acceptable Consider a modify operation we obviously change the maximum value into This increases every by and decreases every non zero by so the answer is easy to calculate Just notice the situation when is too small and the length of the interval is too short How to maintain for all subintervals You can consider simply prefix sums but its time constant factor seems too large for a 2 dimensional array So we lowered the memory limit to reduce such issues An easy way to handle is solve the problem offline and for each we calculate the prefix sum for and and then answer all the queries In this way the time constant factor becomes much smaller and the memory becomes Another way to solve is to use Mo s algorithm It uses memory and time The time complexity is Proof for the optimal way to reorder If it s correct First it is optimal to put at the first position Suppose there s a way to reorder that is not at the first position we can always reverse the prefix so that it still satisfies the condition but is at the first position Then it is optimal to put at the second position Suppose there s a way to reorder that is at the first position and at the second position as and both can fit we can consider them the same any number can be put beside them so it s possible to swap and If then the array isn t good Otherwise any number can be put beside so the method of reordering can be reduced to the same problem of So the conclusion is proved "}
{"statement": "Tsumugi brought n delicious sweets to the Light Music Club They are numbered from 1 to n where the i th sweet has a sugar concentration described by an integer a i Yui loves sweets but she can eat at most m sweets each day for health reasons Days are 1 indexed numbered 1 2 3 ldots Eating the sweet i at the d th day will cause a sugar penalty of d cdot a i as sweets become more sugary with time A sweet can be eaten at most once The total sugar penalty will be the of the individual penalties of each sweet eaten Suppose that Yui chooses exactly k sweets and eats them in any order she wants What is the total sugar penalty she can get Since Yui is an undecided girl she wants you to answer this question for every value of k between 1 and n ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Let s sort array Now we can easily that if Yui wants to eat sweets she has to eat sweets in this order because of rearrangement inequality put lower coefficients day on higher values sugar concentration A naive simulation of this strategy would have complexity which is too slow Let s look what happens when we replace by During the first day Yui will eat sweets Then we reproduce the strategy used for but one day late all coefficients are increased by Formally where because of new sweets eaten and because the coefficient of these sweets are all increased by we eat them one day later We can derive the following formula If we maintain the current prefix sum and all previous answers computed in an array we can compute all answers in Final complexity is because sorting is the slowest part of the solution Implementation "}
{"statement": "You are given a rectangular table Each cell contains an integer You can move from one cell to another if they share a side Find such path from the upper left cell to the bottom right cell of the table that doesn t visit any of the cells twice and the sum of numbers written in the cells of this path is maximum possible ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "The toughest thing about this task is that you can go to the left Try to come up with something to handle that Try to prove that in optimal solution you don t need to go more than one cell to the left before coming back "}
{"statement": "You have an array a 1 a 2 dots a n Answer q queries of the following form If we change all elements in the range a l a l 1 dots a r of the array to k will the sum of the entire array be odd Note that queries are and do not affect future queries ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Note that for each question the resulting array is So the sum of the elements of the new array after each question is We can compute and in time by precomputing the sum of all prefixes and suffixes or alternatively by using the prefix sums technique So we can find the sum each time in per question and just check if it s odd or not The time complexity is "}
{"statement": "Natasha is going to fly on a rocket to Mars and return to Earth Also on the way to Mars she will land on n 2 intermediate planets Formally we number all the planets from 1 to n 1 is Earth n is Mars Natasha will make exactly n flights 1 to 2 to ldots n to 1 Flight from x to y consists of two phases take off from planet x and landing to planet y This way the overall itinerary of the trip will be the 1 st planet to take off from the 1 st planet to landing to the 2 nd planet to 2 nd planet to take off from the 2 nd planet to ldots to landing to the n th planet to the n th planet to take off from the n th planet to landing to the 1 st planet to the 1 st planet The mass of the rocket together with all the useful cargo but without fuel is m tons However Natasha does not know how much fuel to load into the rocket Unfortunately fuel can only be loaded on Earth so if the rocket runs out of fuel on some other planet Natasha will not be able to return home Fuel is needed to take off from each planet and to land to each planet It is known that 1 ton of fuel can lift off a i tons of rocket from the i th planet or to land b i tons of rocket onto the i th planet For example if the weight of rocket is 9 tons weight of fuel is 3 tons and take off coefficient is 8 a i 8 then 1 5 tons of fuel will be burnt since 1 5 cdot 8 9 3 The new weight of fuel after take off will be 1 5 tons Please note that it is allowed to burn non integral amount of fuel during take off or landing and the amount of initial fuel can be non integral as well Help Natasha to calculate the minimum mass of fuel to load into the rocket Note that the rocket must spend fuel to carry both useful cargo and the fuel itself However it doesn t need to carry the fuel which has already been burnt Assume that the rocket takes off and lands instantly ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "First we learn how to determine if a rocket can fly the entire route Consider an element from an array or We denote it by If that is one ton of fuel can carry only one ton cargo fuel then fuel can only take it to ourselves and we need to take a rocket and a useful cargo the mass of which is positive That is if at least for one it is necessary to deduce otherwise do the following calculations It is clear that arrays and will be processed by the computer of the rocket in that order We will process this sequence from the end Let at the current iteration the mass of the payload including fuel that will not be used at this iteration is tons the current element from the array or is the mass of fuel that will be used at this iteration it must be found is We assign before the iterations We form the equation total mass mass that all fuel can transportBy this formula you can find fuel in this iteration For the next iteration to the payload weight you need to add mass of fuel since this fuel needs to be brought to this iteration that is perform the assignment In the end it is necessary to deduce Complexity Bonus In fact it does not matter in which order to process arrays and from the beginning from the end or in general mixed the answer from this will not change Try to prove it by yourself "}
{"statement": "Vasya has got a magic matrix a of size n times m The rows of the matrix are numbered from 1 to n from top to bottom the columns are numbered from 1 to m from left to right Let a ij be the element in the intersection of the i th row and the j th column Vasya has also got a chip Initially the chip is in the intersection of the r th row and the c th column that is in the element a rc Vasya performs the following process as long as possible among all elements of the matrix having their value less than the value of the element with the chip in it Vasya randomly and equiprobably chooses one element and moves his chip to this element After moving the chip he adds to his score the square of the Euclidean distance between these elements that is between the element in which the chip is now and the element the chip was moved from The process ends when there are no elements having their values less than the value of the element with the chip in it Euclidean distance between matrix elements with coordinates i 1 j 1 and i 2 j 2 is equal to sqrt i 1 i 2 2 j 1 j 2 2 Calculate the expected value of the Vasya s final score It can be shown that the answer can be represented as frac P Q where P and Q are coprime integer numbers and Q not equiv 0 mod 998244353 Print the value P cdot Q 1 modulo 998244353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Let s iterate over all the elements of the matrix in order of increasing their values and calculate the expected value for these elements to solve the problem Suppose that now we consider the element at intersection of the th row and the th column Let the elements having value less than the value of the current element be where is the row of the th element and is the column of the th element Then the expected value for the current element can be calculated as follows where is the expected value of the th element We can rewrite the formula to the following form using equivalent transforms So we need to maintain five sums for the elements having value less than current element sum of their values sum of their row indices sum of their column indices sum of squares of their row indices and sum of squares of their column indices We can maintain all these sums if we will iterate over all the elements continuously in order of increasing their values It is also necessary to note that we need to process all the elements having equal values at once and recalculate all the sums right after calculating the expected values for these elements "}
{"statement": "Couple Cover a wildly popular luck based game is about to begin Two players must work together to construct a rectangle A bag with balls each with an integer written on it is placed on the table The first player reaches in and grabs a ball randomly all balls have equal probability of being chosen the number written on this ball is the rectangle s width in meters This ball is not returned to the bag and the second player reaches into the bag and grabs another ball the number written on this ball is the rectangle s height in meters If the area of the rectangle is greater than or equal some threshold square meters the players win Otherwise they lose The organizers of the game are trying to select an appropriate value for so that the probability of a couple winning is not too high and not too low but they are slow at counting so they have hired you to answer some questions for them You are given a list of the numbers written on the balls the organizers would like to know how many winning pairs of balls exist for different values of Note that two pairs are different if either the first or the second ball is different between the two in pair and two different balls with the same number are considered different ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "The problem was suggested by Michael Kirsche mkirsche Let s count the number of pairs with multiple less than To get the number of not less pairs we should sumply subtract from the number of less pairs Let be the number of values in equal to and be the number of pairs from with the multiple equal to To calculate the values from we can use something like Eratosthenes sieve let s iterate over the first multiplier and the multiple of it and increment by the value After calculating the array we should calculate the array of its partial sums and find the number of less pairs in time C solution "}
{"statement": "Alice gave Bob two integers a and b a 0 and b ge 0 Being a curious boy Bob wrote down an array of integers with operatorname MEX value of all elements equal to a and operatorname XOR value of all elements equal to b What is the possible length of the array Bob wrote Recall that the operatorname MEX Minimum EXcluded of an array is the minimum non negative integer that does belong to the array and the operatorname XOR of an array is the bitwise XOR of all the elements of the array ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "First consider the MEX condition the shortest array with MEX is the array which has length Now we ll consider the XOR condition Let the XOR of the array be We have three cases Case 1 Then we don t need to add any elements to the array so the answer is Case 2 and Then we can add the element to the array since so the MEX will still be The XOR of the array will then be The answer is Case 3 and Then we cannot add the element to the end of the array We can just add and so the XOR of the array will be The answer is Time complexity precomputation and per test case if you precalculate the XOR of the numbers from to or if you use the well known formula for it "}
{"statement": "Let s define a multiset the following way Write down the sum of all elements of the multiset in its decimal representation For each position of that number check if the multiset includes at least one element such that the digit of the element and the digit of the sum at that position are the same If that holds for every position then the multiset is Otherwise it s For example multiset 20 300 10001 is and multiset 20 310 10001 is The red digits mark the elements and the positions for which these elements have the same digit as the sum The sum of the first multiset is 10321 every position has the digit required The sum of the second multiset is 10331 and the second to last digit doesn t appear in any number thus making the multiset You are given an array a 1 a 2 dots a n consisting of n integers You are asked to perform some queries on it The queries can be of two types 1 i x replace a i with the value x 2 l r find the subset of the multiset of the numbers a l a l 1 dots a r with the minimum sum or report that no subset exists Note that the empty multiset is For each query of the second type print the lowest sum of the subset Print if no subset exists ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "We are given the definition of the balanced multiset but let s instead fix the criteria to determine if the multiset is unbalanced Take an empty multiset and start adding numbers to it until it becomes unbalanced Empty set to the set of one number is trivial Now for the second number If there is some position such that both numbers have non zero digits in it then the multiset becomes unbalanced let these be non zero digits and then can be neither nor After that let s prove that you can never make an unbalanced multiset balanced again by adding numbers to it Let there be such multisets and such is unbalanced is balanced and Take a look at the lowest position which has non zero digits in several numbers from The sum of these digits should be equal to at least one of them modulo to satisfy the condition of balance That can only mean their sum is greater or equal to thus is make a carry to the next position The sum of digits on the next position plus carry should also be equal to some digit of them thus pushing some other carry value to the next one And so on until the carry makes it to the position greater than any position in any of the numbers But the carry is non zero and there is no number with any non zero digit in this position That makes our assumption incorrect After all it implies that any unbalanced multiset of size greater than two has an unbalanced multiset of size two The problem now got reduced to find a pair of numbers and such that there is at least one position such that both and have non zero digits on it and is minimal possible That can be easily maintained in a segment tree Let a node corresponding to the interval keep the best answer on an interval the sum of such a pair and an array the smallest number on an interval which has a non zero digit at position or if none exists The update is easy Iterate over the digits of a new number and update the values in the array in the corresponding nodes The merge is done the following way push the best answers from children to the parent and then iterate over the positions and try to combine the smallest numbers at each one from the left child and the right child Idea wise this is the same as storing a segtree and calculating the answer by each position separately However these approaches differ by a huge constant factor performance wise The former one accesses the memory in a much more cache friendly way You might want to take that as a general advice on implementing multiple segtrees Overall complexity "}
{"statement": "Little Nastya has a hobby she likes to remove some letters from word to obtain another word But it turns out to be pretty hard for her because she is too young Therefore her brother Sergey always helps her Sergey gives Nastya the word and wants to get the word out of it Nastya removes letters in a certain order one after another in this order strictly which is specified by permutation of letters indices of the word We denote the length of word as Note that after removing one letter the indices of other letters don t change For example if and then removals make the following sequence of words Sergey knows this permutation His goal is to stop his sister at some point and continue removing by himself to get the word Since Nastya likes this activity Sergey wants to stop her as late as possible Your task is to determine how many letters Nastya can remove before she will be stopped by Sergey It is guaranteed that the word can be obtained by removing the letters from word ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "In this problem we have to find the last moment of time when has as a subsequence If at some moment of time is a subsequence of then at any moment before is also its subsequence That s why the solution is binary search for the number of moves Nastya makes For binary search for a moment of time we need to check if is a subsequence of We remove and check if is a subsequence greedily "}
{"statement": "Eugeny has array consisting of integers Each integer equals to 1 or to 1 Also he has queries Query number is given as a pair of integers The response to the query will be integer if the elements of array can be rearranged so as the sum otherwise the response to the query will be integer Help Eugeny answer all his queries ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "If the length of the given segment is even and count of 1 in input is not lower then half of the length of the segment and count of 1 in the input is not lower then half of the length of the segment so we have answer 1 otherwise 0 "}
{"statement": "CQXYM found a rectangle A of size n times m There are n rows and m columns of blocks Each block of the rectangle is an obsidian block or empty CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation A rectangle M size of a times b is called a portal if and only if it satisfies the following conditions a geq 5 b geq 4 For all 1 x a blocks M x 1 and M x b are obsidian blocks For all 1 x b blocks M 1 x and M a x are obsidian blocks For all 1 x a 1 y b block M x y is an empty block M 1 1 M 1 b M a 1 M a b Note that the there must be a rows and b columns not b rows and a columns CQXYM wants to know the minimum number of operations he needs to make at least one sub rectangle a portal ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "We can enumerate the two corner of the submatrix calculate the answer by precalculating the prefix sums The time complexity is When we enumerated the upper edge and the lower edge of the submatrix we can calculate the answer by prefix sum Assume the left edge of the submatrix is and the right edge is The part of anwer contributed by upper and lower edge are two segments we can calculate the answer by prefix sums The middle empty part is a submaxtrix and we can use prefix sums too Since we have enumerated the upper edge and lower edge the left edge part is just about and the right part is just about Then we enumerate the answer of the best can be calculated by precalculating the suffix miniums The time complexity is space complexity is solution "}
{"statement": "Ayoub had an array a of integers of size n and this array had two interesting properties All the integers in the array were between l and r inclusive The sum of all the elements was divisible by 3 Unfortunately Ayoub has lost his array but he remembers the size of the array n and the numbers l and r so he asked you to find the number of ways to restore the array Since the answer could be very large print it modulo 10 9 7 i e the remainder when dividing by 10 9 7 In case there are no satisfying arrays Ayoub has a wrong memory print 0 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Since we need the sum of the array to be divisible by we don t care about the numbers themselves We care about how many numbers such that or or and we count them by simple formulas For example let s count the number of with remainder modulo hence for some integer Then we have and then It is easy to count number of such then After counting all numbers we can solve the problem using dynamic programming Let s say that dp i j represents that the sum of the first numbers modulo is equal to There are states and transitions and the answer will be at dp n 0 "}
{"statement": "Anton is growing a tree in his garden In case you forgot the tree is a connected acyclic undirected graph There are vertices in the tree each of them is painted black or white Anton doesn t like multicolored trees so he wants to change the tree such that all vertices have the same color black or white To change the colors Anton can use only operations of one type We denote it as where is some vertex of the tree This operation changes the color of all vertices such that all vertices on the shortest path from to have the same color including and For example consider the tree and apply operation to get the following Anton is interested in the minimum number of operation he needs to perform in order to make the colors of all vertices equal ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "At first let s observe that if we unite some two vertices connected by an edge that are the same color in one vertex the answer will not change Let s do this Then for instance the tree will look in this way We ll also do such tree compression after every painting operation Then for instance the tree will change after operation and the tree compression in this way It s obvious that the tree will be painted in one color if and only if when after such painting operations with the compression only one vertex remains Let s call the tree diameter maximal possible shortest path between two vertices of the tree It s not hard to observe that the tree will be painted in one color if and only if when the tree diameter becomes equal to because the diameter is only in the tree with one vertex Then we ll see the following fact the tree diameter can t be decreased more than by two per one painting operation with the compression So the answer cannot be less than where is the tree diameter Now we ll prove that it s always possible to paint the tree in operations Find such vertex that the shortest path from it to any other vertex doesn t exceed Such vertex can always be found because otherwise the tree diameter won t be less that which is impossible Now see that if we paint this vertex times we will paint the tree in one color Time complexity is "}
{"statement": "Due to the increase in the number of students of Berland State University it was decided to equip a new computer room You were given the task of buying mouses and you have to spend as little as possible After all the country is in crisis The computers bought for the room were different Some of them had only USB ports some only PS 2 ports and some had both options You have found a price list of a certain computer shop In it for mouses it is specified the cost and the type of the port that is required to plug the mouse in USB or PS 2 Each mouse from the list can be bought at most once You want to buy some set of mouses from the given price list in such a way so that you maximize the number of computers equipped with mouses it is not guaranteed that you will be able to equip all of the computers and in case of equality of this value you want to minimize the total cost of mouses you will buy ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Try coming up either with greedy algorithm or with two pointers algorithm Try to prove the following greedy in each step we can choose the cheapest remaining mouse If there is a computer left that has only one type of port suitable for this mouse plug it there Else if there is a computer with both types plug it there Else discard this mouse Try to also come up with the two pointers solution If you cannot it is described under the next spoiler Sort all of the USB mouses and all of the PS 2 mouses so that the price is non descending Then you will need to buy some prefix of USB mouses and some prefix of PS 2 mouses Iterate over the number of USB mouses from 0 to their count Now the more USB mouses you buy and plug into computers the less PS 2 mouses you will be able to buy because the number of computers will only be decreasing So you should move the first pointer forward and in every iteration move the second pointer backwards until you reach such amount that it is possible to plug both USB and PC 2 mouses in "}
{"statement": "Pak Chanek is given an array a of n integers For each i 1 leq i leq n Pak Chanek will write the one element set a i on a whiteboard After that in one operation Pak Chanek may do the following Choose two different sets S and T on the whiteboard such that S cap T varnothing S and T do not have any common elements Erase S and T from the whiteboard and write S cup T the union of S and T onto the whiteboard After performing zero or more operations Pak Chanek will construct a multiset M containing the sizes of all sets written on the whiteboard In other words each element in M corresponds to the size of a set after the operations How many distinct dagger multisets M can be created by this process Since the answer may be large output it modulo 998 244 353 dagger Multisets B and C are different if and only if there exists a value k such that the number of elements with value k in B is different than the number of elements with value k in C ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Let denote the number of occurrences of element in array Claim A multiset of size where is good if and only if and for every The proof of that claim has been discussed in the comment section here We proceed with formulating a dynamic programming solution Let denote that we have picked a prefix such that and Our transition is going from to for all this can be easily handled using prefix sums However we still have states We can cut down the number of states by noting that That is for each value of there are only values of Since the number of states is bounded by Time complexity "}
{"statement": "ChthollyNotaSeniorious received a special gift from AquaMoon n binary arrays of length m AquaMoon tells him that in one operation he can choose any two arrays and any position pos from 1 to m and swap the elements at positions pos in these arrays He is fascinated with this game and he wants to find the minimum number of operations needed to make the numbers of 1s in all arrays the same He has invited you to participate in this interesting game so please try to find it If it is possible please output specific exchange steps in the format described in the output section Otherwise please output 1 ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "SolutionConsidering that we need to make the number of in each array the same we should calculate the sum of and every array has Because only the same position of two different arrays can be selected for exchange each time for a position we traverse each array each time If the number of in this array is not enough then we need to turn some into If the number of in this array is more than we need then some should be turned into It can be proved that as long as the total number of is a multiple of the number of in each array can be made the same through exchanges "}
{"statement": "Ildar and Ivan are tired of chess but they really like the chessboard so they invented a new game The field is a chessboard 2n times 2m it has 2n rows 2m columns and the cell in row i and column j is colored white if i j is even and is colored black otherwise The game proceeds as follows Ildar marks some of the cells of the chessboard as and asks Ivan to place n times m kings on the remaining cells in such way so that there are no kings attacking each other A king can attack another king if they are located in the adjacent cells sharing an edge or a corner Ildar would like to explore different combinations of cells Initially all cells are marked as available and then he has q queries In each query he marks a cell as unavailable After each query he would like to know whether it is possible to place the kings on the available cells in a desired way Please help him ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Let s divide the grid into squares of size Each square contains exactly two white cells So we should put one king into one square Let s mark a square if its left upper cell is banned and if its right down cell is banned Square can be and at the same time If there exists some square and square such that the answer is It s easy to prove because if such pair of cells exists we can consider path from to In this path there will be two neighboring cells If no such pairs of cells exist the answer is Note that in this version of the problem cells cannot become available againg This means that for some prefix of queries the answer is and for the remaining suffix the answer is Let s do a binary search to find position of the last How to check that the answer is fast enough Let s calculate the values minimal such that is square maximal such that is square After that we should check that for all We can easily do this using prefix maximums for and suffix minimums for Total complexity is "}
{"statement": "Piet is one of the most known visual esoteric programming languages The programs in Piet are constructed from colorful blocks of pixels and interpreted using pretty complicated rules In this problem we will use a subset of Piet language with simplified rules The program will be a rectangular image consisting of colored and black pixels The color of each pixel will be given by an integer number between 0 and 9 inclusive with 0 denoting black A block of pixels is defined as a rectangle of pixels of the same color not black It is guaranteed that all connected groups of colored pixels of the same color will form rectangular blocks Groups of black pixels can form arbitrary shapes The program is interpreted using movement of instruction pointer IP which consists of three parts current block pointer BP note that there is no concept of current pixel within the block direction pointer DP which can point left right up or down block chooser CP which can point to the left or to the right from the direction given by DP in absolute values CP can differ from DP by 90 degrees counterclockwise or clockwise respectively Initially BP points to the block which contains the top left corner of the program DP points to the right and CP points to the left see the orange square on the image below One step of program interpretation changes the state of IP in a following way The interpreter finds the furthest edge of the current color block in the direction of the DP From all pixels that form this edge the interpreter selects the furthest one in the direction of After this BP attempts to move from this pixel into the next one in the direction of DP If the next pixel belongs to a colored block this block becomes the current one and two other parts of IP stay the same It the next pixel is black or outside of the program BP stays the same but two other parts of IP change If CP was pointing to the left now it points to the right and DP stays the same If CP was pointing to the right now it points to the left and DP is rotated 90 degrees clockwise This way BP will never point to a black block it is guaranteed that top left pixel of the program will not be black You are given a Piet program You have to figure out which block of the program will be current after steps ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "As you ve already noticed Piet differs from most other esoteric programming languages in the way it interprets the image the problem offered a very simplified version of it and still it was quite cruel The first step of the solution is finding colored blocks Given that they are rectangular this can be done without BFS once you ve found a colored pixel which is not part of any block you ve seen before you just find the maximal contiguous sequence of pixels of the same color in the same line that starts with this pixel and assume that it s horizontal dimension of its block X XXXXXX vXXXXXX I found it convenient to index the blocks and store their colors and dimensions at this point so that this doesn t need to be re done later After this I calculated state transition function a function which for each state of instruction pointer defined the next state The IP has at most 50x50x4x2 states and they can be indexed with 8 index of current block 2 direction pointer block chooser Thus the transition function can be described with a one dimensional array index is current state of IP and value is the next one and the simulation of interpretation steps becomes just updating the current state of IP which is easier than repeating the full procedure described in the statement on each step It was also possible to note that at some point there will be a loop in the states of the IP since the maximal possible number of distinct states is less than the number of steps to be done But exploiting this wasn t necessary "}
{"statement": "The array a 1 a 2 dots a k is called if it is possible to remove several maybe zero elements from the beginning of the array and insert all these elements to the back of the array in the same order in such a way that the resulting array is sorted in non descending order In other words the array a 1 a 2 dots a k is if there exists an integer i in 0 k 1 such that the array a i 1 a i 2 dots a k 1 a k a 1 a 2 dots a i is sorted in non descending order For example 3 7 7 9 2 3 is we can remove four first elements and insert them to the back in the same order and we get the array 2 3 3 7 7 9 which is sorted in non descending order 1 2 3 4 5 is we can remove zero first elements and insert them to the back and we get the array 1 2 3 4 5 which is sorted in non descending order 5 2 2 1 is not You are given an array a which is initially You have to process q queries to it During the i th query you will be given one integer x i and you have to do the following if you can append the integer x i to the of the array a so that the array a stays you have to append it otherwise do nothing After each query report whether you appended the given integer x i or not ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "First notice that the given operation is a cyclic shift of the array So we can treat the array as cyclic meaning element is a neighbor of element Let s try to rephrase the condition for the beautiful array What does it mean for the array to be sorted For all from to should hold If they do then you can choose leave the array as is What if there are such that If there is only one such then we might still be able to fix the array choose However that will make a pair and cyclically shift into the array So should hold If there are at least two such or just one but then we can show that it s impossible to make the array sorted Since there are at least two pairs of neighboring elements that are not sorted at least one of them will still be in the array after any cyclic shift Thus we can maintain the number of such that and check if every time if the count is exactly Overall complexity per testcase "}
{"statement": "You are given a grid with n rows and m columns The coordinates x y represent the cell on the grid where x 1 leq x leq n is the row number counting from the top and y 1 leq y leq m is the column number counting from the left It is guaranteed that there are exactly 2 mines in the grid at cells denoted as x 1 y 1 and x 2 y 2 You are allowed to make no more than 4 queries to the interactor and after these queries you need to provide the location of In each query you can choose any grid cell x y and in return you will receive the minimum Manhattan distance from both the mines to the chosen cell i e you will receive the value min x x 1 y y 1 x x 2 y y 2 Your task is to determine the location of one of the mines after making the queries ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "First we query 1 1 then you get a value a1 and you know that at least one of the mine is on the line x y a1 2 Now we make two more queries on both ends of this line where it touches the grid After these two queries we get two possible locations of the mine We query one of these positions if we receive 0 as the answer then this location otherwise the other location is the answer Reason One of that two locations contains a mine The other mine could spoil the result of the query only from one end If it was closer from the other mine to both of the ends it would mean that going from one end to the other is shorter through that mine than through the diagonal That s impossible "}
{"statement": "You are given four positive integers n m a b 1 le b le n le 50 1 le a le m le 50 Find any such rectangular matrix of size n times m that satisfies all of the following conditions each row of the matrix contains exactly a ones each column of the matrix contains exactly b ones all other elements are zeros If the desired matrix does not exist indicate this For example for n 3 m 6 a 2 b 1 there exists a matrix satisfying the conditions above begin vmatrix 0 1 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 0 end vmatrix ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s see how the desired matrix looks like Since each row should have exactly ones and each column should have exactly ones the number of ones in all rows should be equal to the number of ones in all columns Thus the desired matrix exists iff or Let s show how to construct the desired matrix if it exists Let s find any number such that where is the remainder of dividing by In the first row of the desired matrix we put the ones at the positions and in the th row we put the ones as in the row but cyclically shifted by to the right "}
{"statement": "Stephen Queen wants to write a story He is a very unusual writer he uses only letters and To compose a story Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet He wants to select the number of to make an story Let a story be a sequence of words that are not necessarily different A story is called if there exists a letter which occurs among all words of the story more times than all other letters together For example the story consisting of three words is interesting the letter occurs 5 times all other letters occur 4 times in total But the story consisting of two words is not no such letter that it occurs more than all other letters in total You are given a sequence of n words consisting of letters and Your task is to choose the maximum number of them to make an interesting story If there s no way to make a non empty story output 0 ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Let be the number of the occurrences of the letter in the word minus the number of the occurrences of all other letters in total Since for each two words and the number of the occurrences of a letter in the word is the sum of the numbers of its occurrences in and the equality is true means the concatenation of and Consider a sequence of words A story consisting of words is interesting if and only if there s a letter such that it exactly means that there s a letter which occurs more times than all other in total So we are interested in searching for a letter such that exists a positive integer a maximal number of words such that Suppose we have a set of words that form an interesting story and where is the letter having more occurrences than all other letters in total Suppose we can add to it one of few words We had better add a word such that is maximal to be able to add more words in the future So the problem has the following solution for each letter of the Latin alphabet and for each word let s calculate Then let s iterate over all letters take a sequence and sort it in descending order Let s initialize an interesting story by a set of a single word corresponding to the first element of the sequence If there s no word such that then there s no non empty interesting story containing some words of the given set Otherwise let s take the next elements of the sequence sequentially until the sum of over all taken words is greater than zero Let s select a letter such that the corresponding taken set is maximal over all letters Finally we should print the set s size The solution consists of two phases the calculation of all works in where is the alphabet s size is the lengths of a string and building a maximal interesting story for each letter sorting and a greedy algorithm "}
{"statement": "Pasha is participating in a contest on one well known website This time he wants to win the contest and will do anything to get to the first place This contest consists of problems and Pasha solves th problem in time units his solutions are always correct At any moment of time he can be thinking about a solution to only one of the problems that is he cannot be solving two problems at the same time The time Pasha spends to send his solutions is negligible Unfortunately there are too many participants and the website is not always working Pasha received the information that the website will be working only during time periods th period is represented by its starting moment and ending moment Of course Pasha can send his solution only when the website is working In other words Pasha can send his solution at some moment iff there exists a period such that Pasha wants to know his best possible result We need to tell him the minimal moment of time by which he is able to have if he acts optimally or say that it s impossible no matter how Pasha solves the problems ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Notice that we can keep solved tasks and then submit all at once So the solution goes down to this you should find the first moment of time that the site works at that moment and Also it s convinient that the intervals are already sorted in increasing order Let s sum up all elements of array and write it to some variable The answer is obtained this way if the sum lies in the current interval then the answer is the sum Otherwise there are two cases If there exists some interval that then the answer is In other case the answer is 1 "}
{"statement": "Xenia lives in a city that has houses built along the main ringroad The ringroad houses are numbered 1 through in the clockwise order The ringroad traffic is one way and also is clockwise Xenia has recently moved into the ringroad house number 1 As a result she s got things to do In order to complete the th task she needs to be in the house number and complete all tasks with numbers less than Initially Xenia is in the house number 1 find the minimum time she needs to complete all her tasks if moving from a house to a neighboring one along the ringroad takes one unit of time ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Tutorial by Fefer Ivan To solve this problem we must learn how to calculate fast enought the time needed to travel between houses and Let s consider the case when Than Xenia needs seconds to get from to Otherwise Xenia will have to go thought house number 1 So she will need seconds "}
{"statement": "When you were a child you must have been told a puzzle of bags and coins Anyway here s one of its versions The answer is quite simple The third bag contains a coin and two other bags This problem is a generalization of the childhood puzzle You have bags You know that the first bag contains coins the second bag contains coins the th bag contains coins In total there are coins Find the way to arrange the bags and coins so that they match the described scenario or else state that it is impossible to do ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "It s easy to see that bags and their relations lies directly in should form directed forest Each vertex should be given value the number of coins in the corresponding bag Let s denote the sum of values in the subtree of vertex as The following conditions should be met It s clear that one of the bags with largest must be the root of some tree It s quite easy to see that the solution exists if and only if there exists a subset such that and this subset contains at least one bag with the largest It s obvious that it is necessary condition the sufficiency is also easy to see let s suppose we have such subset Then all bags from the subset except one of the largest will be roots of the signle vertex trees i e for them All bags that are not in the subset we will consequentially put into the largest bag forming the russian doll this tree will be directed chain So we reduced the task to the well known subset sum problem from the items find the subset with the given sum This problem is NP Complete and with these constraints is solved in a following way let if it is possible to obtain sum using some of the first items and otherwise Then The th row of this table depends only on the previous row so we don t have to store the whole table in memory Also we should use the fact that the values of the table are zeroes and ones and we can use bit compression and store each row in an array of int s of size To get the th row we should calculate the bitwise OR of the previous row and the previous row shifted to the left by positions That is we can find out whether it possible to obtain the sum in approximately operations To find the actual way to obtain we need to use the following trick for every possible sum we will remember the value the number of such item that after considering this item it became possible to obtain This allows us to restore the solution "}
{"statement": "There is a prison that can be represented as a rectangular matrix with n rows and m columns Therefore there are n cdot m prison cells There are also n cdot m prisoners one in each prison cell Let s denote the cell in the i th row and the j th column as i j There s a secret tunnel in the cell r c that the prisoners will use to escape However to avoid the risk of getting caught they will escape at night Before the night every prisoner is in his own cell When night comes they can start moving to adjacent cells Formally in one second a prisoner located in cell i j can move to cells i 1 j i 1 j i j 1 or i j 1 as long as the target cell is inside the prison They can also choose to stay in cell i j The prisoners want to know the minimum number of seconds needed so that every prisoner can arrive to cell r c if they move optimally Note that there can be any number of prisoners in the same cell at the same time ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The problem is equivalent to finding the farthest cell from x y It is easy to see that if they move optimally i j can reach x y just by moving in an L shape and this is equivalent to the Manhattan distance between the two points The longest distance a prisoner will move on rows is max x 1 n x and for the columns it is y 1 m y So answer is just max x 1 n x max y 1 m y "}
{"statement": "You are given a string Find a string where is a palindrome and is a subsequence of A subsequence of a string is a string that can be derived from it by deleting some not necessarily consecutive characters without changing the order of the remaining characters For example is a subsequence of A palindrome is a string that reads the same forward or backward The length of string should be at most It is guaranteed that there always exists such string You do not need to find the shortest answer the only restriction is that the length of string should not exceed ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let be the reverse of string Now will always have as a subsequence as first half and it is a palindrome with size less than So it may be one of the possible solutions "}
{"statement": "You are given two integer arrays a and b of length n You can reverse subarray continuous subsegment of the array a Your task is to reverse such a subarray that the sum sum limits i 1 n a i cdot b i is ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "The naive approach is to iterate over and reverse the subsegment of the array and calculate the answer But this solution is too slow and works in Instead we can iterate over the center of the reversed segment and its length If the current segment is and we want to go to then the answer for the subsegment will increase by It remains to add the answer for and but without reversion this is easy to do if you pre calculate the prefix sums of the values "}
{"statement": "William owns a flat in central London He decided to rent his flat out for the next n days to earn some money Since his flat is in the center of the city he instantly got m offers in the form l i r i which means that someone wants to book the flat from day l i until day r i inclusive To avoid spending a lot of time figuring out whether it s profitable for him to accept an offer William decided to develop an algorithm The algorithm processes all offers as they arrive and will only accept offer i if the following two conditions are satisfied r i l i 1 ge x None of the days between l i and r i are occupied by a previously accepted offer William isn t sure what value x should have and he asks you for help For all x from 1 to n he wants you to calculate the total number of days for which the flat would be occupied if the corresponding value will be assigned to x ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3200", "problem_editorial": "Note that if you think of the answer as the number accepted offers for rent the sum of the answers in the worst case will be no more than This value can be estimated in So for each we can try to learn how to process only those offers that are actually included in the answer for this Let s learn how to solve the problem recursively for a fixed and assume that all segments have a length of at least The recursion will contain two parameters and a continuous segment of days on which all days are still free Now if we learn how to find an offer with a minimum for the segment and such that then we can solve our problem We will only need to recursively find the answer for and To find the minimum you can use a 2D data structure that supports the following queries Get Minimum on the prefix matrix one of the corners of the submatrix lies in the cell The minimum can be found on the prefix matrix because we are dealing with segments for which the condition is is satisfied Update Updates the value in the cell by a strictly smaller number than it was there before In the author s solution such a data structure was a 2D segments tree We can iterate from to so that we only need to add new segments Total complexity "}
{"statement": "During a break in the buffet of the scientific lyceum of the Kingdom of Kremland there was formed a queue of n high school students numbered from 1 to n Initially each student i is on position i Each student i is characterized by two numbers a i and b i of the person i equals the product of a i by the number of people standing to the left of his position add the product b i by the number of people standing to the right of his position Formally the of the student i which is on the position j equals a i cdot j 1 b i cdot n j The director entrusted Stas with the task rearrange the people in the queue so that Although Stas is able to solve such problems this was not given to him He turned for help to you ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Firstly open the brackets As you can see is not depending on so we can sum these values up and consider them as constants Now we must minimize the sum of Let s denote two integers arrays each of length array such that and array such that for each from to Now we must solve the following task minimize the value if we can rearrange the elements of array as we want To solve this problem we must sort array in non increasing order You can use an to prove it Complexity is "}
{"statement": "For an array b of size m we define the of b is the index i that satisfies b 1 ldots b i max j 1 m b 1 ldots b j the of b is the index i that satisfies b i ldots b m max j 1 m b j ldots b m You are given three integers n x and y x y Construct an array a of size n satisfying a i is either 1 or 1 for all 1 le i le n the of a is x the of a is y If there are multiple arrays that meet the conditions print any It can be proven that such an array always exists under the given conditions ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "First we consider making presumx presumj for all x i n and similarly for y We can think of a trivial construction a r l 1 1 a 1 r 1 1 1 and a l 1 n 1 1 The construction doesn t works when presumx 0 but we are close to the correct solution Next we will make a little adjustment a r l 1 1 a 1 r 1 1 1 and a l 1 n 1 1 It is not hard to see presumx presumj for all x i n and for 1 i y max presumi min presumi 1 Thus we get presumx 2 presumy 1 2 min presumi 1 max presumi The same applies to the suffix sum as well Therefore this construction is valid "}
{"statement": "Jon Snow now has to fight with White Walkers He has rangers each of which has his own strength Also Jon Snow has his favourite number Each ranger can fight with a white walker only if the strength of the white walker equals his strength He however thinks that his rangers are weak and need to improve Jon now thinks that if he takes the bitwise XOR of strengths of some of rangers with his favourite number he might get soldiers of high strength So he decided to do the following operation times Arrange all the rangers in a straight line in the order of increasing strengths Take the bitwise XOR is written as of the strength of each alternate ranger with and update it s strength Suppose Jon has rangers with strengths and he performs the operation time with He first arranges them in the order of their strengths Then he does the following The strength of first ranger is updated to i e The strength of second ranger remains the same i e The strength of third ranger is updated to i e The strength of fourth ranger remains the same i e The strength of fifth ranger is updated to i e The new strengths of the rangers are Now Jon wants to know the maximum and minimum strength of the rangers after performing the above operations times He wants your help for this task Can you help him ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Set and Editorial by vntshh The range of strengths of any ranger at any point of time can be 0 1023 This allows us to maintain a frequency array of the strengths of the rangers Now the updation of the array can be done in the following way Make a copy of the frequency array If the number of rangers having strength less than a strength is even and there are rangers having strength y ceil rangers will be updated and will have strengths and the remaining will retain the same strength If the number of rangers having strength less than a strength is odd and there are rangers having strength y floor rangers will be updated and will have strengths and remaining will have the same strength This operation has to be done times thus the overall complexity is Complexity Code "}
{"statement": "You are given a weighted directed graph with n vertices and m edges Each vertex in the graph can be either highlighted or normal Initially all vertices are normal The cost of the graph is defined as the minimum sum of edge weights that need to be selected so that from each normal vertex one can reach at least one highlighted vertex using the selected edges only If it is not possible to select the edges the cost is 1 instead Your task is to compute the cost of the graph after each of the q queries The queries can be of two types v i makes vertex v i highlighted it is guaranteed that the vertex is normal before the query v i makes vertex v i normal it is guaranteed that the vertex is highlighted before the query Output the cost of the graph after each of the q queries ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3500", "problem_editorial": "TutorialLet s unfold all the edges now we need to ensure that all regular vertices are reachable from the selected vertices First you should familiarize yourself with the algorithm for finding the ordered minimum spanning tree also known as the Edmonds algorithm I will refer to his work here and without knowledge of it the solution cannot be understood Next it is worth noting that the compressions in the process of this algorithm almost do not depend on the root and all compressions can be performed as if there is no root previously creating dummy edges from to for from to and from vertex to vertex with a cost of Then after all the compressions only one vertex will remain Note that the difference from Edmonds algorithm is that if at any step of the algorithm the minimum edge from a vertex leads to the root compression is not necessary So let s maintain a tree in which each vertex corresponds to its corresponding compressed vertex or to the original vertex and the children of vertex are all the vertices that we compressed to obtain vertex It is implied that with each compression we create a new vertex Let s call the cost of vertex the minimum cost of an edge leaving vertex in the process of Edmonds algorithm taking into account changes in edge costs during compression in Edmonds algorithm Then we need to maintain the sum of the costs of the vertices in the tree in the subtrees of which there are no selected vertices where the selected vertices can only be leaves This can be easily done using a segment tree "}
{"statement": "Given a connected undirected graph with n vertices and an integer k you have to either either find an independent set that has lceil frac k 2 rceil vertices or find a cycle of length k An independent set is a set of vertices such that no two of them are connected by an edge A simple cycle is a cycle that doesn t contain any vertex twice I have a proof that for any input you can always solve at least one of these problems but it s left as an exercise for the reader ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "The common idea is if the graph is a tree you can easily find an independent set with size by bicoloring the vertices and taking the vertices from the more frequent color Otherwise the graph is cyclic Let s get a cycle that doesn t have any edges cutting through it In other words it doesn t have any pair of non adjacent vertices connected by an edge If its length is at most print it Otherwise take every other vertex take a vertex and leave a vertex and you ll end up with a big enough independent set How to find such cycle "}
{"statement": "Ivan is a novice painter He has n dyes of different colors He also knows exactly m pairs of colors which harmonize with each other Ivan also enjoy playing chess He has 5000 rooks He wants to take k rooks paint each of them in one of n colors and then place this k rooks on a chessboard of size 10 9 times 10 9 Let s call the set of rooks on the board if from any rook we can get to any other rook in this set moving only through cells with rooks from this set Assume that rooks can jump over other rooks in other words a rook can go to any cell which shares vertical and to any cell which shares horizontal Ivan wants his arrangement of rooks to have following properties For any color there is a rook of this color on a board For any color the set of rooks of this color is connected For any two different colors a b union of set of rooks of color a and set of rooks of color b is connected if and only if this two colors harmonize with each other Please help Ivan find such an arrangement ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1700", "problem_editorial": "Let s put rooks with color just on line number Then obviously for any color the set of rooks of this color would be connected Let s put rooks on positions for from to After that for any color there is a rook of this color on a board and for any two different colors union of set of rooks of color and set of rooks of color wouldn t be connected And for final step we can do the following for every pair of harmonizing colors let be index of first column without rooks put rooks on cells and After that for colors union of set of rooks of color and set of rooks of color would become connected and for other pairs the connectedness doesn t change Total number of rooks is "}
{"statement": "While trading on his favorite exchange trader William realized that he found a vulnerability Using this vulnerability he could change the values of certain internal variables to his advantage To play around he decided to change the values of all internal variables from a 1 a 2 ldots a n to a 1 a 2 ldots a n For some unknown reason the number of service variables is always an even number William understands that with his every action he attracts more and more attention from the exchange s security team so the number of his actions must not exceed 5 000 and after every operation no variable can have an absolute value greater than 10 18 William can perform actions of two types for two chosen variables with indices i and j where i j Perform assignment a i a i a j Perform assignment a j a j a i William wants you to develop a strategy that will get all the internal variables to the desired values ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Notice that for transforming any pair of numbers into a pair a sequence of operations such as can be performed Since is even we can apply this sequence of operations for all pairs of numbers for all from to Final complexity "}
{"statement": "An incident occurred in Capygrad the capital of Tyagoland where all the capybaras in the city went crazy and started throwing mandarins Andrey was forced to escape from the city as far as possible using portals Tyagoland is represented by a number line and the city of Capygrad is located at point 0 There are n portals all over Tyagoland each of which is characterised by four integers l i r i a i and b i 1 le l i le a i le b i le r i le 10 9 Note that the segment a i b i in the segment l i r i If Andrey is on the segment l i r i then the portal can teleport him to any point on the segment a i b i Andrey has a pass that allows him to use the portals an unlimited number of times Andrey thinks that the point x is on the segment l r if the inequality l le x le r is satisfied Andrey has q options for where to start his escape each option is characterized by a single integer x i the starting position of the escape He wants to escape from Capygrad as far as possible to the point with the maximum possible coordinate Help Andrey determine how far he could escape from Capygrad starting at each of the q positions ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": " It is always beneficial to teleport to point Proof Let s assume that we were able to teleport from point to the right of but not from Then we used some segment that covers point but does not cover point and ends to the right of This is a contradiction Let be the maximum coordinate we can reach while being on segment and let be the answer to the th query Then we notice that the answer to query We will use the scanline method from the end Events We notice that events of type are not important to us when scanning from the end according to statement number 1 It is important for us that we process events of type first then events of type and then events of type closing the segment in the scanline We will go through the events of the scanline processing them in the order of then events of type and then events of type We assume that there is a data structure that allows us to add elements remove elements and quickly output the maximum For each event of type update the value of take the maximum value of of all open segments from the structure For each event of type update the value of take the maximum value of of all open segments from the structure as well as For each event of type remove from the structure We notice that to solve this problem we can use the std multiset container which automatically sorts elements in ascending order We can store in of all open segments And then when processing events extract the maximum from all operations are performed in This allows us to solve the problem in time and memory "}
{"statement": "You are given an array a of n integers The of an array q 1 q 2 ldots q k is the number p lceil frac k 2 rceil where p is the array q sorted in non decreasing order For example the median of the array 9 5 1 2 6 is 5 as in the sorted array 1 2 5 6 9 the number at index lceil frac 5 2 rceil 3 is 5 and the median of the array 9 2 8 3 is 3 as in the sorted array 2 3 8 9 the number at index lceil frac 4 2 rceil 2 is 3 You are allowed to choose an integer i 1 le i le n and increase a i by 1 in one operation Your task is to find the minimum number of operations required to increase the median of the array Note that the array a may not necessarily contain distinct numbers ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The median is defined as the number at index in the sorted array so we can sort the array and work with it So let s start by sorting the array and finding the median in it namely the number let it be equal to In order for the median to increase that is to become at least it is necessary that there are at least numbers in the array greater than or equal to Now let s find the maximum index such that equals Then we know that there are currently numbers that are greater than or equal to all such that which means that at least operations will be required I claim that this estimate is always achievable it is enough to apply one operation to each index from to because all the numbers under these indices are equal to so after applying the operations they will become equal to And in the end the number of numbers greater than or equal to will become equal to which is what we need "}
{"statement": "The preferred way to generate user login in Polygon is to concatenate a prefix of the user s first name and a prefix of their last name in that order Each prefix must be non empty and any of the prefixes can be the full name Typically there are multiple possible logins for each person You are given the first and the last name of a user Return the alphabetically earliest login they can get regardless of other potential Polygon users As a reminder a prefix of a string is its substring which occurs at the beginning of etc are prefixes of string abcdef but and are not A string is alphabetically earlier than a string if is a prefix of or and coincide up to some position and then has a letter that is alphabetically earlier than the corresponding letter in and are alphabetically earlier than but and are alphabetically later than ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "The most straightforward solution is to generate all possible logins by trying all non empty prefixes of first and last names and combining them and find the alphabetically earliest of them To get a faster solution several observations are required First in the alphabetically earliest login the prefix of the last name is always one letter long whatever login is generated using two or more letter of the last name can be shortened further by removing extra letter to get an alphabetically earlier login Second the prefix of the first name should not contain any letter greater than or equal to the first letter of the last name other than the first letter Thus a better solution is iterate over letter of the first name starting with the second one Once a letter which is greater than or equal to the first letter of the last name is found stop and return all letter until this one plus the first letter of the last name If such a letter is not found return the whole first name plus the first letter of the last name "}
{"statement": "Vitya is studying in the third grade During the last math lesson all the pupils wrote on arithmetic quiz Vitya is a clever boy so he managed to finish all the tasks pretty fast and Oksana Fillipovna gave him a new one that is much harder Let s denote a of an integer as follows number is considered in decimal notation and then reverted If there are any leading zeroes afterwards they are thrown away For example if we flip the result is the integer but flipping we obtain and by flipping we come to Oksana Fillipovna picked some number without leading zeroes and flipped it to get number Then she summed and and told Vitya the resulting value His goal is to find any valid As Oksana Fillipovna picked some small integers as and Vitya managed to find the answer pretty fast and became interested in finding some general algorithm to deal with this problem Now he wants you to write the program that for given finds any without leading zeroes such that or determine that such doesn t exist ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Lets say that input has length of digits then size of answer can be if we didn t carry 1 to the left out of addition and otherwise Lets fix length of our answer and denote th number in the representation as Then we know from the rightmost digit of the sum Lets figure out what does equals to If the remainder is 9 it means that because we can t get 19 out of the sum of two digits Otherwise the result is defined uniquely by the fact that there was carrying 1 in the leftmost digit of the result or not So after this we know It doesn t matter how we divide sum by two digits because the result will be the same After this we can uniquely identify the fact of carrying after the first digit of the result and before the last digit Repeating this times we will get candidate for the answer In the end we will have solution If you ve missed the fact that every step is uniquely defined then you could ve wrote basically the same solution but with dynamic programming "}
{"statement": "Two players play the following game Initially the players have a knife and a rectangular sheet of paper divided into equal square grid cells of unit size The players make moves in turn the player who can t make a move loses In one move a player can take the knife and cut the paper along any segment of the grid line not necessarily from border to border The part of the paper that touches the knife at least once is considered cut There is one limit not to turn the game into an infinite cycle each move has to cut the paper that is the knife has to touch the part of the paper that is not cut before Obviously the game ends when the entire sheet is cut into blocks During the game the pieces of the sheet are not allowed to move It is also prohibited to cut along the border The coordinates of the ends of each cut must be integers You are given an piece of paper somebody has already made cuts there Your task is to determine who will win if the players start to play on this sheet You can consider that both players play optimally well If the first player wins you also need to find the winning first move ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "At first notice that horizontal and vertical cuts are independent Consider a single horizontal line It contains unit segments And in any game state it s always possible to decrease the number of uncut units as the player wants Imagine that she starts growing a segment from a border increasing it s length by 1 at a time Each time the total uncut length decreases by either 0 or 1 In the end it obviously reaches 0 The same holds for vertical lines as well So if there are no initial cuts the game is a nim with piles of stones and piles of stones Could be solved with simple formula Initial cuts should be just a technical difficulty For any vertical horizontal line which contains at least one of the cuts it s pile size should be decreased by the total length of all segments on this line How to make a first move in nim let is the result of state grundy function and is the size of the th pile Then the result of the game without th pile is We want to replace with some so that Obviously the only possible The resulting solution find a pile for which and decrease it downto "}
{"statement": "Since the giant heads have appeared in the sky all humanity is in danger so Ricks and Mortys from all parallel universes are gathering in groups to find a solution to get rid of them There are parallel universes participating in this event Ricks and Mortys I e each of universes has one Rick and one Morty They re gathering in groups Each person can be in many groups and a group can contain an arbitrary number of members Ricks and Mortys have registered online in these groups So a person can have joined a group more than once developer of this website hadn t considered this possibility Summer from universe 1 knows that in each parallel universe including hers exactly one of Rick and Morty from that universe is a traitor and is loyal but no one knows which one She knows that we are doomed if there s a group such that every member in that group is a traitor they will plan and destroy the world Summer knows that if there s a possibility that world ends there s a group where all members are traitors she should immediately cancel this event So she wants to know if she should cancel the event You have to tell her yes if and only if there s at least one scenario among all possible scenarios possible scenarios for who a traitor in each universe such that in that scenario the world will end ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "The problem says given a CNF formula check if we can set value of literals such that the formula isn t satisfied Answer is yes if and only if you can set values so that at least one clause isn t satisfied It s easy to show that answer is yes if and only if there s at least one clause that for that clause there s no such that and are both in it This can be easily implemented Time complexity "}
{"statement": "Timur is in a car traveling on the number line from point 0 to point n The car starts moving from point 0 at minute 0 There are k 1 signs on the line at points 0 a 1 a 2 dots a k and Timur knows that the car will arrive there at minutes 0 b 1 b 2 dots b k respectively The sequences a and b are strictly increasing with a k n Between any two adjacent signs the car travels with a Timur has q queries each query will be an integer d and Timur wants you to output how many minutes it takes the car to reach point d ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "For each query we binary search to find the last sign we passed since the array is sorted Say it is Then minutes have passed To find out how much time has passed since we left that sign we know that the speed between sign and is by the usual formula for speed We have passed a distance since the last sign so the total number of minutes since the last sign is Adding this to our from before we get the answer Be careful about using floating point numbers as they can behave strangely Our solution below doesn t use them at all "}
{"statement": "You are given a table a of size 2 times n i e two rows and n columns consisting of integers from 1 to n In one move you can choose some j 1 le j le n and swap values a 1 j and a 2 j in it Each column can be chosen Your task is to find the number of moves required to obtain permutations of size n in both first and second rows of the table or determine if it is impossible to do that You have to answer t independent test cases Recall that the permutation of size n is such an array of size n that contains from 1 to n exactly once the order of elements doesn t matter ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2300", "problem_editorial": "Firstly we can determine that the answer is if some number has not two occurrences Otherwise the answer exists and we actually don t need to prove it because we can check it later Let s find for each number from to indices of columns in which it appears and Consider some number If then let s just skip it we can t change anything by swapping values in this column Otherwise let be the number of row of the number in the column and is the number of row of the number in the column If then it s obvious that at exactly one of these two columns should be swapped The same if then it s obvious that we either swap both of them or don t swap both of them Let s build a graph consisting of vertices when the vertex determines the state of the th column If then let s add edge of color between vertices and Otherwise let s add the edge of color between these vertices So we have the graph consisting of several connected components and some strange edges Let s color it If the edge has the color then the color of the vertex should be different from the color of the vertex The same if the edge has the color then the color of the vertex should be the same as the color of the vertex This makes sense because edges with color mean that exactly one of the columns connected by this edge should be swapped and vice versa So after we colored the graph we can ensure that conditions for each edge are satisfied If it isn t so the answer is but this case can t actually appear Otherwise we need to decide for each component independently what is the color and the color means for it The color can mean that the column having this color isn t swapped and the color means that the column having this color is swapped in this case and vice versa We can choose greedily the minimum number of swaps for each component and print the answer Time complexity "}
{"statement": "Many years have passed and friends met at a party again Technologies have leaped forward since the last meeting cameras with timer appeared and now it is not obligatory for one of the friends to stand with a camera and thus being absent on the photo Simply speaking the process of photographing can be described as follows Each friend occupies a rectangle of pixels on the photo the th of them in a standing state occupies a pixels wide and a pixels high rectangle But also each person can lie down for the photo and then he will occupy a pixels wide and a pixels high rectangle The total photo will have size where is the total width of all the people rectangles and is the maximum of the heights The friends want to determine what minimum area the group photo can they obtain if no more than of them can lie on the ground it would be strange if more than gentlemen lie on the ground together isn t it Help them to achieve this goal ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "In an online mirror version the problem was slightly harder Let s call people with textit high and remaining people textit wide Let s fix photo height Let s consider several following cases Now we have several people that have to lie on the ground from second case and if there are too many of them more than then such value of is impossible After we put down people from second case there can still be some vacant ground positions we distribute them to the people from fourth case with highest values of Then we calculate the total area of the photo and relax the answer Intended solution has the complexity or For each possible value that we can get write a pair where is number of bills to achieve this value Sort this array in ascending order of and leave only the best possible number of bills for each value of Then to answer a query we should iterate over the first summand in resulting sum and look for the remainder using binary search The alternate way is the method of two pointers for looking in an array for a pair of numbers with a given sum that works in amortized time Check that we used no more than bills totally and relax the answer if needed Let s follow greedily in following way Iterate over all requests in a chronological order Let s try to associate each query to the new person Of course we can t always do that when there are already active users on a site we should associate this request with some existing person Now we need to choose who it will be Let s show that the best way is to associate a request with the most recently active person Indeed such critical state can be represented as a vector consisting of numbers that are times since the last request for each of the active people in descending order If we are currently in the state then we can move to the one of the new states depending on who we will associate the new request with We can see that the first vector is component wise larger then other ones so it is better than other states since the largest number in some component of vector means that this person will probably disappear earlier giving us more freedom in further operations So all we have to do is to simulate the process keeping all active people in some data structure with times of their last activity As a such structure one can use anything implementing the priority queue interface priority queue set segment tree or anything else Complexity of such solution is Let s understand what does it mean that some cell isn t attacked by any rook It means that there exists row and column of the rectangle without rooks on them It s hard to check this condition so it is a good idea to check the opposite for it We just shown that the rectangle is good if on of the two conditions holds there should be a rook in each row of it or there should be a rook in each column We can check those conditions separately How can we check that for a set of rectangles there is a point in each row This can be done by sweeping vertical line from left to right Suppose we are standing in the right side of a rectangle located in rows from to with the left side in a column Then if you denote as the position of the last rook appeared in a row number the criteria for a rectangle looks like That means that we can keep the values in a segment tree and answer for all rectangles in logarithmic time Similarly for columns This solution answers all queries in off line in time The main idea is that the bracket sequence can be seen as a sequence of prefix balances i e sequence such that Calculate the number of opening brackets and closing brackets in original string It is true that if then the string can be fixed by adding closing brackets at the end and shifting the resulting string to the point of balance minimum and if then the string can be similarly fixed by adding opening brackets to the beginning and then properly shifting the whole string It s obvious that it is impossible to fix the string by using the less number of brackets So we know the value of the answer now we need to figure out how it looks like Suppose that we first circularly shift and only then add brackets Suppose that we add closing brackets Consider the following two facts Each of those statements is easy to prove They give us the fact that in the optimal answer we put closing brackets at the end of the string after rotating the initial string So we have to consider the set of the original string circular shifts such that they transform to the correct bracket sequence by adding closing brackets to the end and choose the lexicographically least among them Comparing circular shifts of the string is the problem that can be solved by a suffix array The other way is to find lexicographical minimum among them by using hashing and binary search to compare two circular shifts The case when is similar except that opening brackets should be put into the beginning of the string So overall complexity is "}
{"statement": "You are given a binary matrix b all elements of the matrix are 0 or 1 of n rows and n columns You need to construct a n sets A 1 A 2 ldots A n for which the following conditions are satisfied Each set is nonempty and consists of distinct integers between 1 and n inclusive All sets are distinct For all pairs i j satisfying 1 leq i j leq n b i j 1 if and only if A i subsetneq A j In other words b i j is 1 if A i is a proper subset of A j and 0 otherwise Set X is a proper subset of set Y if X is a nonempty subset of Y and X neq Y It s guaranteed that for all test cases in this problem such n sets exist If there are multiple solutions you can output any of them ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1400", "problem_editorial": "Hint 1 When you are trying to add an element into a set you will have to add the element to every set that is meant to include Hint 2 If does not include then and are already distinct If does include What is the easiest way of making and distinct Solution Denote an ancestor to as a set that is meant to include Denote a descendant to as a set that is meant to be included by Let all sets be empty from the beginning Iterate through the sets To make set distinct from its descendants we can add a new number that hasn t been added to any previous sets to and all of its ancestors After the execution above we will find out that the conditions are all satisfied since For all descendants of a set all the elements they have will be included in Vice versa for all ancestors of a set For each set that is not an ancestor nor a descendant to they will not include each other This is because does not include since does not have the element and does not include for the same reason Therefore the construction above satisfies all given conditions Moreover we can set to the index of for a simpler implementation "}
{"statement": "Petya is having a party soon and he has decided to invite his n friends He wants to make invitations in the form of origami For each invitation he needs red sheets green sheets and blue sheets The store sells an infinite number of notebooks of each color but each notebook consists of only color with k sheets That is each notebook contains k sheets of either red green or blue Find the minimum number of notebooks that Petya needs to buy to invite all n of his friends ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s calculate how many notebooks we need for each color separately and the answer obviously will be their sum We need red sheets green sheets and blue sheets So we need notebooks with red sheets and notebooks with of green sheets and blue sheets respectively "}
{"statement": "You are given two integers l and r l le r Find the largest possible value of a bmod b over all pairs a b of integers for which r ge a ge b ge l As a reminder a bmod b is a remainder we get when dividing a by b For example 26 bmod 8 2 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "It s not hard to see that if then It can be shown that the maximal possible answer At the same time let the segment not contain number that is Then we can show that the maximal answer is Asymptotics per test case "}
{"statement": "Today Hayato came home from school with homework In the assignment Hayato was given an array a of length n The task was to find 3 numbers in this array whose sum is At school he claimed that there are such 3 numbers but Hayato was not sure so he asked you for help Answer if there are such three numbers and if so output indices i j and k such that a i a j a k is odd The odd numbers are integers that are not divisible by 2 1 3 5 and so on ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "TutorialNote that there are two variants of which numbers to take to make their amount odd odd number even and odd Let s save all indices of even and odd numbers into two arrays and check both cases "}
{"statement": "You are given an array a of n positive integers and a score If your score is greater than or equal to a i then you can increase your score by a i and remove a i from the array For each index i output the maximum number of additional array elements that you can remove if you remove a i and then set your score to a i Note that the removal of a i should not be counted in the answer ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "SolutionLet s sort array The answer for the largest element is because the score which is cannot be smaller than any of the other elements Now consider the second largest element The answer is at least because every element that is not greater than can be taken Then we check if the score is at least This inspires the following solution first we find the prefix sum of array We calculate the answer in decreasing order of To calculate the answer for an we find the largest such that and set the answer for equal to the answer of "}
{"statement": "You are given an array a consisting of n nonnegative integers You can swap the elements at positions i and j if a i mathsf XOR a j 4 where mathsf XOR is the bitwise XOR operation Find the lexicographically smallest array that can be made with any number of swaps An array x is lexicographically smaller than an array y if in the first position where x and y differ x i y i ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Note that if then and must share all bits in their binary representation except for the last bits This is because if they have a mismatch in any greater bit their will include this bit making its value This means that we can group the numbers by removing the last two bits and putting equal numbers into the same group In each group we can order the numbers freely since we can swap any two of them so it s optimal to sort the numbers in each group Thus we can just divide the numbers into groups and sort each solving the problem in There are several ways to implement this for instead you can use a storing all the groups and then sort the values in each group The implementation we used maps each integer to a priority queue which automatically will sort the numbers in each group "}
{"statement": "Slavic is preparing a present for a friend s birthday He has an array a of n digits and the present will be the product of all these digits Because Slavic is a good kid who wants to make the biggest product possible he wants to add 1 to exactly one of his digits What is the maximum product Slavic can make ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Just brute force all possibilties for the digit to increase and check the product each time The complexity is per testcase You can make it faster if you notice that it s always optimal to increase the smallest digit why but it wasn t necessary to pass "}
{"statement": "Cirno 9baka has a paper tape with n cells in a row on it As he thinks that the blank paper tape is too dull he wants to paint these cells with m kinds of colors For some aesthetic reasons he thinks that the i th color must be used exactly a i times and for every k consecutive cells their colors have to be distinct Help Cirno 9baka to figure out if there is such a way to paint the cells ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "SolutionFirst We can divide cells into segments that except the last segment all segments have length Then in each segment the colors in it are pairwise different It s easy to find any should be smaller than or equal to Then we can count the number of which is equal to This number must be smaller than or equal to which is the length of the last segment All that satisfies the conditions above is valid We can construct a coloring using the method below First we pick out all colors that then we use color to color the th cell in each segment Then we pick out all colors that and use these colors to color the rest of cells with cyclic order i e color th cell of the first segment of second the segment of the segment and let when one color is used up we begin to use the next color At last we pick out all colors that and color them with the cyclic order This method will always give a valid construction "}
{"statement": "Baby Ehab has a piece of Cut and Stick with an array a of length n written on it He plans to grab a pair of scissors and do the following to it pick a range l r and cut out every element a l a l 1 a r in this range stick some of the elements together in the same order they were in the array end up with multiple pieces where every piece contains some of the elements and every element belongs to some piece More formally he partitions the sequence a l a l 1 a r into subsequences He thinks a partitioning is beautiful if for every piece subsequence it holds that if it has length x then no value occurs strictly more than lceil frac x 2 rceil times in it He didn t pick a range yet so he s wondering for q ranges l r what is the minimum number of pieces he needs to partition the elements a l a l 1 a r into so that the partitioning is beautiful A sequence b is a subsequence of an array a if b can be obtained from a by deleting some possibly zero elements Note that it does have to be contiguous ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Suppose the query interval has length Let s call an element super frequent if it occurs more than Unable to parse markup type CF MATHJAX Unable to parse markup type CF MATHJAX Unable to parse markup type CF MATHJAX Unable to parse markup type CF MATHJAX Unable to parse markup type CF MATHJAX "}
{"statement": "One fine day Sasha went to the park for a walk In the park he saw that his favorite bench is occupied and he had to sit down on the neighboring one He sat down and began to listen to the silence Suddenly he got a question what if in different parts of the park the silence sounds in different ways So it was Let s divide the park into 1 times 1 meter squares and call them and numerate rows from 1 to n from up to down and columns from 1 to m from left to right And now every cell can be described with a pair of two integers x y where x the number of the row and y the number of the column Sasha knows that the level of silence in the cell i j equals to f i j and all f i j form a permutation of numbers from 1 to n cdot m Sasha decided to count how many are there segments of silence Let s take some segment l ldots r Denote S as the set of cells i j that l le f i j le r Then the segment of silence l ldots r is if there is only path between every pair of cells from S path can t contain cells which are not in S In other words set S should look like a tree on a plain Sasha has done this task pretty quickly and called the algorithm algorithm of silence s sounds Time passed and the only thing left from the algorithm is a legend To prove the truthfulness of this story you have to help Sasha and to find the number of segments of silence Two segments l 1 ldots r 1 l 2 ldots r 2 are different if l 1 neq l 2 or r 1 neq r 2 or both at the same time ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3200", "problem_editorial": "A range a tree if the graph formated by it doen t have any cycle and there is only one connected component in this graph Let s be such minimal position that doen t contain cycles forest It is obvous that Suppose for each we find Then the task now is to count the number of such that graph formated by the range consists of one connected component How to find for each Let s move two pointers and For each moment we store a graph formated by that range If you add to one of the pointers then you should add delete up to edges to the graph Before adding an edge check whether two verticies are in different components not to form a cycle and if they are in one component then it is needed to delete some edges move the first pointer So now we need some structure that can process types of queries online add an edge delete an edge check if two verticies are in one connected component As long as the graph will never have a cycle so it is possible to answer queries using link cut tree for one query It is left to count the number of suitable for each Let s iterate from to and maintain the number of connected components for Then for a fixed you should add to the answer the number of such that and What is going on when we move and add some edge at that moment Let s that edge be and if then you can skip this edge For for which won t change after you add an edge but for two trees merge in one decreases by Let s have a segtree to store then decreasing by is equivalent to adding on a range and the number of on a range is the number of minimums All such queries can be done in The total complexity is "}
{"statement": "Robin encounters n people starting from the 1 st and ending with the n th The i th person has a i gold If a i ge k Robin will take all a i gold and if a i 0 Robin will give 1 gold if he has any Robin starts with 0 gold Find out how many people Robin gives gold to ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "This problem requires a simple implementation Set a variable initially 0 to represent the gold Robin has and update it according to the rules as he scans through ai adding 1 to answer whenever Robin gives away a gold "}
{"statement": "You are given a 1 indexed array a of length n where each element is 1 or 2 Process q queries of the following two types check if there exists a subarray dagger of a whose sum equals to s change a i to v dagger An array b is a subarray of an array a if b can be obtained from a by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end In particular an array is a subarray of itself ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "SolutionDenote as the sum of subarray from to Claim If there is any subarray with sum we can find a subarray with sum Proof Suppose consider 3 cases we have we have we have So to check if there exists a subarray whose sum equals we can find the maximum subarray sum having the same parity with and compare it with The case where is obvious suppose the opposite happens If array is full of s the answer is Otherwise let and be the positions of the first and last in Any subarray with will have a different parity with So we will compare with to get the answer "}
{"statement": "You are given 3 integers n x y Let s call the of a permutation dagger p 1 ldots p n the following value In other words the of a permutation is the sum of p i for all indices i divisible by x minus the sum of p i for all indices i divisible by y You need to find the maximum possible among all permutations of length n For example if n 7 x 2 y 3 the maximum is achieved by the permutation 2 color red underline color black 6 color blue underline color black 1 color red underline color black 7 5 color blue underline color red underline color black 4 3 and is equal to 6 7 4 1 4 17 5 12 dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in any order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation the number 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but the array contains 4 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let s call a number red if it is divisible by Let s call a number blue if it is divisible by Let s call a number purple if it is both red and blue at the same time The score of a permutation by definition is the sum of for all red numbers from to minus the sum of for all blue numbers from to It is easy to see that at purple indices does not affect the score of the permutation they are included in the sum once with a plus sign and once with a minus sign Therefore the score of the permutation is the sum of for red but not purple indices minus the sum of for blue but not purple indices Notice that the set of red but not purple indices and the set of blue but not purple indices cannot intersect because if they had a common index it would be purple Therefore it is obviously optimal to place the largest numbers possible on red but not purple indices and the smallest numbers possible on blue but not purple indices To calculate the number of indices that are red but not purple we can calculate the number of red indices and subtract the number of purple indices The number of red indices is and the number of blue indices is calculated similarly To calculate the number of purple indices we need to notice that the condition index is divisible by both and is equivalent to index is divisible by where denotes the least common multiple Therefore the number of purple indices is Let be the number of red but not purple indices and let be the number of blue but not purple indices Then it is not difficult to see that the maximum score is To quickly find this sum we can use the formula for the sum of an arithmetic progression "}
{"statement": "Indiana Jones found ancient Aztec catacombs containing a golden idol The catacombs consists of n caves Each pair of caves is connected with a two way corridor that can be opened or closed The entrance to the catacombs is in the cave 1 the idol and the exit are in the cave n When Indiana goes from a cave x to a cave y using an open corridor all corridors connected to the cave x change their state all open corridors become closed all closed corridors become open Indiana wants to go from cave 1 to cave n going through as small number of corridors as possible Help him find the optimal path or determine that it is impossible to get out of catacombs ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2600", "problem_editorial": "Let us formualate a problem in terms of graph theory and make some observation Denote the start and the finish vertices as s and t Observation 1 If vertices s and t are connected with a simple path consisting of k edges then by the statement of the problem Indiana Johns may use it leading us to the answer of length k Thus the answer does not exceed d where d is the length of the shortest path between s and t if s and t are connected and otherwise Let us call path consisting only of the original edges of the graph trivial and the paths including originally non existent edges non trivial Observation 2 The length of any non trivial path is at least 4 Indeed let s v0 e1v2 e2 ekvk t be the valid path in which some of the edges ei is missing in the original graph Notice that the edge e1 may not be missing as by the moment we follow it nothing was flipped yet and e2 also may not be missing as it requires e2 to be same with e1 which was just flipped Also note that e3 may not be the last edge in our path because otherwise it must be missing in the original graph since the path is non trivial and we did not visit vertex v2 yet as v2 v1 and v2 v0 1 Thus k 4 Observation 3 If d 4 then the answer is d It immediately follows from two previous observations shortest trivial path has the length of d and shortest non trivial has the length of at least 4 4 If d 4 and there exists a vertex v2 at the distance of 2 from v0 s then there exists a non trivial path of length 4 Indeed v0 v1 v2 v0 t is such path where v1 is a vertex through which the path of length 2 between v0 and v2 passes Finally note that v2 and v0 are not initially connected otherwise the distance between v0 and v2 would be 1 hence when we visit v2 the edge v2 v0 is present Similarly by the moment of second visit of vertex v0 originally missing edge v0 t appears Observation 5 Any non trivial path of length 4 looks exactly as described in an observation 4 first two initially existent edges then newly appeared edge leading to s and finally newly appeared edge leading to t It immediately follows from the explanation of the observation 2 Observation 6 If d 4 and there no vertex v2 located at the distance 2 from s then s is connected with all vertices in its connected component and this component does not contain t Observation 7 If under conditions of the previous observation it we remove vertex s then all the vertices initially adjacent to it will be distributed into several connected components If all connected components are cliques there are no valid paths Indeed after first transition we get into some clique and then we may only move inside it and it keeps shrinking until we get to an isolated vertex from which we can not go anywhere Observation 8 If any of the connected components adjacent with s is not a clique then the shortest valid non trivial path has a length of 5 Indeed consider a connected component C initially connected with s that is not a clique It is not a clique hence it contains a vertex v1 of degree less than C 1 This vertex is not connected with a whole component C thus there are vertices v2 v3 C such that v3 is not connected with v1 while v1 and v2 are connected and v2 and v3 are also connected with an edge It means that there is a non trivial path v0 v1 v2 v3 v1 t The observations above cover all possible cases in this problem and also yield a solution working in linear time in terms of a size of the original graph "}
{"statement": "You work in a big office It is a floor building with an elevator that can accommodate up to people It is your responsibility to manage this elevator Today you are late so there are queues on some floors already For each person you know the floor where he currently is and the floor he wants to reach Also you know the order in which people came to the elevator According to the company s rules if an employee comes to the elevator earlier than another one he has to enter the elevator earlier too even if these employees stay on different floors Note that the employees are allowed to leave the elevator in arbitrary order The elevator has two commands Go up or down one floor The movement takes second Open the doors on the current floor During this operation all the employees who have reached their destination get out of the elevator Then all the employees on the floor get in the elevator in the order they are queued up while it doesn t contradict the company s rules and there is enough space in the elevator Each employee spends second to get inside and outside the elevator Initially the elevator is empty and is located on the floor You are interested what is the minimum possible time you need to spend to deliver all the employees to their destination It is not necessary to return the elevator to the floor ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "We have a strict order So let s make where means that first employees already came in the elevator and possibly came out So what is a Let s store something what will allow us to determine the state For this purpose we want to know the floor where the elevator currently is and number of people who want to reach each floor So it s integers Let s estimate the number of states floor takes values can take Also let s notice that we don t want to visit floor of nobody in the elevator don t want to go there and the next person isn t on that floor So we have not more than interesting floors for each Let s say the total count of states is Now we ve got two different solutions The fast one is we say we go from the floor to the floor and iterate over the persons who we let come in on the way The slow one is to run Dijkstra for each from we can go to the floor and let somebody come out or go to the floor Now when we calculated answers for we can calculate if state has floor equals to and there are no more than people inside The answer will be in for Asymptotics is or Solution "}
{"statement": "You have a one dimensional puzzle all the elements of which need to be put in one row connecting with each other All the puzzle elements are completely white and distinguishable from each other only if they have different shapes Each element has straight borders at the top and bottom and on the left and right it has connections each of which can be a protrusion or a recess You rotate the elements You can see that there are exactly 4 types of elements Two elements can be connected if the right connection of the left element is opposite to the left connection of the right element All possible types of elements The puzzle contains c 1 c 2 c 3 c 4 elements of each type The puzzle is considered complete if you have managed to combine elements into one long chain You want to know how many ways this can be done ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Note that the elements of the and types on the right have a connection type opposite to that on the left This means that what type of connection should be at the end of the chain to attach an element of any of these types will remain the same Therefore elements of these types can be combined into separate chains consisting only of elements of the same type Joining such a chain will not change the type of connection at the end Therefore the basis of the chain consists of elements of the and types First you need to make the basis of a chain of only them and then insert an arbitrary set of chains of elements of the and types In order to make the basis of the chain possible it is necessary that be executed Otherwise there will be extra elements left and the answer is The basis of the chain can start with an element of type if where an element of the opposite type for and vice versa If then there are options for the basis of the chain and they need to be counted separately To find the number of combinations at a fixed base of the chain we calculate two values independently and then multiply them the number of ways to arrange chains of type elements after type elements the number of ways to arrange chains of type elements after type elements and are calculated using the same formula also known as the formula of balls and partitions We want to arrange elements is equal to or depending on which value we calculate To arrange them we have positions where is the number of elements of type or similar to and is the value required to process an additional position equal to if the basis of the chain begins with an element of another type then we can put the chain in front of it for example several elements of the type in front of the type element and otherwise The number of ways to arrange indistinguishable elements in positions is where is the number of combinations To calculate the answer multiply the values of and and in the case when sum the resulting products "}
{"statement": "Ivan likes to learn different things about numbers but he is especially interested in numbers Ivan thinks that a positive integer number is if the difference between and the sum of its digits in decimal representation is not less than To prove that these numbers may have different special properties he wants to know how rare or not rare they are in fact he needs to calculate the quantity of numbers that are not greater than Ivan tried to do the calculations himself but soon realized that it s too difficult for him So he asked you to help him in calculations ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s prove that if is then is too Since the sum of digits of let s call it is not greater than then and if then So if is then is This observation allows us to use binary search to find the minimum number let s call it And if then all numbers in the segment are and not greater than so the quantity of these numbers is the answer to the problem "}
{"statement": "Tzuyu gave Sana two integers a and b and a really important quest In order to complete the quest Sana has to output the smallest possible value of a oplus x b oplus x for any given x where oplus denotes the bitwise XOR operation ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Solution Noticing the hint above we now deduce where is bitwise So just printing works but there s an even nicer formula We ll leave it up to you to prove that where is the bitwise "}
{"statement": "You are given three integers x y and n Your task is to construct an array a consisting of n integers which satisfies the following conditions a 1 x a n y a is increasing i e a 1 a 2 ldots a n if we denote b i a i 1 a i for 1 leq i leq n 1 then b is decreasing i e b 1 b 2 ldots b n 1 If there is no such array a print a single integer 1 ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "TutorialWe use the following greedy construction For all set If we ve found a solution otherwise there is no solution Proof Assume there s a solution which includes an index such that We can make for all where After several processes like this we get a solution the same as greedy construction gives This leads to a contradiction "}
{"statement": "Doremy is asked to test n contests Contest i can only be tested on day i The difficulty of contest i is a i Initially Doremy s IQ is q On day i Doremy will choose whether to test contest i or not She can only test a contest if her current IQ is strictly greater than 0 If Doremy chooses to test contest i on day i the following happens if a i q Doremy will feel she is not wise enough so q decreases by 1 otherwise nothing changes If she chooses not to test a contest nothing changes Doremy wants to test as many contests as possible Please give Doremy a solution ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "We call contests that will decrease Doremy s IQ contests and the other contests In the best solution testing the maximum number of contests there is always an index Contest is tested if Contest is good Contest is tested no matter what kind of contest it is How to prove that this conclusion For any choice we can find the last contest that is not tested and the first bad contest that is tested If we can give up contest and choose to test contest and the number of contests that is tested does not change If there is already an valid When is smallest you can get the best solution And we can find the smallest by binary search Time complexity Consider everything in the reverse order Assume that Doremy has IQ in the end Consider whether a contest should be tested in the reverse order Doremy should tested the contest because there is no decrease in her IQ and If Doremy tests the contest her IQ will decrease by so in the reverse order her IQ increases by otherwise she just skipped the contest and nothing happened Doremy can test at most contest with the property But if Doremy gets more IQ she can participate more previous good contests So she should test this contest If and Doremy cannot test the contest because her IQ is not enough So you can determine whether every contest should be tested Time complexity "}
{"statement": "Recently Vova found n candy wrappers He remembers that he bought x candies during the first day 2x candies during the second day 4x candies during the third day dots 2 k 1 x candies during the k th day But there is an issue Vova remembers neither x nor k but he is sure that x and k are positive integers and k 1 Vova will be satisfied if you tell him integer x so there is an integer k 1 that x 2x 4x dots 2 k 1 x n It is guaranteed that at least one solution exists You have to answer t independent test cases ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Notice that Thus we can replace the initial equation with the following So we can iterate over all possible in range because and check if is divisible by If it is then we can print P S I know that so many participants found the formula using geometric progression sum but there is the other way to understand this and it is a way more intuitive for me Just take a look at the binary representation of numbers we can notice that and so on Thus and so on And if we add one to this number consisting of ones then we get "}
{"statement": "Almost everything has density even a graph We define the density of a non directed graph nodes and edges of the graph have some values as follows where is the sum of the values of the nodes is the sum of the values of the edges Once DZY got a graph now he wants to find a connected induced subgraph of the graph such that the density of is as large as possible An induced subgraph of a graph is a graph that satisfies edge if and only if and edge the value of an edge in is the same as the value of the corresponding edge in so as the value of a node Help DZY to find the induced subgraph with maximum density Note that the induced subgraph you choose must be connected ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "If there is a connected induced subgraph containing more than nodes with the maximum density The density of every connected induced subgraph of it that contains only one edge can be represented as where are the values of the two nodes linked by the edge The density of the bigger connected induced subgraph is at most If and for every edge Then we ll have and and it leads to contradiction So just check every single node and every nodes linked by an edge The time complexity is check the C code here "}
{"statement": "Treeland is a country in which there are towns connected by two way road such that it s possible to get from any town to any other town In Treeland there are universities which are located in different towns Recently the president signed the decree to connect universities by high speed network The Ministry of Education understood the decree in its own way and decided that it was enough to connect each university with another one by using a cable Formally the decree will be done To have the maximum sum in the budget the Ministry decided to divide universities into pairs so that the total length of the required cable will be maximum In other words the total distance between universities in pairs should be as large as possible Help the Ministry to find the maximum total distance Of course each university should be present in only one pair Consider that all roads have the same length which is equal to ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "Let s root a tree with vertex 1 by single DFS and by the way find two values for every vertex v lv length of the edge that leads from parent of v to vertex v sv the number of universities in the subtree of vertex v including v itself Consider any optimal solution i e such solution that the total length is maximum Look at some edge that leads from the parent of v to v We claim that it should be used in min sv 2 k sv paths It obviously cannot be used more time than this value however if it is used less number of times that means there is at least one connected pair let s say a and b located in the subtree of v and at least one connected pair located outside vertices c and d By the properties of the tree paths from a to c and from b to d cover all edges of the paths from a to b and from c to d plus some extra edges meaning the current answer is not optimal Thus this edge will be used exactly min sv 2 k sv times The above means we can compute the answer value as Note that the above method doesn t provide the optimal matching itself though not many modifications required "}
{"statement": "Ntarsis has been given a set S initially containing integers 1 2 3 ldots 10 1000 in sorted order Every day he will remove the a 1 th a 2 th ldots a n th smallest numbers in S What is the smallest element in S after k days ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Problem Credits nsqrtlog Analysis nsqrtlog buffering AnswerIf is between and it will move to a new position of since positions before it are deleted "}
{"statement": "Alice and Bob received n candies from their parents Now they want to divide all candies among themselves fairly so that the total weight of Alice s candies is equal to the total weight of Bob s candies Check if they can do that Note that candies ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "If the sum of all the weights is not divisible by two then it is impossible to divide the candies between two people If the sum is divisible then let s count the number of candies with a weight of and Now if we can find a way to collect half the sum with some candies then these candies can be given to Alice and all the rest can be given to Bob Simple solution let s iterate through how many candies of weight we will give to Alice then the remaining weight should be filled by candies of weight If there are enough of them then we have found a way of division In fact if the sum is even and there are at least two candies with weight there can t be one candy then the answer is always we can collect the weight as close to half as possible with weight and then add weight If there are no candies with weight then you need to check whether is even since all the candies have the same weight you just need to divide them in half "}
{"statement": "Someone give a strange birthday present to Ivan It is hedgehog connected undirected graph in which one vertex has degree at least 3 we will call it center and all other vertices has degree 1 Ivan thought that hedgehog is too boring and decided to make himself k multihedgehog Let us define k multihedgehog as follows 1 multihedgehog is hedgehog it has one vertex of degree at least 3 and some vertices of degree 1 For all k ge 2 k multihedgehog is k 1 multihedgehog in which the following changes has been made for each vertex v with degree 1 let u be its only neighbor remove vertex v create a new hedgehog with center at vertex w and connect vertices u and w with an edge New hedgehogs can differ from each other and the initial gift Thereby k multihedgehog is a tree Ivan made k multihedgehog but he is not sure that he did not make any mistakes That is why he asked you to check if his tree is indeed k multihedgehog ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "Solution 1 Firstly let s find all vertices with degree Now we can delete them and all verticies which were incident to them must became verticies with degree And also for each new veretice with degree we must have already deleted not less then verticies If initial graph was multihedgehog after deleting vertices with degree it would became multihedgehog It could be realised using bfs starting from all initial vertices with degree Complexity is Solution 2 First of all let s find diametr of the graph After that we can find middle vertex in diameter and check if it is a center of multihedgehog using simple dfs Complexity is "}
{"statement": "A class of students got bored wearing the same pair of shoes every day so they decided to shuffle their shoes among themselves In this problem a pair of shoes is inseparable and is considered as a single object There are n students in the class and you are given an array s in order where s i is the shoe size of the i th student A shuffling of shoes is valid only if and if every student gets shoes of size their size You have to output a permutation p of 1 2 ldots n denoting a valid shuffling of shoes where the i th student gets the shoes of the p i th student p i ne i And output 1 if a valid shuffling does not exist A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "We can observe that the number of pairs of shoes greater than their size is limited for any student So if student wears shoes that are greater than their size then some student who has a size greater than student will compromise their size So say a valid shuffling exists where a student gets shoes of size greater than their own i e student got shoes of student where Then for all pairs of shoes of size one pair will go to a student whose size is smaller than This chain will continue until a student with shoe size gets a pair of shoes greater than theirs and then there will exist a pair of shoes of size that no student can wear Thus if a valid shuffling every student must get shoes of the same size as their own Hence a valid shuffling exists if more than one student has the same size shoes for all shoe sizes A valid shuffling can be generated by rearranging students shoes with the same shoe size such that no one gets their shoes This can be done in multiple ways for example cyclic rotation "}
{"statement": "Nastya received one more array on her birthday this array can be used to play a traditional Byteland game on it However to play the game the players should first select such a subsegment of the array that where is the product of all integers on the given array is their sum and is a given constant for all subsegments Nastya wonders how many subsegments of the array fit the described conditions A subsegment of an array is several consecutive integers of the array ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s call numbers which are more than 1 as Notice the following fact Indeed let s assume that a subsegment contains more than 60 numbers In this subsegment At the same time as and there is Therefore this subsegment can t be suitable due to Let s keep all positions of numbers in a sorted array We sort out possible left border of a subsegment and then with binary search we find the next number to the right of this left border Then let s iterate from this found number to the right by the numbers that is we sort out the rightmost number in a subsegment until product of all numbers in the subsegment becomes more than it s flag which shows us that product is too big for a suitable subsgment and we need to finish to iterate We have shown above the number of iterations isn t more than 60 Now for sorted out the left border and the rightmost number we only need to know the number of 1 s which needs to be added to the right of the rightmost number as we can easily maintain sum and product in the subsegment during iterating Then we need to check whether found number of 1 s exists to the right of the rightmost number It can be checked if we look at the next number s position Complexity is In order to check that is more than you shouldn t calculate multiply by due to overflow You must only check that "}
{"statement": "It is already the year 3024 ideas for problems have long run out and the olympiad now takes place in a modified individual format The olympiad consists of n problems numbered from 1 to n The i th problem has its own score a i and a certain parameter b i 1 le b i le n Initially the testing system gives the participant the problem When the participant is given the i th problem they have two options They can submit the problem and receive a i points They can skip the problem in which case they will never be able to submit it Then the testing system selects the next problem for the participant from problems with indices j such that If he submitted the i th problem it looks at problems with indices j i If he skipped the i th problem it looks at problems with indices j leq b i Among these problems it selects the problem with the index that it has to the participant he has neither submitted nor skipped it before If there is no such problem then the competition for the participant and their result is equal to the sum of points for all submitted problems In particular if the participant submits the first problem then the competition for them ends Note that the participant receives each problem Prokhor has prepared thoroughly for the olympiad and now he can submit any problem Help him determine the maximum number of points he can achieve ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 1, "problem_dificulty": "1700", "problem_editorial": "Notice that it makes no sense for us to skip problems for which since we can solve the problem earn points for it and the next problem will be chosen from the numbers If we skip it we do not earn points and the next problem will be chosen from the same set of problems or even a smaller one We also note that if we are at problem and the maximum problem number that has been assigned to us earlier in the competition is then it makes no sense to skip this problem because after skipping we could have reached the next problem from problem simply by solving problems Under these conditions it turns out that all the problems assigned to us after the competition ends are on some prefix of the set of problems i e there exists some number from to such that all problems with numbers were received by us and problems with numbers were not received This is indeed the case let be the maximum problem number that has been assigned to us After this problem is assigned we will not skip any more problems as we have already proven that it is not beneficial which means we will only solve problems and will solve all problems with numbers that have not been visited before Instead of trying to maximize the total score for the solved problems we will aim to minimize the total score for the skipped problems We will incur a penalty equal to for a skipped problem and if we solve it We know that the answer lies on some prefix so now we want to determine the minimum penalty required to reach each problem Let s solve the following subproblem We are given the same problems and the following two options if we are at problem Pay a penalty of and move to problem if such a problem exists Pay a penalty of and move to problem Now we are allowed to visit each problem as many times as we want In this case we can construct a weighted directed graph of the following form The graph has vertices each vertex corresponds to problem For each there is an edge of weight from vertex to vertex For each there is an edge of weight from vertex to vertex Thus our task reduces to finding the shortest distance from vertex to each vertex Recall that the shortest distance guarantees that on the way to vertex we visited each vertex at most once which means that if we reached problem with some penalty we can solve all problems on the prefix up to inclusive since the points for all skipped problems will be compensated by the penalty Since we already know that the optimal answer lies on one of the prefixes we need to know the total points for the problems for each prefix which can be easily done using prefix sums After that from all the values of the difference between the prefix sum and the minimum penalty needed to reach vertex we will choose the maximum across all prefixes and this will be the answer We will find the shortest distance using Dijkstra s algorithm in Prefix sums are calculated in Final asymptotic complexity "}
{"statement": "William has a favorite bracket sequence Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c 1 c 2 dots c n where c i is the number of consecutive brackets if i is an odd number or the number of consecutive brackets if i is an even number For example for a bracket sequence a corresponding sequence of numbers is 3 2 1 3 You need to find the total number of continuous subsequences subsegments l r l le r of the original bracket sequence which are regular bracket sequences A bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example sequences and are regular while and are not ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Let s examine a compressed sequence and fix two indexes l r l 2 0 r 2 1 Note that it makes no sense to examine other indexes because the correct bracket sequence always begins with the opening bracket and ends with the closing one Next we can calculate the minimum bracket balance on the segment from l 1 to r 1 The minimum bracket balance is the minimum number of opening brackets that we must put before the sequence of brackets in order for it to be regular provided that we can put any number of closing brackets at the end Let s denote this number as minBalance and denote the sum of cl 1 cl 2 cl 2 as balance The next observation is that if we fix the number of opening brackets taken from cl then we can count the number of brackets that we should take from cr Using these observations we can calculate the answer for l r using the following formula min cl cr balance max 1 minBalance 1 Note that this problem could also be solved in O n but this was not required "}
{"statement": "Consider a linear function Let s define and for For the given integer values and find the value of modulo ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "The problem was suggested by Zi Song Yeoh zscoder The problem can be solved using closed formula it s need to calculate the sum of geometric progression The formula can be calculated using binary exponentiation I ll describe more complicated solution but it s more general If we have a set of variables and at each step all variables are recalculating from each other using linear function we can use binary matrix exponentiation There is only one variable in our problem The new variable is calculating using formula Consider the matrix and the vector Let s multiply and Easy to see that we will get the vector So to make iterations we should multiply and times We can do that using binary matrix exponentiation because matrix multiplication is associative As an exercise try to write down the matrix for the Fibonacci numbers and calculate the th Fibonacci number in time The matrix and the vector is under the spoiler The matrix and the vector for the Fibonacci numbersz 0 1 1 1 v 0 1 "}
{"statement": "You have unlimited number of coins with values 1 2 ldots n You want to select some set of coins having the total value of S It is allowed to have multiple coins with the same value in the set What is the minimum number of coins required to get sum S ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Notice that using maximum value coin whenever possible will be always optimal Hence we can use coins of value Now if is not equal to then we need to use one more coin of valuation Hence our answer can be written as Overall Complexity "}
{"statement": "Burenka has two pictures a and b which are tables of the same size n times m Each cell of each painting has a color a number from 0 to 2 cdot 10 5 and there are no repeating colors in any row or column of each of the two paintings except color 0 Burenka wants to get a picture b from the picture a To achieve her goal Burenka can perform one of 2 operations swap any two rows of a or any two of its columns Tell Burenka if she can fulfill what she wants and if so tell her the sequence of actions The rows are numbered from 1 to n from top to bottom the columns are numbered from 1 to m from left to right ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3500", "problem_editorial": "Let s have two permutations of length and of length Initially both permutations are identical For operation we will execute for operation we will execute It is easy to see that after performing all operations in the position will be Now we need to find permutations of so that Let s look at a bipartite graph where the first part is rows and the second is columns Let if then from there is an undirected edge in of the color if we construct the same graph for then we need to check for isomorphism two bipartite graphs each edge of which has a color and as we remember by the condition of the vertex 2 edges of the same color cannot be Incidence Let s call them graph and graph This problem is largely for implementation therefore starting from this moment the actions that you can observe in the author s solution are described 168728958 Let otherwise let s swap and in places Let s try to match the elements of the array to the elements of the array Let s go through the indices from to Let s now choose which pair of to choose for the th vertex of the first fraction of the graph If we have already found a pair earlier skip the step otherwise let s sort out the appropriate option for the pair among all the vertices of the first component that do not yet have a pair there are no more than after the vertices are matched the edges are also uniquely matched because there are no 2 edges of different colors let s then run the substitution recursively for edges if we have mapped the vertex to the vertex and from there is an edge of color in and from there is an edge in then it is easy to prove that in the answer will be mapped to which means we will restore the entire component Let the sum of the number of vertices and the number of edges in the component be then we will perform no more than actions to restore the component by permutations getting a sequence of swaps is a matter of technique I will not explain it but this is a separate function in the author s solution you will understand in total our solution works for or where is the total number of vertices and edges in all components feel free to ask any questions "}
{"statement": "Polycarp bought a new expensive painting and decided to show it to his n friends He hung it in his room n of his friends entered and exited there one by one At one moment there was no more than one person in the room In other words the first friend entered and left first then the second and so on It is known that at the beginning before visiting friends a picture hung in the room At the end after the n th friend it turned out that it disappeared At what exact moment it disappeared there is no information Polycarp asked his friends one by one He asked each one if there was a picture when he entered the room Each friend answered one of three response encoded with response encoded as response is encoded with Everyone except the thief either doesn t remember or told the The thief can say anything any of the three options Polycarp cannot understand who the thief is He asks you to find out the number of those who can be considered a thief according to the answers ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "First let s note that we will have a transition from to only once otherwise it turns out that first the picture disappeared then it appeared and disappeared back but we can consider that a friend in the middle who answered lied to us but this is not true because even before him the picture disappeared So we need to find this transition Since we can also meet we find the index of the leftmost in case of absence we take and mark it as and the index of rightmost in case of absence we take and mark as Answer the number of indices between them inclusive because only they could lie There could not be a thief to the left of since either the friend under the index lied or the picture was not stolen before There could not be a thief to the right of since either the painting had already been stolen in the presence of s friend or it was he who lied "}
{"statement": "Let number be such number that adding some leading zeros possible none to it produces a palindromic string String is called a palindrome if it reads the same from left to right and from right to left For example numbers and are they can be transformed to strings and respectively which are palindromes You are given some integer number Check if it s a number ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "You can check if the given is by removing all the trailing zeros and checking if resulting string is a palindrome "}
{"statement": "As mentioned previously William really likes playing video games In one of his favorite games the player character is in a universe where every planet is designated by a binary number from 0 to 2 n 1 On each planet there are gates that allow the player to move from planet i to planet j if the binary representations of i and j differ in exactly one bit William wants to test you and see how you can handle processing the following queries in this game universe Destroy planets with numbers from l to r inclusively These planets cannot be moved to anymore Figure out if it is possible to reach planet b from planet a using some number of planetary gates It is guaranteed that the planets a and b are not destroyed ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "Let s change the formulation of the problem we will execute queries in reverse order and assign a lifetime to each segment of blocked vertices Lifetime until what moment the segment is blocked Note if we look through the requests in reverse order then for each segment it is possible to determine the moment of time after which the vertices from this segment cease to be blocked Thus the problem looks like this given a graph that is an dimensional hypercube each vertex has edges to adjacent vertices that differ from it by only one coordinate and there are blocked vertex segments that live up to the time Consider the following fact If we take an dimensional hypercube and sequences of vertices and then the numbers in the corresponding positions from these two sequences are neighbours to each other since they differ only in the most significant bit that is in the bit For a better understanding let s depict this for Here denotes that is a neighbour of and is present in the first sequence and in the second For simplicity we will only prohibit movement between a blocked vertex and an unblocked one Let s learn how to get a compressed graph each vertex of which would represent a connected subset of the vertices of the hypercube Also this set which represents a vertex is a set of consecutive vertices that is it is a segment On each edge of this graph is written the time when this edge begins to exist Time makes sense since an edge can be drawn between a vertex that represents a set of blocked vertices and a vertex that represents a set of unblocked vertices And the time on this edge there will be a moment in time when the set of vertices is unblocked Recall that now we are solving a problem in which the vertices are blocked until a certain moment in time The answer to the reachability request is the reachability request for a given compressed graph It is only necessary to correctly determine the reachability of which two vertices of the compressed graph we are interested in Let s learn how to recursively build a given compressed graph Input data for the construction of this graph are the dimension of the hypercube the set of blocked vertices If there are no segments worth blocking then the compressed graph is one vertex which is responsible for the connected set of hypercube vertices If there is one segment then the compressed graph is one vertex representing all vertices and they are all blocked Otherwise we can divide the hypercube into two parts by the most significant bit That is into two hypercubes of dimensions And each segment can go further as input either into two hypercubes or into one of them Having received compressed graphs from each of the two hypercubes we can match the adjacent vertices of these hypercubes as illustrated above It is not difficult to combine two such graphs since each vertex of the graph describes the set of vertices of the hypercube and this set is a segment therefore if we have the vertices of the first and second graphs and respectively in ascending order of the segments for which they answer then it is possible to combine these two graphs in time and create no more than edges and obtain a new graph of size In total the resulting graph will have a size of and the final asymptotics will be where is the cost of the operation in the DSU The DSU is needed to pass queries in reverse order and connect the edges at the right times when the edges begin to exist The asymptotics is as follows since each vertex of the graph may go through all layers of recursion as you may have noticed the solution procedure resembles divide and conquer and at the same time create a new edge in each layer And the graph has such a size since each blocked segment in this procedure can be split into segments For a better understanding see the author s solution "}
{"statement": "There are knights sitting at the Round Table at an equal distance from each other Each of them is either in a good or in a bad mood Merlin the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the polygon can be found On all vertices of the polygon knights in a good mood should be located Otherwise the next month will bring misfortunes A convex polygon is regular if all its sides have same length and all his angles are equal In this problem we consider only regular polygons with at least 3 vertices i e only nondegenerated On a picture below some examples of such polygons are present Green points mean knights in a good mood Red points mean ones in a bad mood King Arthur knows the knights moods Help him find out if the next month will be fortunate or not ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Define an good polygon as a regular polygon which has a knight in a good mood in every of its vertex Side of polygon we will measure in arcs which is obtained by dividing border of round table with knights Freeze the length of the side Let this length equals k Observe that the regular polygon with such length of side exists only if k divides n We have exactly k of such polygons Every of them has exactly n k vertices Check every of the polygons for goodness by review all of its vertices If sum of vertices with knight in a good mood equals to n k this polygon is good Checking of all polygons with some frozen length of side works in an O n Now observe that n has of divisors Really all divisors may be except only one we can divide into pairs for i corresponds n i for i n i there is no pair One of divisors in every pair less than It means thah number of pairs no more than and number of divisors no more than It gives solution iterate over all divisors of n and for every of them check existence of good polygon with length side equals this divisor Solution has an time In reality for big n is has divisors So solution actually has O n4 3 complexity For all numbers less than 105 maximal number of divisors is 128 UPD There was found an solution by some participants This solution uses following idea If we have a good polygon with xy vertices we also have a good polygon with x vertices So we can check only prime divisors of n except 2 here we must check 4 "}
{"statement": "You are given four integers n m l and r Let s name a tuple x 1 y 1 x 2 y 2 as if 1 le x 1 x 2 le n 1 le y 2 y 1 le m x 1 cdot y 1 x 2 cdot y 2 l le x 1 cdot y 1 le r Find any good tuple ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "Let s look at where It can be proven that there always exists such pair and that and Brief proof is following calculate then let and Obviously such will make from and from if And since and since As we can see divides so if we will iterate over all pairs where there will be pairs in total Let s fix value of Then from one side but from the other side since then Anyway all valid form a segment possibly empty segment And we need to find any that divides any from the segment and doesn t exceed Obviously it s optimally to find the minimum possible such and just check inequality We can find such for a fixed using for example built in in a set with all divisors for all valid To maintain this set we can note that simillary So we can move valid segment s ends as two pointers Each pair will be added and erased from the segment exactly once That s why the total complexity of maintaining the set of divisors as well as the total complexity of queries for each will be equal to All pairs and can be precalculated in using the sieve like algorithm "}
{"statement": "Chiori loves dolls and now she is going to decorate her bedroom As a doll collector Chiori has got n dolls The i th doll has a non negative integer value a i a i 2 m m is given Chiori wants to pick some maybe zero dolls for the decoration so there are 2 n different picking ways Let x be the bitwise xor sum of values of dolls Chiori picks in case Chiori picks no dolls x 0 The value of this picking way is equal to the number of 1 bits in the binary representation of x More formally it is also equal to the number of indices 0 leq i m such that left lfloor frac x 2 i right rfloor is odd Tell her the number of picking ways with value i for each integer i from 0 to m Due to the answers can be very huge print them by modulo 998 244 353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Build linear basis with given numbers Suppose is the length of is the set consisted of numbers which can be produced in is equal to the number of where and is equal to the number of doll picking ways with value Thus Enumerate each base of is picked or not so you can find out the whole in and get Note that you should implement in to make sure the whole algorithm runs in Let s assume the highest bits in every base are so in there are key bits and non key bits We can get a new array of bases by Gauss Jordan Elimination such that every key bit is in exactly one base and is in other bases Then let be if we consider the first bases in the number of ways that key bits are in xor sum and the binary status of all non key bits is Enumerate th base suppose it is equal to is picked or not we write the state transition At last we add up to In conclusion we get an algorithm So far the easy version can be passed if you write a solution which runs Algorithm 1 or Algorithm 2 by the value of We can regard as a long zero indexation array satisfying Similarly we define a long zero indexation array satisfying By XOR Fast Walsh Hadamard Transform we calculate also can be written as is equal to the th number of resulting array That means is also equal to the sum of every number in only contains two different values and Proof The linear space satisfies closure which means Thus We can proved the lemma by solving an equation The th number of is if and only if is always even where is any of bases in Proof XOR Fast Walsh Hadamard Transform tells us the th number of is equal to the sum of for each Once we find a base such that is odd the sum must be according to Lemma 1 The indices of which their values are compose an Proof See Lemma 2 If is even is even obviously is even Suppose is the orthogonal linear basis The length of is Proof We know that so From this we then find that should be which means the length of is Let the key bits in are non key bits in and the non key bits in are key bits in Now I ll show you how to get the bases in Divide key bits for and put them to the left Similarly we put the key bits in to the right Let s make those key bits form a diagonal Look at the following picture Do you notice that the non key bit matrices green areas are symmetrical along the diagonal The proof is intuitive should be even according to Lemma 2 where is any of bases in and is any of bases in Since we ve divided key bits for two linear basis is not more than Once two symmetrical non key bits are respectively there will exist satisfying Otherwise is always or In order to get you can also divide into small linear basis construct their orthogonal linear basis and intersect them It is harder to implement The th number of only depends on Proof The th number of only depends on so it still holds after Fast Walsh Hadamard Transform Let be the th number of Again Fast Walsh Hadamard Transform tells us Note that Let s enumerate There are different intersections each one has ways to generate the remaining part of So It takes to calculate all necessary combinatorial numbers and Finally let s consider the sum of every number in Suppose is equal to the number of where and We can easily get Just like Algorithm 1 We can enumerate each base of is picked or not find out the whole in get and calculate at last Since one of has a length of not more than we just need to enumerate bases of the smaller one in order to pass the hard version in "}
{"statement": "You have to restore the wall The wall consists of N pillars of bricks the height of the i th pillar is initially equal to h i the height is measured in number of bricks After the restoration all the N pillars should have equal heights You are allowed the following operations put a brick on top of one pillar the cost of this operation is A remove a brick from the top of one non empty pillar the cost of this operation is R move a brick from the top of one non empty pillar to the top of another pillar the cost of this operation is M You cannot create additional pillars or ignore some of pre existing pillars even if their height becomes 0 What is the minimal total cost of restoration in other words what is the minimal total cost to make all the pillars of equal height ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "First of all let s do M min M A R this is true since we can emulate moving by adding removing After that it is never profitable to add and remove in one solution since we can always move instead Suppose we have fixed H the resulting height for all pillars How can we calculate the minimal cost for given H Some pillars have no more than H bricks let the total number of missing bricks in these pillars be P Other pillars have no less than H bricks let the total number of extra bricks in these pillars be Q If P ge Q then we are missing P Q bricks in total so we have to make P Q additions There won t be any more additions or removals and we have to do at least Q moves since we have to somehow get rid of extra bricks from those pillars which have more than H bricks initially It is clear that Q moves is enough Therefore the total cost will be C A P Q MQ Similarly if Q ge P then the total cost will be C R Q P MP Let s now assume that P ge Q we have exactly X pillars with no more than H bricks and exactly N X pillars with strictly more than H bricks Let s try to increase H by 1 and see how the total cost will change P P X Q Q N X Q N X C A P Q MQ A P X Q N X M Q N X A P Q MQ AN M N X We can see that the total cost has changed by AN M N X While X is constant the cost change will be constant What are the moments when X changes When H is equal to the initial height of some pillar Therefore the cost as a function of H is piecewise linear with breakpoints in points corresponding to initial heights There is a nuance we have assumed P ge Q The same thing will be true for P le Q but there can be additional breakpoints when we change between these two states This change will happen only once for H approx frac sum h i N approximate equality here means that this point can be non integral so we should add both lfloor frac sum h i N rfloor and lceil frac sum h i N rceil as breakpoints The minima of piecewise linear function are in breakpoints so it is enough to calculate the cost for breakpoints initial heights and H approx frac sum h i N and choose minimal of them To calculate the cost for given H fast we can sort the initial heights and calculate prefix sums of heights Then using binary search we can determine which pillars have height less than H and greater than H and then calculate P and Q using prefix sums We can use two pointers instead of binary searches but it will not improve the total complexity which is O N log N due to sorting and binary searches if we are using them "}
{"statement": "You are given a table a of size n times m We will consider the table rows numbered from top to bottom from 1 to n and the columns numbered from left to right from 1 to m We will denote a cell that is in the i th row and in the j th column as i j In the cell i j there is written a number i 1 cdot m j that is a ij i 1 cdot m j A turtle initially stands in the cell 1 1 and it wants to come to the cell n m From the cell i j it can in one step go to one of the cells i 1 j or i j 1 if it exists A path is a sequence of cells in which for every two adjacent in the sequence cells the following satisfies the turtle can reach from the first cell to the second cell in one step A cost of a path is the sum of numbers that are written in the cells of the path For example with n 2 and m 3 the table will look as shown above The turtle can take the following path 1 1 rightarrow 1 2 rightarrow 1 3 rightarrow 2 3 The cost of such way is equal to a 11 a 12 a 13 a 23 12 On the other hand the paths 1 1 rightarrow 1 2 rightarrow 2 2 rightarrow 2 1 and 1 1 rightarrow 1 3 are incorrect because in the first path the turtle can t make a step 2 2 rightarrow 2 1 and in the second path it can t make a step 1 1 rightarrow 1 3 You are asked to tell the turtle a minimal possible cost of a path from the cell 1 1 to the cell n m Please note that the cells 1 1 and n m are a part of the way ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s notice that the optimal path looks like the following The proof is relatively easy all paths from to consist of cells and in the optimal path we have minimized all numbers in the path The cost of such path is equal to This sum can be found in by just summarizing all numbers or it can be found in if you remember that "}
{"statement": "Gerald found a table consisting of rows and columns As a prominent expert on rectangular tables he immediately counted the table s properties that is the minimum of the numbers in the corners of the table minimum of four numbers However he did not like the final value it seemed to be too small And to make this value larger he decided to crop the table a little delete some columns on the left and some on the right as well as some rows from the top and some from the bottom Find what the maximum property of the table can be after such cropping Note that the table should have at least two rows and at least two columns left in the end The number of cropped rows or columns from each of the four sides can be zero ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "In this problem we must to find maximal value of minimum of values on four intersections of two rows and two columns of table In another words we are looking for maximum value of for all such that Lets us binary search of the answer For us it we must can define is there two rows and two colums with ones on all four its intersections in other words integers so that Lets consider all pair of natural numbers so that there exist nutural number so that Existence of two equals such pairs is equals to existence of above four numbers But it is can be only such pairs Therefore we can make the array where we will mark pair who were meets Lets iterate all pairs in any order until we meet repeated pair or pairs are ends So we have solution of time "}
{"statement": "Sasha wants to take a walk with his girlfriend in the city The city consists of n intersections numbered from 1 to n Some of them are connected by roads and from any intersection there is exactly one simple path dagger to any other intersection In other words the intersections and the roads between them form a tree Some of the intersections are considered dangerous Since it is unsafe to walk alone in the city Sasha does not want to visit three or more dangerous intersections during the walk Sasha calls a set of intersections if the following condition is satisfied If in the city only the intersections contained in this set are dangerous then any simple path in the city contains dangerous intersections However Sasha does not know which intersections are dangerous so he is interested in the number of different good sets of intersections in the city Since this number can be very large output it modulo 998 244 353 dagger A simple path is a path that passes through each intersection at most once ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let dpv be the number of non empty sets of vertices in the subtree rooted at v such that there are no pairs of vertices in the set where one vertex is the ancestor of the other Then dpv dpu1 1 dpu2 1 dpuk 1 where u1 uk are the children of vertex v This is because from each subtree you can choose either any non empty set or an empty set Choosing an empty set from each subtree implies that only the single vertex v is selected since our dynamic programming state cannot be empty Now the claim is the answer to the problem is dp1 dp2 dpn 1 This is because if we consider the case where there is a pair of vertices where vertex v is the ancestor of the other the answer in this case is dpu1 dpuk as we can select such a set of vertices exactly from one subtree from the dynamic programming states And here we are using non empty sets in the dynamic state since otherwise the case where there are no vertices where one is the ancestor of the other would be counted And dp1 1 where 1 is the root of the tree accounts for the scenarios where there is no vertex where one is the ancestor of the other "}
{"statement": "You are playing a game The circle is divided into n sectors sectors are numbered from 1 to n in some order You are in the adjacent room and do not know either the number of sectors or their numbers There is also an arrow that initially points to some sector Initially the host tells you the number of the sector to which the arrow points After that you can ask the host to move the arrow k sectors counterclockwise or clockwise at most 2023 times And each time you are told the number of the sector to which the arrow points Your task is to determine the integer n the number of sectors in at most 2023 queries It is guaranteed that 1 le n le 10 6 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Let be the numbers of the sectors in clockwise order and let the arrow initially point to the sector with number First let s make queries of 1 then we will know the numbers of consecutive sectors If then the number of the first query that gives the answer is the desired If we did not find this means that Let s save Now we will make queries of 1000 until we get one of the numbers as the answer Note that we will need no more than queries of this type after which it is easy to determine the number Thus we can determine the number in no more than queries "}
{"statement": "Given n integers a 1 a 2 dots a n You can perform the following operation on them select any element a i 1 le i le n and divide it by 2 round down In other words you can replace any selected element a i with the value left lfloor frac a i 2 right rfloor where left lfloor x right rfloor is round down the real number x Output the minimum number of operations that must be done for a sequence of integers to become strictly increasing that is for the condition a 1 lt a 2 lt dots lt a n to be satisfied Or determine that it is impossible to obtain such a sequence Note that elements be swapped The only possible operation is described above For example let n 3 and a sequence of numbers 3 6 5 be given Then it is enough to perform two operations on it Write the number left lfloor frac 6 2 right rfloor 3 instead of the number a 2 6 and get the sequence 3 3 5 Then replace a 1 3 with left lfloor frac 3 2 right rfloor 1 and get the sequence 1 3 5 The resulting sequence is strictly increasing because 1 lt 3 lt 5 ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "We will process the elements of the sequence starting from the end of the sequence Each element will be divided by until it is less than If at some point it turns out that it is impossible to obtain the desired sequence "}
{"statement": "You ve got array consisting of integers and a positive integer Array is indexed by integers from to You need to permute the array elements so that value became minimal possible In particular it is allowed not to change order of elements at all ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "We can divide all indices into groups by their remainder modulo While counting we can consider each group separately and sum the distances between neighbouring numbers in each group Consider one group corresponding to some remainder modulo i e containing for Let s write down its numbers from left to right Then this group adds to the overall sum the value We can notice that if we sort in non decreasing order this sum will not increase So in the optimal answer we can consider that numbers in each group don t decrease Furthermore in that case this sum is equal to Now consider two groups and both sorted in non decreasing order We claim that either or i e segments and can have common points only in their endpoints Why is this true These groups add to the overall sum We consider the case the other is symmetric If then swapping and will not increase the values these groups add to the answer since the right border of group moves to the left and the left border of group moves to the right So in that case and the assertion is proved Now we know that the values in each group should from a continuous segment of the sorted original array In fact we have groups of size so called small groups and groups of size so called large groups Consider the following dynamic programming the minimal sum of values added to the answer by large groups and small groups if we choose the elements for them from the first elements of the sorted array There are no more than states and each transition can be made in we choose large or small group to add and obtain the number it adds to the sum by subtracting two elements of the sorted array The answer for the problem will be in The overall complexity of the solution is We can note that in pretests was quite small and some slower solutions could pass but they failed on final tests Problem author zeliboba Problem developers Kostroma riadwaw Solution code 12873418 "}
{"statement": "You are given an array a of length n You are asked to process q queries of the following format given integers i and x multiply a i by x After processing each query you need to output the greatest common divisor GCD of all elements of the array a Since the answer can be too large you are asked to output it modulo 10 9 7 ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Notice that after each query the answer doesn t become smaller and we can solve the problem for each prime divisor independently For each number let s maintain an amount of occurences for all its prime divisors you can implement it using For each prime divisor let s write to its corresponding the amount of times it is met in every of the numbers of the array at the same time we won t add null values Initially Let s understand the way a prime divisor is included in the answer If the size of its is not equal to then won t change otherwise where is a minimal number of Since is not decreasing then we can avoid calculating it all over again every time and instead recalculate it only for divisors that are being changed with that because the minimal number of is not decreasing as well we can just increase the answer using multiplication To process the query we need to find the prime factorization of for example using the Sieve of Eratosthenes and add the prime divisors to the for th element and correspondingly change the for that divisor Each query is processed in the complexity of the amount of prime divisors multiplied by the time of and operation i e "}
{"statement": "In Berland recently a new collection of toys went on sale This collection consists of types of toys numbered with integers from to A toy from the new collection of the th type costs bourles Tania has managed to collect different types of toys from the new collection Today is Tanya s birthday and her mother decided to spend no more than bourles on the gift to the daughter Tanya will choose several different types of toys from the new collection as a gift Of course she does not want to get a type of toy which she already has Tanya wants to have as many distinct types of toys in her collection as possible as the result The new collection is too diverse and Tanya is too little so she asks you to help her in this ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Our task is to take largest amount of toys Tanya doesn t have yet the way the sum of their costs doesn t exceed To do that one can perform greedy algorithm let s buy the cheepest toy Tanya doesn t have at every step while the amount of money left are sufficient to do that The boolean array can be a handle in that storing values in indices equal to toy types which Tanya does have at the moment As soon as money is sufficient to buy no more than toys is enough to be sized we won t buy the toys with types numbered greater So we just need to iterate over the number of type we want to buy and if corresponding value in is equal to we should buy it otherwise we can t The solution complexity is One can use the data structure C texttt std set for example for storing the types Tanya has at the moment In this case the complexity is "}
{"statement": "You ve got two rectangular tables with sizes and cells The tables consist of zeroes and ones We will consider the rows and columns of both tables indexed starting from 1 Then we will define the element of the first table located at the intersection of the th row and the th column as we will define the element of the second table located at the intersection of the th row and the th column as We will call the pair of integers a of the second table relative to the first one We ll call the of the shift value where the variables take only such values in which the expression makes sense More formally inequalities must hold If there are no values of variables that satisfy the given inequalities the value of the sum is considered equal to 0 Your task is to find the shift with the maximum overlap factor among all possible shifts ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "In this problem you should carefully consider every shift count the answer and find the maximum value The complexity of solution is "}
{"statement": "Marmot found a row with pillars The th pillar has the height of meters Starting from one pillar Marmot wants to jump on the pillars From a pillar Marmot can jump on a pillar only if and where is the absolute value of the number Now Marmot is asking you find out a jump sequence with maximal length and print it ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "We have to find a substring such that for Let s suppose that the values in are smaller We can make dynamic programming this way the maximal length of such a substring ending in the th position with and or So we can easily search this maximum in a data structure such as an segment tree or Fenwick tree But those data structure must have the size of which can be For our constraints we mantain the idea described above but instead of going at some specific position in the data structure based on a value we would normalize the values in and binary search the new index where we should go for an update or a query in the data structure Therefore the data structure will have the size The complexity of this solution is "}
{"statement": " She calls such an array a good that for all i 2 le i le n takes place gcd a i 1 a i 1 where gcd u v denotes the greatest common divisor GCD of integers u and v You can perform the operation select two indices i j 1 le i j le n i neq j and two integers x y 1 le x y le 2 cdot 10 9 so that min a i a j min x y Then change a i to x and a j to y The girl asks you to make the array good using n operations It can be proven that this is always possible ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "There are many ways to solve the problem Here is one of them We will use the fact that for any integer Let s find the minimum element of the array that is located in the position Then for all integer perform the following operation That s how we replace to The main condition is satisfied because always equals to and this value always less than any other element in the array Consider the structure of the array after performing the operations describing above Let s define and These are the leftmost and the rightmost elements in the array respectively The array looks like Thus we obtain an absolute difference equal to one between all pairs of adjacent elements "}
{"statement": "The legendary Farmer John is throwing a huge party and animals from all over the world are hanging out at his house His guests are hungry so he instructs his cow Bessie to bring out the snacks Moo There are n snacks flavors numbered with integers 1 2 ldots n Bessie has n snacks one snack of each flavor Every guest has exactly two favorite flavors The procedure for eating snacks will go as follows First Bessie will line up the guests in some way Then in this order guests will approach the snacks one by one Each guest in their turn will eat all remaining snacks of their favorite flavor In case no favorite flavors are present when a guest goes up they become very sad Help Bessie to minimize the number of sad guests by lining the guests in an optimal way ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1700", "problem_editorial": "Since every animal has exactly two favorite snacks this hints that we should model the problem as a graph The nodes are the snacks and the edges are animals with preferences connecting snack nodes Let s consider a connected component of the graph with size greater than 1 The first animal edge in that component to eat must take two snacks nodes all other snack nodes will be eaten by exactly one animal edge It is always possible to find an order so that no other animals takes two snacks for example BFS order Thus a connected component with c vertices can satisfy at most c 1 animals Let N be the number of snacks M be the number of animals and C be the number of connected components including those of size 1 The number of satisfied animals is N C so the number of of unhappy animals is M N C "}
{"statement": "Little Lesha loves listening to music via his smartphone But the smartphone doesn t have much memory so Lesha listens to his favorite songs in a well known social network InTalk Unfortunately internet is not that fast in the city of Ekaterinozavodsk and the song takes a lot of time to download But Lesha is quite impatient The song s duration is seconds Lesha downloads the first seconds of the song and plays it When the playback reaches the point that has not yet been downloaded Lesha immediately plays the song from the start the loaded part of the song stays in his phone and the download is continued from the same place and it happens until the song is downloaded completely and Lesha listens to it to the end For seconds of real time the Internet allows you to download seconds of the track Tell Lesha for how many times he will start the song including the very first start ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Suppose we have downloaded seconds of the song and press the play button Let s find how many seconds will be downloaded when we will be forced to play the song once more Hence Solution let s multiply by while The answer is the amount of operations Complexity "}
{"statement": "Find the number of ways to divide an array a of n integers into any number of disjoint non empty segments so that in each segment there exist at most k distinct integers that appear exactly once Since the answer can be large find it modulo 998 244 353 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Let be the number of integers that appear exactly once in the segment We can use the following recurrence to compute the answer where A naive implementation will definitely be too slow To compute the said recurrence efficiently we will do as follows First let s design an array so that is the sum of elements in segment Ideally it should be easy i e require only a few operations to transform this array into another array that would work with instead One design is as follows First let each entry of be This array now works imaginarily when To make it work for consider the element If this value appeared before at least twice set where is the second last appearance of not counting the appearance at index If this value appeared before at least once set where is the last appearance of Finally set Now you can see that the sum in the segment correctly represents for any Let us divide the array into blocks so that each block contains elements assume for simplicity that divides Each block corresponding to some segment should store sum of elements in i e and for each sum of where is less than or equal to A modification to for some index will require an update With array ready for our we are ready to compute Let be a temporary variable initially equal to For each that belongs to the same block as add to if and also add to This runs in To account for the left possible endpoints from other blocks for each block starting from one directly to the left of the block that contains to the leftmost block Suppose this block corresponds to the segment Let If do nothing If add to If add to Add to The step above runs in That is our algorithm takes time to compute for some The time complexity is since there are values of that we need to compute for If we choose our solution would run in "}
{"statement": "Adilbek was assigned to a special project For Adilbek it means that he has n days to run a special program and provide its results But there is a problem the program needs to run for d days to calculate the results Fortunately Adilbek can optimize the program If he spends x x is a non negative integer days optimizing the program he will make the program run in left lceil frac d x 1 right rceil days left lceil a right rceil is the ceiling function left lceil 2 4 right rceil 3 left lceil 2 right rceil 2 The program cannot be run and optimized simultaneously so the total number of days he will spend is equal to x left lceil frac d x 1 right rceil Will Adilbek be able to provide the generated results in no more than n days ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "At first let s note that if is integer and and are non negative then So instead of looking at we can consider It s easier since the function is more common function and it can be proven that it s concave upward It means that this function has a unique minimum and moreover we can calculate it has minimum value in and Since the ceiling function is monotonically increasing so we can assume that for all So we can just iterate from to and check the unequation The total complexity is equal to There is a simple optimization because of the monotone ceiling we can prove that we need to check only and "}
{"statement": "Mad scientist Mike is building a time machine in his spare time To finish the work he needs a resistor with a certain resistance value However all Mike has is lots of identical resistors with unit resistance Elements with other resistance can be constructed from these resistors In this problem we will consider the following as elements one resistor an element and resistor plugged in sequence an element and resistor plugged in parallel With the consecutive connection the resistance of the new element equals With the parallel connection the resistance of the new element equals In this case equals the resistance of the element being connected Mike needs to assemble an element with a resistance equal to the fraction Determine the smallest possible number of resistors he needs to make such an element ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "If a fraction can be obtained with resistors then it is simple to calculate that we can obtain fractions and with resistors So adding one resistor means performing one operation backwards in Euclidean algorithm That means that the answer is equal to the number of steps in standard Euclidean algorithm Solution complexity Problem authors gen andreyv At first we thought about the major problem any two elements can be joined but had a moment of eureka and got that the given problem unexpectedly naturally can be reduced to GCD By the way the result tree http en wikipedia org wiki Calkin "}
{"statement": "Once people simultaneously signed in to the reception at the recently opened but already thoroughly bureaucratic organization abbreviated TBO As the organization is thoroughly bureaucratic it can accept and cater for exactly one person per day As a consequence each of people made an appointment on one of the next days and no two persons have an appointment on the same day However the organization workers are very irresponsible about their job so none of the signed in people was told the exact date of the appointment The only way to know when people should come is to write some requests to TBO The request form consists of empty lines Into each of these lines the name of a signed in person can be written it can be left blank as well Writing a person s name in the same form twice is forbidden such requests are ignored TBO responds very quickly to written requests but the reply format is of very poor quality that is the response contains the correct appointment dates for all people from the request form but the dates are in completely random order Responds to all requests arrive simultaneously at the end of the day each response specifies the request that it answers Fortunately you aren t among these lucky guys As an observer you have the following task given and determine the minimum number of requests to submit to TBO to clearly determine the appointment date for each person ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Let s imagine that we have a magic function maxN m k that returns given m and k the largest value of n such that it s possible to solve the problem for n people and m empty lines in the form using k requests Then we ll be able to use binary search on the answer the number of requests k Suppose we ve made k requests Let s match a string of length k to each person where the i th character is equal to 1 if this person is mentioned in the i th request and 0 otherwise Note that we ll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct Indeed if two persons strings are the same their appointment dates could be exchanged and the responses to the requests wouldn t have changed If all strings are distinct for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests The constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall Thus function maxN m k should return the maximum size of a set of distinct k bit strings meeting this condition Let s make this restriction weaker we ll search for a set such that the total number of ones in all n strings doesn t exceed k m As we ll prove later the answer won t change With this weaker restriction the problem can be solved using a simple greedy strategy It s obvious that strings with smaller number of ones are better Let s loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones initially it s equal to k m Then at the i th step we can take at most strings containing i ones Let s add p to the answer and subtract p i from t Note that the values of Cki should be calculated with care they can turn out to be too large so it s important not to allow overflows It can be shown that the overall complexity of this algorithm is at most O log2 n The remaining thing is to prove the claim above The idea of the proof below belongs to rng 58 the author s proof is notably harder Let s solve the problem with a greedy algorithm with the k m constraint on the total number of ones The resulting set of strings may not satisfy the restriction of m ones for each position If it doesn t some of the positions contain more than m ones and some contain less than m ones Let s pick any position X containing more than m ones and any position Y containing less than m ones Find all strings containing 1 at X and 0 at Y suppose there are x such strings and all strings containing 0 at X and 1 at Y suppose there are y such strings It s clear that x y In each of x strings we can try to put 0 at X and 1 at Y then the string we obtain will either remain unique in this set or coincide with one of those y strings but only one As x y for at least one of x strings the change above leaves this string unique Let s take this string and put 0 at X and 1 at Y Now position X contains one 1 less and position Y contains one 1 more It means that the total number of extra ones in the positions has been decreased as Y still contains no more than m ones Doing this operation for a needed number of times we ll achieve our goal "}
{"statement": "Recall that the sequence b is a a subsequence of the sequence a if b can be derived from a by removing zero or more elements without changing the order of the remaining elements For example if a 1 2 1 3 1 2 1 then possible subsequences are 1 1 1 1 3 and 1 2 1 3 1 2 1 but not 3 2 3 and 1 1 1 1 2 You are given a sequence a consisting of n positive and negative elements there is no zeros in the sequence Your task is to choose length subsequence of the given sequence i e the sign of each next element is the opposite from the sign of the current element like positive negative positive and so on or negative positive negative and so on Among all such subsequences you have to choose one which has the of elements In other words if the maximum length of subsequence is k then your task is to find the of elements of some subsequence of length k You have to answer t independent test cases ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Firstly let s extract maximum by inclusion segments of the array that consists of the numbers with the same sign For example if the array is then these segments are and We can do it with any two pointers like algorithm The number of these segments is the maximum possible length of the alternating subsequence because we can take only one element from each block And as we want to maximize the sum we need to take the maximum element from each block Time complexity "}
{"statement": "In world there are m different film endings Abendsen owns a storage and a shelf At first he has n ordered films on the shelf In the i th month he will do Empty the storage Put k i cdot m films into the storage k i films for each ending He will think about a question if he puts all the films from the shelf into the storage then randomly picks n films from all the films in the storage and rearranges them on the shelf what is the probability that sequence of endings in l i r i on the shelf will not be changed Notice he just thinks about this question so the shelf will not actually be changed Answer all Abendsen s questions Let the probability be fraction P i Let s say that the total number of ways to take n films from the storage for i th month is A i so P i cdot A i is always an integer Print for each month P i cdot A i pmod 998244353 998244353 is a prime number and it is equal to 119 cdot 2 23 1 It is guaranteed that there will be only no more than 100 different k values ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "First we claim the probability is this Where is the number of times ending occurs in total and is the number of times ending occurs in segment Proof For each position in with ending you can choose any film with the same ending there are of them for the first candidate and of them for the second candidate So you can satisfy the conditions with number of ways After that other positions can be filled arbitrarily there are ways of doing that And the total number of ways is obviously If we can maintain the expression using Mo algorithm with complexity about More precisely it is or Key observation There can only be different occuring times at most Proof In the worst case the occurring times are so Similarly that there are at most different combinations of and Proof In the worst case pairs of are like 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 Let its length of same be and repeat time be Then from the total occurring times we get and from the occurring times in segment we get So around we achieve the minimum Use a hash table actually an array of size to remember them and brute force them for each query We re done About the part since there are no more than different value preprocess that for each Complexity Actually due to limit of if one simply run mo algorithm times it will reach a Under this limit it can be faster than standard solution Bonus can we have a solution that does not depend on if only part is calculated and faster than "}
{"statement": "Having watched the last Harry Potter film little Gerald also decided to practice magic He found in his father s magical book a spell that turns any number in the sum of its digits At the moment Gerald learned that he came across a number How many times can Gerald put a spell on it until the number becomes one digit ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Initial number consist of no more then 100000 digits Therefore after first transform resulting number will be no more then 900000 and then it will constist of no more then 6 digits Thus after next transform number will be no more then 54 and so it will be two digit or one digit Sum of digits of a two digit number no more then 18 and sum of digit of such number no more then 9 Thus Gerald can t do nore then 4 transforms First transform one can implement one simple pass throw symbols of given string Following operations take very little time "}
{"statement": "There are n distinct points on a coordinate line the coordinate of i th point equals to x i Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two It is necessary to consider each pair of points not only adjacent Note that any subset containing one element satisfies the condition above Among all these subsets choose a subset with maximum possible size In other words you have to choose the maximum possible number of points x i 1 x i 2 dots x i m such that for each pair x i j x i k it is true that x i j x i k 2 d where d is some non negative integer number not necessarily the same for each pair of points ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Firstly let s prove that the size of the answer is not greater than Suppose that the answer equals to Let be coordinates of the points in the answer and Let and Then because of the condition It means that Conditions must hold for a triple too Now it is easy to see that if then that is not a power of two So the size of the answer is not greater than Firstly let s check if the answer is Iterate over all middle elements of the answer and over all powers of two from to inclusively Let be the middle element of the answer and the current power of two Then if there are elements and in the array then the answer is Now check if the answer is Do the same as in the previous solution but now we have left point and right point If we did not find answer of lengths or then print any element of the array The solution above have time complexity because of we can check if the element is in the array with some data structure in "}
{"statement": "There are n heaps of stone The i th heap has h i stones You want to change the number of stones in the heap by performing the following process once You go through the heaps from the 3 rd heap to the n th heap in this order Let i be the number of the current heap You can choose a number d 0 le 3 cdot d le h i move d stones from the i th heap to the i 1 th heap and 2 cdot d stones from the i th heap to the i 2 th heap So after that h i is decreased by 3 cdot d h i 1 is increased by d and h i 2 is increased by 2 cdot d You can choose different or same d for different operations Some heaps may become empty but they still count as heaps What is the maximum number of stones in the smallest heap after the process ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "The answer can be binary searched That is we can find the biggest number such that we can make all heap having at least stones So our job here is to check if we can satisfy the said condition with a number Let s consider a problem we go from to pick a number move and stones from the th heap to the heap and th heap respectively In this problem we can greedily move the stones since is the minimum required stones if at some moment we have then we can not satisfy the condition for anymore Otherwise it is always the best to use as many stones as we can that is choose and move and stones to the and heaps respectively In the end if all the heap are not less than we can conclude that we can make all heaps having not less than stones with this process Going back to our original problem it seems like we can solve it by doing the process in the reversed order as discussed above But there is a catch The number of stones that can be moved the number of the stones in the original heap So if we call the original heap size and the current modified heap size then the number of stones that we should move is at each step "}
{"statement": "You are given an array of n integers a 1 a 2 a n and a set b of k distinct integers from 1 to n In one operation you may choose two integers i and x 1 le i le n x can be any integer and assign a i x This operation can be done only if i does not belong to the set b Calculate the minimum number of operations you should perform so the array a is increasing that is a 1 a 2 a 3 dots a n or report that it is impossible ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "First let s solve the problem without blocked positions Let s look at the array Obviously if strictly increases then does not decrease and vice versa Now we have to find the maximum number of positions in the array that can be left unchanged And you can always choose an integer that will not break the non decreasing array for the rest of positions This problem can be solved in by analogy with the largest increasing subsequence but now you can take equal elements Now you can realize that the segments between two blocked positions do not depend on each other and the initial problem can be solved as the problem described above All that remains is to check that all blocked positions do not break the strict array increment "}
{"statement": "Pasha decided to invite his friends to a tea party For that occasion he has a large teapot with the capacity of milliliters and tea cups each cup is for one of Pasha s friends The th cup can hold at most milliliters of water It turned out that among Pasha s friends there are exactly boys and exactly girls and all of them are going to come to the tea party To please everyone Pasha decided to pour the water for the tea as follows Pasha can boil the teapot exactly once by pouring there at most milliliters of water Pasha pours the same amount of water to each girl Pasha pours the same amount of water to each boy if each girl gets milliliters of water then each boy gets milliliters of water In the other words each boy should get two times more water than each girl does Pasha is very kind and polite so he wants to maximize the total amount of the water that he pours to his friends Your task is to help him and determine the optimum distribution of cups between Pasha s friends ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "This problem can be solved in different ways too We consider the simplest solution whici fits in the given restrictions At first we sort all cups in non decreasing order of their volumes Due to reasons of greedy it is correct thatsorted cups with numbers from 1 to n will be given to girls and cups with numbers from n 1 to 2 n will be given to boys Now we need to use binary search and iterate on volume of tea which will be poured for every girl Let on current iteration lf rg 2 mid Then if for i from 1 to n it is correct that mid ai and for i from n 1 to 2 n it is correct that 2 mid ai then we need to make lf mid Else we need to make rg mid Asymptotic behavior of this solution O n log n where n count of cups "}
{"statement": "Bizon the Champion isn t just charming he also is very smart While some of us were learning the multiplication table Bizon the Champion had fun in his own manner Bizon the Champion painted an multiplication table where the element on the intersection of the th row and th column equals the rows and columns of the table are numbered starting from 1 Then he was asked what number in the table is the th largest number Bizon the Champion always answered correctly and immediately Can you repeat his success Consider the given multiplication table If you write out all numbers from the table in the non decreasing order then the th number you write out is called the th largest number ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Solution is binary search by answer We need to find largest such that amount of numbers from table least than is strictly less than To calculate this count we sum counts from rows In th row there will be Total complexity is "}
{"statement": "Vasily the bear has two favorite integers and and a pencil Besides he s got jars with different water color paints All jars are numbered in some manner from to inclusive The jar number contains the paint of the th color Initially the bear took a pencil and drew four segments on the coordinate plane All of them end at point They begin at Then for each the bear drew two squares The first square has the following vertex coordinates The second square has the following vertex coordinates After that the bear drew another square All points mentioned above form the set of points The bear decided to paint the resulting picture in moves The th move consists of the following stages The bear chooses 3 distinct points in set so that any pair of the chosen points has a segment on the picture between them The chosen points and segments mark the area that mustn t contain any previously painted points The bear paints the area bounded by the chosen points and segments the th color Note that after the th move some parts of the picture can stay unpainted The bear asked you to calculate how many distinct ways there are to paint his picture A way to paint the picture is a sequence of three element sets of points he chose on each step Two sequences are considered distinct if there is such number that the th members of these sequences do not coincide as sets As the sought number can be rather large you only need to calculate the remainder after dividing it by number ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Pretty tough problem Consider following DP number of ways to take triangles if we have squares auxiliary values Answer will be means type of transitions we make amount of used quarters 2 quarters quarters It is important to distinguish from because amount of consecutive pairs of unused quarters is different About transitions Iterate amount of pairs considering of consecutive quarters that we will take It is important for them to have no common quarters We can get two pairs only in case Let s also take some quarters that are not in pairs Calculate number of ways to select corresponding triangles and add to the current DP state value For better understanding of check my solution Now we take triangles at the borders number of squares is 2 lvl 1 at the borders means marked X see the picture Iterate amount of pairs considering of consecutive triangles we take It is important for pairs to have no common triangles Let s also take some triangles that are not in pairs Calculate number of ways to select corresponding triangles and add to the current DP state value We take triangles at the borders number of squares is 2 lvl at the borders means marked X see the picture Take some triangles not in pairs Calculate number of ways to select corresponding triangles and add to current DP state value Starting values Author s solution "}
{"statement": "Last week Hamed learned about a new type of equations in his math class called Modular Equations Lets define modulo as the remainder of division of by and denote it by A Modular Equation as Hamed s teacher described is an equation of the form in which and are two non negative integers and is a variable We call a positive integer for which a of our equation Hamed didn t pay much attention to the class since he was watching a movie He only managed to understand the definitions of these equations Now he wants to write his math exercises but since he has no idea how to do that he asked you for help He has told you all he knows about Modular Equations and asked you to write a program which given two numbers and determines how many answers the Modular Equation has ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "If a b then there is no answer since If a b then x can be any integer larger than a so there are infinite number of answers to the equation The only remaining case is when a b Suppose x is an answer to our equation Then x a b Also since then b x These conditions are necessary and sufficient as well So the answer is number of divisors of a b which are strictly greater than b which can be solved in "}
{"statement": " Summer vacation has started so Alice and Bob want to play and joy but Their mom doesn t think so She says that they have to read m books before all entertainments Alice and Bob will read each book to end this exercise faster There are n books in the family library The i th book is described by three integers t i the amount of time Alice and Bob need to spend to read it a i equals 1 if Alice likes the i th book and 0 if not and b i equals 1 if Bob likes the i th book and 0 if not So they need to choose m books from the given n books in such a way that Alice likes k books from the chosen set and Bob likes k books from the chosen set the total reading time of these m books is they are children and want to play and joy as soon a possible The set they choose is for both Alice an Bob it s shared between them and they read all books so the total reading time is the sum of t i over all books that are in the chosen set Your task is to help them and find any suitable set of books or determine that it is impossible to find such a set ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "A little explanation this editorial will be based on the easy version editorial so I ll use some definitions from it Here we go the most beautiful problem of the contest is waiting us Well the key idea of this problem almost the same with the easy version idea Let s iterate over the number of elements in group we need to take the cheapest ones again If the number of elements we take from group is then we need to take elements from and groups But one more thing let s iterate over not from zero but from the smallest possible number which can give us any correct set of books the numeric value of the answer doesn t matter The value of can be calculated using and sizes of groups by formula or even simple loop If we can t find any suitable value of the answer is Let s call elements from group and elements from and groups we take Other elements of the whole set of books are but Let s create the set which contains all free elements and fill it beforehand So now we took some necessary elements but we need to take some free elements to complete our set Let s create the other set which contains free elements we take to the answer and maintain the variable describing the sum of elements of How do we recalculate Before the start of the first iteration our set is already filled with some elements let s update using them Update is such an operation function that tosses the elements between and It will do the following things repeatedly and stop when it cannot do anything While the size of is greater than needed so we take more than books in total let s remove the most expensive element from and add it to while the size of is less than needed so we take less than books in total let s remove the cheapest element from and add it to while the cheapest element from is cheaper than the most expensive element form let s swap them Note that during updates you need to recalculate as well So we go over all possible values updating before the first iteration and after each iteration The size of both sets changes pretty smooth if we go from to we need to remove at most one element from because we take one element from group during each iteration and we need to add at most two elements to and because we remove at most two elements from and groups during one iteration To restore the answer let s save such a value that the answer is minimum with this value let it be Then let s just run the same simulation once more from the beginning but stop when we reach Then will contain free elements we need to take to the answer describes the number of elements we need to take from group and describes which elements from and groups we need to take Of course there are some really tough technical things like case handling there is a lot of cases for example the size of can be negative at some moment and you need to carefully handle that and can be negative after some number of iterations and there are other cases because of that and so on Time complexity "}
{"statement": "The emotion samples are now sufficient After almost 3 years it s time for Ivy to awake her bonded sister Vanessa The system inside A R C s Library core can be considered as an undirected graph with infinite number of processing nodes numbered with all positive integers 1 2 3 ldots The node with a number x x 1 is directly connected with a node with number frac x f x with f x being the lowest prime divisor of x Vanessa s mind is divided into n fragments Due to more than 500 years of coma the fragments have been scattered the i th fragment is now located at the node with a number k i a factorial of k i To maximize the chance of successful awakening Ivy decides to place the samples in a node P so that the total length of paths from each fragment to P is smallest possible If there are multiple fragments located at the same node the path from that node to P needs to be counted multiple times In the world of zeros and ones such a requirement is very simple for Ivy Not longer than a second later she has already figured out such a node But for a mere human like you is this still possible For simplicity please answer the minimal sum of paths lengths from every fragment to the emotion samples assembly node P ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2700", "problem_editorial": "First of all one can see that the network is a tree rooted at vertex thus for each pair of vertices in it there can only be one simple path Also the assembly node must be on at least one simple path of a fragment to the root proof by contradiction explicit solution is trivial Let s start with being node From here moving down to any branch will increase for each element not being in that branch and decrease for each element being in thus we ll only move down to the branch having the most elements until the decreasing cannot outmatch the increasing in other words the number of fragments in a branch must be more than half for that branch to be reached Given the criteria of the graph we can see that two nodes are in the same branch from the root if having the same one largest factor from the prime factorization they are in the same branch from a depth 1 node if having the same two largest factors in the same branch from a depth node if having the same largest factors Keep in mind that here the largest factors can be the duplicated i e in the case of the two largest factors are and and the three largest factors are and The process will now become factorizing the numbers and then cycle by cycle pop the current largest factor of each number and group them find out the group branch with most occurences and either move on if the total sum can be lowered or stop the process Since all of these are factorials the factorizing can be done with a bottom up dynamic programming fashion Also as and consider grouping duplicated elements to reduce calculating complexity Both factorization and processing has the worst case complexity of with being the estimated quantity of prime divisors of It s proven that with being the Meissel Mertens constant The proof of this formula is based on the fact this number is calculated through the sum of the reciprocals of the primes "}
{"statement": "One day Vogons wanted to build a new hyperspace highway through a distant system with n planets The i th planet is on the orbit a i there could be multiple planets on the same orbit It s a pity that all the planets are on the way and need to be destructed Vogons have two machines to do that The first machine in one operation can destroy any planet at cost of 1 Triganic Pu The second machine in one operation can destroy all planets on a single orbit in this system at the cost of c Triganic Pus Vogons can use each machine as many times as they want Vogons are very greedy so they want to destroy all planets with minimum amount of money spent Can you help them to know the minimum cost of this project ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "To solve the problem it was enough to count the number of planets with the same orbits and sum up the answers for the orbits separately For one orbit it is advantageous either to use the second machine once and get the cost or to use only the first one and get the cost equal to "}
{"statement": "Little Susie listens to fairy tales before bed every day Today s fairy tale was about wood cutters and the little girl immediately started imagining the choppers cutting wood She imagined the situation that is described below There are trees located along the road at points with coordinates Each tree has its height Woodcutters can cut down a tree and fell it to the left or to the right After that it occupies one of the segments or The tree that is not cut down occupies a single point with coordinate Woodcutters can fell a tree if the segment to be occupied by the fallen tree doesn t contain any occupied point The woodcutters want to process as many trees as possible so Susie wonders what is the maximum number of trees to fell ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "One can solve this problem using dynamic programming or greedy algorithm Start with DP solution Define and as maximal count of trees that woodcutters can fell if only trees with number from to exist and th tree isn t cutted down th tree is cutted down and fallen left th tree is cutted down and fallen right correspondingly Now we can compute this values for each from to by time because for each next we need only two previous value Answer is maximum of Also this problem can be solved by the next greedy algoritm Let s fell leftmost tree to the left it always doesn t make an answer worse After that try to fell the next tree If we can fell it to the left let s do it because it also always doesn t make an answer worse If we can t then try to fell it to the right If it is possible let s do it Last step is correct because felling some tree to the right may only prevent the next tree s fallen So we may exchange one tree to another without worsing an answer Time complexity "}
{"statement": "In the Catowice city next weekend the cat contest will be held However the jury members and the contestants haven t been selected yet There are n residents and n cats in the Catowice and each resident has exactly one cat living in his house The residents and cats are numbered with integers from 1 to n where the i th cat is living in the house of i th resident Each Catowice resident is in friendship with several cats including the one living in his house In order to conduct a contest at least one jury member is needed and at least one cat contestant is needed Of course every jury member should know none of the contestants For the contest to be successful it s also needed that the number of jury members plus the number of contestants is equal to n Please help Catowice residents to select the jury and the contestants for the upcoming competition or determine that it s impossible to do ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "You are given bipartite graph and a perfect matching in it You have to find independent set of size which doesn t coincide with either of two parts Suppose such independent set exists let s call it Also let s call left part of graph as and right part of graph as Then define is set of all nodes which are connected by edges from matching with similarly for It s easy to see that Let s direct all edges in graph Edges from matching will be directed from right to left and all other edges will be directed from left to right Now edges from matching will direct from to and from to Other edges could direct from to from to and from to Observe that edges cannot direct from to cause it wouldn t be an independent set otherwise It s easy to see that isn t reachable from So let s find all strongly connected components SCC in this graph If there s only one such component answer doesn t exist due to the fact that any node of isn t reachable from any node of If SCC is only one any node is reachable from any other node therefore in this case either or are empty If there are at least two SCC let s choose any source SCC and call it Consider and define as set of all nodes in left part which are not connected by edges from matching with Let s proof that if some lies in then pair of in matching also lies in That s obvious since there are no incoming edges in and there s edge from to So none of nodes from will lay in chosen SCC Thus won t be reachable from and will be an independent set The only exception is in such case there are two SCC but answer doesn t exist cause chosen will be empty "}
{"statement": "Nastya baked m pancakes and spread them on n dishes The dishes are in a row and numbered from left to right She put a i pancakes on the dish with the index i Seeing the dishes Vlad decided to bring order to the stacks and move some pancakes In one move he can shift one pancake from any dish to the closest one that is select the dish i a i 0 and do one of the following if i 1 put the pancake on a dish with the previous index after this move a i a i 1 and a i 1 a i 1 1 if i n put the pancake on a dish with the following index after this move a i a i 1 and a i 1 a i 1 1 Vlad wants to make the array a after moving as few pancakes as possible Help him find the minimum number of moves needed for this The array a a 1 a 2 dots a n is called non increasing if a i ge a i 1 for all i from 1 to n 1 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "For convenience we will calculate the prefix sums on the array we will also enter the array containing the indexes of all pancakes and calculate the prefix sums on it Let s use dynamic programming Let s define as the required number of operations to correctly lay out the th prefix with the final and Then you can go to from the previous number must be greater and the sum is fixed To it will be necessary to add a certain number of actions necessary to get let s call it all the terrible prefix sums are needed to count it Since depends only on and we only need to choose the minimum the choice can be optimized by suffix minima As a result the solution works for that s how many states need to be processed "}
{"statement": "Consider a perfect binary tree with size 2 n 1 with nodes numbered from 1 to 2 n 1 and rooted at 1 For each vertex v 1 le v le 2 n 1 1 vertex 2v is its left child and vertex 2v 1 is its right child Each node v also has a value a v assigned to it Define the operation mathrm pop as follows initialize variable v as 1 repeat the following process until vertex v is a leaf i e until 2 n 1 le v le 2 n 1 among the children of v choose the one with the larger value on it and denote such vertex as x if the values on them are equal i e a 2v a 2v 1 you can choose any of them assign a x to a v i e a v a x assign x to v i e v x assign 1 to a v i e a v 1 Then we say the mathrm pop operation is deterministic if there is a unique way to do such operation In other words a 2v neq a 2v 1 would hold whenever choosing between them A binary tree is called a max heap if for every vertex v 1 le v le 2 n 1 1 both a v ge a 2v and a v ge a 2v 1 hold A max heap is deterministic if the mathrm pop operation is deterministic to the heap when we do it Initially a v 0 for every vertex v 1 le v le 2 n 1 and your goal is to count the number of different deterministic max heaps produced by applying the following operation mathrm add exactly k times Choose an integer v 1 le v le 2 n 1 and for every vertex x on the path between 1 and v add 1 to a x Two heaps are considered different if there is a node which has different values in the heaps Since the answer might be large print it modulo p ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "idea solution Misuki SolutionConsider properties of the result sequence Since there may be multiple ways to apply operations to make the same heap let s consider the decision version of the problem instead of counting the operation sequence directly That is Given a sequence a resulting from k operations check whether such a is a deterministic max heap and try to figure out what properties are needed Rephrase of problem Let v 2 n 1 be the only leaf such that after popping one element from the top every element on the path between 1 and v would be moved upward then the condition of a deterministic max heap can be rephrased as follows a 1 k a v ge a 2v a 2v 1 for any v 1 le v 2 n 1 a 2 cdot 2 k a 2 cdot 2 k 1 for any k 0 le k le n 2 So we can see that for any k 0 le k le n 2 the number of operations done in the subtree of 2 cdot 2 k should be greater than the number of operations done in the subtree of 2 cdot 2 k 1 and we don t care much about how these operations distribute in the subtree of 2 cdot 2 k 1 as long as 3 holds Let s call such subtree uncritical Apply counting For any uncritical subtree with size sz if we do x operations under it there are binom x sz 1 x ways to do so Now we can use dp to consider all valid a we can get by enumerating the number of operation done on each vertex on the path from 1 to 2 n 1 and all uncritical subtree Let dp i j be the number of different a we can get by j operations on the subtree with size 2 i 1 then we havebase case dp 1 j 1 forall j in 0 k transition dp i 1 l text dp i j times binom x 2 i 2 x forall x in 0 j l in j x k using prefix sum we can optimize the above dp to O nk 2 and the number of deterministic max heap where vertex 2 n 1 would be pulled up is dp n k Make use of symmetry Finally due to the symmetry property of a perfect binary tree the number of deterministic max heap where v would be pulled are equal for all possible v so the final answer we want would be dp n k times 2 n 1 "}
{"statement": "One day Zimpha casually came up with a problem As a member of Zimpha fan club you decided to solve that problem You are given two strings s and t of length n and m respectively Both strings only consist of lowercase English letters and You need to replace all occurrences of and observing the following rules For each you must replace it with any lowercase English letter For each you must replace it with a string of any possibly zero length which only consists of lowercase English letters Note that you can replace two different instances of with different characters You can also replace each two different instances of with different strings Suppose s and t have been transformed into s and t Now you re wondering if there s a replacement that makes s t ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "In the following we consider n m to be of the same order Consider the case where s and t do not contain We only need to be compared bit by bit Consider the case where s t both contain if the beginning of s is not or the beginning of t is not If one of the first characters of s and t is or the first characters can match delete the first characters of the two strings that are not Oherwise the answer is obviously No Performing the same operation on the last characters it is not difficult to find that it will be reduced to two strings s and t where s and t are arbitrary strings Then it is not difficult to find that t s matches two strings at the same time Therefore as long as the head and tail can be successfully deleted the answer must be Yes Consider the hardest case Without loss of generality we assume that only t contains otherwise s t can be exchanged We still delete the beginning and the end first It is not difficult to find that thereafter t can be written as t 1 t 2 t k Then we will have a greedy solution We iterate i from 1 to n find the first matching position of t i in s each time and delete tthese matching characters and all preceding characters in s that is remove a prefix of s and then until all matching is completed or no matching position is found in s Assume that we use FFT to brute force solve this problem every time See Hint 3 for the specific solution then the complexity is O nklogn But it is not difficult to find that this is very wasteful In fact we can do this When matching t i only take out the first 2t i characters of s each time and try to match t i Because if the match is successful then since all positions matching t i are deleted it is not difficult to find that at least t i characters are deleted And if the match fails it is not difficult to find that the first t i characters of s will no longer be useful and can also be deleted Therefore we remove at least the first t i characters in s in complexity O t i log t i "}
{"statement": "n leq 1000 and the sum of n over all test cases does not exceed 1000A is a row of n equal segments numbered 1 to n in order There are two terminals one above the other You are given an array a of length n For all i 1 2 dots n there should be a straight wire from some point on segment i of the top terminal to some point on segment a i of the bottom terminal You can t select the endpoints of a segment For example the following pictures show two possible wirings if n 7 and a 4 1 4 6 7 7 5 A occurs when two wires share a point in common In the picture above crossings are circled in red What is the number of crossings there can be if you place the wires optimally ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let s look at two wires from and If there can never be any intersection If there has to be an intersection If it is possible that there is an intersection or not depending on how we arrange the wires on the bottom terminal In the last case if there are multiple wires that go to the same segment we can make all pairs of them cross by arranging the points in which they hit this segment from right to left For example if then we can make all pairs of segments cross as shown Since we want to maximize the number of intersections we just need to count the number of pairs such that You can brute force all pairs in "}
{"statement": "Iahub and Iahubina went to a date at a luxury restaurant Everything went fine until paying for the food Instead of money the waiter wants Iahub to write a Hungry sequence consisting of integers A sequence consisting of integers is if and only if Its elements are in increasing order That is an inequality holds for any two indices For any two indices and must be divisible by Iahub is in trouble so he asks you for help Find a Hungry sequence with elements ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "We ll present two different solutions for this task Solution 1 What if we solve a more general task What if each hungry number from the solution isn t allowed to be divided by any number smaller than it except 1 which is divides every natural number If this more general condition would be met then the hungry condition would be met too as a i won t be divided by a number smaller than it except 1 it won t be divided by a j too with j i assuming that a j is different from 1 Now how to find numbers for this more general condition We can rephrase it as each number from more general condition has 2 divisors 1 and itself So if we print N numbers with 2 divisors in increasing order that would be a good solution As you probably know numbers with 2 divisors are called prime numbers The task reduces to finding first N prime numbers This can be done via brute force or via Sieve of Eratosthenes however not necessarily to get an AC solution Solution 2 Suppose we are given the number N We can observe that for big enough consecutive numbers the array is always hungry For example we can print 3 N 0 3 N 1 3 N 2 3 N N 1 Magic isn t it Why does it work now Pick an arbitrary a i The solution would be bad if one of numbers 2 a i 3 a i 4 a i and so on would be in a array However it will never happen The smallest multiple from that ones will be 2 3 N 6 N There is not possible to obtain a smallest multiple than that one On the other hand the biggest number from a array would be 3 N N 1 4 N 1 Since smallest multiple is bigger than biggest term of the array it and of course other multiples bigger than it will never exist in a array So the above solution is correct also "}
{"statement": "You are given an array a consisting of n non negative integers You have to choose a non negative integer x and form a new array b of size n according to the following rule for all i from 1 to n b i a i oplus x oplus denotes the operation bitwise XOR An inversion in the b array is a pair of integers i and j such that 1 le i j le n and b i b j You should choose x in such a way that the number of inversions in b is minimized If there are several options for x output the smallest one ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Take any arbitrary integers and It is a well known fact that whether or depends only on one bit the highest bit which differs in both So let s construct a on our array integers Represent each number as a binary string from the highest bit to the lowest bit Each leaf will keep a corresponding index indices from the array and each non leaf node will have at most two children one for edge and one for edge Let s denote as a sorted list of indices of all values in the subtree of These lists can be easily maintained while inserting our numbers into trie Take any arbitrary vertex which has both children and has a depth distance from root of Let and be its children Here comes the most important thing to notice If the th highest bit of is toggled lists and will change their relative order Otherwise it will not change Thus exploiting the fact that both lists are sorted we can efficiently calculate the corresponding number of inversions between those lists and add them to our values and means the number of inversions we have to add if th highest bit of is equal to After the calculation of our table is done the value of can be easily restored Time complexity Memory complexity "}
{"statement": "You are given array a 1 a 2 dots a n Find the subsegment a l a l 1 dots a r 1 le l le r le n with maximum arithmetic mean frac 1 r l 1 sum limits i l r a i in floating point numbers i e without any rounding If there are many such subsegments find the one ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "There is a property of arithmetic mean and the equality holds when Obviously we can always gain maximum arithmetic mean equal to by taking single maximum element from Considering the property above we need to take only maximum elements in our subsegment that s why we need to find the longest subsegment consisting only of maximum elements "}
{"statement": "You are given a bipartite graph is the set of vertices of the first part is the set of vertices of the second part and is the set of edges There might be multiple edges Let s call some subset of its edges iff the graph has each of its vertices incident to at least edges is such a covering that the size of the subset is minimal possible Your task is to find minimal covering for each where is the minimal degree of any vertex in graph ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2500", "problem_editorial": "To get the answer for some we can build the following network connect the source to every vertex of the first part with edge with capacity where is the degree of vertex then transform every edge of the original graph into a directed edge with capacity and then connect each vertex from the second part to the sink with capacity Then edges saturated by the maxflow are not present in the answer and all other edges are in the answer To solve it fastly we might just iterate on from its greatest value to and each time augment the flow we found on previous iteration Since maxflow in the network is at most and we will do not more than searches that don t augment the flow this solution is "}
{"statement": "You are given a square grid with n rows and n columns Each cell contains either 0 or 1 In an operation you can select a cell of the grid and flip it from 0 to 1 or 1 to 0 Find the minimum number of operations you need to obtain a square that remains the same when rotated 0 circ 90 circ 180 circ and 270 circ The picture below shows an example of all rotations of a grid ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let s rotate the grid by and and mark all cells that map to each other under these rotations For example for and grids mirror grid must have the following patterns the same letters denoting equal values In general we can rotate the grid by and and see which cells need to have equal values by seeing the positions which each cell maps to Now to solve the problem we consider each equal value each of the letters in the above figures independently and consider the minimum number of moves to make them all or all The answer is the total across all values See the implementation for better understanding The time complexity is per testcase "}
{"statement": "The new pedestrian zone in Moscow city center consists of n squares connected with each other by n 1 footpaths We define a as a sequence of squares such that no square appears in this sequence twice and any two adjacent squares in this sequence are directly connected with a footpath The size of a simple path is the number of squares in it The footpaths are designed in a such a way that there is exactly one simple path between any pair of different squares During preparations for Moscow City Day the city council decided to renew ground tiles on all n squares There are k tile types of different colors numbered from 1 to k For each square exactly one tile type must be selected and then used to cover this square surface To make walking through the city center more fascinating it was decided to select tiles types for each square in such a way that any possible simple path of size exactly k contains squares with all k possible tile colors You need to find out whether it is possible to place the tiles this way or not ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Suppose there exists a vertex with tree with a tree paths going from it with longest paths of lengths and in edges Then if then clearly the answer is Impossible We can check whether such vertex exists in using subtree dp and uptree dp Good news this is the only case when the answer is No Bad news providing the coloring is slightly more sophisticated In fact we can prove that the following coloring works Construct a tree s diameter Color vertices on diameter with periodic colors By the way if diameter has less than vertices any coloring will be correct Cut the diameter in half the parts lengths will differ by atmost Color both halves of the tree with dfs colors in the left part will decrease while colors in the right part will increase The result will look roughly as follows The total complexity is Let s give a sketch of the why this coloring works Well suppose there is some bad path of vertices Let s analyze path s position with respect to the diameter The bad path is not related to the diameter It s easy to see that blue part of diameter is greater or equal than any half of the red path so the vertex is a bad vertex to the our criterion The bad path goes through a diameter but lies in one half of it The vertex makes a bad vertex for the criterion just for the same reasons The bad path goes through a diameter and lies in both halves If you recall how our coloring looks like you will see that all paths of this form are well colored "}
{"statement": "On Sunday Leha the hacker took Nura from the house where she lives and went with her to one of the most luxurious restaurants in Vi kopolis Upon arrival they left the car in a huge parking lot near the restaurant and hurried inside the building In the restaurant a polite waiter immediately brought the menu to Leha and Noora consisting of dishes It is interesting that all dishes in the menu are numbered with integers from to After a little thought the girl ordered exactly different dishes from available in the menu To pass the waiting time while the chefs prepare ordered dishes the girl invited the hacker to play a game that will help them get to know each other better The game itself is very simple Noora wants Leha to guess any two dishes among all ordered At the same time she is ready to answer only one type of questions Leha can say two numbers and After that Noora chooses some dish for the number such that at first is among the dishes Noora ordered can be equal to and secondly the value is the minimum possible By the same rules the girl chooses dish for After that Noora says to Leha if and otherwise However the restaurant is preparing quickly so Leha has enough time to ask no more than questions After that he should name numbers of any two dishes Noora ordered Help Leha to solve this problem ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Let s start with searching the first point We can do it using this binary search let s ask points and each time when we calculated the center of search interval So we always know in which of the halves exists at least one point Since in the initial interval there is at least one point and we will never lose this point out of the search Now let s run two binsearches more similarly for everything to the left and to the right of the first found point Again any point in the interval of search is closer than any point out of the interval Now it is not guaranteed that initially exist at least one point so we have to check the found one using one query "}
{"statement": "You are given two positive integers x and y You can perform the following operation with x write it in its binary form without leading zeros add 0 or 1 to the right of it reverse the binary form and turn it into a decimal number which is assigned as the new value of x For example 34 can be turned into 81 via one operation the binary form of 34 is 100010 if you add 1 reverse it and remove leading zeros you will get 1010001 which is the binary form of 81 34 can be turned into 17 via one operation the binary form of 34 is 100010 if you add 0 reverse it and remove leading zeros you will get 10001 which is the binary form of 17 81 can be turned into 69 via one operation the binary form of 81 is 1010001 if you add 0 reverse it and remove leading zeros you will get 1000101 which is the binary form of 69 34 can be turned into 69 via two operations first you turn 34 into 81 and then 81 into 69 Your task is to find out whether x can be turned into y after a certain number of operations possibly zero ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "There are two main approaches to this problem Let s analyze how the binary representation of changes after the operation If there are no zeroes at the end of it appending just reverses the binary representation if there are any trailing zeroes we remove them and reverse the binary representation If we append we just reverse the binary representation and add at the beginning No matter which action we choose on the first step the resulting binary representation will have at its beginning and at its end so no bits can be removed from it no zero from the resulting binary representation can become leading It means that every number we can obtain from will have the following form several ones maybe none then then several ones again maybe none where is one of the following four strings the binary representation of after appending in the first operation the binary representation of after appending in the first operation one of the aforementioned representations but reversed We can check that meets one of these four templates but since we only considered the case when we apply at least one operation we also have to verify if Run something like implicit BFS or DFS to generate all possible values you can obtain pruning when the length of the binary representation we get becomes too large say greater than Why does this work fast As we have shown in our first approach the numbers we can get from have a very specific form and if we limit their lengths to we will consider only about different numbers Note that if you try this approach you have to store the obtained numbers in some associative data structure I use a set of strings in my solution "}
{"statement": "Marcin is a coach in his university There are n students who want to attend a training camp Marcin is a smart coach so he wants to send only the students that can work calmly with each other Let s focus on the students They are indexed with integers from 1 to n Each of them can be described with two integers a i and b i b i is equal to the skill level of the i th student the higher the better Also there are 60 known algorithms which are numbered with integers from 0 to 59 If the i th student knows the j th algorithm then the j th bit 2 j is set in the binary representation of a i Otherwise this bit is not set Student x thinks that he is better than student y if and only if x knows some algorithm which y doesn t know Note that two students can think that they are better than each other A group of students can work together calmly if no student in this group thinks that he is better than everyone else in this group Marcin wants to send a group of at least two students which will work together calmly and will have the maximum possible sum of the skill levels What is this sum ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1700", "problem_editorial": "If there are multiple people with the same set of skills i e the same values of it s optimal to take each of them to the camp as they won t think they re better than everyone else Now consider a person which has a different set of skills than everyone else If they have a strictly smaller set of skills than someone already in the group they can safely be included in the group If they don t we can prove that they can t ever be included in the group This allows us to implement a simple solution first take all people that have an equal set of skills as someone else and then include everyone else who has a strictly smaller set of skills than someone already in the group "}
{"statement": "In Python code blocks don t have explicit begin end or curly braces to mark beginning and end of the block Instead code blocks are defined by indentation We will consider an extremely simplified subset of Python with only two types of statements are written in a single line one per line An example of a simple statement is assignment are compound statements they contain one or several other statements For statement consists of a header written in a separate line which starts with for prefix and loop body Loop body is a block of statements indented one level further than the header of the loop Loop body can contain both types of statements Loop body can t be empty You are given a sequence of statements without indentation Find the number of ways in which the statements can be indented to form a valid Python program ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "This problem can be solved using dynamic programming Let s consider all possible programs which end with a certain statement at a certain indent Dynamic programming state will be an array which stores the number of such programs ending with statement at indent The starting state is a one dimensional array for there is exactly one program which consists of the first statement only and its last statement has indent 0 The recurrent formula can be figured out from the description of the statements When we add command its possible indents depend on the possible indents of command and on the type of command If command is a for loop command must have indent one greater than the indent of command so and for If command is a simple statement command can belong to the body of any loop before it and have any indent from 0 to the indent of command If we denote the indent of command simple statement as the indent of command as we need to sum over all cases where The answer to the task is the total number of programs which end with the last command at any indent The complexity of this solution is "}
{"statement": "Marin and Gojou are playing hide and seek with an array Gojou initially performs the following steps First Gojou chooses 2 integers l and r such that l leq r Then Gojou makes an array a of length r l 1 which is a permutation of the array l l 1 ldots r Finally Gojou chooses a secret integer x and sets a i to a i oplus x for all i where oplus denotes the bitwise XOR operation Marin is then given the values of l r and the final array a She needs to find the secret integer x to win Can you help her Note that there may be multiple possible x that Gojou could have chosen Marin can find any possible x that could have resulted in the final value of a ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s look at the binary representation of numbers from to Let us look at the th bit only maybe we will get a sequence like Notice that the number of zeroes equals the number of ones in a prefix only when the length of the prefix is a multiple of Otherwise there will be more zeros than ones So we will count the number of flipped and unflipped bits for each bit position If the number of ones is greater than the number of zeros the th bit of must be If the number of zeros is greater than the number of ones the th bit of must be If the number of ones is equal to the number of zeros that th bit of can either be or However if the number of ones is equal to the number of zeros we can assign the th bit anything we like The rough sketch of the proof is that if is inside then is also inside "}
{"statement": "There is a straight snowy road divided into blocks The blocks are numbered from 1 to from left to right If one moves from the th block to the th block he will leave a right footprint on the th block Similarly if one moves from the th block to the th block he will leave a left footprint on the th block If there already is a footprint on the th block the new footprint will cover the old one At the beginning there were no footprints Then polar bear Alice starts from the th block makes a sequence of moves and ends in the th block It is known that Alice never moves outside of the road You are given the description of Alice s footprints Your task is to find a pair of possible values of by looking at the footprints ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "The starting position can be anywhere with a footprint The footprints can be categorized into 3 types In case 1 we end in the left of all footprints In case 2 we end in the right of all footprints In case 3 we either end in the rightmost or the leftmost "}
{"statement": "An array b of m positive integers is if for all pairs i and j 1 leq i j leq m max b i b j is divisible by min b i b j You are given an array a of n positive integers You can perform the following operation Select an index i 1 leq i leq n and an integer x 0 leq x leq a i and add x to a i in other words a i a i x After this operation a i leq 10 18 should be satisfied You have to construct a sequence of n operations that will make a good It can be proven that under the constraints of the problem such a sequence of operations exists ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Suppose gives the smallest power of which is greater than Iterate from to and change to by adding to th element Time complexity is "}
{"statement": "Consider an array a of n integers where every element is from 1 to k and every integer from 1 to k appears Let the array b be constructed as follows for the i th element of a b i is the distance to the closest element in a which is not equal to a i In other words b i min limits j in 1 n a j ne a i i j For example if a 1 1 2 3 3 3 3 1 then b 2 1 1 1 2 2 1 1 Calculate the number of different arrays b you can obtain if you consider all possible arrays a and print it modulo 998244353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Consider a block of equal elements in a If we split a into such blocks we can consider each block separately for each element we need only the distance to the closest border of the block except for the first and the last block where we consider only one border It s quite easy to see that if the length of the block is even let s say it s 2x then the distances for the elements in this block are 1 2 3 x 1 x x x 1 3 2 1 And if the length of the block is odd let s say it s 2x 1 the distances are 1 2 3 x 1 x x 1 3 2 1 Now we don t need the actual values in a we only need the information about the blocks of equal elements We need at least k blocks of equal elements in a since if the number of blocks is less than k it s impossible for the array a to have k different values and if there are at least k blocks it s possible to assign each block a value so that every integer from 1 to k appears So it looks like we need to calculate the number of ways to split the array into at least k blocks However this only works if there is a bijection between the ways to split the array and the resulting arrays b Unfortunately some ways to split the array might result in the same distance array for example the distance array 1 1 1 1 can be obtained either by splitting into four blocks of size 1 or into three blocks the middle of which has size 2 So if there is a block of size 2 and it is not the first or the last block in the split it can be replaced with two blocks of size 1 and nothing changes except for the number of blocks which goes up Thankfully this is the only such situation we need to handle any block longer than 2 can be uniquely determined by the values in the middle of it if there is a value x which is greater than both its neighbors it is the middle of a block of size 2x 1 and if there is a pair of values x which are greater than both the value to the left and the value to the right it is the middle of a block of size 2x So we need to count the number of ways to split the array of size n into at least k blocks so that only the first and the last block can have size 2 This can be done with the following dynamic programming let dpi j be the number of ways to split the first i elements into j blocks This looks like it works in O n3 but we can use two improvements to speed this up the values j k are treated identically to the values j k so we can limit the value of j to k and say that dpi j is the number of ways to split the first i elements into at least j blocks if j k we can do transitions in O 1 instead of O n by using partial sums Combining these two optimizations we get a solution in O nk "}
{"statement": "Tsovak and Narek are playing a game They have an array a and a matrix b of integers with n rows and m columns numbered from 1 The cell in the i th row and the j th column is i j They are looking for the elements of a in turns Tsovak starts first Each time a player looks for a cell in the matrix containing the current element of a Tsovak looks for the first then Narek looks for the second etc Let s say a player has chosen the cell r c The next player has to choose his cell in the submatrix starting at r 1 c 1 and ending in n m the submatrix can be empty if r n or c m If a player cannot find such a cell or the remaining submatrix is empty or the array ends the previous player has chosen the last element then he loses Your task is to determine the winner if the players play optimally For example in C it is enough to use the following lines at the start of the function int main ios base sync with stdio false cin tie NULL cout tie NULL ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Let s define dp0i j as the minimal even index k 1 k l such that dpk i j wins Define dp1i j similarly for odds First fill all of them with Then compute them from the bottom right cell of the matrix to the top left cell of the matrix dp0i j will be the minimal of the following three values dp0i 1 j if i n there will be no submatrix left so dp0i 1 j will be dp0i j 1 Let s define by ind the index of bi j in a there are no duplicates in a and if there is no bi j there assign to ind If dp1i 1 j 1 ind 1 which means that dpind 1 i 1 j 1 loses and ensues the current player s win then the value of this part will be ind Otherwise This is because in other cases the opponent either had a winning position starting from ind 1 or even earlier in the game so we can t win from that index We count dp1 similarly but we count dp0 and dp1 simultaneously for every i j Lastly if dp11 1 1 then Tsovak wins otherwise Narek wins "}
{"statement": "Lee has n integers a 1 a 2 ldots a n in his backpack and he has k friends Lee would like to distribute integers in his backpack between his friends such that the i th friend will get exactly w i integers and each integer will be handed over to exactly one friend Let s define the of a friend as the sum of the maximum and the minimum integer he ll get Lee would like to make his friends as happy as possible in other words he d like to maximize the sum of friends happiness Now he asks you to calculate the maximum sum of friends happiness ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": " First if for some then assign the greatest element to th friends it s always better obviously Sort the elements in non descending order and sort the friends in non ascending order of Define the set of indices of elements to give to th friend Also define the minimum element to give to th friend and the maximum element to give to th friend and define Now it s easy to see that the first element of the smallest element is always equal to for some Indeed it s better to have the rest of equal to a small number except one of them which should be equal to a very large number So we can greedily assign to and then assign to it also it s better to have One can prove that there exist an optimal distributing such that the set is equal to one of s proof is blow So add to the answer for remaining elements of excluding the set and remaining friends excluding one of the friends with maximum and so it will be optimal Look at an optimal distributing which maximizes sum of happiness first element of is in for example we want to prove that in at least one of the optimal distributings smallest elements of are in including the first element proof by contradiction If at least one of the smallest elements is not in then call the smallest of them lets say it s in now add to and erase it from instead add a greater number than in to it s at least two of them and one of them is so there exist another one erase it from and add it to it s easy to see that sum of happiness won t decrease that way continue the process until all smallest elements are in so we have an optimal answer which has all smallest elements in contradiction As we proved above we have an optimal distributing such that all smallest elements are in for some now we want to prove that the greatest element is in in at least one of the optimal distributings again proof by contradiction Lets say it s not that way so look at an optimal distributing such that first elements are in and is not equal to the greatest element for some if there exist such that then swap and the resulting distributing has the same happiness continue it until no such exist now lets say the greatest element of is in for some also we know that is equal to the greatest element of and if then the process of swapping is not finished which is contradiction So now we can swap and again the resulting distributing has happiness greater than or equal to the happiness of the optimal distributing the one we chose in the beginning and so its also an optimal distributing and is equal to the greatest element we have found an optimal distributing such that first elements of and are in for some contradiction Now we have proved that there exist an optimal distributing such that first elements of and are in for some call such optimal distributing and now the only remaining part is to prove that there exist an optimal distributing such that first elements of and are in for some See the whole algorithm its like we choose a permutation of friends then we do that greedy assignment to them one by one from left to right now we want to prove that there exist an optimal distributing such that it s and it s permutation is sorted in non descending order of call them distributings Again proof by contradiction Choose a distributing such that it s a it s permutation called is not sorted in non descending order of otherwise it s a distributing contradiction so there exist an such that now swap them i e swap and and then do the same greedy assignment using the modified permutation of friends it s easy to see that happiness of friends after in permutation wont change also happiness of friends before in the permutation wont change as well Now look at the happiness of and you can realize that sum of happiness will increase You really don t need to prove it like that it s not time friendly at all "}
{"statement": "There are n colorful balls arranged in a row The balls are painted in n distinct colors denoted by numbers from 1 to n The i th ball from the left is painted in color c i You want to reorder the balls so that the i th ball from the left has color i Additionally you have k ge 1 balls of color 0 that you can use in the reordering process Due to the strange properties of the balls they can be reordered only by performing the following operations Place a ball of color 0 anywhere in the sequence between any two consecutive balls before the leftmost ball or after the rightmost ball while keeping the relative order of other balls You can perform this operation no more than k times because you have only k balls of color 0 Choose any ball of color such that at least one of the balls adjacent to him has color 0 and move that ball of non zero color anywhere in the sequence between any two consecutive balls before the leftmost ball or after the rightmost ball while keeping the relative order of other balls You can perform this operation as many times as you want but for each operation you should pay 1 coin You can perform these operations in any order After the last operation all balls of color 0 magically disappear leaving a sequence of n balls of non zero colors What is the minimum amount of coins you should spend on the operations of the second type so that the i th ball from the left has color i for all i from 1 to n It can be shown that under the constraints of the problem it is always possible to reorder the balls in the required way Solve the problem for all k from 1 to n ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s solve the problem for some fixed Consider the set of all balls that were never moved with operation of type Let s call balls from and balls not from The relative order of fixed balls never changes so their colors must form an increasing sequence Let s define as the number of segments of mobile balls that the fixed balls divide sequence into For example if and then these segments are and is equal to As every mobile ball has to be moved at least once there must be at least one zero colored ball in each such segment whicn means that Also it means that we will need at least operations of type In fact we can always place mobile balls at correct positions with exactly operations The proof is left as exercise for reader So the answer for is equal to minimum value of over all sets of balls such that and the colors of balls in form an increasing sequence This problem can be solved with dynamic programming let be maximum value of if only balls from to exist ball belongs to and is equal to To perform transitions from you need to enumerate the next ball from after Then if you transition to otherwise you transition to After each transition increases by so you just update with value There are states and at most transitions from each state so the complexity is Solution can be optimized to with segment tree but this was not required "}
{"statement": "The prison of your city has prisoners As the prison can t accommodate all of them the city mayor has decided to transfer of the prisoners to a prison located in another city For this reason he made the prisoners to stand in a line with a number written on their chests The number is the severity of the crime he she has committed The greater the number the more severe his her crime was Then the mayor told you to choose the prisoners who will be transferred to the other prison He also imposed two conditions They are The chosen prisoners has to form a contiguous segment of prisoners Any of the chosen prisoner s crime level should not be greater then Because that will make the prisoner a severe criminal and the mayor doesn t want to take the risk of his running away during the transfer Find the number of ways you can choose the prisoners ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "The severity of crimes form an integer sequence Find all the contiguous sequences without any integer greater than If the length of any sequence is then we can choose prisoners from them in ways Model solution 6546272 "}
{"statement": "In a magical land there are n cities conveniently numbered 1 2 dots n Some pairs of these cities are connected by magical colored roads Magic is unstable so at any time new roads may appear between two cities Vicky the witch has been tasked with performing deliveries between some pairs of cities However Vicky is a beginner so she can only complete a delivery if she can move from her starting city to her destination city through a A double rainbow is a sequence of cities c 1 c 2 dots c k satisfying the following properties For each i with 1 le i le k 1 the cities c i and c i 1 are connected by a road For each i with 1 le i le frac k 1 2 the roads connecting c 2i with c 2i 1 and c 2i 1 have the same color For example if k 5 the road between c 1 and c 2 must be the same color as the road between c 2 and c 3 and the road between c 3 and c 4 must be the same color as the road between c 4 and c 5 Vicky has a list of events in chronological order where each event is either a delivery she must perform or appearance of a new road Help her determine which of her deliveries she will be able to complete ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "Let be the graph with cities as vertices and roads as edges Note that the edges originally in can be regarded as queries of the add edge type so we will just describe a solution that can handle queries of any type We need a way to capture the idea of going through two roads of the same color in a row To do this consider a graph with the same vertices as in which vertices and are connected by an edge if and are edges of the same color for some vertex Then any path in this graph corresponds to a double rainbow in the original However this doesn t solve the problem yet because of the condition that the final edge of a double rainbow can be of any color To help in solving this issue consider sets such that has all of the connected components of both and any neighbor of Then we can see that we have a double rainbow from to if and only if the connected component of is in either we reach directly or we reach one of its neighbors and then use our final edge to go to So as long as we can mantain these sets we have a time way to answer queries of the second type Now we need to deal with adding edges To do this we will store the connectivity of using a DSU When we connect two connected components in we do the merges from small to large If we merge component into component then for each vertex in component and every neighbor of we remove from and insert instead By merging from small to large we guarantee that each vertex changes component at most times and thus we also update through the edge at most times Each update is just two operations so over all updates this amortizes to because we have edges plus for actually moving the vertices There s an easy to fix but important note which is that the number of edges in can be quadratically large However we can check that for each edge of color that we add we only need to add two edges to Namely if and are neighbors of and respectively through an edge of color then it is enough to add edges and If one of or doesn t exist then we just don t add the corresponding edge We can store these colored neighbors of each vertex in sets which have total size at most so we can find in which updates we need to perform and we perform a constant number of updates per added edge Complexity or using hash tables "}
{"statement": "You are given an array a 1 a 2 ldots a n consisting of integers 1 and 1 You have to build a partition of this array into the set of segments l 1 r 1 l 2 r 2 ldots l k r k with the following property Denote the alternating sum of all elements of the i th segment as s i s i a l i a l i 1 a l i 2 a l i 3 ldots pm a r i For example the alternating sum of elements of segment 2 4 in array 1 0 1 1 1 equals to 0 1 1 2 The sum of s i over all segments of partition should be equal to zero Note that each s i does have to be equal to zero this property is about sum of s i over all segments of partition The set of segments l 1 r 1 l 2 r 2 ldots l k r k is called a of the array a of length n if 1 l 1 le r 1 l 2 le r 2 ldots l k le r k n and r i 1 l i 1 for all i 1 2 ldots k 1 In other words each element of the array must belong to exactly one segment You have to build a partition of the given array with properties described above or determine that such partition does not exist Note that it is required to minimize the number of segments in the partition ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "If the sum of all elements of the array is odd the partitions does not exist because the partition does not affect the parity of the sum Otherwise the answer exists Let s build such construction As the sum of all elements is even is even too Consider pairs of elements with indices Consider the pair If add the segment to the answer In this case the alternating sum of elements of this segment will be equal to Otherwise we will add two segments to the answer and The sum of the first segment is and the sum of the second segment is The sum of two sums will be equal to zero So the sum of all alternating sums will be equal to zero "}
{"statement": "Polycarp was given an array a of n integers He really likes triples of numbers so for each j 1 le j le n 2 he wrote down a triple of elements a j a j 1 a j 2 Polycarp considers a pair of triples b and c if they differ in exactly one position that is one of the following conditions is satisfied b 1 ne c 1 and b 2 c 2 and b 3 c 3 b 1 c 1 and b 2 ne c 2 and b 3 c 3 b 1 c 1 and b 2 c 2 and b 3 ne c 3 Find the number of pairs of triples among the written triples a j a j 1 a j 2 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "To consider each pair only once we will go from left to right and while adding a new triplet we will add to the answer the number of already added triplets that form a beautiful pair with the current one We will maintain a with triplets to denote a triplet with an error we will place or any other value that cannot occur in the array in place of the error Thus for each triplet the already found triplets will be good In each case triplets equal to will also be included so they need to be subtracted from each of the three cases "}
{"statement": "Dora has just learned the programming language C However she has completely misunderstood the meaning of C She considers it as two kinds of adding operations on the array c with n elements Dora has two integers a and b In one operation she can choose one of the following things to do Choose an integer i such that 1 leq i leq n and increase c i by a Choose an integer i such that 1 leq i leq n and increase c i by b Note that a and b are and they can be the same Let s define a of array d as max d i min d i For instance the range of the array 1 2 3 4 is 4 1 3 the range of the array 5 2 8 2 2 1 is 8 1 7 and the range of the array 3 3 3 is 3 3 0 After any number of operations possibly 0 Dora calculates the range of the new array You need to help Dora minimize this value but since Dora loves exploring all by herself you only need to tell her the minimized value ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Read the hints Consider First the answer is less than Otherwise you can always increase the minimum value by so that all elements are greater than Let s go over all possible minimum values say and we can do the operations so that all elements are in the range Then we can calculate the range and compare it with the answer There are possible minimum values so the process is too slow Consider first letting be the minimum and we do the operations to make in the range Then sort the array and try as the minimum in turn Suppose is the current minimum and is the largest integer such that If exists then is the maximum That s because for all and for all So we can do this in after sorting In the case of We can prove that this is equivalent to according to the Bezout s Identity Please search it yourself on https en wikipedia org wiki for the character cannot be displayed inside a link First the changes in value of each element must be a multiple of since are both multiples of Second we can always construct integers such that so we can perform some operations such that we only increase decrease an element by Time complexity "}
{"statement": "Let s define a RDB of level n as a rooted tree constructed as described below A rooted dead bush of level 1 is a single vertex To construct an RDB of level i we at first construct an RDB of level i 1 then for each vertex u if u has no children then we will add a single child to it if u has one child then we will add two children to it if u has more than one child then we will skip it Let s define a as a rooted tree with four vertices one root vertex called also as center with three children It looks like a claw Lee has a Rooted Dead Bush of level n Initially all vertices of his RDB are green In one move he can choose a claw in his RDB if all vertices in the claw are and all vertices of the claw are children of its center then he colors the claw s vertices in yellow He d like to know the maximum number of yellow vertices he can achieve Since the answer might be very large print it modulo 10 9 7 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1900", "problem_editorial": " First realize that a RDB of level is consisted of a vertex the root of the RDB of level connected to the roots of two RDBs of level and a RDB of level Now define equal to the answer for a RDB of level Also define equal to if Lee can achieve yellow vertices in a RDB of level such that the root is green and otherwise It s easy to see that is equal to either or If both and are equal to then we can color the claw rooted at the root of the RDB then and Also if either or is equal to then and "}
{"statement": "Apart from plush toys Imp is a huge fan of little yellow birds To summon birds Imp needs strong magic There are trees in a row on an alley in a park there is a nest on each of the trees In the th nest there are birds to summon one bird from this nest Imp needs to stay under this tree and it costs him points of mana However for each bird summoned Imp increases his mana capacity by points Imp summons birds one by one he can summon any number from to birds from the th nest Initially Imp stands under the first tree and has points of mana and his mana capacity equals as well He can only go forward and each time he moves from a tree to the next one he restores points of mana but it can t exceed his current mana capacity Moving only forward what is the maximum number of birds Imp can summon ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "The problem can be solved by utilizing dynamic programming Let us denote by the maximum possible remaining amount mana for the state where stands for the number of nests passed by and stands for the number of birds summoned The base is as we have passed by no nests have summoned no birds and have mana at our disposal in the beginning Let us also initialize all other states with The transitions are as follows consider us having walked to the next nest and summoned additional birds from there therefore proceeding from the state to of course it is reasonable to require that the answer for is not After we have proceeded units of mana would be replenished taking summoned birds into consideration the amount of mana at the moment is bounded above by The summoning would cost us mana If after the replenishing and the summoning the remaining amount of mana is nonnegative we update the answer for the state The answer is the maximal among reachable states those not equal to Note that the constant in the square is no more than "}
{"statement": "BigData Inc is a corporation that has data centers indexed from to that are located all over the world These data centers provide storage for client data you can figure out that client data is really big Main feature of services offered by BigData Inc is the access availability guarantee even under the circumstances of any data center having an outage Such a guarantee is ensured by using the Two way replication is such an approach for data storage that any piece of data is represented by two identical copies that are stored in two different data centers For each of company clients let us denote indices of two different data centers storing this client data as and In order to keep data centers operational and safe the software running on data center computers is being updated regularly Release cycle of BigData Inc is one day meaning that the new version of software is being deployed to the data center computers each day Data center software update is a non trivial long process that is why there is a special hour long time frame that is dedicated for data center maintenance During the maintenance period data center computers are installing software updates and thus they may be unavailable Consider the day to be exactly hours long For each data center there is an integer defining the index of an hour of day such that during this hour data center is unavailable due to maintenance Summing up everything above the condition should hold for each client or otherwise his data may be unaccessible while data centers that store it are under maintenance Due to occasional timezone change in different cities all over the world the maintenance time in some of the data centers may change by one hour sometimes Company should be prepared for such situation that is why they decided to conduct an experiment choosing some non empty subset of data centers and shifting the maintenance time for them by an hour later i e if then the new maintenance hour would become otherwise it would become Nonetheless such an experiment should not break the accessibility guarantees meaning that data of any client should be still available during any hour of a day after the data center maintenance times are changed Such an experiment would provide useful insights but changing update time is quite an expensive procedure that is why the company asked you to find out the minimum number of data centers that have to be included in an experiment in order to keep the data accessibility guarantees ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1900", "problem_editorial": "Formally you are given a properly colored graph and you are asked to find out size of smallest non empty subset such that after addition modulo to colors of vertices in this subset coloring will remain proper Let s build a directed graph with vertices and edge from to iff and are connected by edge in original graph and Now let s fix some vertex which color will be changed It s clear that we should take into its set all vertices which are reachable from it Now our problem is reduced to following problem Given directed graph find vertex with smallest number reachable from it vertices It s just any vertex from smallest strongly connected component which is sink strongly connected component such there is no strongly connected component reachable from it Given graph is not properly colored but you don t have to minimize size of the set Can you solve it Given graph is not properly colored but you have to minimize size of the set "}
{"statement": "You are given an array a of n integers where n is In one operation you will remove two elements from the array a and then concatenate the remaining parts of the array For example given the array 4 7 4 2 9 we can obtain the arrays 4 2 9 and 4 7 9 by the operations underline 4 7 4 2 9 to 4 2 9 and 4 7 underline 4 2 9 to 4 7 9 respectively However we cannot obtain the array 7 2 9 as it requires deleting non adjacent elements underline 4 7 underline 4 2 9 You will repeatedly perform this operation until exactly one element remains in a Find the maximum possible value of the remaining element in a ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The answer is the maximum value of the elements at odd indices Proof Any element at an odd index can be preserved until the end Since each element at an odd index has an even number of elements on both sides pairs of adjacent elements can be removed from left to right until only the element at the odd index remains For example if you want to keep the element at the i th position you can remove the elements at positions 1 and 2 3 and 4 and so on until the elements at positions i 2 and i 1 are removed Then continue removing elements at positions i 1 and i 2 and so on until the elements at positions n 1 and n are removed Therefore any element at an odd index can be preserved through this method No element at an even index can be preserved until the end Since n is odd there are more elements at odd indices than at even indices Each operation removes one element at an odd index and one element at an even index Since there are always more elements at odd indices the last remaining element must be at an odd index "}
{"statement": "You went to the store selling n types of chocolates There are a i chocolates of type i in stock You have unlimited amount of cash so you are not restricted by any prices and want to buy as many chocolates as possible However if you buy x i chocolates of type i clearly 0 le x i le a i then for all 1 le j i at least one of the following must hold x j 0 you bought zero chocolates of type j x j x i you bought less chocolates of type j than of type i For example the array x 0 0 1 2 10 satisfies the requirement above assuming that all a i ge x i while arrays x 0 1 0 x 5 5 and x 3 2 don t Calculate the maximum number of chocolates you can buy ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "It is optimal to proceed greedily from the back of the array If we have taken candies of the type then we can only take candies for type If this value is less than zero we take from here Overall Complexity "}
{"statement": "Alice has a grid of size n times m The cell on the intersection of i th row and j th column is denoted as i j Alice can do the following operations with this grid Choose any subrectangle containing cell 1 1 and flip the colors of all its cells Flipping means changing its color from white to black or from black to white Choose any subrectangle containing cell n 1 and flip the colors of all its cells Choose any subrectangle containing cell 1 m and flip the colors of all its cells Choose any subrectangle containing cell n m and flip the colors of all its cells Alice wants to obtain her favorite coloring with these operations What s the smallest number of coins that she would have to spend It can be shown that it s always possible to transform the initial grid into any other ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "We will transform favorite coloring to the all white coloring instead Let s denote by and by First observation is that it doesn t make sense to do operations of type and at all Indeed each of them can be replaced with operations of type Instead of flipping subrectangle we can flip subrectangles and and similarly for So from now on we only consider first and last operations Let s create a grid of rows and columns where denotes the parity of the sum of numbers in those of cells of favorite coloring which are present on the grid Clearly all numbers in are if and only if current coloring is all so we will want to just make the grid all Let s look at how first and last operations affect the grid If we flip the subrectangle with the operation of the first type in grid the only value that changes is If we flip the subrectangle clearly otherwise we could have instead used operations of the first type Then it s easy to see that the only cells that will change are So now we have the following problem we have a binary grid In one operation we can change some to with cost of coin or to select some and flip the numbers in cells with cost of coins What s the smallest cost to make all numbers Now it s easy to see that it doesn t make sense to apply second operation more than once as instead of doing it twice we can apply the operation of the first type at most times as cell will be flipped twice Moreover it only makes sense to apply the second operation if there exist such for which all cells are So the algorithm would be to calculate the grid to calculate the total number of ones in it and substract from if there exists such for which all cells are Complexity "}
{"statement": "A is a graph with vertices and exactly edges this graph should meet the following condition there exists exactly one shortest by number of edges path between any pair of its vertices A of a tree is a tree with both vertices and edges as subsets of vertices and edges of You re given a tree with vertices Consider its vertices numbered with integers from 1 to Additionally an integer is written on every vertex of this tree Initially the integer written on the th vertex is equal to In one move you can apply the following operation Select the subtree of the given tree that includes the vertex with number 1 Increase or decrease by one all the integers which are written on the vertices of that subtree Calculate the minimum number of moves that is required to make all the integers written on the vertices of the given tree equal to zero ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "In the problem statement vertex 1 is not mentioned as root of the tree But it seems if we make it the root of the tree we can figure out the solution easier For the leaves of the tree we can see the least number of steps needed to make each of them equal to zero Consider a vertex which all its children are leaves The minimum number of times that we should increase this vertex is at least as the maximum times one of the children of this vertex is increased Also the minimum number of times this vertex is decreased is at least as maximum times one of the children of this vertex is decreased Now we know some necessary plus or minus steps that this vertex is included in them So after all of the children of this vertex reached zero this vertex itself has some new value If the current value of the vertex is positive we should decrease this vertex certain times otherwise we should decrease it So we can find the minimum number of times this vertex should be decreased and the minimum number of times this vertex should be increased As we showed above if we know these pair of numbers for each child of a vertex then we can calculate these numbers for that vertex too This can be implemented using a simple DFS on the rooted tree And the answer to the problem would be the sum of increments and decrements of vertex 1 The time complexity of the solution is O n "}
{"statement": "Danil decided to earn some money so he had found a part time job The interview have went well so now he is a light switcher Danil works in a rooted tree undirected connected acyclic graph with vertices vertex is the root of the tree There is a room in each vertex light can be switched on or off in each room Danil s duties include switching light in all rooms of the subtree of the vertex It means that if light is switched on in some room of the subtree he should switch it off Otherwise he should switch it on Unfortunately or fortunately Danil is very lazy He knows that his boss is not going to personally check the work Instead he will send Danil tasks using personal messages There are two types of tasks describes a task to switch lights in the subtree of vertex describes a task to count the number of rooms in the subtree of in which the light is turned on Danil should send the answer to his boss using messages A subtree of vertex is a set of vertices for which the shortest path from them to the root passes through In particular the vertex is in the subtree of Danil is not going to perform his duties He asks you to write a program which answers the boss instead of him ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Let s construct Euler tour tree We ll put vertex in vector when first time visit it For each vertext subtree is segment in this vector borders of which we can calculate while constructing Now we need to make inversion on segment and get sum of segment Segment tree is good for it "}
{"statement": "Leha is planning his journey from Moscow to Saratov He hates trains so he has decided to get from one city to another by car The path from Moscow to Saratov can be represented as a straight line well it s not that straight in reality but in this problem we will consider it to be straight and the distance between Moscow and Saratov is n km Let s say that Moscow is situated at the point with coordinate 0 km and Saratov at coordinate n km Driving for a long time may be really difficult Formally if Leha has already covered i kilometers since he stopped to have a rest he considers the i 1 th kilometer as a i 1 It is guaranteed that for every i in 1 n 1 a i le a i 1 The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey Fortunately there may be some rest sites between Moscow and Saratov Every integer point from 1 to n 1 may contain a rest site When Leha enters a rest site he may have a rest and the next kilometer will have difficulty a 1 the kilometer after it difficulty a 2 and so on For example if n 5 and there is a rest site in coordinate 2 the difficulty of journey will be 2a 1 2a 2 a 3 the first kilometer will have difficulty a 1 the second one a 2 then Leha will have a rest and the third kilometer will have difficulty a 1 the fourth a 2 and the last one a 3 Another example if n 7 and there are rest sites in coordinates 1 and 5 the difficulty of Leha s journey is 3a 1 2a 2 a 3 a 4 Leha doesn t know which integer points contain rest sites So he has to consider every possible situation Obviously there are 2 n 1 different distributions of rest sites two distributions are different if there exists some point x such that it contains a rest site in exactly one of these distributions Leha considers all these distributions to be equiprobable He wants to calculate p the expected value of difficulty of his journey Obviously p cdot 2 n 1 is an integer number You have to calculate it modulo 998244353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Let s consider each kilometer of the journey separatedly and calculate the expected value of its difficulty and then use linearity of expectation to obtain the answer The difficulty of each kilometer depends on the rest site right before it or if there were no rest sites on the distance from Moscow to this kilometer So when considering the difficulty of th kilometer one indexed we may obtain a formula The denominator of the last summand is because it represents the situation where the last rest was in Moscow and its probability is exactly We can actually rewrite this as follows thus calculating all that we need in linear time "}
{"statement": "While walking down the street Vanya saw a label Hide Seek Because he is a programmer he used as a bitwise AND for these two words represented as a integers in base and got new word Now Vanya thinks of some string and wants to know the number of pairs of words of length length of such that their bitwise AND is equal to As this number can be large output it modulo To represent the string as a number in numeral system with base Vanya uses the following rules digits from to correspond to integers from to letters from to correspond to integers from to letters from to correspond to integers from to letter correspond to integer letter correspond to integer ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "We can transform our word in binary notation we can do it easily because Move through the bits of this number if bit is equal to then we can have 3 different optinos of this bit in our pair of words 0 1 1 0 0 0 else we can have only one option 1 1 So the result will be where is amount of zero bits Complexity Code "}
{"statement": "Jaroslav owns a small courier service He has recently got and introduced a new system of processing parcels Each parcel is a box the box has its weight and strength The system works as follows It originally has an empty platform where you can put boxes by the following rules If the platform is empty then the box is put directly on the platform otherwise it is put on the topmost box on the platform The total weight of all boxes on the platform cannot exceed the strength of platform at any time The strength of any box of the platform at any time must be no less than the total weight of the boxes that stand above You can take only the topmost box from the platform The system receives parcels the th parcel arrives exactly at time its weight and strength are equal to and respectively Each parcel has a value of bourles However to obtain this value the system needs to give the parcel exactly at time otherwise Jaroslav will get 0 bourles for it Thus Jaroslav can skip any parcel and not put on the platform formally deliver it at time and not get anything for it Any operation in the problem is performed instantly This means that it is possible to make several operations of receiving and delivering parcels at the same time and in any order Please note that the parcel that is delivered at time immediately gets outside of the system and the following activities taking place at the same time are made without taking it into consideration Since the system is very complex and there are a lot of received parcels Jaroslav asks you to say what maximum amount of money he can get using his system ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2600", "problem_editorial": "Let s make two observations First consider the parcels as time segments It is true that if at some moment of time both parcel and parcel are on the platform and is higher than then Second let s imagine that there are some parcels on the platform It turns out that it is enough to know just a single number to be able to decide whether we can put another parcel on top of them Let s denote this value as residual strength For a parcel or a platform itself the residual strength is it s strength minus the total weight of parcels on top of it For a set of parcels the residual strength is the minimum of individual residual strengths So we can put another parcel on top if it s weight does not exceed the residual strength These observations lead us to a dynamic programming solution Let the top parcel at the given moment has number and the residual strength is Make this pair the state of DP because it is exactly the original problem where the platform strength is and there are only parcels with In we will store the answer to this instance of the original problem Which transitions are there We can choose a set of parcels such that This choice corresponds to the following sequence of actions first put parcel on the top of This gets us to the state so we add up the answer for this state and the cost of Then we take away all parcels including and put the parcel on top of and so on As the number of states in DP is all transitions should take linear time It can be achieved by making an inner helper DP This give a solution in Note that for simplicity the platform can be considered as a parcel too "}
{"statement": "Okabe needs bananas for one of his experiments for some strange reason So he decides to go to the forest and cut banana trees Consider the point in the 2D plane such that and are integers and There is a tree in such a point and it has bananas There are no trees nor bananas in other points Now Okabe draws a line with equation Okabe can select a single rectangle with axis aligned sides with all points on or under the line and cut all the trees in all points that are inside or on the border of this rectangle and take their bananas Okabe s rectangle can be degenerate that is it can be a line segment or even a point Help Okabe and find the maximum number of bananas he can get if he chooses the rectangle wisely Okabe is sure that the answer does not exceed You can trust him ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "The critical observation to make is that the optimal rectangle should always have a lower left vertex at the origin This is due to the fact that the line has positive y intercept and negative slope any rectangle which doesn t have a vertex at the origin could easily be extended to have a vertex at the origin and even more bananas Then we just need to try every x coordinate for the upper right corner of the box and pick the maximum y coordinate without going over the line We can compute the sum of any rectangle in O 1 using arithmetic series sums so this becomes O bm because the x intercept can be up to bm You can make it faster by trying every y coordinate this makes the complexity O b but this was unnecessary to solve the problem "}
{"statement": "Tokitsukaze and her friends are trying to infiltrate a secret base built by Claris However Claris has been aware of that and set a bomb which is going to explode in a minute Although they try to escape they have no place to go after they find that the door has been locked At this very moment CJB Father of Tokitsukaze comes With his magical power given by Ereshkigal the goddess of the underworld CJB is able to set m barriers to protect them from the explosion Formally let s build a Cartesian coordinate system on the plane and assume the bomb is at O 0 0 There are n persons in Tokitsukaze s crew the i th one of whom is at P i X i Y i Every barrier can be considered as a line with infinity length and they can intersect each other For every person from Tokitsukaze s crew there must be at least one barrier separating the bomb and him which means the line between the bomb and him intersects with at least one barrier In this definition if there exists a person standing at the position of the bomb any line through O 0 0 will satisfy the requirement Although CJB is very powerful he still wants his barriers to be as far from the bomb as possible in order to conserve his energy Please help him calculate the maximum distance between the bomb and the closest barrier while all of Tokitsukaze s crew are safe ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "TutorialIt is obvious that we can binary search the answer because we can pull any line closer to and the situation won t change Applying a binary search we focus on if it is possible to set barriers with the same distance to and meet the requirement By doing so we can draw a circle whose center is such that the closest point to on each barrier is on the circumference Then it becomes a classic problem for each barrier we can get the angle range of its closest point on the circle and we have to choose at most points on the circle to ensure that there is at least one point within each range This kind of greedy trick is very simple on a sequence As to ranges on a sequence you only have to sort all ranges in increasing order of left endpoint and take every necessary right endpoint As to ranges on a circle you can enumerate a position to break the circle into a sequence But if you enumerate as the same way on the sequence the time complexity will be which is not enough Instead we can double and extend these ranges into ranges and then regard them as on a sequence We can do some precalculation such as if we want to choose a point to cover the th sorted range and other ranges in its right as many as possible what is the next range that we cannot cover Let s denote that as and then we can calculate the next range after repeated steps from the th range as which can be obtained from After preparation we can enumerate the beginning position and use binary lifting method each time in complexity to know that whether we can use steps to cover all the ranges Therefore the total time complexity can be where is the precision requirement "}
{"statement": "As a tradition every year before IOI all the members of Natalia Fan Club are invited to Malek Dance Club to have a fun night together Malek Dance Club has members and coincidentally Natalia Fan Club also has members Each member of MDC is assigned a unique id from to The same holds for each member of NFC One of the parts of this tradition is one by one dance where each member of MDC dances with a member of NFC A dance pair is a pair of numbers such that member from MDC dances with member from NFC The complexity of a pairs assignment is the number of pairs of dancing pairs and such that and You are given a binary number of length named We know that member from MDC dances with member from NFC Your task is to calculate the complexity of this assignment modulo Expression denotes applying XOR to numbers and This operation exists in all modern programming languages for example in and it denotes as in ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Solving this problem was easy when you modeled the assignment with two sets of points numbered from to inclusive paired with line segments Each line segment corresponds to a dance pair And each pair of intersecting lines increase the complexity by one Imagine you now the solution for binary string Now we want to calculate the answer for and easily Look at the figure below The figure shows what happens in a simple case Whenever you append before the same structure appears twice in the result But whenever you append before the same structure appears twice but the first half of points in right column are swapped with the second half This increases the number of intersections by size of first half times size of the second half So if has length and is the complexity of the assignment then we have An interesting fact is that is equal to "}
{"statement": "DZY has a sequence consisting of integers We ll call a sequence a subsegment of the sequence The value denotes the length of the subsegment Your task is to find the longest subsegment of such that it is possible to change at most one number change one number to any integer you want from the subsegment to make the subsegment strictly increasing You only need to output the length of the subsegment you find ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "We can first calculate for each satisfying which is maximal Then calculate satisfying which is also maximal Update the answer when It s easy to solve this problem in "}
{"statement": "In this problem we consider a very simplified model of Barcelona city Barcelona can be represented as a plane with streets of kind x c and y c for every integer c that is the rectangular grid However there is a detail which makes Barcelona different from Manhattan There is an avenue called Avinguda Diagonal which can be represented as a the set of points x y for which ax by c 0 One can walk along streets including the avenue You are given two integer points A and B somewhere in Barcelona Find the minimal possible distance one needs to travel to get to B from A ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "One way is to handle some cases intersect the line with the border of the bounding box of x1 y1 and x2 y2 and relax answer by some values depending on the mutual location of intersection points as on the pics below Another way is to intersect horizontal and vertical lines through x1 y1 and x2 y2 intersect them with the ax by c 0 line consider the obtained 6 points as vertices of a graph add all horizontal and vertical edges in this graph run Floyd Ford Bellman Dijkstra algorithm "}
{"statement": "During the latest mission of the starship U S S Coder Captain Jan Bitovsky was accidentally teleported to the surface of an unknown planet Trying to find his way back Jan found an artifact from planet Earth s ancient civilization a mobile device capable of interstellar calls created by Byterola Unfortunately there was another problem Even though Jan as a representative of humans knew perfectly the old notation of the cell phone numbers the symbols on the device s keyboard were completely worn down and invisible to the human eye The old keyboards had exactly m 1 buttons one for each digit from the base m numerical system and one single backspace button allowing one to erase the last written digit if nothing was written on the screen then this button does nothing but it s still counted as pressed Jan would like to communicate with his crew He needs to type a certain number also from the base m numerical system that is digits from 0 to m 1 He wants to know the expected number of button presses necessary to contact the U S S Coder Jan always chooses the most optimal buttons based on his current knowledge Buttons are indistinguishable until pressed Help him ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "Let us make some observations First of them is that if a phone number consists of two or more of the same kind then we will always pay exactly click for each but the first occurrence of it it follows from the fact that we have to already the key responsible for this digit This is why we can reduce the problem to finding a solution for a phone number with unique digits Secondly since all the buttons are indistinguishable at the beginning then the order of digits in the input does not matter This leads to the conclusion that what we want to compute is some kind of which stands for expected time of completing number if buttons that we have to eventually click are not yet discovered and buttons that we don t need are also not yet discovered Unfortunately the BackSpace key and necessity of clearing incorrect prefix of the phone number complicates things significantly We will create additional dimension of the responsible for the state of the prefix and the information about if we have already clicked backspace Those four states will be empty prefix of digits on the screen non empty correct prefix of digits on the screen non empty prefix that is not prefix of the phone number when we have already found a backspace we assume prefix is correct or in other words paid in advance Let us first compute If then Else we try to click new buttons If we guess correctly exactly the next button then we get Otherwise we could guess one of the remaining good buttons with probability Since we already know backspace location we can remove it and in future we will pay only for this digit We hence get operations Similarly if we guess bad button we get Rest of the states can be computed using similar approach Even though transitions may look scary they are similar for different dimensions and common implementation can be used "}
{"statement": "You are given the array of integer numbers For each element find the distance to the nearest zero to the element which equals to zero There is at least one zero element in the given array ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let s divide the solution into two parts firstly check the closest zero to the left and then the closest zero to the right After that we can take minimum of these numbers Initialize distance with infinity Iterate over array from left to right If value in current position is then set distance to otherwise increase distance by On each step write value of distance to the answer array Do the same thing but going from right to left This will find closest zero to the right Now you should write minimum of current value of distance and value that s already in answer array Finally you should retrieve the answer from distances Overall complexity "}
{"statement": "Entering senior high school life Tom is attracted by LIS problems not only the Longest Increasing Subsequence problem but also the Largest Interval Sum problem Now he gets a really interesting problem from his friend Daniel However it seems too hard for him to solve it so he asks you for help Given an array a consisting of n integers In one operation you do the following Select an interval l r 1 le l le r le n such that the sum of the interval is the largest among in the array a More formally displaystyle sum i l r a i max 1 le l le r le n sum i l r a i Then subtract 1 from all elements a l a l 1 ldots a r Find the minimum number of operations you need to perform to make a i 0 for every 1 le i le n ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "Call an interval if and only if it has no prefixes or suffixes with sum For a candidate good interval if there is no or such that or is also a candidate good interval we call it It s easy to show that all intervals which satisfy the condition in the statement are candidate good intervals and at least one of them is a good interval For two good intervals and they will never intersect More formally either or or If they intersect then the union of the two intervals is also a candidate good interval violating the definition of good intervals In each operation we choose one good interval that satisfies the condition in the statement This will give the minimum answer Following our process of the greedy algorithm it s easy to see that the intervals on which we perform operations each time will form a tree structure If we do the operation on one such interval then one of the following happens The interval remains good The interval is no longer good and we can split it into several good intervals For example if we do one operation on it will be split into good intervals In the first case we can keep doing operations on this interval without thinking whether it will have the largest sum among all intervals since it remains good and all good intervals must be split into shorter good intervals unless it has length In this case we can simply do the operations until the only element falls In the second case let means that if all the elements in the interval decrease is the smallest integer which meets with the following then That is where is defined similarly Have you noticed that it is very similar to the slope between points and on a 2 D plane So what we need to find is just the first point before after in the convex hull for points To find it we can use a segment tree to directly maintain the convex hull for certain intervals each time we query intervals and do ternary search on the convex hull of each interval This step will cost In each split the number of good intervals increases so we do at most splits Overall time complexity is "}
{"statement": "Two people are playing a game with a string s consisting of lowercase latin letters On a player s turn he should choose two consecutive equal letters in the string and delete them For example if the string is equal to than there is only one possible turn delete so the string will become A player not able to make a turn loses Your task is to determine which player will win if both play optimally ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "It can be shown that the answer does not depend on the order of deletions Let s remove letters from left to right storing a stack of letters remaining in the left When we process a letter it will be deleted together with the last letter in the stack if they are equal or will be pushed to the stack Let s calculate parity of the number of deletions during this process and determine the answer "}
{"statement": "Vova again tries to play some computer card game The rules of deck creation in this game are simple Vova is given an existing deck of cards and a magic number The order of the cards in the deck is fixed Each card has a number written on it number is written on the th card in the deck After receiving the deck and the magic number Vova removes possibly cards from the top of the deck possibly cards from the bottom of the deck and the rest of the deck is his new deck Vova has to leave at least one card in the deck after removing cards So Vova s new deck actually contains cards from the original deck Vova s new deck is considered iff the product of all numbers written on the cards in his new deck is divisible by So Vova received a deck possibly not a one and a number and now he wonders how many ways are there to choose and so the deck he will get after removing cards from the top and cards from the bottom is ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s use two pointers Firstly you need to learn to factorize any number in no more than We don t actually need any of their prime divisors except for those that are presented in So let s factorize in After that check for the maximum power of each useful prime will work in for each number Now notice that if some segment has its product divisible by then all segments for will also have products divisible by Now we have to find the smallest for each out there That s where two pointers kick in Let s maintain the current product of the segment in factorized form only useful primes as in normal form its enormous The power of some prime in this form is the sum of powers of this prime in all the numbers in the segment We firstly move the left border of the segment one step to the right and then keep moving the right border to the right until power of at least one prime number in the product is smaller than in It means that it is not divisible by Moving the left border means subtracting all the powers of useful primes of number from the product and moving the right border is adding all the powers of useful primes of The first time we reach such a segment we add to answer consider indexed Overall complexity where is up to "}
{"statement": "Fox Ciel is playing a card game with her friend Fox Jiro There are piles of cards on the table And there is a positive integer on each card The players take turns and Ciel takes the first turn In Ciel s turn she takes a card from the top of any non empty pile and in Jiro s turn he takes a card from the bottom of any non empty pile Each player wants to maximize the total sum of the cards he took The game ends when all piles become empty Suppose Ciel and Jiro play optimally what is the score of the game ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "First let s consider the case which all piles have even size In this case we can prove in the optimal play Ciel will gets all top most half cards of each pile and Jiro gets the remain cards We can prove by these facts Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome For Jiro this strategy is easy just pick the card from pile that Ciel have just picked For Ciel it s a little bit harder Why we can conclude they are both the optimal strategy Ciel just can t win more because if she played with Jiro with above strategy Jiro will get the bottom half of each pile Then we come back with cases that contain odd size piles The result is for odd size pile Ciel will get the top s 1 2 cards and Jiro will get the bottom s 1 2 cards Then what about the middle one Let s denote S is all such middle cards Then we define a reduced game In each turn they pick one card from S The optimal play for this game is easy Ciel gets the max one and Jiro gets the 2nd largest one and Ciel gets the 3rd largest one and so on We can prove Ciel have a strategy to get all top half parts cards she will get in the optimal play in the reduced game And Jiro also have a strategy to get all bottom half parts cards he will get in the optimal play in the reduced game And these strategy are optimal "}
{"statement": "One day Petya got a set of wooden cubes as a present from his mom Petya immediately built a whole city from these cubes The base of the city is an square divided into unit squares The square s sides are parallel to the coordinate axes the square s opposite corners have coordinates and On each of the unit squares Petya built a tower of wooden cubes The side of a wooden cube also has a unit length After that Petya went an infinitely large distance away from his masterpiece and looked at it in the direction of vector Petya wonders how many distinct cubes are visible from this position Help him find this number Each cube includes the border We think that a cube is visible if there is a ray emanating from some point belonging to the cube in the direction of vector that doesn t contain any points belonging to other cubes ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "You need for every column find the lowermost cube that you can see You will see all cubes above this cube Consider the city from above You will see drid of size n n Now you should draw the line through every node of the grid parallel to vector v We need know only that happens in every strip between two neighbour lines Every column cover segment of O n adjacent strips Now you should create an array a every element of a corresponding to one strip This array will store maximal height of considered columns Then you should sort all columns in order if increasing distance from observer In that order you should do following queries of 2 types Minimum on segment This query is needed when you want find the lowermost visible cube Replace ai max ai h on segment You need this query for drawing column in the array That is all solution You just need choose some data structure that can fast do queries You can select from block decomposition length of every block should be because length of every query about O n total complexity of solution will be O n5 2 segment tree stupid array it s O n3 cache optimized implementaton fits in the time limit "}
{"statement": "Once the mischievous and wayward shooter named Shel found himself on a rectangular field of size n times m divided into unit squares Each cell either contains a target or not Shel only had a lucky shotgun with him with which he can shoot in one of the four directions right down left down left up or right up When fired the shotgun hits all targets in the chosen direction the Manhattan distance to which does not exceed a fixed constant k The Manhattan distance between two points x 1 y 1 and x 2 y 2 is equal to x 1 x 2 y 1 y 2 Shel s goal is to hit as many targets as possible Please help him find this value ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "First of all notice that we can consider only the case where the triangle of affected cells is oriented left up To solve the remaining cases we can solve the problem for four different board orientations and choose the maximum result from the obtained results We will store several arrays with prefix sums for the sum of all numbers in the cells of the current column above the given one as well as for the sum of all numbers in the cells up and to the right of the given one Using such prefix sums we can easily recalculate the answer in cell through the answer in cell in To do this we need to add the sum of the cells marked in green and subtract the sum of the cells marked in red The total time complexity of this solution is Note that the problem could also be solved in time by computing prefix sums in the minimum of the directions and calculating the sums in the triangle in This solution also fits within the time limit "}
{"statement": "PizzaForces is Petya s favorite pizzeria PizzaForces makes and sells pizzas of three sizes small pizzas consist of 6 slices medium ones consist of 8 slices and large pizzas consist of 10 slices each Baking them takes 15 20 and 25 minutes respectively Petya s birthday is today and n of his friends will come so he decided to make an order from his favorite pizzeria Petya wants to order so much pizza that each of his friends gets at least one slice of pizza The cooking time of the order is the total baking time of all the pizzas in the order Your task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total For example if 12 friends come to Petya s birthday he has to order pizzas containing at least 12 slices in total He can order two small pizzas containing exactly 12 slices and the time to bake them is 30 minutes if 15 friends come to Petya s birthday he has to order pizzas containing at least 15 slices in total He can order a small pizza and a large pizza containing 16 slices and the time to bake them is 40 minutes if 300 friends come to Petya s birthday he has to order pizzas containing at least 300 slices in total He can order 15 small pizzas 10 medium pizzas and 13 large pizzas in total they contain 15 cdot 6 10 cdot 8 13 cdot 10 300 slices and the total time to bake them is 15 cdot 15 10 cdot 20 13 cdot 25 750 minutes if only one friend comes to Petya s birthday he can order a small pizza and the time to bake it is 15 minutes ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Note that the speed of cooking slice of pizza is the same for all sizes slice of pizza for minutes If is odd then we will increase it by since the pizza is cooked only with an even number of pieces Now the value of is always even If then for such the answer is equal to the answer for so we can say that While we can order a small pizza Eventually the value of will be equal to or This means that for any there will be a set of pizzas with exactly slices Then the answer is in the solution it is better to use the formula "}
{"statement": "You are given three integers n l and r You need to construct an array a 1 a 2 dots a n l le a i le r such that gcd i a i are all distinct or report there s no solution Here gcd x y denotes the greatest common divisor GCD of integers x and y ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": " Because all are different then which means is the multiple of To check if there is such just check if the minimum multiple of that is strictly bigger than is less than Time complexity for each test case "}
{"statement": "For an array a a 1 a 2 dots a n let s denote its a l r as the array a l a l 1 dots a r For example the array a 1 3 1 has 6 non empty subarrays a 1 1 1 a 1 2 1 3 a 1 3 1 3 1 a 2 2 3 a 2 3 3 1 a 3 3 1 You are given two integers n and k Construct an array a consisting of n integers such that all elements of a are from 1000 to 1000 a has exactly k subarrays with positive sums the rest dfrac n 1 cdot n 2 k subarrays of a have negative sums ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "There are many ways to solve this problem I will describe the following recursive solution if let s compose an array where every segment ending with the th element is positive and every other segment is negative This array can be where is the th element of the array note that when doesn t belong to the array so it consists of only negative numbers but if solve the same problem with and recursively get an array of length with positive subarrays and append to it to make all segments ending with the last element positive "}
{"statement": "Misha has found a binary tree with n vertices numbered from 1 to n A binary tree is an acyclic connected bidirectional graph containing n vertices and n 1 edges Each vertex has a degree at most 3 whereas the root is the vertex with the number 1 and it has a degree at most 2 Unfortunately the root got infected The following process happens n times Misha either chooses a non infected and not deleted vertex and deletes it with all edges which have an end in this vertex or just does nothing Then the infection spreads to each vertex that is connected by an edge to an already infected vertex all already infected vertices remain infected As Misha does not have much time to think please tell him what is the maximum number of vertices he can save from the infection note that deleted vertices are not counted as saved ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "SolutionLet be the sequence of removed vertices such that the infection cannot spread anymore If vertex was never directly connected to an infected vertex then we could have deleted its parent instead of and we would have got a better solution Hence we may assume we always delete a vertex directly connected to an infected one Now we may use some dynamic programming ideas Let be the maximum number of vertices we can save in the subtree of vertex if that vertex is infected and we use operations only in the subtree We can assume the second as the tree is binary and we have two choices save the subtree of one child by deleting it and infect the other or the other way around In each case the infection will be active in at most one subtree of some vertex If and are the children of vertex the transition is where denotes the number of vertices in the subtree of The answer to the problem is Complexity is "}
{"statement": "There is an empty matrix M of size n times m Zhongkao examination is over and Daniel would like to do some puzzle games He is going to fill in the matrix M using permutations of length m That is each row of M must be a permutation of length m dagger Define the of the i th column in M as v i operatorname MEX M 1 i M 2 i ldots M n i ddagger Since Daniel likes diversity the of M is s operatorname MEX v 1 v 2 cdots v m You have to help Daniel fill in the matrix M and its beauty dagger A permutation of length m is an array consisting of m distinct integers from 0 to m 1 in arbitrary order For example 1 2 0 4 3 is a permutation but 0 1 1 is not a permutation 1 appears twice in the array and 0 1 3 is also not a permutation m 1 2 but there is 3 in the array ddagger The operatorname MEX of an array is the smallest non negative integer that does not belong to the array For example operatorname MEX 2 2 1 0 because 0 does not belong to the array and operatorname MEX 0 3 1 2 4 because 0 1 2 and 3 appear in the array but 4 does not ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "On one hand the matrix has rows so the maxmium does not exceed and does not exceed On the other hand the matrix has columns and there are only numbers in the array so must not exceed Therefore the upper bound of is How can we reach the upper bound If then the only possible in this case so must be which unfortunately cannot reach the upper bound I ve added this test to examples If let s construct the in two cases In this case we can construct like following More formally Note that in this case so we have Then which reaches the upper bound In this case we can construct like following More formally for for Note that and Similarly to case 1 we can get which also reaches the upper bound Time Complexity per test case "}
{"statement": "Little Gerald and his coach Mike play an interesting game At the beginning of the game there is a pile consisting of candies and a pile consisting of stones Gerald and Mike move in turns Mike goes first During his move Mike checks how many candies and stones Gerald has eaten Let Gerald eat candies and stones Then Mike awards Gerald prize points Gerald during his move either eats a candy from the pile of candies or a stone from the pile of stones As Mike sees that Gerald has eaten everything apart one candy and one stone he awards points for the last time and the game ends Gerald is not allowed to eat all the candies and he is not allowed to eat all the stones too Tell Gerald how to play to get the largest possible number of points it is required to find one of the possible optimal playing strategies for Gerald ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Essence of problem is that there is a board n m in cell of wich placed numbers And one must go from cell 0 0 to cell n 1 m 1 doing moves to one cell up and right that is increasing by 1 on of coordinates maximizing sum o number on the cell in the path Gerald s problems is determine m n 1 cells of optimal path Lets start with search one middle cell Lets What cell of board can be k th in path It is cell sum of coordinate of wich is equal to k thus it is diagonal of doard And then we can calculate what maximum sum Gerald can collect came to every cell in the diagonal by dynamic programming in lower triangle And the same way we can calculate what maximum sum Gerald can collect came to cell n 1 m 1 starting from every cell in the diagonal Sumed up this to values we calculate what maximum sum Gerald can collect came to from cell 0 0 to cell n 1 m 1 travel throw every cell in the diagonal And now we will find cell x y in wich maximum is reached It is k th cell of the path We used time O n m 2 and memory O n m Then we make recursive call on subproblems In other word will find optimal path from cell 0 0 to cell x y and from cell x y to cell n m It is evident this solution take memory O n m Why it tkae time O n m 2 Lets n m is r Once we are find middle cell of path of length k Twice we are find middle cell of path of length Four times we are find middle cell of path of length And so on Therefore time of program working will be "}
{"statement": "Masha wants to open her own bakery and bake muffins in one of the cities numbered from to There are bidirectional roads each of whose connects some pair of cities To bake muffins in her bakery Masha needs to establish flour supply from some storage There are only storages located in different cities numbered Unforunately the law of the country Masha lives in prohibits opening bakery in any of the cities which has storage located in it She can open it only in one of another cities and of course flour delivery should be paid for every kilometer of path between storage and bakery Masha should pay ruble Formally Masha will pay roubles if she will open the bakery in some city for every and choose a storage in some city for some and and are connected by some path of roads of summary length if there are more than one path Masha is able to choose which of them should be used Masha is very thrifty and rational She is interested in a city where she can open her bakery and choose one of storages and one of the paths between city with bakery and city with storage and pay minimum possible amount of rubles for flour delivery Please help Masha find this amount ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1300", "problem_editorial": "Note that it makes no sense to choose the city for bakeries and the city with the warehouse so that had more than one way between them as every road increases the distance over which you have to pay So the problem reduces to the following select two neighboring cities so that one is a warehouse and in the other mdash no For doing this simply iterate through all the city with the warehouse among the neighbors of each town without looking for a warehouse and update the answer If there is such a pair of cities print 1 "}
{"statement": "Tenzing has an array a of length n and an integer v Tenzing will perform the following operation m times Choose an integer i such that 1 leq i leq n uniformly at random For all j such that i leq j leq n set a j a j v Tenzing wants to know the expected value of prod i 1 n a i after performing the m operations modulo 10 9 7 Formally let M 10 9 7 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output the integer x that 0 le x M and x cdot q equiv p pmod M ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "TutorialBefore starting to solve this problem let s establish two basic properties For two completely independent random variables we have For we have Returning to this problem let be a random variable its value is when the th operation sets to otherwise it is Then note that the answer is the expected value of Applying the second property above to split the product each term is a product of some and Specifically each term has factors and for each either is one of its factors or some is one of its factors Let s investigate the expectation of a specific term Note that if then that is if is then the whole product is and if is then must be Therefore for all the factors in a term we categorize them by the first index i e we group all into category For each category we only need to focus on the first variable If it s then the remaining variables take value otherwise the result is Note that the variables in different categories are completely independent because their values are determined by operations in two different rounds so the expected product of the variables in two categories can be split into the product of the expected products of the variables within each category Our goal is to compute the expected sum of all the terms which can be nicely combined with DP Let be the value that we have determined the first factors of each term and there are categories that have appeared at least once if adding the variable at position brings contribution otherwise the contribution is The transition can be easily calculated with depending on whether to append or to each term and if it s the latter we discuss whether the variable belongs to one of the categories that have appeared or the other categories The time complexity is "}
{"statement": "Petya calls a of a positive integer the number that is obtained after successive writing of all lucky digits of number from the left to the right For example the mask of number is number the mask of is the mask of is Obviously mask of any number is always a lucky number Petya has two numbers an arbitrary integer and a lucky number Help him find the minimum number such that the mask of number equals ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "You can see that in worst case the answer will be equal to 177777 It can t be greater So only thing you need is to write some function F x which will return mask of the x After that you need to write such kind of code x a 1 while F x is not equal to b increase x and x will contain the answer "}
{"statement": "Your friend Ivan asked you to help him rearrange his desktop The desktop can be represented as a rectangle matrix of size n times m consisting of characters empty cell of the desktop and an icon The desktop is called if all its icons are occupying some prefix of full columns and possibly the prefix of the next column and there are no icons outside this figure In other words some amount of first columns will be filled with icons and possibly some amount of first cells of the next after the last full column column will be also filled with icons and all the icons on the desktop belong to this figure This is pretty much the same as the real life icons arrangement In one move you can take one icon and move it to any empty cell in the desktop Ivan loves to add some icons to his desktop and remove them from it so he is asking you to answer q queries what is the number of moves required to make the desktop after adding removing one icon Note that and change the state of the desktop ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "I ve seen a lot of data structures solutions for this problem but author s solution doesn t use them and works in Firstly let s change our matrix to a string because it will be easier to work with a string than with a matrix The order of characters will be from top to bottom from left to right i e the outer cycle by columns and the inner by rows Then let s calculate the number of icons on the desktop the number of in Then the answer will be obviously the number of dots on the prefix of of size Now let s deal with queries It can be shown that one query changes our answer by no more than Let be the position of the cell that is being changed in zero indexed Then if there are two cases If is then we have one more icon on our prefix so the answer decreases by one because we filled one empty space in the good desktop Otherwise it increases by one because this icon is outside our prefix Then let s change the corresponding character by the opposite After that we should move our right border accordingly to the new number of icons Note that this border is exclusive If becomes then we will increase the variable But before that if is then there should be an icon and it is not here yet so the answer increases Otherwise our border will decrease Then if is then the answer decreases because there was a place for an icon and now it is not needed anymore Time complexity "}
{"statement": "One drew a closed polyline on a plane that consisted only of vertical and horizontal segments parallel to the coordinate axes The segments alternated between horizontal and vertical ones a horizontal segment was always followed by a vertical one and vice versa The polyline did not contain strict self intersections which means that in case any two segments shared a common point that point was an endpoint for both of them please consult the examples in the notes section Unfortunately the polyline was erased and you only know the lengths of the horizonal and vertical segments Please construct any polyline matching the description with such segments or determine that it does not exist ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "First note that in a correct polyline since the horizontal and vertical segments alternate if this equality does not hold the answer is negative Now let s fix a vertex and go around the polyline in some direction Then in the process of traversin we will move in one of four possible directions up down right or left Since the polyline is closed this means that we will move to the left in total by the same distance as we will move to the left in total The same is true for moving up and down This means that if we split all the segments into four sets named then the total length of the segments in will be equal to the total length of the segments in and the total length of the segments in will be equal to the total length of the segments in But it means that the set of lengths of all horizontal segments can be divided into two sets with the same sum The same should hold for vertical segments Let s check whether it is possible to divide the set of lengths of horizontal segments into two sets of the same sum This classic problem can be solved by applying the dynamic programming method to solve the backpack problem The complexity of this solution will be If it is impossible to split horizontal or vertical lengths into two sets of equal length the answer is Now we will show how to construct a correct answer if such divisions exist Let us divide all horizontal lengths into two sets of equal total length We denote the smaller set as and the larger set as We will do the same with the set of lengths of vertical segments we will denote the smaller set as and the larger one as Since Similarly we have which follows that Now let s divide all the segments into pairs as follows each segment of we match with a segment from All remaining segments of are matched with one of the remaining vertical segments Thus we have divided all these segments into three sets of pairs in the first one a segment from is paired with a segment from In the second set a segment from is paired with a segment from In the third set a segment from is paired with a segment from From the first set of pairs we make up the set of vectors directed up and to the right from the pair r u we construct the vector r u This way we can construct a set of vectors We will do the same with the second set of pairs constructing a set of vectors and the third set of pairs constructing a set of vectors for a better understanding see the picture above Note that the set may be empty while the other two can not Let s make a convex polyline from the vectors of In order to do this sort them in ascending order by the polar angle and make a polyline from them in this order see the picture below Now we will replace each of the vectors of our polyline with two vectors one vector directed to the right and one vector directed upwards We will do the same for vectors from sort them in ascending order by the polar angle and make a convex polyline from them Let s combine these two polylines so that the first one goes from the point to the point and the second one goes from the point to the point We don t have much left to do we hate to connect the points and using vectors from the set Let s take these vectors directed up and to the left in any arbitrary order then since the sum of all vectors is 0 the resulting polyline if you draw it with the beginning at the point will end at the point Since the first two polylines were convex this means that none of the points of the first two polylines will lie strictly inside the angle which means that if you replace each of the vectors of the third polyline with two vectors one directed to the left and one directed upwards the resulting closed polyline will not contain self intersections It is easy to show that the resulting polyline will be closed and will satisfy all the conditions of the problem "}
{"statement": "Julia is going to cook a chicken in the kitchen of her dormitory To save energy the stove in the kitchen automatically turns off after minutes after turning on During cooking Julia goes to the kitchen every minutes and turns on the stove if it is turned off While the cooker is turned off it stays warm The stove switches on and off instantly It is known that the chicken needs minutes to be cooked on the stove if it is turned on and minutes if it is turned off You need to find out how much time will Julia have to cook the chicken if it is considered that the chicken is cooked evenly with constant speed when the stove is turned on and at a constant speed when it is turned off ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "There are repeated segments in the cooking process that are between two consecutive moments when Julia turns the stove on Let s call such segment a Consider two cases If when Julia comes the stove is always off that means In other case Julia comes to the kitchen times between two turnings on when the stove is still on and does nothing In this case is a number such that the stove is on the stove is off Then the period is and is equal to So Let s say the chicken consists of independent parts On the working stove two parts of the chicken are prepared per minute If the stove is off one part is prepared Let s find the number of prepared parts during one period and we need whole periods After that we still have parts left to cook If chicken will be prepared after minutes minutes the stove will be on and it will be off Thus the answer is Otherwise parts become ready after minutes and answer is "}
{"statement": "You are given a sequence a 1 a 2 dots a n consisting of n integers You may perform the following operation on this sequence choose any element and either increase or decrease it by one Calculate the minimum possible difference between the maximum element and the minimum element in the sequence if you can perform the aforementioned operation k times ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Suppose that the maximum value in the resulting array should be and the minimum value should be Let s estimate the required number of operations to make an array with such properties All elements that are less than should be increased to and all elements that are greater than should be decreased to and we don t have to do any operation with remaining elements Now we claim that either or should belong to the initial array Why so Suppose we constructed an answer such that and If the number of elements we increased to is not less than the number of elements we decreased to then we could construct the answer with minimum equal to and maximum equal to and it would not require more operations And if the number of elements we increased to is less than the number of elements we decreased to then we construct the answer for as minimum and as maximum So we can shift the range so that one of its endpoints belongs to the initial array Now we can solve the problem as follows iterate on the maximum in the resulting array and find the largest minimum we can obtain with binary search and then do it vice versa iterate on the minimum in the resulting array and find the largest maximum we can obtain with binary search To check how many operations we need for example to make all values not less than we can find the number of elements that we have to change with another binary search let the number of such elements be and find their sum with prefix sums let their sum be Then the required number of operations is exactly The same approach can be used to find the number of operations to make all elements not greater than This is the way the problem was supposed to solve but unfortunately we failed to find a much easier greedy solution "}
{"statement": "You are given two arrays of integers and For each element of the second array you should find the number of elements in array that are less than or equal to the value ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s sort all numbers in a Now let s iterate over elements of and for element find the index of lowest number that is greater than We can do that using binary search That index will be the answer for value Complexity "}
{"statement": "Today is tuesday that means there is a dispute in JOHNNY SOLVING team again they try to understand who is Johnny and who is Solving That s why guys asked Umnik to help them Umnik gave guys a connected graph with n vertices without loops and multiedges such that a degree of any vertex is at least 3 and also he gave a number 1 leq k leq n Because Johnny is not too smart he promised to find a simple path with length at least frac n k in the graph In reply Solving promised to find k simple by vertices cycles with representatives such that Length of each cycle is at least 3 Length of each cycle is not divisible by 3 In each cycle must be a representative vertex which belongs only to this cycle among all cycles You need to help guys resolve the dispute for that you need to find a solution for Johnny a simple path with length at least frac n k n is not necessarily divided by k or solution for Solving k cycles that satisfy all the conditions above If there is no any solution print 1 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2700", "problem_editorial": "Let s build a dfs spanning tree from the vertex 1 and find the depth of the tree If the depth is at least nk then we can just print the path from the root to the deepest vertex Otherwise there will be at least k leaves in the tree Let s prove it Consider a tree with c leaves after that consider a path from a particular leaf to the root let s denote length of i th path in vertices by xi We can say that x1 xc n because every particular vertex in the tree will be covered by one of pathways So using Dirichlet s principle we can say that max x1 xc nc Hence depth of the tree is at least nc Now consider a leaf in our spanning tree let s denote it like v This leaf has at least 2 back edges edges which connected with one of ancestors let s denote ancestors like x and y Obviosly we have three cycles here path from x to v with corresponding back edge the same cycle from y to v and path between x and y with two back edges connected with v Lengths of these cycles are d v x 1 d v y 1 and d x y 2 where d a b distance between vertices a and b It s clear that one of these numbers is not divisible by three Last problem is to choose representative we should choose leaves Size of output is not exceed 106 because the depth of our tree at most nk and each cycle has length O nk "}
{"statement": "XYMXYM and CQXYM will prepare n problems for Codeforces The difficulty of the problem i will be an integer a i where a i geq 0 The difficulty of the problems must satisfy a i a i 1 m 1 leq i n and a 1 a n m where m is a fixed integer XYMXYM wants to know how many plans of the difficulty of the problems there are modulo 998 244 353 Two plans of difficulty a and b are different only if there is an integer i 1 leq i leq n satisfying a i neq b i ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "If two numbers satisfying there can only be one number not less than Consider that cut the cycle to a sequence at the first position satisfying When we minus all the numbers that are not less than by we can get a sub problem However If is an even number we may not find such a position but we can still get a sub problem easily For this problem on a sequence we can divide the sequence into many segments and each of them can not be cut by us anymore There may be only segment and the first last element of the segment are not less than There may be many segments the length of the first one and last one are even and the rest of them are odd To solve the problem we define the GF A B A is the GF of the length of the segments are odd situation and B is the even one If is odd the segment with only a number exists and the GF of number of the sequence should be Otherwise it is To solve this problem use NTT and polynomial inversion algorithm is just ok Each time we transform a problem with limit to so the time complexity is solution "}
{"statement": "You are given a directed graph consisting of vertices and edges The vertices and are marked as source and sink correspondingly Additionally there are no edges ending at and there are no edges beginning in The graph was constructed in a following way initially each edge had capacity A maximum flow with source at and sink at was constructed in this flow network Let s denote as the value of flow passing through edge with index Next all capacities and flow value were erased Instead indicators were written on edges if flow value passing through edge was positive i e if and otherwise Using the graph and values find out what is the possible number of edges in the initial flow network that could be saturated the passing flow is equal to capacity i e Also construct the corresponding flow network with maximum flow in it A flow in directed graph is described by flow values on each of the edges so that the following conditions are satisfied for each vertex except source and sink total incoming flow and total outcoming flow are equal for each edge A flow is maximum if the difference between the sum of flow values on edges from the source and the sum of flow values on edges to the source there are no such in this problem is maximum possible ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3000", "problem_editorial": "Let s find a minimal set of saturated edges We will create new flow network consisting of the same set of vertices and a little bit different edges For an each edge from original graph without any flow let s create a new edge with the same direction and carrying capacity For every edge with a flow let s create two edges the first one with the same direction and capacity and the second edge with reversed direction and In the new network we have to find the minimum cut it will consist of edges with corresponding edges of the initial graph will be a desired minimal set If this minimal set was equal to infinity the description of the problem wouldn t be about maximum flow because it had to be increasing for sure So now it s enough to create a non zero flow for all edges needed in the task and to make on edges which we chose to be saturated and on the rest Let s consider directed graph with edges with a flow In the first situation we might make a circulation on a cycle in the second case we can put a flow on the way from the source to the stream of Thus for each edge on which something is to flow something will flow Suppose the contrary Let s take the edge of the form Well then there is no way from to or no way from to Let the second be true without loss of generality Let s consider the set of vertices attainable from If there are in this set there is a cycle Otherwise this set is bad cause there are no in it something flows in and nothing follows in a correct network this is impossible "}
{"statement": "You are given an array a of length n Also you are given m distinct positions p 1 p 2 ldots p m 1 leq p i leq n A subset of these positions T is randomly selected with equal probability and the following value is calculated sum i 1 n a i cdot min j in T left i j right In other word for each index of the array a i and the distance to the closest chosen position are multiplied and then these values are summed up Find the expected value of this sum This value must be found modulo 998 244 353 More formally let M 998 244 353 It can be shown that the answer can be represented as an irreducible fraction frac p q where p and q are integers and q neq 0 mod M Output the integer equal to p cdot q 1 mod M In other words output such integer x that 0 leq x M and x cdot q p mod M ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "First of all calculate for each index the total sum of distances among all subsets if the closest selected position is to the left Let where the number of cpecial positions at or to the right of if then Let if position is special otherwise It s not hard to see that the value for the position in this case equals to Then for each calculate two values Since we can find first value using DNC the second value we will find similary we want to consider every Then halve this segment Then create two polynomials The polynomial of size where The polynomial of size where By multiplying this two polinomials we can recalculate the values for positions from to and then solve two parts recursively Thus we can find for each index the total sum of distances among all subsets if the closest selected position is to the left To find for each index the total sum of distances among all subsets if the closest selected positions is to the right we can do the same stuff but in inverse order Note that we need to consider the case where the closest selected position to the left and the closest selected position are at the same distance from It can be done by changing in one of the cases by the number of special positinos strickly to the right of It can be implemented in using FFT "}
{"statement": "The new generation external memory contains an array of integers a 1 ldots n a 1 a 2 ldots a n This type of memory does not support changing the value of an arbitrary element Instead it allows you to cut out any segment of the given array rotate it by any offset and insert it back into the same place Technically each cyclic shift consists of two consecutive actions You may select arbitrary indices l and r 1 le l r le n as the boundaries of the segment Then you replace the segment a l ldots r with it s to the by an arbitrary offset d The concept of a can be also explained by following relations the sequence 1 4 1 3 is a cyclic shift of the sequence 3 1 4 1 to the left by the offset 1 and the sequence 4 1 3 1 is a cyclic shift of the sequence 3 1 4 1 to the left by the offset 2 For example if a 1 color blue 3 2 8 5 then choosing l 2 r 4 and d 2 yields a segment a 2 ldots 4 3 2 8 This segment is then shifted by the offset d 2 to the and you get a segment 8 3 2 which then takes the place of of the original elements of the segment In the end you get a 1 color blue 8 3 2 5 Sort the given array a using no more than n cyclic shifts of any of its segments Note that you don t need to minimize the number of cyclic shifts Any method that requires n or less cyclic shifts will be accepted ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "In this problem it was enough to implement an analogue of standard or Here is an example of a solution based on selection sort Let s find the minimum element in the array by simply iterating over it Let s denote its index in the array by If we apply a shift to it the following happens Once again please note that all shifts are made in the left direction so shifting by to the left will put the element that was previously at index in the first place Let us perform a similar shift for the second largest element of the array putting it in second place for the third largest element of the array putting it in third place and so on More formally let s describe the th iteration as follows At the beginning of the th iteration the first elements of the array are its minimal elements already in their correct places in sorted order During the th iteration the th largest element of the array is placed in the th place in the array Since the first minimal elements are already in their places the th largest element of the array is simply the smallest element among Let s find it by iterating over these elements and denote its index in the array by Make a shift The first elements will not change and the element from the th place in the array will move to the th It is worth noting that the output format forbids shifting segments with Regarding this case we should check the equality separately If these two indexes coincide then the th element is already in its place and no shift should be done on this iteration Let us repeat this algorithm for At each iteration the new element will be shifted into its place in sorted order and each iteration performs no more than one shift operation Thus in strictly less than shifts the array will be completely sorted The time complexity is "}
{"statement": "Polycarp loves ciphers He has invented his own cipher called Repeating cipher is used for strings To encrypt the string s s 1 s 2 dots s m 1 le m le 10 Polycarp uses the following algorithm he writes down s 1 ones he writes down s 2 twice he writes down s 3 three times he writes down s m m times For example if s the process is to to So the encrypted s is Given string t the result of encryption of some string s Your task is to decrypt it i e find the string s ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "There are many possible approaches in this problem I will describe one of the easiest Let s print the initial string by the following algorithm firstly init the variable Then while the encrypted string isn t empty print the first character of this string remove first characters from it and increase by one "}
{"statement": "It seems that Borya is seriously sick He is going visit doctors to find out the exact diagnosis Each of the doctors needs the information about all previous visits so Borya has to visit them in the prescribed order i e Borya should first visit doctor then doctor then doctor and so on Borya will get the information about his health from the last doctor Doctors have a strange working schedule The doctor goes to work on the th day and works every day So he works on days The doctor s appointment takes quite a long time so Borya can not see more than one doctor per day What is the minimum time he needs to visit all doctors ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Note that Borya can use a greedy algorithm He will visit each doctor as soon as possible We only need to find the earliest day when he can do it Constraints are pretty low so we can use almost any reasonable way For example we can just go through all the days starting from the current one and check if the doctor is working on that day At the step we need to go through at most days There is a more efficient way We can find the smallest that is greater than the current day such that in If Borya will visit a doctor on day otherwise on day This solution is "}
{"statement": "n people came to the festival and decided to dance a few round dances There are at least 2 people in the round dance and each person has exactly two neighbors If there are 2 people in the round dance then they have the same neighbor on each side You decided to find out exactly how many dances there were But each participant of the holiday remembered exactly neighbor Your task is to determine what the minimum and maximum number of round dances could be For example if there were 6 people at the holiday and the numbers of the neighbors they remembered are equal 2 1 4 3 6 5 then the number of round dances is1 1 2 3 4 5 6 1 and the is 3 1 2 1 3 4 3 5 6 5 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1600", "problem_editorial": "Let s build an undirected graph draw the edges Let s split this graph into connectivity components denote their number by There could not be more than round dances Since the degree of each vertex is no more than two the connectivity components are simple cycles and bamboos If we connect the vertices of degree one in each bamboo we get a partition into round dances Now let s try to get the minimum number of round dances Nothing can be done with cycles and all bamboos can be combined into one If you get bamboos and cycles then the answer is Time complexity is "}
{"statement": "You are given an array a consisting of n positive integers You can perform the following operation on it Choose a pair of elements a i and a j 1 le i j le n and i neq j Choose one of the divisors of the integer a i i e an integer x such that a i bmod x 0 Replace a i with frac a i x and a j with a j cdot x Determine whether it is possible to make all elements in the array the same by applying the operation a certain number of times possibly zero For example let s consider the array a 100 2 50 10 1 with 5 elements Perform two operations on it Choose a 3 50 and a 2 2 x 5 Replace a 3 with frac a 3 x frac 50 5 10 and a 2 with a 2 cdot x 2 cdot 5 10 The resulting array is a 100 10 10 10 1 Choose a 1 100 and a 5 1 x 10 Replace a 1 with frac a 1 x frac 100 10 10 and a 5 with a 5 cdot x 1 cdot 10 10 The resulting array is a 10 10 10 10 10 After performing these operations all elements in the array a become equal to 10 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "To solve the problem we need to decompose all numbers in the array into prime divisors After that let s calculate the number of each divisor summarizing the decompositions of all numbers If each divisor enters times where is a natural number then we can equalize all the numbers in the array we will sequentially apply the operation so that each number consists of the same set of prime divisors If some divisor enters a different number of times then it will not be possible to equalize the numbers in the array "}
{"statement": "An online contest will soon be held on ForceCoders a large competitive programming platform The authors have prepared n problems and since the platform is very popular 998244351 coder from all over the world is going to solve them For each problem the authors estimated the number of people who would solve it for the i th problem the number of accepted solutions will be between l i and r i inclusive The creator of ForceCoders uses different criteria to determine if the contest is good or bad One of these criteria is the number of inversions in the problem order An inversion is a pair of problems x y such that x is located earlier in the contest x y but the number of accepted solutions for y is greater Obviously both the creator of ForceCoders and the authors of the contest want the contest to be good Now they want to calculate the probability that there will be inversions in the problem order assuming that for each problem i any number of accepted solutions for it between l i and r i is equally probable and all these numbers are independent ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "The naive solution is dynamic programming let be the probability that the first problems don t have any inversions and the th one got accepted solutions Let s somehow speed it up For convenience I will modify the variable denoting the maximum number of accepted solutions for each problem and I will also reverse the problem order so that we don t want the number of solutions to decrease from problem to problem We know that if and otherwise Let s divide the whole segment between and into segments with the values of and and analyse the behavior of values on each such segment Let If we consider the behavior of on some segment we got we can prove by induction that it is a polynomial of degree not exceeding All that is left is to carefully calculate and maintain these polynomials on segments The main thing we will use to calculate the polynomials is interpolation To transition from to we will consider each segment separately calculate the first several values of on each segment we need to calculate the sum fast if is a polynomial this can also be done with interpolation and then interpolate it on the whole segment This is actually slow we have to interpolate at least polynomials and not easy to write Let s consider a better solution We will use combinatoric approach instead of calculating probabilities we will count all the non descending sequences such that and divide it by the number of all sequences without the non descending condition that is just Let s again divide into segments using the points and enumerate these segments from left to right If there are two neighboring values and they either belong to the same segment or the segment belongs to is to the right of the segment belongs to We could try to write the following dynamic programming solution is the number of non descending prefixes of the sequence such that there are elements in the prefix and the last one belongs to segment It s easy to model transitions from to where but we don t know how to model the transition to Let s get rid of them altogether We will introduce an additional constraint in our dynamic programming is the number of prefixes of the sequence of length The transitions in this dynamic programming are different we iterate on the number of elements belonging to the next segment and transition into if possible Calculating the number of ways to take elements from an interval in sorted order can be reduced to calculating the number of ways to compose as the sum of non negative summands order matters We should be able to calculate binomial coefficients with fairly large and not so large but that s not really hard if we use the formula "}
{"statement": "Some dwarves that are finishing the StUDY State University for Dwarven Youngsters Bachelor courses have been told no genome no degree That means that all dwarves should write a thesis on genome Dwarven genome is far from simple It is represented by a string that consists of lowercase Latin letters Dwarf Misha has already chosen the subject for his thesis determining by two dwarven genomes whether they belong to the same race Two dwarves belong to the same race if we can swap two characters in the first dwarf s genome and get the second dwarf s genome as a result Help Dwarf Misha and find out whether two gnomes belong to the same race or not ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "If the lengths of 2 strings aren t equal that means NO We try to find the positions in strings where chars are different If there 1 or more than 2 such positions NO After that we swap 2 characters in the first string and check for their equality "}
{"statement": "You are coloring an infinite square grid in which all cells are initially white To do this you are given n stamps Each stamp is a rectangle of width w i and height h i You will use stamp exactly to color a rectangle of the same size as the stamp on the grid in black You cannot rotate the stamp and for each cell the stamp must either cover it fully or not cover it at all You can use the stamp at any position on the grid even if some or all of the cells covered by the stamping area are already black What is the minimum sum of the of the connected regions of black squares you can obtain after all the stamps have been used ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "We must minimize the perimeter and an obvious way to attempt this is to maximize the overlap To achieve this we can place each stamp such that the lower left corner of each stamp is at the same position like shown in the sample explanation Now we can observe that the perimeter of this shape is determined solely by the maximum height and width of any stamp and these values cannot be reduced further Therefore the answer is Furthermore it s true that any arrangement of stamps which are fully enclosed in an outer rectangular area of by will yield the same perimeter "}
{"statement": "Recently a start up by two students of a state university of city F gained incredible popularity Now it s time to start a new company But what do we call it The market analysts came up with a very smart plan the name of the company should be identical to its reflection in a mirror In other words if we write out the name of the company on a piece of paper in a line horizontally from left to right with large English letters then put this piece of paper in front of the mirror then the reflection of the name in the mirror should perfectly match the line written on the piece of paper There are many suggestions for the company name so coming up to the mirror with a piece of paper for each name wouldn t be sensible The founders of the company decided to automatize this process They asked you to write a program that can given a word determine whether the word is a mirror word or not ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "One should firstly recognize that the required string should be palindrome and each character of the string should be symmetric All the symmetric characters are "}
{"statement": "You are given two arrays a and b of size n along with a fixed integer v An interval l r is called a interval if b l mid b l 1 mid ldots mid b r ge v where denotes the bitwise OR operation The of a good interval is defined as max a l a l 1 ldots a r You are given q queries of two types assign b i x find the beauty among all intervals l 0 r 0 satisfying l le l 0 le r 0 le r If there is no suitable good interval output 1 instead Please process all queries ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "Tutorial First we use the line segment tree to maintain sequence For the nodes on each line segment tree we maintain the first and last occurrence positions of each binary bit in the interval We need to merge the two intervals whether it is modification or query Suppose you want to use the information of to merge the information of Consider the answer that spans two intervals If we want to make the th position of the interval OR then there are two possibilities Select the last occurrence position of the th bit in Select the first occurrence position of the th bit in Let If we can choose the position greedily because his price is smaller If you choose then you must also choose because choosing does not increase max Otherwise select on the contrary With the above greedy then you can enumerate the first binary bit that is larger than The th bit of the interval OR must be and the th bit of is For the th bit if the th bit of is then the th bit must also be The rest of the bits can be regarded as or you only need to deal with these bits that must be selected greedily and expand the interval You can use the st table to find the interval max of so you can merge the information of the two intervals in the time of With the line segment tree can be done "}
{"statement": "Three guys play a game first each person writes down n distinct words of length 3 Then they total up the number of points as follows if a word was written by one person that person gets 3 points if a word was written by two people each of the two gets 1 point if a word was written by all nobody gets any points In the end how many points does each player have ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "You need to implement what is written in the statement To quickly check if a word is written by another guy you should store some or Python dictionary and increment every time you see a new string in the input Then you should iterate through each guy find the number of times their word appears and update their score The complexity is per testcase "}
{"statement": "You are given a sequence of n digits d 1d 2 dots d n You need to paint all the digits in two colors so that each digit is painted either in the color 1 or in the color 2 if you write in a row from left to right all the digits painted in the color 1 and then after them all the digits painted in the color 2 then the resulting sequence of n digits will be non decreasing that is each next digit will be greater than or equal to the previous digit For example for the sequence d 914 the only valid coloring is 211 paint in the color 1 two last digits paint in the color 2 the first digit But 122 is not a valid coloring 9 concatenated with 14 is not a non decreasing sequence It is allowed that either of the two colors is not used at all Digits painted in the same color are not required to have consecutive positions Find any of the valid ways to paint the given sequence of digits or determine that it is impossible to do ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "The sequence must split into two non decreasing where the end of the first start of the second Let s bruteforce the value x so that all elements x go to the color 1 all elements x go to the color 2 and for x we are not sure Actually we can say that all elements equal to x which go before the first element x an safely go to the color 2 while the rest can only go to the color 1 So we colored our sequence and we now only need to check whether this coloring is fine Complexity is 10 n "}
{"statement": "One day liouzhou 101 got a chat record of Freda and Rainbow Out of curiosity he wanted to know which sentences were said by Freda and which were said by Rainbow According to his experience he thought that Freda always said at the end of her sentences while Rainbow always said at the beginning of his sentences For each sentence in the chat record help liouzhou 101 find whose sentence it is ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "We only need to find out if miao is a prefix of the sentence and if lala is a suffix of the sentence Pay attention to the situation when both conditions are satisfied "}
{"statement": "There are balls They are arranged in a row Each ball has a color for convenience an integer and an integer value The color of the th ball is and the value of the th ball is Squirrel Liss chooses some balls and makes a new sequence without changing the relative order of the balls She wants to maximize the value of this sequence The value of the sequence is defined as the sum of following values for each ball where and are given constants If the ball is not in the beginning of the sequence and the color of the ball is same as previous ball s color add the value of the ball Otherwise add the value of the ball You are given queries Each query contains two integers and For each query find the maximal value of the sequence she can make when and Note that the new sequence can be and the value of an empty sequence is defined as zero ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "There are many O Q N logN solutions using segment trees or other data structures but probably they will get time limit exceeded We can solve each query independently First let s consider the following DP algorithm dp c the maximal value of a sequence whose last ball s color is c For each ball i we want to update the array Let the i th ball s color be col i the i th ball s value be val i and the maximal value of dp array other than dp col i be otherMAX We can update the value of dp col i to dp col i val i a or otherMAX val i b Here we only need to know dp col i and otherMAX If we remember the biggest two values of dp array in that time and their indexes in the array otherMAX can be calculated using the biggest two values which always include maximal values of dp array other than any particular color Since the values of dp array don t decrease we can update the biggest two values in O 1 Finally the answer for the query is the maximal value of dp array "}
{"statement": "Johnny drives a truck and must deliver a package from his hometown to the district center His hometown is located at point on a number line and the district center is located at the point Johnny s truck has a gas tank that holds exactly liters and his tank is initially full As he drives the truck consumes exactly one liter per unit distance traveled Moreover there are gas stations located at various points along the way to the district center The th station is located at the point on the number line and sells an unlimited amount of fuel at a price of dollars per liter Find the minimum cost Johnny must pay for fuel to successfully complete the delivery ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "We binary search on the answer so we need to answer queries of the following form is the a depth first search traversal such that the first k vertices all have value at least v We can answer this with a greedy tree DP for each subtree we compute whether or not all its vertices have value at least v and if not the longest possible prefix with all values at least v Then our transition function can be greedy the maximum possible prefix with all values at least v is the sum of the sizes of all child subtrees which are all at least v plus the largest prefix of all child subtrees "}
{"statement": "Pari has a friend who loves palindrome numbers A palindrome number is a number that reads the same forward or backward For example and are palindrome numbers while and are not Pari is trying to love them too but only very special and gifted people can understand the beauty behind palindrome numbers Pari loves integers with even length i e the numbers with even number of digits so she tries to see a lot of big palindrome numbers with even length like a digit or digit so maybe she could see something in them Now Pari asks you to write a program that gets a huge integer from the input and tells what is the th even length positive palindrome number ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Hint Try to characterize even length palindrome numbers Solution For simplifications in the following solution we define lovely integer as an even length positive palindrome number An even length positive integer is lovely if and only if the first half of its digits is equal to the reverse of the second half So if a and b are two different 2k digit lovely numbers then the first k digits of a and b differ in at least one position So a is smaller than b if and only if the first half of a is smaller than the the first half of b Another useful fact The first half of a a lovely number can be any arbitrary positive integer Using the above facts it s easy to find the first half of the n th lovely number it exactly equals to integer n When we know the first half of a lovely number we can concatenate it with its reverse to restore the lovely integer To sum up the answer can be made by concatenating n and it s reverse together "}
{"statement": "Alice and Bob play ping pong with simplified rules During the game the player serving the ball commences a play The server strikes the ball then the receiver makes a return by hitting the ball back Thereafter the server and receiver must alternately make a return until one of them doesn t make a return The one who doesn t make a return loses this play The winner of the play commences the next play Alice starts the first play Alice has x stamina and Bob has y To hit the ball while serving or returning each player spends 1 stamina so if they don t have any stamina they can t return the ball and lose the play or can t serve the ball in this case the other player serves the ball instead If both players run out of stamina the game is over Sometimes it s strategically optimal not to return the ball lose the current play but save the stamina On the contrary when the server commences a play they have to hit the ball if they have some stamina left Both Alice and Bob play optimally and want to firstly maximize their number of wins and secondly minimize the number of wins of their opponent Calculate the resulting number of Alice s and Bob s wins ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s find an answer for a little different version of the game Let s say that is the final score if the first player has stamina and the second has stamina The first player can either hit the ball or How to calculate Obviously and Otherwise the first player can either hit the ball then the player spent stamina and now it s to the second player to decide hit or lose So basically we moved to the state and the answer in this case is where or lose the play then the player doesn t spend any stamina but the opponent serve the ball He serves the ball spend stamina and return to the state where the first player decides hit or lose Formally the answer in this case is Looking at and one of transitions we can guess that and prove it by induction is either or but and and is better than so The final step is to note that since Alice starts the first play and serve ball the answer is "}
{"statement": "A new pack of t shirts came to a shop Each of the t shirts is characterized by three integers and where is the price of the th t shirt is front color of the th t shirt and is back color of the th t shirt All values are distinct and values and are integers from to buyers will come to the shop Each of them wants to buy exactly one t shirt For the th buyer we know his favorite color A buyer agrees to buy a t shirt if at least one side front or back is painted in his favorite color Among all t shirts that have colors acceptable to this buyer he will choose the cheapest one If there are no such t shirts the buyer won t buy anything Assume that the buyers come one by one and each buyer is served only after the previous one is served You are to compute the prices each buyer will pay for t shirts ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let s store in three arrays t shirts which have appropriate color About each t shirt is enough to store its index but we will additionally store its cost It is possible that one t shirt will be in two arrays if this t shirt colorful Then we need to sort t shirts in each array in increasing order of cost After that we will process buyers Also for each array we will store the pointer to leftmost t shirt which was not purchased yet For a new buyer we need to look on array with t shirts which appropriate to his favorite color Using appropriate pointer let s iterate to the right until there are t shirts or until we not found unsold t shirt to this we can store one more array with type bool did we sell or no appropriate t shirt If there are no t shirt with needed color print In the other case print the cost of founded t shirt and tag in array that we sold this t shirt "}
{"statement": "One company of IT City decided to create a group of innovative developments consisting from to people and hire new employees for it After placing an advertisment the company received resumes Now the HR department has to evaluate each possible group composition and select one of them Your task is to count the number of variants of group composition to evaluate ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "The amount of ways to choose a group of 5 people from n candidates is equal to the number of combinations the amount of ways to choose a group of 6 people from n candidates is the amount of ways to choose a group of 7 people from n candidates is the amount of ways to choose a group of 5 6 or 7 people from n candidates is To avoid 64 bit integer overflow can be calculated in the following way n 1 n 1 2 n 2 3 n 3 4 n 4 5 n 5 6 n 6 7 Each division returns an integer because each prefix of this formula after division is also the number of combinations "}
{"statement": "Recently Lynyrd and Skynyrd went to a shop where Lynyrd bought a permutation p of length n and Skynyrd bought an array a of length m consisting of integers from 1 to n Lynyrd and Skynyrd became bored so they asked you q queries each of which has the following form does the subsegment of a from the l th to the r th positions inclusive have a subsequence that is a cyclic shift of p Please answer the queries A of length n is a sequence of n integers such that each integer from 1 to n appears exactly once in it A of a permutation p 1 p 2 ldots p n is a permutation p i p i 1 ldots p n p 1 p 2 ldots p i 1 for some i from 1 to n For example a permutation 2 1 3 has three distinct cyclic shifts 2 1 3 1 3 2 3 2 1 A of a subsegment of array a from the l th to the r th positions inclusive is a sequence a i 1 a i 2 ldots a i k for some i 1 i 2 ldots i k such that l leq i 1 i 2 ldots i k leq r ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "For each if the number has position in let s find the greatest such that is less then and let s define We will call this position This can be done in time just for each we will keep the last it s position in while iterating over Now let s notice that using this info for each we can find the beginning of right most subsequence of which is a ciclic shift of and ends exactly at This can easily be done because if there is a subsequence of which is the right most such subsequence then is is and so on So to find such subsequence and the position of it s beginning we need to calculate times To do it we can use binary lifting Then we will have precalc and we will get the beginning of such subsequence in time Now for each prefix of let s calculate the the beginning of right most subsequence of it which is a cyclic shift of This can be calculated in linear time first we look at the answer for this prefix without the last number and then update it with the right most subsequence which ends at the end of prefix Now we can answer each query in time because we just need to find the beginning of the right most subsequence which ends at prefix of length and compare it with "}
{"statement": "Suppose you have two polynomials and Then polynomial can be uniquely represented in the following way This can be done using long division Here denotes the degree of polynomial is called the remainder of division of polynomial by polynomial it is also denoted as Since there is a way to divide polynomials with remainder we can define Euclid s algorithm of finding the greatest common divisor of two polynomials The algorithm takes two polynomials If the polynomial is zero the result is otherwise the result is the value the algorithm returns for pair On each step the degree of the second argument decreases so the algorithm works in finite number of steps But how large that number could be You are to answer this question You are given an integer You have to build two polynomials with degrees not greater than such that their coefficients are integers not exceeding by their absolute value the leading coefficients ones with the greatest power of are equal to one and the described Euclid s algorithm performs exactly steps finding their greatest common divisor Moreover the degree of the first polynomial should be greater than the degree of the second By a step of the algorithm we mean the transition from pair to pair ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "As for integers it is well known that worst case are consequent Fibonacci s numbers Solutions to this problem are based on the same idea There were two main intended solutions First of all you should note that sequence Gives us the family of solutions we just have to output and It can be directly checked for given constraints that you can always choose or to satisfy coefficients constraints The other solution is the same sequence but you use instead of and take coefficients modulo That s true because if remainders sequence has steps while you consider numbers by some modulo it will have at least steps in rational numbers So the second intended solution is "}
{"statement": "You have wooden staves The th stave has length You have to assemble barrels consisting of staves each you can use any staves to construct a barrel Each stave must belong to exactly one barrel Let volume of barrel be equal to the length of the stave in it You want to assemble exactly barrels with the maximal total sum of volumes But you have to make them so a difference between volumes of any pair of the resulting barrels must not exceed i e for any and Print maximal total sum of volumes of barrels or if it s impossible to satisfy the condition above ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "At first sort all in non decreasing order Let be first position that if Then each barrel should have at least one stave from segment So if answer is Otherwise for each from to let s take no more than smallest staves from this segment in the th barrel but in such way that there are at least staves left for next barrels "}
{"statement": "Polycarp has just attempted to pass the driving test He ran over the straight road with the signs of four types speed limit this sign comes with a positive integer number maximal speed of the car after the sign cancel the action of the previous sign of this type overtake is allowed this sign means that after some car meets it it can overtake any other car no speed limit this sign cancels speed limit if any car can move with arbitrary speed after this sign no overtake allowed some car can t overtake any other car after this sign Polycarp goes past the signs consequentially each new sign cancels the action of all the previous signs of it s kind speed limit overtake It is possible that two or more no overtake allowed signs go one after another with zero overtake is allowed signs between them It works with no speed limit and overtake is allowed signs as well In the beginning of the ride overtake is allowed and there is no speed limit You are given the sequence of events in chronological order events which happened to Polycarp during the ride There are events of following types Polycarp changes the speed of his car to specified this event comes with a positive integer number Polycarp s car overtakes the other car Polycarp s car goes past the speed limit sign this sign comes with a positive integer Polycarp s car goes past the overtake is allowed sign Polycarp s car goes past the no speed limit Polycarp s car goes past the no overtake allowed It is guaranteed that the first event in chronological order is the event of type Polycarp changed the speed of his car to specified After the exam Polycarp can justify his rule violations by telling the driving instructor that he just didn t notice some of the signs What is the minimal number of signs Polycarp should say he didn t notice so that he would make no rule violations from his point of view ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Let s notice that you should never say that you didn t notice signs no speed limit and overtake is allowed Also if you drive with speed you don t want to remove signs speed limit with number greater or equal to Thus greedy solution will work Process all the events in chronological order We should maintain stack of signs speed limit and amount of signs no overtake allowed If we meet sign speed limit we push its limit to stack sign no overtake allowed increase no speed limit clear stack overtake is allowed assign to zero After every event we should check if our speed is fine While value of sign on the top of the stack is less than current speed pop it and increase answer If we overtake someone we add to answer and assign to zero Overall complexity "}
{"statement": "Vus the Cossack has two binary strings that is strings that consist only of and We call these strings a and b It is known that b leq a that is the length of b is at most the length of a The Cossack considers every substring of length b in string a Let s call this substring c He matches the corresponding characters in b and c after which he counts the number of positions where the two strings are different We call this function f b c For example let b 00110 and c 11000 In these strings the first second third and fourth positions are different Vus the Cossack counts the number of such substrings c such that f b c is For example let a 01100010 and b 00110 a has four substrings of the length b 01100 11000 10001 00010 f 00110 01100 2 f 00110 11000 4 f 00110 10001 4 f 00110 00010 1 Since in three substrings f b c is even the answer is 3 Vus can not find the answer for big strings That is why he is asking you to help him ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Let s say that we want to know whether is even for some strings and Let s define as number of ones in string and as number of ones in It s easy to see that is even if and only if and have same parity In other words if then is even So we can check if two strings have even number of distinct bits in if know how many ones does each of them contain Using that fact we can easily solve problem in by using prefix sums "}
{"statement": "Ashish has n elements arranged in a line These elements are represented by two integers a i the value of the element and b i the type of the element there are only two possible types 0 and 1 He wants to sort the elements in non decreasing values of a i He can perform the following operation any number of times Select any two elements i and j such that b i ne b j and swap them That is he can only swap two elements of different types in one move Tell him if he can sort the elements in non decreasing values of a i after performing any number of operations ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "If there is at least one element of type and at least one element of type we can always sort the array If all the elements are of the same type we cannot swap any two elements So in this case we just need to check if given elements are already in sorted order Otherwise there is at least one element of type and at least one element of type In this case it is possible to swap any two elements We can swap elements of different types using only one operation Suppose we want to swap two elements and of the same type We can do it in operations Let be an element of the type different from and We can first swap and then swap and and then swap and again In doing so remains at its initial position and are swapped This is exactly how we swap two integers using a temporary variable Since we can swap any two elements it is always possible to sort the array in this case Time complexity "}
{"statement": "Recently Vlad has been carried away by spanning trees so his friends without hesitation gave him a connected weighted undirected graph of n vertices and m edges for his birthday Vlad defined the of a spanning tree as the bitwise OR of all its weights and now he is interested in what is the minimum possible that can be achieved by choosing a certain spanning tree A spanning tree is a connected subgraph of a given graph that does not contain cycles In other words you want to keep n 1 edges so that the graph remains connected and the bitwise OR weights of the edges are as small as possible You have to find the minimum bitwise OR itself ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1900", "problem_editorial": "We need to minimize the result of the bitwise operation so for convenience we represent the answer as a mask Firstly let s assume that this mask is composed entirely of ones Let s go from the most significant bit to the least significant one and try to reduce the answer To understand whether it is possible to remove the th bit remove it and check if the graph in which all the weights are submasks of the current answer is connected for this you can use depth first search or a disjoint sets union If the graph is connected then the bit can obviously be thrown out and if not it cannot and must be returned "}
{"statement": "Roman planted a tree consisting of vertices Each vertex contains a lowercase English letter Vertex is the root of the tree each of the remaining vertices has a in the tree Vertex is connected with its parent by an edge The parent of vertex is vertex the parent index is always less than the index of the vertex i e The of the vertex is the number of nodes on the path from the root to along the edges In particular the depth of the root is equal to We say that vertex is in the of vertex if we can get from to moving from the vertex to the parent In particular vertex is in its subtree Roma gives you queries the th of which consists of two numbers Let s consider the vertices in the subtree located at depth Determine whether you can use the letters written at these vertices to make a string that is a The letters that are written in the vertexes can be rearranged in any order to make a palindrome but all letters should be used ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 1, "problem_dificulty": "2200", "problem_editorial": "We need to write vertices in DFS order and store time of enter exit of vertices in DFS All vertices in subtree represent a segment Now we can get all vertices in subtree v on height h as a segment making two binary searches We can make a palindrome if quantity of uneven entries of each letter is less than 2 This function can be counted for each prefix in bypass for each depth For saving the memory bit compression can be used considering that we need only parity and function is xor D had a offline solution too in time and memory Solutions "}
{"statement": "You are given an integer n and an array a 1 a 2 ldots a n In one operation you can choose an index i 1 le i lt n for which a i neq a i 1 and delete both a i and a i 1 from the array After deleting a i and a i 1 the remaining parts of the array are concatenated For example if a 1 4 3 3 6 2 then after performing an operation with i 2 the resulting array will be 1 3 6 2 What is the maximum possible length of an array of elements obtainable from a by performing several perhaps none of the aforementioned operations ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "SolutionLemma An array can be fully deleted via a sequence of operations if and only if it satisfies both of the following constraints is even The maximum frequency of any element in the array is at most ProofIf is odd then any final array will also have an odd length which can t be An optimal strategy is to always delete one of the most frequent elements and any one of its neighbours If the most frequent element occurs times then the final array will have at least elements Otherwise this strategy ensures the full deletion of the array since after performing an operation it is impossible for an element to occur more than times in the array Since the maximum frequency of a value for every subarray can be computed in it is possible to precompute all subarrays which can be deleted via a sequence of operations Let be the maximum length of a final array consisting of and some subsequence from the first elements Initially is set to if the prefix can be fully deleted Otherwise For every pair of indices and if we can fully delete the subarray then we can append to any final array ending in Naturally will be strictly greater than This gives us the following recurrence If we define a final array as a subsequence of equal elements from the array to which is forcefully appended then the final answer can be written as Note that when computing should not be compared to Total time complexity per testcase "}
{"statement": "Limak is a little grizzly bear He will once attack Deerland but now he can only destroy trees in role playing games Limak starts with a tree with one vertex The only vertex has index and is a root of the tree Sometimes a game chooses a subtree and allows Limak to attack it When a subtree is attacked then each of its edges is destroyed with probability independently of other edges Then Limak gets the penalty an integer equal to the height of the subtree after the attack The height is defined as the maximum number of edges on the path between the root of the subtree and any vertex in the subtree You must handle queries of two types denotes a query of the first type A new vertex appears and its parent is A new vertex has the next available index so new vertices will be numbered denotes a query of the second type For a moment let s assume that the game allows Limak to attack a subtree rooted in Then what would be the expected value of the penalty Limak gets after the attack In a query of the second type Limak doesn t actually attack the subtree and thus the query doesn t affect next queries ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Let denote the probability that subtree if attacked now would have height at most The first observation is that we don t care about big because it s very unlikely that a path with e g 100 edges will survive Let s later talk about choosing and now let s say that it s enough to consider up to When we should answer a query for subtree then we should sum up to get the answer The other query is harder Let s say that a new vertex is attached to vertex Then among only changes other values stay the same Also one value changes and so does and so on You should iterate over vertices each time going to parent and update the corresponding value TODO puts here come formula for updating value The complexity is You may think that is enough because is small enough Unfortunately there exist malicious tests Consider a tree with paths from root each with length Now we talk about the probability of magnitude which is more than for http www wolframalpha com input i 1 1 1 "}
{"statement": "Many of you must be familiar with the Google Code Jam round rules Let us remind you of some key moments that are crucial to solving this problem During the round the participants are suggested to solve several problems each divided into two subproblems an easy one with small limits Small input and a hard one with large limits Large input You can submit a solution for Large input only after you ve solved the Small input for this problem There are no other restrictions on the order of solving inputs In particular the participant can first solve the Small input then switch to another problem and then return to the Large input Solving each input gives the participant some number of points usually different for each problem This takes into account only complete solutions that work correctly on all tests of the input The participant gets the test result of a Small input right after he submits it but the test result of a Large input are out only after the round s over In the final results table the participants are sorted by non increasing of received points If the points are equal the participants are sorted by ascending of time penalty By the Google Code Jam rules the time penalty is the Vasya decided to check out a new tactics on another round As soon as the round begins the boy quickly read all the problems and accurately evaluated the time it takes to solve them Specifically for each one of the problems Vasya knows five values Solving the Small input of the th problem gives to the participant points and solving the Large input gives more points That is the maximum number of points you can get for the th problem equals Writing the solution for the Small input of the th problem takes exactly minutes for Vasya Improving this code and turning it into the solution of the Large input takes another minutes Vasya s had much practice so he solves all Small inputs from the first attempt But it s not so easy with the Large input there is the probability that the solution to the Large input will turn out to be wrong at the end of the round Please keep in mind that these solutions do not affect the participants points and the time penalty A round lasts for minutes The time for reading problems and submitting solutions can be considered to equal zero Vasya is allowed to submit a solution exactly at the moment when the round ends Vasya wants to choose a set of inputs and the order of their solution so as to make the expectation of the total received points maximum possible If there are multiple ways to do this he needs to minimize the expectation of the time penalty Help Vasya to cope with this problem ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Suppose we have fixed set of inputs that we have to solve Let s learn how to determine the optimal order Obviously Small inputs and Large inputs with won t fail in any case It means that our penalty time is no less than submission time of last such safe inputs So we will solve such inputs before all the others Inputs with are just a waste of time we won t solve such inputs Now we have only inputs with Let and be two problems that we are going to solve consecutively at some moment Let s check if it is optimal to solve them in order or in reversed order We can discard all the other inputs because they don t affect on the relative order of these two Now we ve got a comparator for sort which will give us the optimal order Note that inputs with will be sorted by the comparator correctly as well so it s not a corner case Let s return to the initial problem First of all sort problems with the optimal comparator it s clear that any other order won t be optimal by time and the score doesn t depend on the order Calculate the DP pair of maximal expected total score and minimal expected penalty time with this score if we ve already decided what to do with the first problems and we ve spent real minutes from the contest s start There are 3 options for the the problem skip update with the same expected values solve the Small input update the expected total score increases by and the expected penalty time increases by we assume that this input is solved in the very beggining of the contest solve both inputs update the expected total score increases by and the expected penalty time becomes where is the expected penalty time from DP The resulting answer is the best of The expected total score could be a number around with 6 digits after decimal point So it can t be precisely stored in double And any even small error in calculating score may lead to completely wrong expected time pretest 7 For example you can multiply all the probabilities by and store the expected score as integer number to avoid this error "}
{"statement": "Andrey received a postcard from Irina It contained only the words Hello Andrey and a strange string consisting of lowercase Latin letters snowflakes and candy canes Andrey thought that this string is an encrypted message and decided to decrypt it Andrey noticed that snowflakes and candy canes always stand after the letters so he supposed that the message was encrypted as follows Candy cane means that the letter before it can be removed or can be left A snowflake means that the letter before it can be removed left or repeated several times For example consider the following string This string can encode the message For this candy canes and snowflakes should be used as follows candy cane 1 remove the letter snowflake 1 repeat the letter twice candy cane 2 leave the letter snowflake 2 remove the letter snowflake 3 leave the letter Please note that the same string can encode different messages For example the string above can encode and other messages Andrey knows that messages from Irina usually have a length of k letters Help him to find out if a given string can encode a message of k letters and if so give an example of such a message ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "If the string in the postcard does not contain any snowflakes or candy cones must be equal to the length of the string because the only string encoded by such message is the string itself and in this case if is not equal to the length of the string the answer is Let s call the characters of the message if they are not followed by snowflakes or candy cones Clearly should be at least the number of mandatory characters otherwise the answer is In case there a snowflake in the message we can repeat the preceding character enough times to get the length and remove the rest of non mandatory characters If there are no snowflakes but only candy cones we should use the characters followed by candy cones until we get the desired length In case we don t have enough the answer is "}
{"statement": "You are given an array a of length n You can perform the following operation several possibly zero times Choose i j b Swap the b th digit in the binary representation of a i and a j Find the maximum possible value of max a min a In a binary representation bits are numbered from right least significant to left most significant Consider that there are an infinite number of leading zero bits at the beginning of any binary representation For example swap the 0 th bit for 4 100 2 and 3 11 2 will result 101 2 5 and 10 2 2 Swap the 2 nd bit for 4 100 2 and 3 11 2 will result 000 2 0 2 0 and 111 2 7 Here max a denotes the maximum element of array a and min a denotes the minimum element of array a The binary representation of x is x written in base 2 For example 9 and 6 written in base 2 are 1001 and 110 respectively ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Need more hints Considering the last two hints try to maximize the maximum element and minimize the minimum element "}
{"statement": "Little Vasya s uncle is a postman The post offices are located on one circular road Besides each post office has its own gas station located next to it Petya s uncle works as follows in the morning he should leave the house and go to some post office In the office he receives a portion of letters and a car Then he must drive in the given car exactly one round along the circular road and return to the starting post office the uncle can drive along the circle in any direction counterclockwise or clockwise Besides since the car belongs to the city post it should also be fuelled with gasoline only at the Post Office stations The total number of stations equals to One can fuel the car at the th station with no more than liters of gasoline Besides one can fuel the car no more than once at each station Also the distance between the st and the nd station is kilometers the distance between the nd and the rd one is kilometers between the th and the th ones the distance is kilometers and between the th and the st one the distance is kilometers Petya s uncle s high tech car uses only one liter of gasoline per kilometer It is known that the stations are located so that the sum of all is equal to the sum of all The th gas station and th post office are very close so the distance between them is kilometers Thus it becomes clear that if we start from some post offices then it is not always possible to drive one round along a circular road The uncle faces the following problem to what stations can he go in the morning to be able to ride exactly one circle along the circular road and visit all the post offices that are on it Petya who used to attend programming classes has volunteered to help his uncle but his knowledge turned out to be not enough so he asks you to help him write the program that will solve the posed problem ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "First of all we divide our problem into 2 parts consider stations from which we can start if we are moving in the clockwise direction and stations from which we can start if we are moving in the counterclockwise direction Obviously if we know the solution of one of these problems we know the solution of another problem So we may assume that stations are located in the counterclockwise order and we are moving in the counterclockwise direction Consider the following differences D1 a1 b1 D2 a1 a2 b1 b2 D3 a1 a2 a3 b1 b2 b3 Dn a1 a2 an b1 b2 bn Obviously if one of Di s is less than a zero then we cannot drive one round along the road Let D min Di we will use it later Obviously if D 0 then the first station cannot be the start station Now we can check with complexity O n whether the first station can be used as the starting point Next we want to show how we can check this for the second station with complexity O 1 To show this consider E1 D1 a1 b1 E2 D2 a1 b1 En Dn a1 b1 Next substitute Di in these equalities We get the following E1 a1 b1 a1 b1 0 a2 a3 an a1 b2 b3 bn b1 a1 an b1 bn X E2 a1 a2 b1 b2 a1 b1 a2 b2 E3 a1 a2 a3 b1 b2 b3 a1 b1 a2 a3 b2 b3 En a1 a2 an b1 b2 bn a1 b1 a2 an b2 bn But it s easy to see that number E1 has the same meaning for the second station as number D1 for the first one So we just have to check min Ei 0 But Ei Di a1 b1 so we have to check min Di a1 b1 0 Now we can see that if min Di Dk then min Di a1 b1 Dk a1 b1 So if we know Dk that we can check whether the second station can be the starting point with complexity O 1 Similarly we can check this for the third the fourth the nth stations "}
{"statement": "There is a grid with n rows and m columns and three types of cells An empty cell denoted with A stone denoted with An obstacle denoted with the lowercase Latin letter All stones fall down until they meet the floor the bottom row an obstacle or other stone which is already immovable In other words all the stones just fall down as long as they can fall Simulate the process What does the resulting grid look like ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Note that the columns don t affect each other so we can solve for each column by itself For each column go from the bottom to the top and keep track of the row of the last obstacle seen call it Note that initially since we treat the floor as the th row of obstacles Whenever we see a new obstacle we should update Now if we ever see a stone we should move it to row since it will be one row above the last obstacle seen it will fall on top of it Afterwards we should also decrease by because if any future stones fall on top of it they will land on the row above this stone This solution works in We also accepted slower solutions that run in that simulate each stone falling "}
{"statement": "You have a string s consisting of lowercase Latin alphabet letters You can color some letters in colors from 1 to k It is not necessary to paint all the letters But for each color there must be a letter painted in that color Then you can swap any two symbols painted in the same color as many times as you want After that k strings will be created i th of them will contain all the characters colored in the color i written in the order of their sequence in the string s Your task is to color the characters of the string so that all the resulting k strings are palindromes and the length of the shortest of these k strings is as as possible Read the note for the first test case of the example if you need a clarification Recall that a string is a palindrome if it reads the same way both from left to right and from right to left For example the strings and are palindromes but the strings and are not ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "We will solve the problem greedily First we will try to add pairs of identical characters to palindromes As long as there are at least pairs let s add them After that it is no longer possible to add a couple of characters but you can try to add one character in the middle This can be done if there are at least characters left There is no need to paint other characters "}
{"statement": "Vlad decided to compose a melody on his guitar Let s represent the melody as a sequence of notes corresponding to the characters a b c d e f and g However Vlad is not very experienced in playing the guitar and can only record notes at a time Vlad wants to obtain the melody s and to do this he can merge the recorded melodies together In this case the last sound of the first melody must match the first sound of the second melody For example if Vlad recorded the melodies and he can merge them together and obtain the melody and then merge the result with to get Help Vlad determine the number of melodies consisting of two notes that he needs to record in order to obtain the melody s ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s construct the melody sequentially In the first step we can record the notes and In the next step we need to record and because there must be a common symbol when gluing and so on That is we need to have recorded melodies for all We only need to count how many different ones among them because we don t need to record one melody twice "}
{"statement": " There are 2n light bulbs arranged in a row Each light bulb has a color from 1 to n Initially all light bulbs are turned off You choose a set of light bulbs S that you initially turn on After that you can perform the following operations in any order any number of times choose two light bulbs i and j exactly one of which is on and turn on the second one choose three light bulbs i j k such that both light bulbs i and k and the light bulb j is between them i j k and turn on the light bulb j You want to choose a set of light bulbs S that you initially turn on in such a way that by performing the described operations you can ensure that all light bulbs are turned on Calculate two numbers the minimum size of the set S that you initially turn on the number of sets S of minimum size taken modulo 998244353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "Let s call a contiguous segment of lamps if the number of lamps for each color is either or in this segment For example a segment of lamps is closed Furthermore let s say that a closed segment of lamps is if it is impossible to split it into multiple closed segments For example is minimal but is not since it can be split into and which are closed Each closed segment has the following property if you start with any lamp in this segment you cannot leave this segment i e you cannot use the lamps from this segment to light any lamps outside To prove this let s suppose the opposite we started in the closed segment and managed to turn a lamp of color outside that segment on and this was the first lamp outside of the segment we turned on We could not do it with the operation of the first type since it would mean that the other lamp of color is in the segment so it is not closed and we could not do it with the operation of the second type since for every color present in the closed segment both lamps of that color and the segment they can light up belong to the closed segment For every minimal closed segment we can light it up using just one lamp for example the first lamp So to calculate the minimum possible size of a set of lamps we initially turn on we can just split the given sequence of colors into minimal closed segments Unfortunately calculating the number of possible sets of lamps is trickier For every minimal closed segment we got we can calculate the number of starting lamps that allow us to light the whole segment and multiply them However not every lamp from a minimal closed segment can be a starting lamp for example in the segment any lamp of color can be used but no lamp of other color can be used To deal with this let us find minimal closed segments in the sequence of colors In the example above we have to find out that both the segments and are closed and since lamps of colors and belong to the inner closed segment they cannot be used to light the whole outer closed segment So if a lamp belongs to any of the inner closed segments it cannot be used as a starting lamp Let s mark all such lamps We can also show that if a lamp is not marked it can be used as a starting lamp It is because if we start with some lamp and try to turn on everything we can with the operations given in the statement we will get precisely the shortest closed segment that lamp belongs to Proving it is not that hard suppose we stopped before turning the whole shortest closed segment on either we got multiple segments of lamps and we can turn on everything in between them or we got a segment which is not closed and for at least one color there is exactly one lamp in it so we can light the other lamp of that color Okay let s recap Our solution consists of the following steps find all minimal closed segments of lamps for every inner segment mark all lamps in it to show they cannot be used as the starting lamps split the given sequence of colors into the minimum number of segments for each segment we got from the split calculate the number of unmarked lamps and multiply those values The most difficult part is finding all minimal closed segments of lamps To get a solution in something like we can do it naively iterate on the left border of the segment add the first lamp in the segment and keep adding next lamps until the number of lamps of each color becomes either or That s how the easy version of the problem is solved For the hard version this is too slow We have to find the closed segments faster In order to do this we can use hashing Many hashing methods can help but in my opinion the most elegant one is XOR hashing which works as follows For each color generate a random bit integer and replace both occurrences of that color with the generated number Then if the segment is closed the XOR of all numbers in the segment is equal to each color occurs either or times thus each integer is taken either or times and all integers taken twice cancel out This allows us to find all minimal closed segments in as follows iterate on the array of colors from left to right maintaining the XOR on the current prefix and a map where for each XOR we encountered we store the longest prefix which has that value of XOR Then after we process the th element we can quickly find the left border of the segment ending in the th element by looking for the current XOR in the map Don t forget to update the map after that That way we arrive at a solution which works in which is enough to solve the hard version "}
{"statement": "Vasya is an administrator of a public page of organization Mouse and keyboard and his everyday duty is to publish news from the world of competitive programming For each news he also creates a list of hashtags to make searching for a particular topic more comfortable For the purpose of this problem we define hashtag as a string consisting of lowercase English letters and exactly one symbol located at the beginning of the string The of the hashtag is defined as the number of symbols in it the symbol The head administrator of the page told Vasya that hashtags should go in lexicographical order take a look at the notes section for the definition Vasya is lazy so he doesn t want to actually change the order of hashtags in already published news Instead he decided to delete some suffixes consecutive characters at the end of the string of some of the hashtags He is allowed to delete any number of characters even the whole string except for the symbol Vasya wants to pick such a way to delete suffixes that the total number of deleted symbols is possible If there are several optimal solutions he is fine with any of them ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "It is possible to solve this problem in many ways One of them was to iterate over all strings in reversed order and to try to leave the longest possible prefix of each string greedily without breaking the statement Let s prove this solution formally Note that the set of possible lengths of some string in a correct answer forms a segment between and some critical length Indeed if there exists a correct answer with string having a length of then there also exists an answer with th string having a length of since it is possible to leave only the first symbol of all previous strings and make the answer correct Let s express through Reduce the length of st string to and consider two options First may be lexicographically not greater than and in this case we may obviously let be equal to Otherwise can t be larger than where deontes the length of the longest common prefix of two strings if we keep longer it will be larger than any possible prefix of At the same time if we reduce up to it will be correct So we may let be equal to Note that due to the way we defined if we just reduce any string up to its maximum possible length it will also be a correct answer So it is also a correct answer to the original problem "}
{"statement": "Little boy Igor wants to become a traveller At first he decided to visit all the cities of his motherland Uzhlyandia It is widely known that Uzhlyandia has cities connected with bidirectional roads Also there are no two roads in the country that connect the same pair of cities but roads starting and ending in the same city can exist Igor wants to plan his journey beforehand Boy thinks a path is if the path goes over roads twice and over the other exactly once The good path can start and finish in any city of Uzhlyandia Now he wants to know how many different good paths are in Uzhlyandia Two paths are considered different if the sets of roads the paths goes over exactly once differ Help Igor calculate the number of good paths ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "We can consider the system of towns and roads as a graph where edges correspond to roads and vertexes to cities Now let s fix two edges that will be visited once All other edges we can split into two Then the good way in the old graph equivalents to any Euler path in the computed one Widely known that Euler path exists in graph when and only when there are 0 or 2 vertexes with odd degree Consider following cases of mutual placement of edges that will be visited once Regular not loops edges that are not adjacent graph has four vertexes with odd degree so Euler path doesn t exist Regular edges that are adjacent graph has exactly two vertexes with odd degree so Euler path exists So any pair of adjacent regular edges satisfies Igor One of the edges is a loop graph hasn t any vertex with the odd degree if another chosen edge is a loop too or has two of them if another chosen edge is regular So any pair in which at least one edge is a loop satisfies Igor So we have to calculate the number of pairs of adjacent regular edges and add the answer for loops For every vertex we can calculate the number of regular edges incoming in it General number of adjacent regular edges is Also we need to add the number of pairs with loops Let s count general number of loops in the graph So we can add to the answer Now we included pairs with two loops twice That s why we need to subtract the number of pairs with two loops Also we need to check the graph to be connected If the graph is not connected then the answer is 0 We can do it using algorithms of DFS or BFS Complexity of the given solution if "}
{"statement": "You are given a rectangular matrix of size n times m consisting of integers from 1 to 2 cdot 10 5 In one move you can choose of the matrix and change its value to integer between 1 and n cdot m inclusive take and shift it one cell up cyclically see the example of such cyclic shift below A cyclic shift is an operation such that you choose some j 1 le j le m and set a 1 j a 2 j a 2 j a 3 j dots a n j a 1 j Example of cyclic shift of the first column You want to perform the minimum number of moves to make this matrix look like this In other words the goal is to obtain the matrix where a 1 1 1 a 1 2 2 dots a 1 m m a 2 1 m 1 a 2 2 m 2 dots a n m n cdot m i e a i j i 1 cdot m j with the performed ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "At first let s decrease all elements by one and solve the problem in indexation The first observation is that we can solve the problem independently for each column Consider the column It consists of elements Now consider some element We don t need to replace it with some other number in only one case if we shift the column such that will coincide with the corresponding number of the required matrix Obviously there is only one cyclic shift of the column that can rid us of replacing So the idea is the following let s calculate for each cyclic shift the number of elements we don t need to replace if we use this cyclic shift Let for the th cyclic shift indexed it be Then the answer for this column can be taken as How to calculate for the element the corresponding cyclic shift Firstly if is modulo operation then there is no such cyclic shift Otherwise let If then there is such cyclic shift can be greater than or equal to because can be up to and the number of such cyclic shift is So let s increase and continue After considering all elements of this column take the answer by the formula above and go to the next column Time complexity "}
{"statement": "Sofia has a string s of length n consisting only of lowercase English letters She can perform operations of the following types with this string Select an index 1 le i le s and remove the character s i from the string Select a pair of indices l r 1 le l le r le s and sort the substring s l s l 1 ldots s r in alphabetical order Here s denotes the current length of s In particular s n before the first operation For example if s mathtt sofia then performing the operation of the first type with i 4 results in s becoming mathtt sofa and performing the operation of the second type with l r 2 4 after that results in s becoming mathtt safo Sofia wants to obtain the string t of length m after performing zero or more operations on string s as described above Please determine whether it is possible or not ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "SolutionWe sort only the substrings of length We can swap two adjacent characters if the first is greater than or equal to the second Let us fix some character and presume we want to change its position to We have to perform the described swaps if they are possible More formally if then every character in the segment must be greater than or equal to if then every character in the segment must be smaller than or equal to We want to reorder the string and get the string Then we check if we can delete some characters in to achieve In other words we want to be a subsequence of A general algorithm that checks if the string is a subsequence of the string is as follows We iterate through and for each character we find its first next appearance in If such a character does not exist we conclude that is not a subsequence of If we complete the iteration gracefully then is a subsequence of We will try to check if is a subsequence of but we allow ourselves to modify along the way We maintain queues for positions of each lowercase English letter in the string We iterate through the string and for every character we try to move the first available equivalent character in to position In other words at every moment the prefix of string is equal to the prefix of string if possible For the current character and the corresponding prefixes and are the same which means that To move to position we need to delete all characters between and that are smaller than We will delete them and all characters from the current prefix from the queues because they are no longer candidates for By doing so will be the first character in the corresponding queue If at some moment in our greedy algorithm the queue we are looking for becomes empty then the answer is NO Otherwise we will make the prefix equal to the and delete the remaining characters from Why is this greedy approach optimal Let s suppose for some character we chose and for we chose such that and We need to prove that if we can move to position and to position when we can move to and to In the moment when we chose prefixes and are the same so Similarly which means the only possibility is If we can move to position than we can also move to because and Also if we can move to than we can move to because from which it follows that we can move to because and The overall complexity is where is the alphabet size in this problem "}
{"statement": "One day Vasya heard a story In the city of High Bertown a bus number 62 left from the bus station It had grown ups and kids The latter events happen to be of no importance to us Vasya is an accountant and he loves counting money So he wondered what maximum and minimum sum of money these passengers could have paid for the ride The bus fare equals one berland ruble in High Bertown However not everything is that easy child can ride for free with each grown up passenger That means that a grown up passenger who rides with his children pays overall rubles a ticket for himself and tickets for his children Also a grown up can ride without children in this case he only pays one ruble We know that in High Bertown children can t ride in a bus unaccompanied by grown ups Help Vasya count the minimum and the maximum sum in Berland rubles that all passengers of this bus could have paid in total ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Firstly if then children can t be in the bus so if then the answer is otherwise the answer is Now If than it is only one possible variant of passage the answer is Otherwise more grown up take some children less the sum that people pay So if only one adult takes all children than we get maximal sum Maximum adults can take the children with them so the minimal answer is "}
{"statement": "You are exploring the stunning region of Natlan This region consists of n cities and each city is rated with an attractiveness a i A directed edge exists from City i to City j if and only if i j and gcd a i a j neq 1 where gcd x y denotes the greatest common divisor GCD of integers x and y Starting from City 1 your task is to determine the total number of distinct paths you can take to reach City n modulo 998 244 353 Two paths are different if and only if the set of cities visited is different ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Denote dp i the number of ways to get to city i Brute forcing all possible previous cities is out of the question as this solution will take O n2 log maxai time complexity What else can we do Instead consider caseworking on what the greatest common factor can be Let s keep track of an array count which for index i keeps track of the sum of dp values of all previous cities who has a factor of i Say the current city has attractiveness ai We can almost recover dp i by adding up the count values of all factors of ai Unfortunately this fails as it overcounts many instances For example if gcd ai aj 12 the dp state from i will be counted five times 2 3 4 6 12 Note that we don t actually care what the greatest common factor is since the only requirement is that the greatest common factor is not 1 This also means that repeat appearances of the same prime number in the factorization of ai doesn t matter at all we can assume each prime factor occurs exactly once Now if gcd ai aj 12 it is only counted three times 2 3 6 Now instead of blindly adding the count values from all previous states let s instead apply the Principle of Inclusion Exclusion on the prime factors Let s first add the count values from all prime factors then subtract the count values from all factors with two prime factors then add the count values from all factors with three prime factors and so on It can be seen that actually the value is only counted one time now So what s the time complexity of this solution Precomputing the set of all prime number takes O max ai log max ai time by the harmonic series n1 n2 nn nlog n For each number ai we have to consider all 2f ai subsets of prime factors where f ai is the number of prime factors of ai The number with the most distinct prime factors is 510510 2 3 5 7 11 13 17 so worst case 27 128 operations are needed per number This goes to a total operation count of approximately 128 n which will pass in the time limit Note that we may also use the Mobius function to compute the answer The Mobius function s properties makes it utilize the Principle of Inclusion Exclusion efficiently The time complexity of this solution is O max ai log max ai nmax d ai where d ai is the maximum number of factors of ai This time complexity can be shown to be the same as the above time complexity "}
{"statement": "You are given a colored permutation p 1 p 2 dots p n The i th element of the permutation has color c i Let s define an as infinite sequence i p i p p i p p p i dots where all elements have c i c p i c p p i dots We can also define a multiplication of permutations a and b as permutation c a times b where c i b a i Moreover we can define a power k of permutation p as p k underbrace p times p times dots times p k text times Find the minimum k 0 such that p k has at least one infinite path i e there is a position i in p k such that the sequence starting from i is an infinite path It can be proved that the answer always exists ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2200", "problem_editorial": "Let s look at the permutation as at a graph with n vertices and edges i p i It s not hard to prove that the graph consists of several cycles self loops are also considered as cycles So the sequence i p i p p i dots is just a walking on the corresponding cycle Let s consider one cycle c 1 c 2 dots c m In permutation p we have p c i c i 1 mod m But since p 2 p times p or p 2 i p p i so p 2 c i c i 2 mod m and in general case p k c i c i k mod m Now walking with step k we can note that the initial cycle c split up on GCD k m cycles of length frac m GCD k m Looking at the definition of infinite path we can understand that all we need to do is to check that at least one of GCD k m cycles have all vertices of the same color We can check it in O m time for the cycle c and fixed k The final observation is next for k 1 and k 2 such that GCD k 1 m GCD k 2 m the produced cycles will have the same sets of vertices and differ only in the order of walking so we can check only one representative for each GCD k m i e we can take only such k which divide m We can handle each cycle of p separately So using the approximation that the number of divisors of n is O n frac 1 3 we get O n frac 4 3 time complexity "}
{"statement": "There is a programing contest named SnakeUp people want to compete for it In order to attend this contest people need to form teams of exactly two people You are given the strength of each possible combination of two people All the values of the strengths are Every contestant hopes that he can find a teammate so that their team s strength is as high as possible That is a contestant will form a team with highest strength possible by choosing a teammate from ones who are willing to be a teammate with him her More formally two people and may form a team if each of them is the best possible teammate among the contestants that remain unpaired for the other one Can you determine who will be each person s teammate ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Sort all possible combinations from high strength to low strength Then iterator all combinations If two people in a combination still are not contained in any team then we make these two people as a team "}
{"statement": "In Ann s favorite book shop are as many as books on math and economics Books are numbered from to Each of them contains non negative number of problems Today there is a sale any subsegment of a segment from to can be bought at a fixed price Ann decided that she wants to buy such non empty subsegment that the sale operates on it and the number of math problems is greater than the number of economics problems by Note that may be positive negative or zero Unfortunately Ann is not sure on which segment the sale operates but she has assumptions For each of them she wants to know the number of options to buy a subsegment satisfying the condition because the time she spends on choosing depends on that Currently Ann is too busy solving other problems she asks you for help For each her assumption determine the number of subsegments of the given segment such that the number of math problems is greaten than the number of economics problems on that subsegment exactly by ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "If th book is on economics Now problem is to calculate count of segments of sum Calculate prefix sums Then Now we can solve it in We ll go along the segment and calculate number of occurences of in segment Then we ll add to answer can be big enought so we should use something like This is where the logarithm comes from Note that we can easily move both borders to the left and to the right Then we can solve it using Mo s algorhitm in Unfortunatelly it s still too slow Let s use coordinate compression For each prefsum calculate compressed value of compressed value and compressed value It allows us to get rid of logarithm "}
{"statement": "You are given an undirected graph with weighted edges The length of some path between two vertices is the bitwise xor of weights of all edges belonging to this path if some edge is traversed more than once then it is included in bitwise xor the same number of times You have to find the minimum length of path between vertex and vertex ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2300", "problem_editorial": "Let s find some path from to Let its length be then the answer to the problem can be represented as where is the total length of some set of cycles in the graph they can be disconnected it doesn t matter because we can traverse the whole graph and return to the starting vertex with cost Let s treat each cycle s cost as a vector where is the th bit in binary representation of cycle s cost We can use Gaussian elimination to find the independent set of vectors that generates all these vectors To do this let s build any spanning tree of the graph and then for any edge not belonging to the spanning tree we can try to add to the independent set is the length of the path from the root to in the spanning tree When trying to add some vector we firstly need to check if it can be represented as a combination of some vectors from the set and only if it s impossible then we add it to the set The number of vectors in the set won t exceed so we can use Gaussian elimination to check if the vector is a combination of elements from the set Then after we found the basis let s build the answer greedily from the most significant bit to the least we will check if we can set the current bit so it is equal to the corresponding bit of while maintaining all the previous bit To check it we also can use Gaussian elimination "}
{"statement": "We call an array a if all elements in it are pairwise distinct For example an array 1 7 9 is pure 1 3 3 7 isn t because 3 occurs twice in it A pure array b is to a pure array c if their lengths n are the same and for all pairs of indices l r such that 1 le l le r le n it s true that operatorname argmax b l b l 1 ldots b r operatorname argmax c l c l 1 ldots c r where operatorname argmax x is defined as the index of the largest element in x which is unique for pure arrays For example operatorname argmax 3 4 2 2 operatorname argmax 1337 179 57 1 Recently Tonya found out that Burenka really likes a permutation p of length n Tonya decided to please her and give her an array a to p He already fixed some elements of a but exactly k elements are missing in these positions temporarily a i 0 It is guaranteed that k ge 2 Also he has a set S of k 1 numbers Tonya realized that he was missing one number to fill the empty places of a so he decided to buy it He has q options to buy Tonya thinks that the number d suits him if it is possible to replace all zeros in a with numbers from S and the number d so that a becomes a array to p For each option of d output whether this number is suitable for him or not ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "Tutorial Let s build a tree recursively starting from the segment at each step we will choose the root of the subtree then recursively construct trees for subtrees if they are not empty then create edges from the root to the roots of these subtrees What we got is called a Cartesian tree by array This Cartesian tree will be mentioned further in the analysis It is easy to see that Cartesian trees by arrays coincide if and only if these arrays are similar Then the necessary and sufficient condition for the array to be similar to is that for any pair such that is in the subtree is satisfied in other words is the maximum among the numbers in the subtree of the vertex Let s call the position initially empty if initially Let s call an array almost similar to if for any pair such that is in the subtree is executed or both positions are initially empty Let s prove that if there is a way to fill in the gaps in to get an array almost similar to then there is also a way to fill in the gaps to get a similar to array Indeed let s look at the array almost similar to let s walk through the tree recursively starting from the root At the step with the vertex we first start recursively from all the children of now it is true for them that the maxima of their subtrees are in them let s look at the maximum child let it be then if then everything is fine otherwise note that is initially an empty position because for all initially non empty positions it is true that they are maximums in their subtrees this is easy to see in the definition but is not Note that is initially an empty position Otherwise we have never changed and therefore in the original array almost similar to contradiction was executed it is contradiction so are initially empty we can perform and everything will be executed After executing this algorithm we changed only the initially empty elements and got similar to Q E D How to check the existence of an array almost similar to Let s call the number the minimum among all the numbers such that is in the subtree of Let s call the number the maximum among all the numbers such that is in the subtree of it is easy to see that is almost similar to if and only if for all is satisfied That sounds incredibly good So all we need is to find a matching of the set and number and segments for that are initially empty Now it is easy to prove that the suitable is a continuous segment let s say the answer is yes for we don t know the answer for try looking at the alternating path from to in good matching for it s easy to see that if there is such a path then for the answer is yes otherwise no If you look at the structure of the matching of points with segments you can see that an alternating path exists for a continuous segment of values the boundaries can be found by binary search or by typing greedily twice Final complexity is or "}
{"statement": "Lately a national version of a bingo game has become very popular in Berland There are players playing the game each player has a card with numbers The numbers on each card are distinct but distinct cards can have equal numbers The card of the th player contains numbers During the game the host takes numbered balls one by one from a bag He reads the number aloud in a high and clear voice and then puts the ball away All participants cross out the number if it occurs on their cards The person who crosses out all numbers from his card first wins If multiple people cross out all numbers from their cards at the same time there are no winners in the game At the beginning of the game the bag contains 100 balls numbered 1 through 100 the numbers of all balls are distinct You are given the cards for each player Write a program that determines whether a player can win the game at the most favorable for him scenario or not ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "It is good idea to think about cards as set of numbers It is easy to see that card can t be finished before if is subset of So all you need is to find such cards sets which do not have other card other set as subset Since there are at most 1000 cards you may iterate through all pairs and check that one card contains other in naive way like "}
{"statement": "Polycarp wants to assemble his own keyboard Layouts with multiple rows are too complicated for him his keyboard will consist of only one row where all 26 lowercase Latin letters will be arranged in some order Polycarp uses the same password s on all websites where he is registered it is bad but he doesn t care He wants to assemble a keyboard that will allow to type this password very easily He doesn t like to move his fingers while typing the password so for each pair of adjacent characters in s they should be adjacent on the keyboard For example if the password is then the layout is perfect since characters and are adjacent on the keyboard and and are adjacent on the keyboard It is guaranteed that there are no two adjacent equal characters in s so for example the password cannot be two characters are adjacent Can you help Polycarp with choosing the perfect layout of the keyboard if it is possible ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "The problem can be solved using a greedy algorithm We will maintain the current layout of the keyboard with letters that have already been encountered in the string and the current position on the layout If the next letter of the string is already on the layout it must be adjacent to the current one otherwise there is no answer If there was no such letter yet we can add it to the adjacent free position if both of them is occupied then there is no answer At the end you have to add letters that were not in the string "}
{"statement": "Ann has recently started commuting by subway We know that a one ride subway ticket costs rubles Besides Ann found out that she can buy a special ticket for rides she can buy it several times It costs rubles Ann did the math she will need to use subway times Help Ann tell her what is the minimum sum of money she will have to spend to make rides ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Solution of this problem is based on two claims If then there is no point to buy a ride ticket Sometimes it is better to buy summary more ride tickets for amount of rides than we need If we receive profits bying ride tickets then number of such ones will be For the remain rides we must choose the best variant to buy separate ticket for each ride or to buy ride ticket and use it not fully Complexity Solution 7784793 "}
{"statement": "Given an array a of n elements find the maximum value of the expression a i a j a j a k a k a l a l a i where i j k and l are four indices of the array a with 1 le i j k l le n Here x denotes the absolute value of x ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "SolutionSuppose if there were only elements in the array Let them be Then the answer will be maximum of the three cases which are listed as follows so clearly is the maximum So to maximize this we can set as large as possible and as small as possible i e and where means element in sorted order of given array "}
{"statement": "Iris likes full binary trees Let s define the depth of a rooted tree as the maximum number of on the simple paths from some vertex to the root A full binary tree of depth d is a binary tree of depth d with exactly 2 d 1 vertices Iris calls a tree a tree if some vertices and edges can be to it to make it a full binary tree of depth d Note that can be chosen as the root of a full binary tree Since performing operations on large trees is difficult she defines the of a tree as the minimum d satisfying that the tree is d binary Specifically if there is no integer d ge 1 such that the tree is d binary the binary depth of the tree is 1 Iris now has a tree consisting of only vertex 1 She wants to add n 1 more vertices to form a larger tree She will add the vertices one by one When she adds vertex i 2 leq i leq n she ll give you an integer p i 1 leq p i i and add a new edge connecting vertices i and p i Iris wants to ask you the binary depth of the tree formed by the first i vertices for each 1 le i le n Can you tell her the answer ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "Here re two lemmas that will be used in the solution Lemma 1 Among all the points on a tree with the greatest distance from a certain point one of which must be one of the two endpoints of a certain diameter Lemma 2 After merging two trees at least one new diameter is generated at the four endpoints of two certain diameters Obviously we consider a subtree composed of the first points which corresponds to a fully binary tree with a depth of and must have only one node with the smallest depth otherwise it would not be connected If the depth of the node with the smallest depth is greater than then we can reduce the depth of all nodes by It is easy to see that this will not cause conflicts and should be reduced by In this case we obtain Conclusion 1 There must be a node corresponding to the root of a fully binary tree Meanwhile due to the degrees of the nodes of a full binary tree it is obtained that Conclusion 2 The node corresponding to the root should have a degree if there is a node with a degree then all subsequent queries should be We can consider the case where each point is the root and due to the Lemma we can obtain as the maximum distance from that point to the endpoints of two diameters then plus Finally select the point with degree that minimizes this maximum value as the root Brute practices can achieve time Consider optimization According to Lemma 2 each time a point is added the diameter length either remains unchanged or increases by In the case of adding as mentioned earlier we investigate the maximum distance of all points temporarily ignoring their degrees If we consider real time maintenance of its changes it is obvious that if the new diameter distance is even it is equivalent to a maximum distance of for all points except for a subtree at the midpoint of the new diameter otherwise it is equivalent to a maximum distance of for all points of the subtree at the midpoint of the original diameter Pay attention to the subtrees mentioned where the roots of the entire tree are variable but this is not very important We can traverse and number all nodes in the DFS order so that the subtree of each node is within an interval in such order Therefore an indefinite rooted subtree can also be represented by intervals You can use a segment tree to facilitate the maintenance of the operations In addition considering the impact of degrees we just need to increase the maximum distance of a degreed node by Ultimately at the end of each operation we need only the global minimum value The time complexity is "}
{"statement": "Egor has an array a of length n initially consisting of zeros However he wanted to turn it into another array b of length n Since Egor doesn t take easy paths only the following operation can be used possibly zero or several times choose an array l of length k 1 leq l i leq n all l i are and change each element a l i to l i ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "TutorialIf then we can change to so the answer is YES only if otherwise the answer is NO Otherwise let s build an undirected graph with vertices and edges Any component of this graph will look like a cycle possibly of size to each vertex of which a tree is attached possibly empty ProofLet s assume that there are vertices in a component then there are also edges in it since each vertex has exactly one outgoing edge We can construct a depth first search DFS tree for this component which will have edges Now when we add the remaining edge a cycle is formed in the component formed by the edge and the path between and in the DFS tree Each vertex will have a tree attached to it because before adding the edge we had a tree Now it is claimed that if the cycle in each component has a size exactly then the answer is YES otherwise NO ProofLet s first consider the situation where the size of the cycle in some component is not Let the cycle contain vertices in that order Now let s look at the last operation in which one of the was equal to some element from the cycle If the size of the cycle is less than then in the last operation there will be at least one vertex not from the cycle which means that at least one vertex from the cycle will be replaced by a number that is not the next vertex in the cycle which is incorrect because each vertex from the cycle should be replaced by the next vertex after it If the size of the cycle is greater than then we will have a vertex from the cycle that will be replaced by a vertex that is not the next vertex in the cycle otherwise we would have used all the vertices of the cycle and there are more than of them Therefore in any case there is no valid last operation with vertices from the cycle so the answer is NO If the size of the cycle in a component is equal to then we can apply the following algorithm While there is at least one vertex in the component that is a leaf we will perform the operation with all elements are distinct because we will enter the cycle and it has a size of After this operation we will have and we can remove vertex it had only outgoing edge When only the cycle remains we can apply the operation for the vertices in the cycle preserving the order and then for all vertices in the component we will have By doing this for all components we will get which is what we wanted so the answer is YES Time Complexity per test case "}
{"statement": "This task is very simple Given a string of length and queries each query is on the format which means sort the substring consisting of the characters from to in non decreasing order if or in non increasing order if Output the final string after applying the queries ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "In this problem we will be using counting sort So for each query we will count the number of occurrences for each character and then update the range like this But this is too slow We want a data structure that can support the above operations in appropriate time Let s make 26 segment trees each one for each character Now for each query let s get the count of every character in the range and then arrange them and update each segment tree with the new values We will have to use lazy propagation technique for updating ranges Time complexity where sz is the size of the alphabet i e 26 Implementation "}
{"statement": "You are given an undirected graph consisting of n vertices and m edges The graph does not necessarily connected Guaranteed that the graph does not contain multiple edges more than one edges between a pair of vertices or loops edges from a vertex to itself A cycle in a graph is called a simple if it contains each own vertex exactly once So simple cycle doesn t allow to visit a vertex more than once in a cycle Determine the edges which belong to simple cycle ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "To solve this problem it is good to know about Briefly in the graph it is easy to select such a minimal set of cycles that any other cycle can be obtained as XOR of some subset of cycles from This set is also called the fundamental set of cycles To find it in a connected graph you can find any carcass and alternately independently add to this carcass each of the edges that are not entered into it When each such edge is added to the carcass its cycle closes The set of these cycles is a fundamental set of cycles Thus if the graph is connected then the size of the fundamental set of cycles is exactly It is easy to see that if an edge belongs to exactly one cycle from the fundamental set of cycles then it belongs to exactly one simple cycle We solve the problem independently for each connected component For a connected component it finds its carcass by a search in depth and each edge that does not enter the search tree into the depth will close a cycle We only take into account those cycles that do not intersect along the edges We should print only them in the form of a set of edges If the carcass was built with a search in depth then each cycle represents a path from the vertex to the child plus the reverse edge Thus the problem now is a set of pairs of vertices a vertex and its descendant that specify a set of paths from top to bottom is given in the tree It is required to select those paths that do not intersect with any other paths from this set To find such ways quickly it is possible with help of DSU system of non intersecting subsets on paths On the edge you should store the 1 mark or the path number to which it belongs When passing the edges without marking it should be marked by this path When passing an edge with a mark it is necessary to merge two paths into the DSU because they intersect After processing the path for all the vertices of the path the ancestor should be reassign to the top vertex of the path Because if we do not make this we will repeatedly go through the same path Using the following code we find for each vertex its depth in the depth search tree and all the back edges an array void dfs int u int pu int d dep u d color u 1 p u pu for int v g u if v pu continue if p v 1 dfs v u d 1 else if color v 1 be push back u v color u 2 Using the following code we process all paths actually cycles merging the intersecting ones pp p k be size for int i 0 i k i int x be i first vector int path while dep x dep be i second path push back x if index x 1 index x i else unite i index x DSU x p x for auto j path p j be i second Let it is an original array of ancestors in depth search tree because array has been changed by the code above Now it is sufficient to the answer to take such paths plus the corresponding reverse edge that do not intersect with others that is the size of the DSU component is 1 vector int sizes k for int i 0 i k i sizes leader i set int result for int i 0 i be size i if sizes i 1 result insert e be i int x be i first while x be i second result insert e x pp x x pp x This problem has another solution based on the allocation of the doubly connected components with the help of the corresponding linear algorithm "}
{"statement": "Adilbek s house is located on a street which can be represented as the OX axis This street is really dark so Adilbek wants to install some post lamps to illuminate it Street has n positions to install lamps they correspond to the integer numbers from 0 to n 1 on the OX axis However some positions are blocked and no post lamp can be placed there There are post lamps of different types which differ only by their power When placed in position x post lamp of power l illuminates the segment x x l The power of each post lamp is always a positive integer number The post lamp shop provides an infinite amount of lamps of each type from power 1 to power k Though each customer is only allowed to order post lamps of type Post lamps of power l cost a l each What is the minimal total cost of the post lamps of type Adilbek can buy to illuminate the entire segment 0 n of the street If some lamps illuminate any other segment of the street Adilbek does not care so for example he may place a lamp of power 3 in position n 1 even though its illumination zone doesn t completely belong to segment 0 n ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s start with learning how to place lamps of fixed power to cover the segment with the minimal number of them The following greedy strategy works find the rightmost non blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp Initially you only consider to be covered Function the minimal number of post lamps to cover segment is clearly monotonous thus you want to update states as early as possible Okay now you iterate over all and update the answer with the results multiplied by cost Now why will this work fast You obviously precalculate the rightmost free position for each prefix segment If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment Finally any two consecutive iterations of the algorithm will either move you by positions or return This can be easily proven by contradiction Overall complexity as you do about steps for each and that is a common series sum "}
{"statement": "You are given two binary strings a and b both of length n You can do the following operation any number of times possibly zero Select two indices l and r l r Change a l to 1 a l and a r to 1 a r If l 1 r the cost of the operation is x Otherwise the cost is y You have to find the minimum cost needed to make a equal to b or say there is no way to do so ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Consider another binary string in which So doing an operation means selecting two indices of and flipping them Also let s define is the number of in Because the parity of never changes the answer is if is odd If is even classify the cases If and two s are adjacent the answer is Because holds we can always replace one cost operation with two cost operations If and two s are not adjacent the answer is If select th and th each This costs and we showed the cost cannot be reduced more in hint 3 "}
{"statement": "Theofanis has a string s 1 s 2 dots s n and a character c He wants to make all characters of the string equal to c using the minimum number of operations In one operation he can choose a number x 1 le x le n and where i is divisible by x replace s i with c Find the minimum number of operations required to make all the characters equal to c and the x s that he should use in his operations ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "If the whole string is equal to then you don t need to make any operations In order to find if it is possible with exactly operation we can pass through every and count all the letters that are divisible by This takes time complexity If for some all its multiples are then the answer is operation with that If all the above conditions don t hold you can always make operations and make all the elements equal One possible way is with and After the first operation only the last element of is not thus if we use since then is not divisible by and it will become equal to Time complexity per test case "}
{"statement": "Given an array a consisting of n integers find max limits 1 le i j le n LCM a i a j where LCM x y is the smallest positive integer that is divisible by both x and y For example LCM 6 8 24 LCM 4 12 12 LCM 2 3 6 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Since it makes sense to try and fix Let s call it Now let s only care about the multiples of in the input Assume we divide them all by We now want the maximum product of 2 numbers in this new array Let s sort the numbers and iterate from the biggest to the smallest keeping a stack Assume the current number you re iterating on is While there is a number in the stack coprime to you can actually pop the top of the stack you ll never need it again That s because this number together with a number smaller than can never give a better product than that of a greater or equal number together with Now we just need to figure out whether there s a number coprime to in the stack This could be easily done with inclusion exclusion Assume the number of multiples of in the stack is the number of elements in the stack coprime to is Where is the Mobius function So we ll just iterate on the integers from greatest to smallest and while there s a number coprime to in the stack we ll keep maximizing the answer popping and updating the array Then we ll push to the stack and also update The complexity is where is the divisor count function That s because each number enters the routine of calculating the maximum product of a coprime pair times and we iterate through its divisors in this routine "}
{"statement": "Nikita is a student passionate about number theory and algorithms He faces an interesting problem related to an array of numbers Suppose Nikita has an array of integers a of length n He will call a subsequence dagger of the array if its least common multiple LCM is not contained in a The LCM of an empty subsequence is equal to 0 Nikita wonders what is the length of the longest subsequence of a Help him answer this question dagger A sequence b is a subsequence of a if b can be obtained from a by the deletion of several possibly zero or all elements without changing the order of the remaining elements For example 5 2 3 is a subsequence of 1 5 7 8 2 4 3 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "First let s understand if we can take the entire array a as the special subsequence To do this find the LCM a1 a2 an If it is greater than max a1 a2 an then obviously such a number is not in the subsequence because LCM max After this check it becomes known that each ai max a1 a2 an Then we iterate over the divisors of the maximum and greedily check for the presence of a subsequence with such an LCM If we do this naively it will be O C n d C log C but this is already sufficient Note that we can count the occurrence of each number and check only the distinct numbers Then the complexity will be O C d C 2 log C "}
{"statement": "There are n warriors in a row The power of the i th warrior is a i All powers are pairwise distinct You have two types of spells which you may cast Fireball you spend x mana and destroy k consecutive warriors Berserk you spend y mana choose two consecutive warriors and the warrior with greater power destroys the warrior with smaller power For example let the powers of warriors be 2 3 7 8 11 5 4 and k 3 If you cast Berserk on warriors with powers 8 and 11 the resulting sequence of powers becomes 2 3 7 11 5 4 Then for example if you cast Fireball on consecutive warriors with powers 7 11 5 the resulting sequence of powers becomes 2 3 4 You want to turn the current sequence of warriors powers a 1 a 2 dots a n into b 1 b 2 dots b m Calculate the minimum amount of mana you need to spend on it ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "The first thing we need to do is to find the occurrences of in the sequence these are the monsters that have to remain Since both spells Fireball and Berserk affect consecutive monsters we should treat each subsegment of monsters we have to delete separately Consider a segment with monsters we have to delete such that the last monster before it has power the first monster after the segment has power and the strongest monster on the segment has power If then we have to use Berserk at least times Let s make the strongest monster on segment kill some other monster If then the strongest monster should also be killed by one of the monsters bounding the segment so if and there is no solution Okay now the number of monsters is divisible by If it is more profitable to use Fireball we use the required number of Fireballs to kill all of them Otherwise we have to kill the maximum possible number of monsters with Berserk and finish the remaining ones with Fireball If or then one of the monsters just outside the segment can kill all the monsters inside the segment otherwise the strongest monster should kill adjacent monsters until exactly remain and those monsters are finished with a single Fireball Now we know what we need to consider when processing a single segment all that s left is to sum the minimum required mana over all such segments Since the total length of these segments is at most and we can process each segment in linear time we have a solution with complexity "}
{"statement": "There are n locations on a snowy mountain range numbered from 1 to n connected by n 1 trails in the shape of a tree Each trail has length 1 Some of the locations are base lodges The height h i of each location is equal to the distance to the nearest base lodge a base lodge has height 0 There is a skier at each location each skier has initial kinetic energy 0 Each skier wants to ski along as many trails as possible Suppose that the skier is skiing along a trail from location i to j Skiers are not allowed to ski uphill i e if h i h j It costs one unit of kinetic energy to ski along flat ground i e if h i h j and a skier gains one unit of kinetic energy by skiing downhill i e if h i h j For each location compute the length of the longest sequence of trails that the skier starting at that location can ski along without their kinetic energy ever becoming negative Skiers are allowed to visit the same location or trail multiple times ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2900", "problem_editorial": "SolutionRead the hints The rest is just implementation For each set of flippable vertices of the same height we can calculate the set of starting vertices which are able to reach at least one vertex in that flippable set To do this split the graph up into layers of equal height Let be the minimum required energy to reach a vertex in the flippable set can be computed via shortests paths where edges in the same layer have weight and edges from layer to have weight We can use bfs to relax the costs of vertices in a single layer and then easily transition to the next layer We do this for different starting heights so the total complexity is "}
{"statement": "You are given a rooted tree consisting of n vertices The vertex 1 is the root Each vertex has an integer written on it this integer is val i for the vertex i You are given q queries to the tree The i th query is represented by two vertices u i and v i To answer the query consider all vertices w that lie in the subtree of u i or v i For all vertices in these two subtrees list all integers written on them and find the integer with the maximum number of occurrences If there are multiple integers with maximum number of occurrences the among them is the answer ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "First let s solve the following problem we need to maintain a multiset of numbers and process queries of th types add a number to the multiset remove one occurrence of a number from the multiset it is guaranteed that it exists calculate the mode on this multiset To do this we will maintain the array the frequency of in the multiset Now the mode is the position of the leftmost maximum in this array There are many ways to search for this position we will use the following we will build a sqrt decomposition on the array for a block we will maintain a maximum on this block and an array the number of positions in this block such that Since in each of the initial requests changes by no more than the maximum in the block also changes by no more than 1 and using the array it is easy to update it after each query Now to find the mode the position of the leftmost maximum in the array you first need to go through all the blocks to find the value of the maximum and the leftmost block in which this maximum occurs then iterate over the desired position in this block Thus queries to add and remove an element run in and a mode search query runs in where is the number of possible distinct values in a given problem Now let s get back to the problem itself Let s build a Preorder traversal of our tree Let be the position in the indexing of the vertex in the Preorder traversal be the size of the Preorder traversal after leaving the vertex Then the half interval of the Preorder traversal represents the set of vertices of the subtree of the vertex For the th query we will consider Let be the size of the subtree of be some integer then will be called light if and heavy otherwise A query is called light heavy if is a light heavy vertex We will solve the problem for light and heavy queries independently Let s use the small to large technique and maintain the multiset described at the beginning of the solution Let at the moment we have this multiset for the vertex Let s answer all light queries for which To do this take all the vertices from the subtree of and add the numbers written on them calculate the mode on the current multiset this will be the answer to the query and then delete the newly added vertices In the standard implementation of small to large you need to maintain several structures at the same time which in this case is impossible due to the fact that each of them takes up of memory This problem can be avoided for example as follows before constructing the Preorder traversal for each vertex put its heaviest son at the head of the adjacency list Then it will be possible to iterate over the vertices in the order of the Preorder traversal preserving the asymptotics This part of the solution runs in Let s divide all heavy vertices into non intersecting vertical paths so that two vertices from the same path have subtrees that differ by no more than vertices and the number of the paths themselves is To do this let s take the deepest of the unused heavy vertices and build one of the desired paths going up to the parent while the first of these conditions is met Then we mark all the vertices in this path as used and start over We will continue to do this while there are still unused heavy vertices It is easy to see that the resulting paths are vertical and the subtrees of two vertices from the same path differ by no more than by construction Let s prove that there are not very many of these paths To do this we will understand in which cases the path breaks If the current path contains a root then since the root has no parent the path will terminate Obviously this path is only If the parent of the last vertex of the path has only one heavy child this last vertex itself From the construction a break means that the number of vertices in this path plus the number of children outside the heaviest son subtree of the parent of the last vertex and each vertex of the path except for the initial one is more than in total but each of the counted vertices can be counted in only one of such cases that is the number of paths that terminate in this way does not exceed If the parent of the last node has more than one heavy child Let s leave only heavy vertices in the tree since the parent of a heavy vertex is a heavy vertex too it will indeed be a tree or an empty graph This tree contains at most leafs Calculating the total degree of the vertices of this tree we can see that there are at most additional sons all sons of a vertex except one This means that the number of paths terminating in this way is at most We got that the paths are Let s divide the heavy queries according to the paths where the is situated We will answer queries with vertices from the same path together We will do it similarly to the case with light queries with minor differences at the very beginning we add to the multiset all the vertices of the subtree of the initial vertex of the path and mentally remove these vertices from the subtrees of vertices Everything else is preserved Let s calculate how long it takes add all vertices from one subtree small to large to answer one query due to condition on vertices from one path we have to add at most vertices Since there are only paths the whole solution will take We take and counting we get and total running time As already mentioned a subtree corresponds to a segment of the Preorder traversal so subtrees are segments We will maintain the data structure described at the beginning on the sum of segments By moving the boundaries of these segments you can move from one query to another as in Mo s algorithm It remains only to sort the queries Heavy queries are sorted first by path number of then by Light queries are sorted only by but here you can t just move the segment of the subtree you need to rebuild it for each query Solve this problem for two subtrees and a path connecting the roots of these subtrees This solution partially intersects with the one described by the problem author We will use the same data structure for maintaining the mode and we will also use DFS order of the tree but before constructing it we will reorder the children of each vertex so that the heaviest child is the first one Let be the moment we enter the vertex in DFS and be the moment we leave the vertex As usual the segment represents the subtree of vertex and we can change the state of the structure from the subtree of the vertex to the subtree of the vertex in operations Let this number of operations be Let be the DFS order of the tree We can prove that is estimated as if we order the children of each vertex in such a way that the first of them is the heaviest one Let s analyze how many times some vertex is added when we go in DFS order and maintain the current set of vertices When some vertex is added to the current subtree this means that the previous vertex in DFS order was not an ancestor of the current vertex so the current vertex is not the first son of its parent So the size of the subtree of the parent is at least 2x the size of the current vertex Since the path from to root can have at most such vertices then the vertex is added at most times Okay how do we use it to process queries efficiently Let s say that the vertex the th vertex in DFS order has coordinate equal to Let this coordinate be Then if we have the data structure for the query and we want to change it so it meets the query we can do it in at most operations which can be treated as the Manhattan distance between points and Do you see where this is going We can map each query to the point and then order them in such a way that the total distance we need to travel between them is not too large We can use Mo s algorithm to do this Since the coordinates are up to but there are only points some alternative sorting orders for Mo like the one that uses Hilbert s curve may work better than the usual one "}
{"statement": "The girl will perform the following operation with her tree as long as she needs Remove any existing edge Add an edge between any pair of vertices What is the number of operations Nastia needs to get a bamboo from a tree A bamboo is a tree in which no node has a degree greater than 2 ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Let s define the variable as a minimum number of operations that we need to get bamboo from a tree Let s remove edges first and then add new ones to the graph Consider the structure of the graph after removing edges This is a with a connected components Easy to notice each of the connected components in the getting forest of trees to get the bamboo after adding new edges Thus we can get the bamboo from the forest of bamboo after removing edges by times adding the conjunction between leaves that are in the different components of connectivity of the forest So the task is to find the minimum number of the removing edges needs to get the forest of bamboos Here works the following greedy Let s define any vertice of the tree as a root We will solve the problem for each of the subtrees First solve the problem for all child vertices of Then define the value as the number of the children and the value as the ancestor for vertex There are cases If then we don t remove anything If then we remove the edge if exists If then we remove the edge if exists and any existing edges from to one of the children vertex Take a look at the picture "}
{"statement": "After the most stunning success with the fifth graders Madoka has been trusted with teaching the sixth graders There s n single place desks in her classroom At the very beginning Madoka decided that the student number b i 1 le b i le n will sit at the desk number i Also there s an infinite line of students with numbers n 1 n 2 n 3 ldots waiting at the door with the hope of being able to learn something from the Madoka herself Pay attention that each student has his number After each lesson the following happens in sequence The student sitting at the desk i moves to the desk p i All students move simultaneously If there is more than one student at a desk the student with the lowest number keeps the place and the others are removed from the class For all empty desks in ascending order the student from the lowest number from the outside line occupies the desk Note that in the end there is exactly one student at each desk again It is guaranteed that the numbers p are such that at least one student is removed after each lesson Check out the explanation to the first example for a better understanding After several possibly zero lessons the desk i is occupied by student a i Given the values a 1 a 2 ldots a n and p 1 p 2 ldots p n find the lexicographically smallest suitable initial seating permutation b 1 b 2 ldots b n The permutation is an array of n different integers from 1 up to n in any order For example 2 3 1 5 4 is a permutation but 1 2 2 is not 2 occurs twice 1 3 4 is not a permutation either n 3 but there s 4 in the array For two different permutations a and b of the same length a is lexicographically less than b if in the first position where a and b differ the permutation a has a smaller element than the corresponding element in b ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "After each lesson the person s number increases from the maximum number by the number of desks where no one goes Therefore it is easy to calculate how much time has passed since the very beginning let it be the number k Then let s imagine that schoolchildren are not expelled but at any given time we are simply interested in a student with a minimum number Obviously the answer in this case will not change in any way Let toi be the desk to which the student will move after k transfers who originally sat at i desk This is a standard problem that can be solved using binary lifts or not the most pleasant dfs with cycle allocation and the like but we do not recommend you to write the latter we define the set Vi as the set of all numbers j where toj i Let the starting placement of the student be a permutation of b then we will understand that if someone is transferred to the i desk after k operations then the value in it is the minimum value in Vi And if no one changes seats for it then a student with the same number will always sit in it regardless of the initial seating arrangement After that it is not difficult to guess the optimal starting seating of schoolchildren Let s be a lot of schoolchildren for whom we have not yet chosen the desk at which they are sitting We will iterate over i from 1 to n in ascending order Then you need to understand who should sit at the i desk If we know that there is a desk for which min Vi i must be performed then we must put a student with the minimum number of Vi at i and we can put the remaining people at any desks with a number greater than i so we will add all the other students to the set s Otherwise we just need to take a person from s with the minimum number and put him in a place under the number i and then just remove him from the set of s "}
{"statement": "Sloth is bad mkay So we decided to prepare a problem to punish lazy guys You are given a tree you should count the number of ways to remove an edge from it and then add an edge to it such that the final graph is a tree and has a perfect matching Two ways of this operation are considered different if their removed edges or their added edges aren t the same The removed edge and the added edge can be equal A perfect matching is a subset of edges such that each vertex is an endpoint of exactly one of these edges ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "If graph had odd number of vertices the answer is Otherwise let s call edges that by removing them the remaining graph would have two even components good and all the other edges are bad If you remove a good edge and put another edge somewhere such that the final graph is a tree then it would have prefect matching if and only if the input tree had prefect matching If no two bad edges share a vertex after removing a bad edge lets call it we should chose the end points of the edge we want to add lets call them such that the path between and in the input tree has alternately bad and good edges the first and the last edges in the path are bad and is in this path too So for any path in the tree that has alternately bad and good edges and the first and final edges in it are bad we should add the to the answer This can be done using dp If there are bad edges that share vertices we know that each vertex has odd number of bad edges to its neighbors and if this number is greater than 3 then the answer is 0 So each vertex has 1 or 3 odd edges to its neighbors The path between end points of added edge should contain all the vertices with 3 bad edges and also two of their bad edges should be in the path So if the vertices with 3 bad edges aren t in a path with this condition then the answer is 0 and otherwise we can calculate the answer by checking some conditions in their path and counting the number of paths with some condition at the end points of their path "}
{"statement": "You are given a binary array a all elements of the array are 0 or 1 of length n You wish to sort this array but unfortunately your algorithms teacher forgot to teach you sorting algorithms You perform the following operations until a is sorted Choose two random indices i and j such that i j Indices are chosen equally probable among all pairs of indices i j such that 1 le i j le n If a i a j then swap elements a i and a j What is the expected number of such operations you will perform before the array becomes sorted It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod 998 244 353 Output the integer equal to p cdot q 1 bmod 998 244 353 In other words output such an integer x that 0 le x 998 244 353 and x cdot q equiv p pmod 998 244 353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Let the number of zeros in the array be Let be the expected number of swaps needed when there are zeros in the first positions Then we know that and we can write down the recurrence equations for by considering the case where some element equals to one from the first positions and some element equals to zero from the last positions are swapped This is the only case where the value will change Thus our recurrence is as follows Let Then The answer is where is the initial number of zeros in the first positions "}
{"statement": "Hongcow is learning to spell One day his teacher gives him a word that he needs to learn to spell Being a dutiful student he immediately learns how to spell the word Hongcow has decided to try to make new words from this one He starts by taking the word he just learned how to spell and moves the last character of the word to the beginning of the word He calls this a He can apply cyclic shift many times For example consecutively applying cyclic shift operation to the word abracadabra Hongcow will get words aabracadabr raabracadab and so on Hongcow is now wondering how many distinct words he can generate by doing the cyclic shift arbitrarily many times The initial string is also counted ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "We only need to consider at most s cyclic shifts since s cyclic shifts returns us back to the original string So we can put these all in a set and return the size of the set code "}
{"statement": "Recenlty Luba got a credit card and started to use it Let s consider consecutive days Luba uses the card In the of th day a transaction occurs If then bourles are deposited to Luba s account If then bourles are withdrawn And if then the amount of money on Luba s account is checked In the of any of days Luba can go to the bank and deposit any integer amount of burles to her account But there is a limitation the amount of money on the account can never exceed Luba must not exceed this limit and also she wants that the days when the amount of money on her account is non negative It takes a lot of time to go to the bank so Luba wants to know the minimum number of days she needs to deposit some money to her account if it is possible to meet all the requirements Help her ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "The following greedy solution works Firstly deposite money only on days with Secondly every time the balance is negative to the day with refill it to maximal possible value such that it won t go over later Days with can only lead to invalid state by going over card limit We can only add money to the balance Adding zero money in those days won t make invalid states if all were valid previously Finally if it s possible to get valid state in every day then it s possible to get it by refilling the same day the check happens For example you can make balance in those days Then you will never have negative balance there Though it s not the most optimal way Let be some value you deposite in some day with to pass all conditions till the next day with I state that function of number of game s moves dependancy on is monotonious Let s check it for some fixed Define minimum balance you will get on any suffix from now as Obviously taking will make it If it goes negative then you will need an extra move to finish the game Thus taking maximal will lead to the lowest score possible And last but not least realization part What will be the maximum possible value to deposite Actually it s such a value that optimal game after this will lead to maximum balance of in some day Thus you want to check what will be the maximum balance if you add zero money and take as Obviously if it s negative then output Naively this still works on per day and lead to overall Notice that by depositing you increase maximums on each suffix for now by So you can calculate it as you will do nothing and add sum of your s to get actual value You store prefix sum of up to in Then take maximum on suffix for every is the maxumum for from to I hope I made it clear enough DOverall comlpexity "}
{"statement": "Cat Furrier Transform is a popular algorithm among cat programmers to create longcats As one of the greatest cat programmers ever exist Neko wants to utilize this algorithm to create the perfect longcat Assume that we have a cat with a number x A perfect longcat is a cat with a number equal 2 m 1 for some non negative integer m For example the numbers 0 1 3 7 15 and so on are suitable for the perfect longcats In the Cat Furrier Transform the following operations can be performed on x Operation A you select any non negative integer n and replace x with x oplus 2 n 1 with oplus being a bitwise XOR operator Operation B replace x with x 1 The first applied operation must be of type A the second of type B the third of type A again and so on Formally if we number operations from one in the order they are executed then odd numbered operations must be of type A and the even numbered operations must be of type B Neko wants to produce perfect longcats at industrial scale thus for each cat Neko only wants to perform at most 40 operations Can you help Neko writing a transformation plan Note that it is to minimize the number of operations You just need to use no more than 40 operations ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "There are various greedy solutions possible I ll only cover one of them We ll perform a loop as follows If stop the process since it s already correct If perform operation A with Obviously the resulting will be which satisfies the criteria so we stop the process Otherwise let s denote as the position exponential of the most significant bit of for example We ll perform operation A with If after this phase is not a valid number we ll then perform operation B and return to the beginning of the loop This will never take more than queries since each iteration removes the most significant bit and it would never reappear after later steps and can only have at most bits initially Also it is possible to solve this problem by finding exactly shortest operation sequence by using a BFS However this was not required "}
{"statement": "Andrew Fedor and Alex are inventive guys Now they invent the game with strings for two players Given a group of non empty strings During the game two players build the word together initially the word is empty The players move in turns On his step player must add a single letter in the end of the word the resulting word must be prefix of at least one string from the group A player loses if he cannot move Andrew and Alex decided to play this game times The player who is the loser of the th game makes the first move in the th game Guys decided that the winner of all games is the player who wins the last th game Andrew and Alex already started the game Fedor wants to know who wins the game if both players will play optimally Help him ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "To solve this problem we need the prefix tree trie which will have all the strings from the group Next we will calculate the two DP win v Can player win if he makes a move now players have word equal to prefix in the prefix tree trie lose v Can player lose if he makes a move now players have word equal to prefix in the prefix tree trie if is leaf of trie then win v false lose v true Else such children of vertex Let s look at a few cases If then second player win first player lose all games If then first player win he can change the state of the game in his favor If and then if then first player win else second player win Asymptotics "}
{"statement": "You are given an undirected unweighted connected graph consisting of n vertices and m edges It is guaranteed that there are no self loops or multiple edges in the given graph Your task is to find spanning tree of this graph such that the is equal to D or say that there are no such spanning trees Recall that the degree of a vertex is the number of edges incident to it ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1900", "problem_editorial": "Firstly let s remove the vertex from the graph Then let s calculate the number of connected components Let it be The answer is if and only if or is greater than the number of edges incident to the first vertex Otherwise let s construct the answer Firstly let s add into the new graph spanning trees of components in the initial graph without vertex Then let s add into the new graph edges from vertex one edge to each component Then let s add into the new graph any remaining edges from vertex The last thing we need is to construct a spanning tree of a new graph such that all edges incident to the vertex are in this spanning tree and other edges doesn t matter How to do it Let s run from the vertex in a new graph "}
{"statement": "Let s call of some string t 1 t 2 t 3 dots t n 1 t n as string t 2 t 3 dots t n 1 t n t 1 Analogically let s call of string t as string t n t 1 t 2 t 3 dots t n 1 Let s say string t is if its left cyclic shift is equal to its right cyclic shift You are given string s which consists of digits What is the minimum number of characters you need to erase from s to make it good ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Let s analyze when the string is good Suppose it is The cyclic shifts of this string are and We get the following constraints for a good string If the string has odd length then all characters should be equal to each other otherwise all characters on odd positions should be equal and all characters on even positions should be equal Now since there are only different types of characters we can brute force all possible combinations of the first and the second character of the string we want to obtain there are only of them and for each combination greedily construct the longest possible subsequence of beginning with those characters in "}
{"statement": "You are given a positive integer n In one move you can increase n by one i e make n n 1 Your task is to find the minimum number of moves you need to perform in order to make the sum of digits of n be less than or equal to s You have to answer t independent test cases ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Firstly let s check if the initial fits the conditions If it is print and continue Otherwise let s solve the problem greedily At first let s try to set the last digit to zero Let We need exactly moves to do that Let s add this number to and to the answer and check if the current fits the conditions If it isn t let s try to set the previous last digit to zero Let Then we need moves to do that Let s add this number to and to the answer and check if the current fits the conditions If it isn t repeat the same with the third digit and so on This cycle can do no more than iterations And we can fing the sum of digits of in at most iterations too decimal logarithm of So the total time complexity is "}
{"statement": "You are given a set of elements indexed from to The weight of th element is The weight of some subset of a given set is denoted as The weight of some partition of a given set into subsets is recall that a partition of a given set is a set of its subsets such that every element of the given set belongs to exactly one subset in partition Calculate the sum of weights of all partitions of a given set into exactly subsets and print it modulo Two partitions are considered different iff there exist two elements and such that they belong to the same set in one of the partitions and to different sets in another partition ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Let s look at some facts At first the answer is the sum of weights taken with some coefficients So it s enough to calculate those coefficients Then can be calculated by iterating on the size of the subset containing th element where is the number of partitions of set with elements into nonempty subsets with one subset of fixed size where belongs This solution is still quite slow so the next fact is if two elements and belong to the same subset then increases the coefficient before So for each element we can iterate over all elements which will lie in one subset with In other words is the number of ways to divide set with elements into subsets in such a way that elements and wil lie in one subset can be calculated using Stirling numbers of the second kind let be the number of partitions of set with elements into non empty subsets If then else we just merge and into one element and let Final formula is And the answer is Counting Stirling numbers can be done with inclusion exclusion principle or by searching Wiki Resulting complexity is "}
{"statement": "You are given a positive integer n Find the sequence of positive integers a a 1 a 2 ldots a k that satisfies the following conditions and print the sequence a i le n for all 1 le i le k a is strictly increasing That is a i a i 1 for all 2 le i le k a i a i 1 n for all 2 le i le k where denotes the bitwise OR operation ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "It s obvious that the answer only depends on the popcount of n Below we assume n 2k 1 If k 1 it is shown in the samples that the length is 1 Otherwise the maximum sequence length for 2k 1 is k 1 This can be achived by ai n 2i 1 1 i k ak 1 n "}
{"statement": "You are given two integers n and m Calculate the number of pairs of arrays a b such that the length of both arrays is equal to m each element of each array is an integer between 1 and n inclusive a i le b i for any index i from 1 to m array a is sorted in non descending order array b is sorted in non ascending order As the result can be very large you should print it modulo 10 9 7 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s consider the following sequence It s sequence of length sorted in non descending order where each element of each sequence is an integer between and We can find the number of such sequences by simple combinatorics it s combination with repetitions So the answer is "}
{"statement": "Ahmed and Mostafa used to compete together in many programming contests for several years Their coach Fegla asked them to solve one challenging problem of course Ahmed was able to solve it but Mostafa couldn t This problem is similar to a standard problem but it has a different format and constraints In the standard problem you are given an array of integers and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum But in this problem you are given small arrays and you will create one big array from the concatenation of one or more instances of the small arrays each small array could occur more than once The big array will be given as an array of indexes 1 based of the small arrays and the concatenation should be done in the same order as in this array Then you should apply the standard problem mentioned above on the resulting big array For example let s suppose that the small arrays are 1 6 2 3 3 and 5 1 And the indexes in the big array are 2 3 1 3 So the actual values in the big array after formatting it as concatenation of the small arrays will be 3 3 5 1 1 6 2 5 1 In this example the maximum sum is 9 Can you help Mostafa solve this problem ", "greedy": 1, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "This problem is my favorite one in this problem set Maybe it will be easier to solve this problem if you know how to solve the standard one But because we can t construct the big array so we can t apply the standard solution for this problem Let s see first how to solve the standard problem the following code solves it for a given array arr with length len Now let s solve the big array problem the first step is to calculate 4 values for each small array 1 The total sum of it let s call it tot 2 The maximum sum of 0 or more consecutive elements starting from the first element in the array let s call it lft 3 The maximum sum of 0 or more consecutive elements ending at the last element in the array let s call it rght 4 The maximum sum of 1 or more consecutive elements let s call it gen The final result will be 1 of 2 cases 1 The consecutive elements with the maximum sum will start and end inside the same small array 2 The consecutive elements with the maximum sum will start and end inside different small arrays For the first case we can simply pick the maximum gen for all small arrays which exist in the big array For the second case we can apply something similar to the standard solution we will keep a variable called sum and it s initialized to 0 this will be the maximum sum of 0 or more consecutive elements ending at the last element in the previous small array Now for each small array if the maximum possible sum will end in this small array so it will be sum lft and maximize over this value make sure this will be for 1 or more elements And we need to update sum to be the maximum of the following 3 values 1 sum tot we will include all elements of this small array to the old sum 2 rght we will take the maximum sum ending at the last element in the current small array 3 0 we will not take any elements in sum The running time for this solution will be just for reading the input in my solutions I have no iterations except for reading the input "}
{"statement": "Karen just got home from the supermarket and is getting ready to go to sleep After taking a shower and changing into her pajamas she looked at her shelf and saw an album Curious she opened it and saw a trading card collection She recalled that she used to play with those cards as a child and although she is now grown up she still wonders a few things about it Each card has three characteristics and The values of all characteristics of all cards are positive integers The maximum possible strength any card can have is the maximum possible defense is and the maximum possible speed is There are cards in her collection The th card has a strength defense and speed respectively A card another card if at least two of its characteristics are than the corresponding characteristics of the other card She now wonders how many different cards can beat all the cards in her collection Two cards are considered different if at least one of their characteristics have different values ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Let s say we have one card with and For simplicity we have Consider which cards will beat this one Let s fix the of our card and see what happens at all various Note that a green cell at in grid represents that the card can beat the card Hence the total number of cards that can beat this card is simply the number of green cells across all grids This representation is helpful because we can easily account for more cards For example let s say we have another card and Now what happens when we want to consider the cards that beat of these cards Well we simply have to consider the of both sets of grids Remember that we are simply trying to count the total number of green cells in all grids It turns out that trying to count the number of green cells directly is quite difficult Instead it is more feasible to count the number of cells and then simply subtract it from the number of cells How could we do this We should exploit some properties of the grids First for any particular card all the grids from to are the same and all the grids from to are the same This means that we can avoid a lot of redundancy and only perform some sort of update when we reach the change Second if some cell is not green for some fixed then neither are the cells for all and for the same This means that we can replace each grid with an array where is the largest for which is not green Additionally Third for any card there are only at most two distinct values in for any fixed in one card Finally for any card no value in is less than in if These properties are all pretty easy to observe and prove but they will form the bread and butter of our solution Let s iterate cards from to Suppose we maintain an array which will at first contain all This will be the number of cells that are not green We will update it for all grids first For each card we are essentially setting for all to Of course doing this for each grid will take which is too slow To remedy this initialize as a instead Now we are basically just setting to for all cards Because is essentially a maximum of a bunch of s which are all nonincreasing by the second property it follows that is also nonincreasing at all times Therefore these updates are easy to do we are essentially setting to for the smallest where We can find using binary search Binary searching the segment tree can be done in time using an implicit binary search by going down the tree an explicit binary search might have trouble passing the time limit Using the aforementioned procedure we are able to generate corresponding to the layer in time Using the segment tree we should also be able to get the sum of all values in at all times This will allow us to count the number of not green cells Now we will go backwards from to We should decrement and then see which grids changed Just sort the cards by and do a two pointers approach All the newly changed grids can then be updated in a similar manner as before When a grid changes thanks to the fourth property there is no worry of any getting smaller than it was before they can only get bigger So we have to update two ranges to and to The former is a simple range update the latter can be done using binary search like before After we update all grids for a particular get the range sum and decrement again and so on until we reach We will have the found the total number of not green cells in all and from there we can recover all the green cells and hence the final answer Sorting the cards by takes time constructing the segment tree takes time there are updates each taking time and iterating takes time The final runtime is therefore time which is sufficient to solve this problem This solution can be modified to pass too however this was not done as it uses only standard ideas and just contains more tedious implementation If you want you can try to implement it "}
{"statement": "Monocarp has a dictionary of n words consisting of 12 first letters of the Latin alphabet The words are numbered from 1 to n In every pair of adjacent characters in each word the characters are different For every word i Monocarp also has an integer c i denoting how often he uses this word Monocarp wants to design a keyboard that would allow him to type some of the words easily A keyboard can be denoted as a sequence of 12 first letters of the Latin alphabet where each letter from to appears exactly once A word can be typed with the keyboard easily if for every pair of adjacent characters in the word these characters are adjacent in the keyboard as well The of the keyboard is the sum of c i over all words i that can be typed easily with it Help Monocarp to design a keyboard with the maximum possible optimality ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "For each word let s consider a graph on vertices where the th and the th vertices are connected by an edge iff the th character of the alphabet is adjacent to the th character of the alphabet in this string Obviously this graph is connected except for the isolated vertices If there is a vertex of degree or more in this graph or if there is a cycle in this graph it is impossible to design a keyboard to type the word easily in the first case the letter represented by that vertex must have at least three neighbors on the keyboard but can have only at most two in the second case the keyboard must be cyclic and it is not So the word can be typed easily only if the graph representing it consists of one path and several isolated vertices Let s write the letters along the path we constructed for the word in a single string For example for the word we get edges and in the graph so the letters along the path are either or and obviously one can be obtained from the other by reversing the string Let and be the two strings we obtain from the word using this method Now we claim that the word can be typed easily if and only if one of these two strings and is a substring of the keyboard this would mean that every pair of letters that should be on adjacent positions are actually on adjacent positions Okay now we construct and for each word and our goal is to find the permutation of the first characters of Latin alphabet such that the sum of over all words having either or as a substring is the maximum possible There are two key observations that allow us to solve this problem and cannot be the substrings of the same keyboard the proof is simple if is a substring its first character must be before its second character and if is a substring its second to last character which is the second character of must be before its last character which is the first character of neither nor can appear in the keyboard twice it s obvious since the keyboard is a permutation So we can reformulate the problem as follows let be the cost of the string and the cost of the string as well find the permutation of the first characters of the Latin alphabet so that its cost which is the sum of costs of its substrings is the maximum possible To solve this problem we can store the strings in an Aho Corasick automaton and for every state of the automaton precalculate the total cost of all string ending in this state that is the cost of this state and all states reachable from it via the suffix links Then run a dynamic programming of the form the maximum possible cost of a partial keyboard if we used a of characters and the Aho Corasick automaton is currently in the state This dynamic programming runs in where is the size of the alphabet and is the size of the automaton up to "}
{"statement": "You are playing one famous sandbox game with the three dimensional world The map of the world can be represented as a matrix of size n times m where the height of the cell i j is a i j You are in the cell 1 1 right now and want to get in the cell n m You can move only down from the cell i j to the cell i 1 j or right from the cell i j to the cell i j 1 There is an additional if the height of the current cell is x then you can move only to the cell with height x 1 you can perform several operations During one operation you can decrease the height of cell by one I e you choose some cell i j and assign set a i j a i j 1 Note that you make heights Also note that you decrease the height of the cell 1 1 Your task is to find the number of operations you have to perform to obtain at least one suitable path from the cell 1 1 to the cell n m It is guaranteed that the answer exists You have to answer t independent test cases ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Firstly consider the field in indexation Suppose that the cell has some fixed height Let it be Then we can determine what should be the height of the cell as In fact it does not matter which way we choose we actually need only the number of moves to reach the cell and the height of the cell Then when the height of the cell is fixed we can solve the problem with the following dynamic programming is the minimum number of operations we need to reach the cell from the cell Initially all values except Then can be calculated as But one more thing if then this value of is incorrect and we cannot use it We also can t update from the incorrect values The answer for the problem with the fixed height of the cell is only when is correct and This part can be calculated in But if we iterate over all possible heights our solution obvious will get time limit exceeded verdict Now we can notice one important fact in the optimal answer the height of some cell remains unchanged Let this cell be Then we can restore the height of the cell as and run our quadratic dynamic programming to find the answer for this height Time complexity "}
{"statement": "There is a rectangular grid of size n times m Each cell has a number written on it the number on the cell i j is a i j Your task is to calculate the number of paths from the upper left cell 1 1 to the bottom right cell n m meeting the following constraints You can move to the right or to the bottom only Formally from the cell i j you may move to the cell i j 1 or to the cell i 1 j The target cell can t be outside of the grid The of all the numbers on the path from the cell 1 1 to the cell n m must be equal to k operation is the bitwise exclusive OR it is represented as in Java or C and in Pascal Find the number of such paths in the given grid ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "This is a typical problem on the technique The number of moves we will made equals So if would be small enough 25 is the upper bound I think then we can just run recursive backtracking in or in to iterate over all binary masks of lengths containing exactly ones and check each path described by such mask in this mask is the move to the bottom and is the move to the right if its is But it is too slow So let s split this mask of bits into two parts the left part will consist of bits and the right part will consist of bits Note that each left mask and each right mask too uniquely describes the endpoint of the path and the path itself Let s carry associative arrays where for the endpoint and will denote the number of paths which end in the cell having Let s run recursive backtracking which will iterate over paths starting from the cell and move to the right or to the bottom and maintain of the path If we made moves and we are currently in the cell with right now set and return from the function Otherwise try to move to the bottom or to the right changing as needed Let s run another recursive backtracking which will iterate over paths starting from the cell and move to the left or to the top and maintain of the path except the last cell The same if we made moves and we are currently in the cell with right now let s add to the answer obvious that way we complement our from the right part of the path with the suitable from the left part of the path Otherwise try to move to the left or to the top changing as needed So this is the technique at least the way I code it Overall complexity is "}
{"statement": "There is an rectangular grid each cell of the grid contains a single integer zero or one Let s call the cell on the th row and the th column as Let s define a rectangle as four integers Rectangle denotes a set of cells of the grid Let s define a good rectangle as a rectangle that includes only the cells with zeros You should answer the following queries calculate the number of good rectangles all of which cells are in the given rectangle ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "We can precalculate all rectangles in O N 2M 2 with using consecutive sums for 2D And then we use 4D consecutive sums we can answer the queries The time conplexity is O N 2M 2 Q my solution http ideone com QOjwse "}
{"statement": "You have discovered n mysterious particles on a line with integer charges of c 1 dots c n You have a device that allows you to perform the following operation Choose a particle and remove it from the line The remaining particles will shift to fill in the gap that is created If there were particles with charges x and y directly to the left and right of the removed particle they combine into a single particle of charge x y For example if the line of particles had charges of 3 1 4 1 5 9 performing the operation on the 4th particle will transform the line into 3 1 9 9 If we then use the device on the 1st particle in this new line the line will turn into 1 9 9 You will perform operations until there is only one particle left What is the maximum charge of this remaining particle that you can obtain ", "greedy": 1, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Consider the set of even indexed particles and the set of odd indexed particles Observe that particles can only ever combine with other particles from the same set It follows that the answer is at most On the other hand this bound is almost always obtainable We can first perform the operation on all negatively charged particles in the same set as the desired final particle then perform the operation on all the particles from the opposite set There is a corner case where all particles are negative where the answer is just The time complexity is "}
{"statement": "You are given a rebus of form consisting of only question marks separated by arithmetic operation and equality and positive integer The goal is to replace each question mark with some positive integer from to such that equality holds ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "First we check whether any solution exists at all For that purpose we calculate the number of positive the first one and any other with the sign and negative elements with the sign in the sum Let them be and respectively Then the minimum value of the sum that can be possibly obtained is equal to as each positive number can be but all negative can be Similarly the maximum possible value is equal to The solution therefore exists if and only if Now suppose a solution exists Let s insert the numbers into the sum one by one from left to right Suppose that we have determined the numbers for some prefix of the expression with the sum of Let the sign of the current unknown be or and there are some unknown numbers left to the right excluding the examined unknown among them positive and negative elements Suppose that the current unknown number takes value How do we find out whether this leads to a solution The answer is in the same way we checked it in the beginning of the solution Examine the smallest and the largest values of the total sum that we can get These are equal to and respectively Then we may set the current number to if holds To find the value of we can solve a system of inequalities but it is easier simply to check all possible values from to BONUS Let be the number of unknowns in the rebus Prove that the complexity of the described solution implementation shown below is not Code "}
{"statement": "The USA Construction Operation USACO recently ordered Farmer John to arrange of n haybale piles on the farm The i th pile contains a i haybales However Farmer John has just left for vacation leaving Bessie all on her own Every day Bessie the naughty cow can choose to move one haybale in any pile to an adjacent pile Formally in one day she can choose any two indices i and j 1 le i j le n such that i j 1 and a i 0 and apply a i a i 1 a j a j 1 She may also decide to not do anything on some days because she is lazy Bessie wants to maximize the number of haybales in pile 1 i e to maximize a 1 and she only has d days to do so before Farmer John returns Help her find the maximum number of haybales that may be in pile 1 if she acts optimally ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "At any point it is optimal to move a haybale in the closest pile from pile to the left So for every day we can loop through the piles from left to right and move the first haybale we see closer If all the haybales are in pile at some point we can stop early Time Complexity "}
{"statement": "You are given a string s 1 dots n consisting of lowercase Latin letters It is guaranteed that n 2 k for some integer k ge 0 The string s 1 dots n is called if of the following three conditions is satisfied The length of s is 1 and it consists of the character c i e s 1 c The length of s is greater than 1 the first half of the string consists of only the character c i e s 1 s 2 dots s frac n 2 c and the second half of the string i e the string s frac n 2 1 s frac n 2 2 dots s n is a string The length of s is greater than 1 the second half of the string consists of only the character c i e s frac n 2 1 s frac n 2 2 dots s n c and the first half of the string i e the string s 1s 2 dots s frac n 2 is a string For example is is In one move you can choose one index i from 1 to n and replace s i with any lowercase Latin letter any character from to Your task is to find the minimum number of moves required to obtain an string from s i e for c It is guaranteed that the answer always exists You have to answer t independent test cases Another example of an string is as follows Consider the string s It is an string because the second half of the string consists of only the character the first half of the string is string because the second half of the string consists of only the character the first half of the string is string because the first half of the string consists of only the character the second half of the string is string ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Consider the problem in indexation Define the function which finds the minimum number of changes to make the string Let Then let and where is the number of occurrences of the character in We can see that describes the second condition from the statement and describes the third one So returns except one case When we need to return if and otherwise This function works in each element of belongs to exactly segments like segment tree You can get the answer if you run "}
{"statement": "There are n workers and m tasks The workers are numbered from 1 to n Each task i has a value a i the index of worker who is proficient in this task Every task should have a worker assigned to it If a worker is proficient in the task they complete it in 1 hour Otherwise it takes them 2 hours The workers work in parallel independently of each other Each worker can only work on one task at once Assign the workers to all tasks in such a way that the tasks are completed as early as possible The work starts at time 0 What s the minimum time all tasks can be completed by ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "The statement should instantly scream binary search at you Clearly if you can assign the workers in such a way that the tasks are completed by time you can complete them all by or more as well How to check if the tasks can be completed by some time What that means is that all workers have hours to work on some tasks If all tasks took hours to complete then each of them could complete of them Thus together they would be able to complete tasks How to incorporate the hour tasks into that Well we can redistribute the tasks in such a way that each worker first completes the tasks they are proficient in then some other tasks if they have more time So the general idea is the following Let each worker complete hour tasks where is the number of tasks the th worker is proficient in Then remember how many hour tasks they can complete which is Finally remember how many tasks that they are proficient in they didn t have time to complete which is If the sum of the number of incomplete tasks doesn t exceed the sum of the number of tasks they have time to complete then everything can be completed in time Worst case it can take up to hours to complete everything if you assign all tasks to a single worker and they are not proficient in any of them Overall complexity per testcase "}
{"statement": "You re given queries of the form For each query you have to find the number of such that and there exist integer numbers such that ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s fix some power It s obvious that there are no more than numbers such that does not exceed At the same time only for this amoung is relatively huge for all other the total amount of such numbers will be of the order of Let s then generate all of them and dispose of all perfect squares among them Then answer to query is equal to the amount of generated numbers between and plus some perfect squared in range The first value can be calculated via two binary searches The second one is Note that due to precision issues the standard might produce incorrect values so you can use additional binary searches instead "}
{"statement": "One day Petya got a birthday present from his mom a book called The Legends and Myths of Graph Theory From this book Petya learned about a graph A non oriented graph is a if it has a structure shown on the figure below Namely there are two nodes and connected by an edge they are the hydra s and correspondingly The chest is connected with nodes which are the hydra s The stomach is connected with nodes which are the hydra s Note that the hydra is a tree consisting of nodes Also Petya s got a non directed graph consisting of nodes and edges Petya got this graph as a last year birthday present from his mom Graph contains no self loops or multiple edges Now Petya wants to find a hydra in graph Or else to make sure that the graph doesn t have a hydra ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 1, "problem_dificulty": "2000", "problem_editorial": "You should check for every edge this one can be body of hydra or not Let s fix some edge u v order of vertices is important i e you should also check edge v u Now you should chose some set of h vertices connected with u and some set of t vertices connected with v These sets should not contain vertices u and v Also these two sets should have no common vertices If and there is no any hydra here Orherwise if or there is some hydra in any case Even if all vertices connected with u and with v are common number of them so big that you always can split them into groups of size h and size t The last case is and Here you can find all common vertices in O h t using array of flags When you find the common subset you can easy check existence of hydra "}
{"statement": "Valera the horse lives on a plane The Cartesian coordinate system is defined on this plane Also an infinite spiral is painted on the plane The spiral consists of segments and so on Thus this infinite spiral passes through each integer point of the plane Valera the horse lives on the plane at coordinates He wants to walk along the spiral to point Valera the horse has four legs so he finds turning very difficult Count how many times he will have to turn if he goes along a spiral from point to point ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Since constraints are small you can just simulate the whole process but I ll explain an solution Let s look at the path Now it s easy to see that the plane can be divided into four parts And then we can calculate answer for each part separately just be careful with borders For example for the right part the answer is Code "}
{"statement": "people are standing in a line to play table tennis At first the first two players in the line play a game Then the loser goes to the end of the line and the winner plays with the next person from the line and so on They play until someone wins games in a row This player becomes the winner For each of the participants you know the power to play table tennis and for all players these values are different In a game the player with greater power always wins Determine who will be the winner ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "It s not very difficult to solve this problem in The statement hints us that we can use the data structure We need to maintain the queue of players the current winner and the number of wins he has Each game is processed in It can be shown that number of games is less than Of course this solution is too slow Let s think what happens if is large More precisely assume that The winner need to win at least games in a row that is he need to win against all the other players Hence the winner is just the strongest player So if we can solve the problem in Otherwise simulation works in "}
{"statement": "There will be a launch of a new powerful and unusual collider very soon which located along a straight line particles will be launched inside it All of them are located in a straight line and there can not be two or more particles located in the same point The coordinates of the particles coincide with the distance in meters from the center of the collider is the coordinate of the th particle and its position in the collider at the same time All coordinates of particle positions are You know the direction of each particle movement it will move to the right or to the left after the collider s launch start All particles begin to move simultaneously at the time of the collider s launch start Each particle will move straight to the left or straight to the right with the constant speed of meter per microsecond The collider is big enough so particles can not leave it in the foreseeable time Write the program which finds the moment of the first collision of any two particles of the collider In other words find the number of microseconds before the first moment when any two particles are at the same point ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "To solve this problem it is enough to look at all pairs of adjacent particles such that the left particle will move to the right and the right particle will move to the left If there is no such pair the answer is Otherwise let s iterate through the particles from the left to the right If the particle will move to the right and the particle will move to the left we know that this particles will be at the same point simultaneously so we need to update the answer with value The answer is always integer because all coordinates of the particles are even numbers "}
{"statement": "You are participating in a Codeforces Round with n problems You spend exactly one minute to solve each problem the time it takes to submit a problem can be ignored You can only solve at most one problem at any time The contest starts at time 0 so you can make your first submission at any time t ge 1 minutes Whenever you submit a problem it is always accepted The scoring of the i th problem can be represented by three integers k i b i and a i If you solve it at time t minutes you get max b i k i cdot t a i points Your task is to choose an order to solve all these n problems to get the maximum possible score You can assume the contest is long enough to solve all problems ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "Since we can pre calculate the sum of Let Now our mission is to minimize the sum of If we assume for some sort these problems in descending order of then assign to their in order For they can be directly calculated There comes a DP solution Let be the minimum sum when considering first problems after sorting problems of them satisfying The time complexity is We can find that is convex Proof below Let Thus rewrite this formula with the original recursive formula Then Let be Subtract the above two formulas from each other Because is monotone non increasing so we can use mathematical induction to proof that for the increase speed of is faster than that of We can find a critical value that and So compared with the first part of the sequence remains unchanged and the last part is added with with an additional number in the middle where is the maximum number satisfied Use the treap to maintain this sequence which might be called the slope trick "}
{"statement": "This is a well known formula among Tattah s colleagues On a Wednesday afternoon Tattah was attending Professor HH s lecture At right before falling asleep he was staring at the digital watch around Saher s wrist He noticed that the digits on the clock were the same when read from both directions i e a palindrome In his sleep he started dreaming about such rare moments of the day when the time displayed on a digital clock is a palindrome As soon as he woke up he felt destined to write a program that finds the next such moment However he still hasn t mastered the skill of programming while sleeping so your task is to help him ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "In this problem it was required to find next palindrome on a digital clock Since the lowest unit of time used 1 minute and there are only 24 60 minutes in a day one could simply go through each minute starting from the time given in the input plus 1 minute until finding a palindrome If no palindrome is found till the end of the day 23 59 the output should then be 00 00 "}
{"statement": "Iahub does not like background stories so he ll tell you exactly what this problem asks you for You are given a matrix with rows and columns Initially all values of the matrix are zeros Both rows and columns are 1 based that is rows are numbered 1 2 and columns are numbered 1 2 Let s denote an element on the th row and th column as We will call a submatrix such elements for which two inequalities hold Write a program to perform two following operations Query print the xor sum of the elements of the submatrix Update each element from submatrix gets xor ed by value ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "The motivation of the problem is that x x 0 x x x x even times 0 Update per range query per element When dealing with complicated problems it s sometimes a good idea to try solving easier versions of them Suppose you can query only one element each time x0 x1 y0 y1 To update a submatrix x0 y0 x1 y1 I ll do following operations A x0 y0 val A x0 y1 1 val A x1 1 y0 val A x1 1 y1 1 val To query about an element X Y that element s value will be the xor sum of submatrix A 1 1 X Y Let s take an example I have a 6x6 matrix and I want to xor all elements from submatrix 2 2 3 4 with a value The below image should be explanatory how the method works Next by 1 1 X Y I ll denote xor sum for this submatrix White cells are not influenced by 2 2 3 4 matrix as matrix 1 1 X Y with X Y a white cell will never intersect it Red cells are from the submatrix the ones that need to be xor ed Note that for a red cell 1 1 X Y will contain the value we need to xor as it will contain 2 2 Next blue cells For this ones 1 1 X Y will contain the value we xor with despite they shouldn t have it This is why both 2 5 and 4 2 will be xor ed again by that value to cancel the xor of 2 2 Now it s okay every blue cell do not contain the xor value in their 1 1 X Y Finally the green cells These ones are intersection between the 2 blue rectangles This means in their 1 1 X Y the value we xor with appears 3 times this means it is contained 1 time For cancel this we xor 4 5 with the value Now for every green cell 1 1 X Y contains 4 equal values which cancel each other You need a data structure do to the following 2 operations Both operations can be supported by a Fenwick tree 2D If you don t know this data structure learn it and come back to this problem after you do this Coming back to our problem Now instead of finding an element I want xor sum of a submatrix You can note that xor sum of x0 y0 x1 y1 is 1 1 x1 y1 1 1 x0 1 y1 1 1 x1 y0 1 1 1 x0 1 y0 1 This is a classical problem the answer is 1 1 x1 y1 from which I exclude what is not in the matrix 1 1 x0 1 y1 and 1 1 x1 y0 1 Right now I excluded 1 1 x0 1 y0 1 2 times so I need to add it one more time How to get the xor sum of submatrix 1 1 X Y In brute force approach I d take all elements x y with 1 x X and 1 y Y and xor their values Recall the definition of the previous problem each element x y is the xor sum of A 1 1 x y So the answer is xor sum of all xor sums of A 1 1 x y with 1 x X and 1 y Y We can rewrite that long xor sum A number A x y appears in exactly X x 1 Y y 1 terms of xor sum If X x 1 Y y 1 is odd then the value A x y should be xor ed to the final result exactly once If X x 1 Y y 1 is even it should be ignored Below you ll find 4 pictures They are matrixes with X lines and Y columns Each picture represents a case X odd Y odd X even Y even X even Y odd X odd Y even Can you observe a nice pattern Elements colored represent those for which X x 1 Y y 1 is odd Yep that s right There are 4 cases diving the matrix into 4 disjoint areas When having a query of form 1 1 X Y you only need specific elements sharing same parity with X and Y This method works in O 4 logN logN for each operation and is the indented solution We keep 4 Fenwick trees 2D We made tests such as solutions having complexity greater than O 4 logN logN per operation to fail Here is our official solution 4383473 "}
{"statement": "To play the game Alice draws a straight line and marks n points on it indexed from 1 to n Initially there are no arcs between the points so they are all disjoint After that Alice performs m operations of the following type She picks three integers a i d i 1 le d i le 10 and k i She selects points a i a i d i a i 2d i a i 3d i ldots a i k i cdot d i and connects each pair of these points with arcs After performing all m operations she wants to know the number of connected components dagger these points form Please help her find this number dagger Two points are said to be in one connected component if there is a path between them via several possibly zero arcs and other points ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "The main idea is to take advantage of the low upper bound of and apply the Disjoint Set Union We will consider which denotes the number of ranges that contain the node in connection by the triplets ranges with as and is not and which denotes the node that represents an overall connected component of which node is part of for now The size of both and is We will maintain two other arrays and which store the number of triplets with as and respectively and with as to help us maintain the beginning and end of ranges We will now apply Disjoint Set Union For each th triplet we assume will be the parent node of the Set created by The transitions of are as follows 1 if max of for all are the same as just with some possible changes These changes are due to being the start or the end of some triplet with as So let us start with as If is non zero then perform a union operation of DSU between the node and increment by and assign as This unites the ranges over the node 2 if max of we do the same as above rather than doing for all we would restrict ourselves with from to The net time complexity updation of value by and union operations due to union of with over all incrementing values by copying values in worst case "}
{"statement": "You have n rectangular wooden blocks which are numbered from 1 to n The i th block is 1 unit high and lceil frac i 2 rceil units long Here lceil frac x 2 rceil denotes the result of division of x by 2 rounded For example lceil frac 4 2 rceil 2 and lceil frac 5 2 rceil lceil 2 5 rceil 3 For example if n 5 then the blocks have the following sizes 1 times 1 1 times 1 1 times 2 1 times 2 1 times 3 Find the maximum possible side length of a square you can create using these blocks Note that you don t have to use all of the blocks ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "SolutionIf is odd let be the width of the last block It is possible to create a square of side length using every block as follows Line contains a block Line contains a block and a block Line contains a block and a block Line contains a block and a block Line contains a block and a block Since the area of this square is and the th block has a width of tiles the total area of the first blocks is equal to Therefore the answer for is also In conclusion the answer for each testcase is Time complexity per testcase "}
{"statement": "There is a game called I Wanna Be the Guy consisting of levels Little X and his friend Little Y are addicted to the game Each of them wants to pass the whole game Little X can pass only levels of the game And Little Y can pass only levels of the game You are given the indices of levels Little X can pass and the indices of levels Little Y can pass Will Little X and Little Y pass the whole game if they cooperate each other ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "I Wanna Be the Guy is an interesting game I strongly recommend it to you The problem itself is easy Just check if all the levels could be passed by Little X or Little Y 7894174 "}
{"statement": "This morning Roman woke up and opened the browser with n opened tabs numbered from 1 to n There are two kinds of tabs those with the information required for the test and those with social network sites Roman decided that there are too many tabs open so he wants to close some of them He decided to accomplish this by closing every k th 2 leq k leq n 1 tab Only then he will decide whether he wants to study for the test or to chat on the social networks Formally Roman will choose one tab let its number be b and then close all tabs with numbers c b i cdot k that satisfy the following condition 1 leq c leq n and i is an integer it may be positive negative or zero For example if k 3 n 14 and Roman chooses b 8 then he will close tabs with numbers 2 5 8 11 and 14 After closing the tabs Roman will calculate the amount of remaining tabs with the information for the test let s denote it e and the amount of remaining social network tabs s Help Roman to calculate the maximal absolute value of the difference of those values e s so that it would be easy to decide what to do next ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "The constraints in this task allowed us to simply iterate over the closed tab and check the answer but we can solve it more quickly calculate the sum for each value modulo and count the total sum for the whole array After that you just need to go through the module tab numbers that we delete and update the answer Complexity or "}
{"statement": "You have a rectangular board of size n times m n rows m columns The n rows are numbered from 1 to n from top to bottom and the m columns are numbered from 1 to m from left to right The cell at the intersection of row i and column j contains the number i j i raised to the power of j For example if n 3 and m 3 the board is as follows Find the number of distinct integers written on the board ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "It is easy to see that the first row only contains the number and that this number doesn t appear anywhere else on the board We say that an integer is a if it can be represented as where and are positive integers and For each positive integer which is not a perfect power we call to the set of all numbers which appear in rows Claim If are not perfect powers then and have no elements in common Proof Suppose there is a common element then there exist positive integers such that This is the same as Because is not a perfect power has to be a positive integer If then which cannot happen So then which cannot happen as is not a perfect power Thus this common element cannot exist Based on the observation above for each not perfect power we can compute the size of independently and then sum the results For a fixed let be the number of rows that start with a power of Then contains all numbers of the form where and But the size of this set is the same as the size of the set containing all numbers of the form where and Note that the number of elements in this set does not depend on it just depends on Thus the size of is uniquely determined by the value of As then we have that Then for each we just need to compute the number of distinct elements of the form where and We can do this using an array of length and at the th step for we mark the numbers as visited in the array and add one to the value we are computing for each number that was not visited before After the th step we have computed this value for So to solve the problem it is enough to compute for each not perfect power how many rows in the matrix start with a power of and using the values we calculated in the last paragraph we can know how many distinct numbers are there in Intended complexity "}
{"statement": "Santa Claus has tangerines and the th of them consists of exactly slices Santa Claus came to a school which has pupils Santa decided to treat them with tangerines However there can be too few tangerines to present at least one tangerine to each pupil So Santa decided to divide tangerines into parts so that no one will be offended In order to do this he can divide a tangerine or any existing part into two smaller equal parts If the number of slices in the part he wants to split is odd then one of the resulting parts will have one slice more than the other It s forbidden to divide a part consisting of only one slice that also means that everyone must get a positive number of slices One or several tangerines or their parts may stay with Santa Let be the number of slices the th pupil has in the end Let Santa s be the minimum among all s Your task is to find the maximum possible Santa can have after he treats everyone with tangerines or their parts ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "It is obvious that if the total number of slices is less than k then the answer is 1 Otherwise it s at least 1 Let s find the answer in this case Let s divide tangerines and parts in halves one by one in order to find the best answer It s easy to see that it makes no sense to divide a part of size x if there is an undivided part of size y x So we are going to proceed dividing the largest part on each step Let s also maintain current answer i e the size of the k th biggest current part and a set of parts which we are going to present to the pupils When we divide the largest part there are two possible cases If the size of any part is less then the current answer then it s obvious that the answer will never be greater if we proceed further so we can stop the process If the sizes of both parts are greater than or equal to the current answer then we should delete the initial part and add the resulting parts to those we present to the pupils in the current answer and then delete the smallest part from the set making it of size k again We can see that in the second case the answer never decreases so we can just proceed until the first case happens To emulate this process in a fast way we can keep an array from 1 to A where A 107 is the maximum possible number of slices in a part where each cell contain the current number of parts of that size Thus we can maintain two pointers one to the current answer and one to the current maximum size so the whole process can be done in O n The overall complexity is O n A "}
{"statement": "You are given two arrays a and b each contains n integers You want to create a new array c as follows choose some real i e not necessarily integer number d and then for every i in 1 n let c i d cdot a i b i Your goal is to maximize the number of zeroes in array c What is the largest possible answer if you choose d optimally ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "For each index let s try to find which we should use in order to make th element of equal to zero If then no matter which we choose So we should just ignore this index and add to the answer if Otherwise we should choose Let s calculate the required fraction for each index and among all fractions find one that fits most indices this can be done for example by storing all fractions in a The only thing that s left to analyze is how to compare the fractions because floating point numbers may be not precise enough Let s store each fraction as a pair of integers where is the numenator and is the denominator We should normalize each fraction as follows firstly we reduce it by finding the greatest common divisor of and and then dividing both numbers by this divisor Secondly we should ensure that numenator is non negative and if numenator is zero then denominator should also be non negative this can be achieved by multiplying both numbers by "}
{"statement": "Given a positive integer m we say that a sequence x 1 x 2 dots x n of positive integers is m cute if for every index i such that 2 le i le n it holds that x i x i 1 x i 2 dots x 1 r i for some positive integer r i satisfying 1 le r i le m You will be given q queries consisting of three positive integers a b and m For each query you must determine whether or not there exists an m cute sequence whose first term is a and whose last term is b If such a sequence exists you must additionally find an example of it ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "We will first deal with determining when the sequence doesn t exist To do this we place some bounds on the values of If we choose all values of the to be equal to then we can calculate that Reciprocally if we choose all to be equal to then we find All other values give something inbetween so we getTherefore if doesn t lie on any of the intervals for some value of then it is impossible for to be a term of an cute sequence starting at This can be checked naively in since there are this many relevant values of We can convince ourselves that all values in these intervals are feasible through some experimentation so we now turn to the more difficult problem of actually constructing a sequence First notice that we can rearrange the definition of the sequence as follows Now we can try to find a pattern We see that and in general it would seem that This is actually very easy to prove inductively using All coefficients double from one term to the next but we substract once so that coefficient becomes instead Now we can also find an explicit solution Write as where and consider the binary representation of Then choosing where works becauseAlternatively after getting the formula we can iterate on from to and greedily choose the values of to be as large as we can without exceeding This can be easily shown to work using that the coefficients are consecutive powers of two Both of these approaches can be implemented in per query Complexity "}
{"statement": "For the first place at the competition Alex won many arrays of integers and was assured that these arrays are very expensive After the award ceremony Alex decided to sell them There is a rule in arrays pawnshop you can sell array only if it can be compressed to a generator This generator takes four non negative numbers n m c s n and m must be positive s non negative and for c it must be true that 0 leq c m The array a of length n is created according to the following rules a 1 s bmod m here x bmod y denotes remainder of the division of x by y a i a i 1 c bmod m for all i such that 1 i le n For example if n 5 m 7 c 4 and s 10 then a 3 0 4 1 5 Price of such an array is the value of m in this generator Alex has a question how much money he can get for each of the arrays Please help him to understand for every array whether there exist four numbers n m c s that generate this array If yes then maximize m ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Handle the case of c 0 separately For this check whether for every i from 1 i n there holds an equality arr i arr i 1 or in other words all numbers are the same If this is true then the modulo can be arbitrarily large Otherwise if arr i arr i 1 holds for at least one i then c must equal zero but we already know that it s not the case so the answer is 1 Ok now c 0 and no two consecutive numbers coincide Note that x c modm is either x c or x m c So all positive differences between pairs of consecutive numbers must be the same as well as all negative differences Otherwise the answer is 1 If there is no positive difference or similarly if there is no negative difference then the modulo can be arbitrarily large Otherwise the modulo has to equal their sum c m c m After we find out m and c it only remains to check if they in fact generate our sequence "}
{"statement": "The last contest held on Johnny s favorite competitive programming platform has been received rather positively However Johnny s rating has dropped again He thinks that the presented tasks are lovely but don t show the truth about competitors skills The boy is now looking at the ratings of consecutive participants written in a binary system He thinks that the more such ratings differ the more unfair is that such people are next to each other He defines the difference between two numbers as the number of bit positions where one number has zero and another has one we suppose that numbers are padded with leading zeros to the same length For example the difference of 5 101 2 and 14 1110 2 equals to 3 since 0101 and 1110 differ in 3 positions Johnny defines the unfairness of the contest as the sum of such differences counted for neighboring participants Johnny has just sent you the rating sequence and wants you to find the unfairness of the competition You have noticed that you ve got a sequence of integers from 0 to n That s strange but the boy stubbornly says that everything is right So help him and find the desired unfairness for received numbers ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let us start by calculating the result for It can be quickly done by calculating the results for each bit separately and summing these up For th bit the result is equal to as this bit is different in and iff is a multiple of Summing these up we get that the result for is equal to How to compute the answer for arbitrary Let us denote as set bits in the binary representation of I claim that the answer is equal to the sum of answers for Why We can compute results for intervals We can notice that the result for interval where is a multiple of is equal to the answer for so we can just compute the results for intervals This allows us to compute the answer for arbitrary in just iterate over all bits and add if is set Equivalently we can just write down as the answer Final complexity is "}
{"statement": "You are given a directed graph of n vertices and m edges Vertices are numbered from 1 to n There is a token in vertex 1 The following actions are allowed Token movement To move the token from vertex u to vertex v if there is an edge u to v in the graph This action takes 1 second Graph transposition To transpose all the edges in the graph replace each edge u to v by an edge v to u This action takes increasingly more time k th transposition takes 2 k 1 seconds i e the first transposition takes 1 second the second one takes 2 seconds the third one takes 4 seconds and so on The goal is to move the token from vertex 1 to vertex n in the shortest possible time Print this time modulo 998 244 353 ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "Consider a sequence of actions that moves the token from vertex to vertex Let us say it has token movements and graph transpositions This sequence takes seconds Note that the optimal path does not visit any edge twice That means we need to consider only paths with Consider another sequence consisting of token movements and graph transpositions Let Note the following If then This is true because the difference between and does not exceed and This gives us the following if there is any sequence of actions with that moves the token from vertex to vertex then optimal path s is less than too Let us check this with the following algorithm and if it is so find the optimal sequence of actions We can now build a new graph that consists of copies of the original graph Reverse all the edges in every even graph copy For every vertex add new edge between th and th copies of vertex with weight for We can find optimal paths from the first copy of vertex to all the copies of vertex using Dijkstra algorithm Shortest of these paths would correspond to the answer movement along a copy of original edge denotes token movement movement along a new edge denotes graph transposition If the algorithm found no paths then the sequence of actions that moves the token to from vertex 1 to vertex consists of at least transpositions Note that if then It means that all sequences of actions can be compared using ordered vector lexicographically Let us build another graph consisting of copies of the original graph Reverse all the edges in the second copy of the graph Assign to weights of all of these edges For every vertex add two new edges between copies of from the first to the second copy and back Weights of both edges is Let us find optimal paths from the first copy of vertex to both copies of vertex using Dijkstra algorithm Let be the length of the shortest one New graph allows us to restore the optimal sequence of actions that moves the token from vertex to vertex that will take seconds "}
{"statement": "There are n points and a line x y k on a two dimensional plane The i th point is at x i y i All points have non negative coordinates and are strictly below the line Alternatively 0 leq x i y i x i y i k Tenzing wants to erase all the points He can perform the following two operations Draw triangle Tenzing will choose two non negative integers a b that satisfy a b k then all points inside the triangle formed by lines x a y b and x y k will be erased It can be shown that this triangle is an isosceles right triangle Let the side lengths of the triangle be l l and sqrt 2 l respectively Then the cost of this operation is l cdot A The blue area of the following picture describes the triangle with a 1 b 1 with cost 1 cdot A Erase a specific point Tenzing will choose an integer i that satisfies 1 leq i leq n and erase the point i The cost of this operation is c i Help Tenzing find the minimum cost to erase all of the points ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "TutorialObserve that all triangles will be disjoint if two triangle were not disjoint we can merge them together to such that the cost used is less Therefore we can consider doing DP The oblique side of the triangle is a segment on the line Therefore we use the interval to represent the triangle with the upper left corner at and the lower right corner at First suppose that all points will generate costs After covering points with a triangle the costs can be reduced Let represent the sum of costs of points covered by triangle minus We need to find several intervals without common parts and maximize Let represent the maximum value of when considering the prefix There are two transitions If is not covered by any interval then If is covered by interval then Enumerate from small to large for maintain When will change as follows Subtract from For each point add the cost of the point to needs to support interval addition and global maximum value assuming that illegal positions are 0 which can be achieved using a segment tree Time complexity is "}
{"statement": "You are given a directed graph G which can contain loops edges from a vertex to itself Multi edges are absent in G which means that for all ordered pairs u v exists at most one edge from u to v Vertices are numbered from 1 to n A path from u to v is a sequence of edges such that vertex u is the start of the first edge in the path vertex v is the end of the last edge in the path for all pairs of adjacent edges next edge starts at the vertex that the previous edge ends on We will assume that the empty sequence of edges is a path from u to u For each vertex v output one of four values 0 if there are no paths from 1 to v 1 if there is only one path from 1 to v 2 if there is more than one path from 1 to v and the number of paths is finite 1 if the number of paths from 1 to v is infinite Let s look at the example shown in the figure Then the answer for vertex 1 is 1 there is only one path from 1 to 1 path with length 0 the answer for vertex 2 is 0 there are no paths from 1 to 2 the answer for vertex 3 is 1 there is only one path from 1 to 3 it is the edge 1 3 the answer for vertex 4 is 2 there are more than one paths from 1 to 4 and the number of paths are finite two paths 1 3 3 4 and 1 4 the answer for vertex 5 is 1 the number of paths from 1 to 5 is infinite the loop can be used in a path many times the answer for vertex 6 is 1 the number of paths from 1 to 6 is infinite the loop can be used in a path many times ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "The first motivation for solving this problem is to write a lot of standard code like find strongly connected components do some DP over the condensed graph the graph of strongly connected components and so on In fact this problem can be solved much more elegantly with less code if you have a little better understanding of how depth first search works Consider a usual depth first search on a digraph that is started from the vertex This will be a normal depth first search which will paint vertices using three colors white the vertex has not yet been found by the search gray the vertex is processing by DFS and black the vertex has already been processed by the DFS completely that is completely bypassed its subtree of the depth first search tree Here s the pseudocode The following statements are true there is a cycle in the digraph reachable from if and only if the root call visits in the line when moreover for each reachable cycle from there is at least one vertex that will execute the previous item then the vertex belongs to the cycle if the root call visits in the line when then there is more than one path the opposite is not true It is clear that there are infinite paths from to if and only if there is a vertex on some path from to such that is in a cycle Thus we mark all such vertices for which at the moment of execution of the line The fact is true A similar fact is also true for finding vertices to which at least two paths but a finite number lead Let s mark all such vertices for which at the moment of execution of the line The fact is true So the solution looks like this let s make a depth first search from the root mark during it those vertices that were gray when trying to go to them group A and were black when trying to go to them group B mark the vertices reachable from the group A let s call them AA mark the vertices reachable from the group B let s call them BB the answer for the vertex is if it is not reachable from this determines the first DFS if it is from AA if it is from BB but not from AA if it is not from AA and not from BB In the author s solution only one dfs function was used with an additional boolean parameter to determine its mode "}
{"statement": "An array a is called if it contains element which is equal to the If the array is not ugly it is For example the array 6 3 9 6 is ugly the element 9 is equal to 6 3 the array 5 5 7 is ugly the element 5 the second one is equal to 5 the array 8 4 10 14 is beautiful 8 ne 0 4 ne 8 10 ne 8 4 14 ne 8 4 10 so there is no element which is equal to the sum of all elements before it You are given an array a such that 1 le a 1 le a 2 le dots le a n le 100 You have to the elements of a in such a way that the resulting array is beautiful Note that you are not allowed to insert new elements or erase existing ones you can only change the order of elements of a You are allowed to keep the array a unchanged if it is beautiful ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "If we put the maximum in the array on the first position then for every element starting from the third one the sum of elements before it will be greater than it since that sum is greater than the maximum value in the array So the only element that can make our array ugly is the second element We need to make sure that it is not equal to the first element Let s put the maximum element on the first position the minimum element on the second position and then fill the rest of the array arbitrarily The only case when it fails is when the maximum element is equal to the minimum element and it s easy to see that if the maximum is equal to the minimum then the first element of the array will be equal to the second element no matter what and the array cannot become beautiful So the solution is to check if the maximum is different from the minimum and if it is so put them on the first two positions and the order of remaining elements does not matter Note that the given array is sorted so the minimum is the first element the maximum is the last element "}
{"statement": "You are organizing a boxing tournament where n boxers will participate n is a power of 2 and your friend is one of them All boxers have different strength from 1 to n and boxer i wins in the match against boxer j if and only if i is stronger than j The tournament will be organized as follows n boxers will be divided into pairs the loser in each pair leaves the tournament and frac n 2 winners advance to the next stage where they are divided into pairs again and the winners in all pairs advance to the next stage and so on until only one boxer remains who is declared the winner Your friend really wants to win the tournament but he may be not the strongest boxer To help your friend win the tournament you may bribe his opponents if your friend is fighting with a boxer you have bribed your friend wins even if his strength is lower Furthermore during each stage you distribute the boxers into pairs as you wish The boxer with strength i can be bribed if you pay him a i dollars What is the minimum number of dollars you have to spend to make your friend win the tournament provided that you arrange the boxers into pairs during each stage as you wish ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "If our friend is the strongest boxer he wins without any bribing Otherwise we have to bribe the strongest boxer and he can defeat some other boxers directly or indirectly Suppose we chose the boxers he will defeat then there is another strongest boxer If our friend is the strongest now we don t need to bribe anyone otherwise we will bribe the strongest remaining boxer again and he can defeat other boxers and so on The only thing that s unclear is which boxers should be defeated by the ones we bribe We may use dynamic programming to bribe them is the minimum cost to bribe boxers so that all boxers among strongest ones are either bribed or defeated by some bribed boxer For each value of we know the maximum amount of boxers that are defeated by bribed boxers so the transitions in this dynamic programming are the following if we can t defeat the next boxer for free our bribed boxers have already defeated as many opponents as they could we have to bribe him otherwise we either bribe him or consider him defeated by some other boxer Overall complexity is "}
{"statement": "All of us love treasures right That s why young Vasya is heading for a Treasure Island Treasure Island may be represented as a rectangular table n times m which is surrounded by the ocean Let us number rows of the field with consecutive integers from 1 to n from top to bottom and columns with consecutive integers from 1 to m from left to right Denote the cell in r th row and c th column as r c Some of the island cells contain impassable forests and some cells are free and passable Treasure is hidden in cell n m Vasya got off the ship in cell 1 1 Now he wants to reach the treasure He is hurrying up so he can move only from cell to the cell in next row downwards or next column rightwards i e from cell x y he can move only to cells x 1 y and x y 1 Of course Vasya can t move through cells with impassable forests Evil Witch is aware of Vasya s journey and she is going to prevent him from reaching the treasure Before Vasya s first move she is able to grow using her evil magic impassable forests in previously free cells Witch is able to grow a forest in any number of any free cells except cells 1 1 where Vasya got off his ship and n m where the treasure is hidden Help Evil Witch by finding out the minimum number of cells she has to turn into impassable forests so that Vasya is no longer able to reach the treasure ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "The answer is no more than two as we can block and If there is no way from to the answer is zero The only thing to do is to distinguish and If answer is one there must exist such cell that each path from to goes through that cell Also we can notice that in each path the cell goes on the place Let s run to obtain the set of cells which are accessible from and backwards to obtain the set on cells such that is accessible from them Let s intersect these sets and group cells by the distance from If some group has a single cell that would be the cell to block and the answer is one If each group has more than one cell the answer is two "}
{"statement": "You are given an array a of length n and an array b of length n The of a segment l r 1 le l le r le n is defined as b l a r b r a l Recall that two segments l 1 r 1 1 le l 1 le r 1 le n and l 2 r 2 1 le l 2 le r 2 le n are non intersecting if one of the following conditions is satisfied r 1 l 2 or r 2 l 1 The length of a segment l r 1 le l le r le n is defined as r l 1 Find the maximum possible sum of costs of non intersecting segments l j r j 1 le l j le r j le n whose total length is equal to k ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "TutorialLet s call the value of a segment Let s write maximum value of segments of total length that end before The obvious way to recalc is the following This works in and is too slow Now let s consider the following instead of getting the absolute value of segment we consider the maximum of the following four combinations We can see that this always gives us the correct answer to the absolute value since we check all of the possibilities Now we can look at out dp states as a table and notice that we recalc over the diagonal we recalc over all states that have the same value of n1 k1 Now for each diagonal we maintain four maximum combinations and when we want to recalc state we just consider all of the four possibilities "}
{"statement": "You are given two strings of equal length s and t consisting of lowercase Latin letters You may perform any number possibly zero operations on these strings During each operation you choose two characters in string and assign the value of the first character to the value of the second or vice versa For example if s is you can get the following strings in operation if you perform s 2 s 1 if you perform s 1 s 2 if you perform s 3 s 2 or s 3 s 4 if you perform s 2 s 3 if you perform s 4 s 3 Note that you can also apply this operation to the string t Please determine whether it is possible to transform s into t applying the operation above any number of times Note that you have to answer q independent queries ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "If there is a character which is contained in string s and t let s denote it as c then we answer is YES because we can turn these string into string consisting only of this character c Otherwise the answer is NO because if initially strings have not a common character then after performing operation they also have not a common character "}
{"statement": "You are a coach at your local university There are n students under your supervision the programming skill of the i th student is a i You have to form k teams for yet another new programming competition As you know the more students are involved in competition the more probable the victory of your university is So you have to form no more than k and at least one teams so that the number of students in them is maximized But you also know that team should be It means that the programming skill of each pair of students in team should differ by no more than 5 Teams are independent from one another it means that the difference between programming skills of two students from two different teams does not matter It is possible that some students not be included in any team at all Your task is to report the maximum possible number of students in no more than k and at least one teams ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Firstly let s sort all students in order of non decreasing their programming skill Then let s calculate the following dynamic programming is the maximum number of students in at most non empty teams if we consider first students How to do transitions from The first transition is pretty intuitive just skip the th indexed student Then we can set The second possible transition is to take some team starting from the th student The only assumption we need to do it is the following take the maximum by number of students team starting from the th student is always optimally Why it is so If we consider the student with the maximum programming skill in the team we can take him to this team instad of forming the new team with this student because this is always not worse So the second transition is the following let be the number of students in a team if the th student is the first in it We can calculate this part in naively or in using two pointers We can set Time complexity "}
{"statement": "There is the following puzzle popular among nuclear physicists A reactor contains a set of atoms of some chemical elements We shall understand the phrase atomic number as the number of this atom s element in the periodic table of the chemical elements You are allowed to take any two different atoms and fuse a new one from them That results in a new atom whose number is equal to the sum of the numbers of original atoms The fusion operation can be performed several times The aim is getting a new pregiven set of atoms The puzzle s difficulty is that it is only allowed to fuse two atoms into one it is not allowed to split an atom into several atoms You are suggested to try to solve the puzzle ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "At first you can use some search engine for find periodic table in some printable form Next use copy paste one or several times and format it by deleting all excess It is mechanical work for no more than 5 minutes Also some parser may be written Note than author s solution does not mean write 100 symbols by hand from a picture Next build some functions which transform symbols into numbers and vice versa So we have some set of numbers We need summarize some from them and get some another set of numbers We will use dymanic programming over subsets Compute the first dp dp1 mask sum For each subset calculate sum of numbers of all atoms in this subset It can be done in O 2nn Now compute the second dp dp2 mask length The length is a length of some prefix of result sequence of atoms which can be obtained by subset mask If length 1 it means that it is impossible to get any prefix from this subset The second dp we can calculate in O 3n Iterate over all masks and if dp2 mask 1 iterate all its subsets of remained atoms invert mask and get all its submasks If some subset has sum of numbers which equals number of dp2 1 th atom from result set recalculate dp2 mask XOR submask dp2 mask 1 At end if dp2 2n 1 k there are solution "}
{"statement": "You are given a multiset S Initially S 1 2 3 ldots n You will perform the following operation n 1 times Choose the largest number S text max in S and the smallest number S text min in S Remove the two numbers from S and add S text max S text min into S It s easy to show that there will be exactly one number left after n 1 operations Output that number ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "TutorialAssume that the moment before the th operation but after th the first time we have Let s divide the operation into two part before and equal or after Still at the moment just before the th operation let us sort the elements in the multiset in non decreasing order We will show that the answer is ProofThis lemma is based on the fact that after each operation which is after th to will not change is removed and turn to Which also means always holds At the very beginning obviously holds And we can observe that either or When the new after two operations is equal to the old When the new after two operations is equal to the old minus one So if we write the as an array by time order always holds Thus always holds Let be the value in the th operation Let s prove that before the th operation where ProofWe prove this by Mathematical induction One fact should be known that during these operations always holds for the th operation since For it is true because and Assume for it is true Still use the fact that or The necessary and sufficient condition for is all the numbers greater or equal to is used How many numbers are there We have numbers from the original multiset and some numbers that occurs during the operations which are the number of satisfying Thus is equivalent to Note that is always increasing which means that formula holds for but does not hold for The first equation always holds Because and ofcourse Let s do the research when the second equation does not hold Let and Note that since The topic we are going to research is when hold which also means Then let s focus on if when will hold It s easy to find when holds And since we can tell Thus we proved the topic for all before the th operation Then by solve we can get Now let s prove for also holds ProofUsing the similar idea as lemma 2 find out when holds However at this time only will contribute since for those according to lemma 1 they become the minimal one and do not contribute to anything Similarly that is Seems to be different this time but actually they are the same because holds the proving is easy leave it as a exercise This condition holds means that we can use the same method in lemma 2 to prove it Till now the lemmas told us the solving the problem is actually solving something like We can divide them into positive part and negtive part and then solving where range from some to and is a irrational constant Since is not very large we can approximate by where are integers and turn it into a traditional task Maybe it is called floor sum or something like I m not sure about the algorithm s english name The marvelous jiangly told me in long long range is enough But the tester used int128 We can dig more about the Let sorted before the th operation and what we care is We can find that array is actually a consecutive substring of fibonacci string More over let be the starting point of array in the fibonacci string when the initial size is we have the conclusion for where represents a list of numbers Now the only left problem is to find the prefix sum of fibonacci string of even positions or of odd positions This is quite a simple task by using any or solution "}
{"statement": "The new nation consists of n cities and some roads between them JYP has given some restrictions To guarantee efficiency while avoiding chaos The logo of rivaling companies should not appear in the plan that is 4 A B C D JYP has given criteria for your diagram For two cities A B let dis A B be the smallest number of roads you have to go through to get from A to B If it is not possible to walk from A to B dis A B 614n Then the efficiency value is defined to be the sum of dis A B for all ordered pairs of distinct cities A B You have drawn a design diagram that satisfies JYP s restrictions Find the sum of dis A B over all ordered pairs of cities A B with A neq B ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3500", "problem_editorial": "The solution contains several tricky observations but its not hard to prove each of them seperately so I will mention only the key points of the solution and proof Firstly we should repeatedly remove points that have no in degree We can calculate their contribution easily For a node define to be the set of nodes that exists has no cycles for any node Let s pick to be the node with maximum in degree Let and let where is the set of all vertices There exist nodes such that exists Let and let For all nodes exists has no cycles has no cycles has no cycles has no cycles That means we have partitioned the graph into two sets of nodes where each set is completely ordered Lets label the nodes in by where is an integer from to such that for two nodes and exists iff Label nodes in by in similar manner Define to be the set of nodes that exists Define to be the set of nodes that exists If then If then iff iff and iff and iff iff and iff and Finally we can count the answer in by the above observations "}
{"statement": "Touko s favorite sequence of numbers is a permutation a 1 a 2 dots a n of 1 2 dots n and she wants some collection of permutations that are similar to her favorite permutation She has a collection of q intervals of the form l i r i with 1 le l i le r i le n To create permutations that are similar to her favorite permutation she coined the following definition A permutation b 1 b 2 dots b n allows an interval l r to if for any pair of integers x y such that l le x y le r we have b x b y if and only if a x a y A permutation b 1 b 2 dots b n is if b allows all intervals l i r i for all 1 le i le k to hold their shapes Yuu wants to figure out all k similar permutations for Touko but it turns out this is a very hard task instead Yuu will the set of all k similar permutations with directed acylic graphs DAG Yuu also coined the following definitions for herself A permutation b 1 b 2 dots b n a DAG G if for all edge u to v in G we must have b u b v A is a DAG G k on the set of vertices 1 2 dots n such that a permutation b 1 b 2 dots b n satisfies G k if and only if b is k similar Since Yuu is free today she wants to figure out the minimum number of edges among all k encodings for each k from 1 to q ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "We will first solve the problem for similar permutations only Let s transform each of the ranges into edges on a DAG we call for all ranges for all pairs of indices such that we add an edge from to We can easily see a permutation is similar iff it satisfies Now our task is to remove edges from such that the number of permutations that satisfy it stays the same We can remove an edge if and only if there is a path from to with length If there exists a path of length between then we can remove the edge without having to worry about losing dependency between and On the other hand if there doesn t exist such a path then the only path connecting and is via the edge itself removing that edge removes any dependency between and When that is the case we can easily create a permutation such that then we simply swap and to gain a permutation that does not satisfy the original DAG Let s return to our problem For any element we consider the edges connecting such that a of we define a of in a similar manner There is at most one right edge of Suppose there are two right edges of namely and suppose Because of our range construction there must be a range that covers both and This range must covers too therefore there is a path between and therefore we can remove either or Therefore there is at most one right edge We can actually find this right edge suppose is a range such that and is as large as possible Then is the index between and such that and is as small as possible We can prove similar results with the left edge of denoted as However there will be cases when is actually not needed I will call this phenomenon What is the condition for to be hidden That s when there s a path from to with length Suppose this path is in the format We can prove that if then that implies but which means the right edge of is instead Because we can take the range such that is as small as possible and check if there exists an index such that That concludes the solution for finding the optimal encoding for permutations To recap Find left and right edges of all Check if the left right edges of all are hidden If they are remove them from the answer Let s return to the original problem For each range instead of adding an edge for every to let s only add an edge between and such that and are adjacent values in the range This doesn t change our answer because of lemma 1 Let s call these edges Surprisingly all of our previous observations hold but this time on the set of candidate edges Namely At any query there is at most one right edge which is one of the candidate edges The right edge must satisfy that and is the smallest such value in the range where is the range covering with the largest is hidden if there exists a candidate edge such that and where is the range covering with the smallest We call this edge the of the edge All of the above points holds for the left edge Let s organize the candidate edges for any edge if label as a of else label as a of Let s sort the right candidate edges of by increasing and sort the left candidate edges of by decreasing The values of the right end of the right candidate edges are decreasing i e if the right candidate edges of are such that then Similarly if we sort the left candidate edges of by decreasing index then the values of the left end of these candidate edges are decreasing Using this observation we can prove that if the destroyer of is and the destroyer of is then or we can also prove a similar result with the destroyers of left candidate edges Therefore we can use two pointers to figure out the destroyer for each left and right candidate edge of For each right candidate edge let s see when this candidate edge is used in the optimal encoding The candidate edge is first activated when there exists a range covering We call this timestamp The candidate edge is hidden when there exists a range covering where is the destroyer of We call this timestamp The candidate edge is deactivated when there exists a range covering where is the right candidate edge after We call this timestamp For each candidate edge we can find these timestamps using a Fenwick tree With these three timestamps we can figure out the range of time where each candidate edge is used which is and modify the answer accordingly Finally let s find out how many candidate edges there are The number of candidate edges is Suppose for a range we maintain edges such that and the values and are adjacent in the range When we add subtract one of the ends by 1 i e when we consider the amount of edges that are modified between and is for example if we add another element then we remove at most 1 old edge and add at most 2 new edges similarly when removing an element we remove at most 2 old edges and add at most 1 new edge Therefore consider Mo s algorithm on the given collection of ranges each candidate edge must appear during the process of iterating over the ranges and the number of modification is therefore the number of candidate edges is That concludes the solution to the full problem To recap Find all candidate edges Find the destroyer of all candidate edges Find the range of timestamps where each candidate edge is used The complexity is In particular your set candidate edges does not have to be exactly the edges connecting consecutive values between ranges these candidate edges only need to satisfy 3 conditions All edges that are included in some optimal encoding must be present in the set of candidate edges The observation is not violated i e if we sort the left right candidate edges of any node by the other endpoint then the value at the other endpoint must be sorted as well The number of candidate edges must not be too large at about edges This is to loosen up the process of generating the candidate edges since the naive Mo and set of values approach is incredibly expensive My edge generating approach involves using Mo with rollback to only allow deletion of values so I can maintain the sorted values with a linked list and I also do not delete intermediary edges while iterating one range to another "}
{"statement": "On the planet Mars a year lasts exactly days there are no leap years on Mars But Martians have the same weeks as earthlings 5 work days and then 2 days off Your task is to determine the minimum possible and the maximum possible number of days off per year on Mars ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "There are many ways to solve this problem Let s talk about one of them At first we need to write a function which takes the start day of the year and calculate the number of days off in such year To make it let s iterate on the days of the year and will check every day is it day off or no It is easy to show that if the first day of the year equals to the first day of the week i e this day is Monday in this year will be minimum possible number of the days off If the first day of the year equals to the first day off of the week i e this day is Saturday in this year will be maximum possible number of the days off "}
{"statement": "Utkarsh is forced to play yet another one of Ashish s games The game progresses turn by turn and as usual Ashish moves Consider the 2D plane There is a token which is initially at In one move a player must increase either the x coordinate or the y coordinate of the token by k In doing so the player must ensure that the token stays within a Euclidean distance d from 0 0 In other words if after a move the coordinates of the token are p q then p 2 q 2 leq d 2 must hold The game ends when a player is unable to make a move It can be shown that the game will end in a finite number of moves If both players play optimally determine who will win ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let be the maximum integer such that the point is within the circle If the point is also within the circle player 1 wins Otherwise player 2 wins Regardless of what move player 1 makes player 2 can force the token to be at some point on the line at the end of his turn if player 1 moves up player 2 can move right and vice versa Case 1 lies outside the circlePlayer 2 can guarantee his victory in this fashion as player 1 will not have any moves left after reaching the point Player 2 wins Case 2 lies within the circleAfter player 1 makes his first move player 2 finds himself in the same situation as player 1 did in the previous case That is player 1 can ensure that they reach either or in the same way Points and do not lie within the circle as by definition Thus player 2 will not have any moves left and player 1 wins "}
{"statement": "A string consisting of only characters p q and w is painted on a glass window of a store Ship walks past the store standing directly in front of the glass window and observes string a Ship then heads inside the store looks directly at the same glass window and observes string b Ship gives you string a Your job is to find and output b ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Problem Credits Lilypad Analysis Lilypad macaquedev Solution The letters she reads that comprise string are just the letters that comprise string flipped left to right This means that p becomes q q becomes p and w stays w since it is vertically symmetrical The order in which the letters are read is also reversed because what used to be the left side of string gets flipped over to the right side of string and vice versa We now have an algorithm for constructing string which is to iterate from right to left on string outputting p when there is a q q when there is a p and w when there is a w "}
{"statement": "IT City company developing computer games invented a new way to reward its employees After a new game release users start buying it actively and the company tracks the number of sales with precision to each transaction Every time when the next number of sales is divisible by all numbers from to every developer of this game gets a small bonus A game designer Petya knows that the company is just about to release a new game that was partly developed by him On the basis of his experience he predicts that people will buy the game during the first month Now Petya wants to determine how many times he will get the bonus Help him to know it ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s factorize numbers from 2 to 10 2 2 3 3 4 22 5 5 6 2 3 7 7 8 23 9 32 10 2 5 If a number is divisible by all numbers from 2 to 10 its factorization should contain 2 at least in the power of 3 3 at least in the power of 2 5 and 7 at least in the power of 1 So it can be written as x 23 32 5 7 x 2520 So any number divisible by 2520 is divisible by all numbers from 2 to 10 There are numbers from 1 to n divisible by all numbers from 2 to 10 In a programming language it is usually implemented as simple integer division "}
{"statement": "The guys lined up in a queue of n people starting with person number i 1 to ask Serafim the Owl about the meaning of life Unfortunately Kirill was very busy writing the legend for this problem so he arrived a little later and stood at the end of the line after the n th person Kirill is completely dissatisfied with this situation so he decided to bribe some people ahead of him For the i th person in the queue Kirill knows two values a i and b i If at the moment Kirill is standing at position i then he can choose any position j such that j i and exchange places with the person at position j In this case Kirill will have to pay him a j coins And for each k such that j k i Kirill will have to pay b k coins to the person at position k Kirill can perform this action any number of times Kirill is thrifty so he wants to spend as few coins as possible but he doesn t want to wait too long so Kirill believes he should be among the first m people in line Help Kirill determine the minimum number of coins he will have to spend in order to not wait too long ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s consider a greedy approach Suppose we are standing at position Find the first such that and If such exists and then swap with This will be optimal because in any case we will have to pay the people at positions some amount of coins and in this way we will pay each person at position where coins According to the greedy condition so is the minimum amount of coins we can pay th person We will also pay the th person coins hence we will pay the minimum amount of coins to all people If such does not exist then it is advantageous for us to choose the final position such that in order to finish the movements and overpay as little as possible Simply check each recalculating the answer using prefix sums on array and choose the smallest one Asymptotics "}
{"statement": "You are given two integers n and k You are also given an array of integers a 1 a 2 ldots a n of size n It is known that for all 1 leq i leq n 1 leq a i leq k Define a two dimensional array b of size n times n as follows b i j min a i a j Represent array b as a square where the upper left cell is b 1 1 rows are numbered from top to bottom from 1 to n and columns are numbered from left to right from 1 to n Let the color of a cell be the number written in it for a cell with coordinates i j this is b i j For each color from 1 to k find the smallest rectangle in the array b containing all cells of this color Output the sum of width and height of this rectangle ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "TutorialLet s fix the color for which we will calculate the answer If there is no then there will be no cells of color and the answer is Otherwise there is at least one cell of color To find the minimum rectangle containing all cells of this color we need to find the topmost bottommost leftmost and rightmost cells of this color in the array Let s find the prefix in of the maximum length where all numbers are strictly less than Let the length of this prefix be Then in the first rows and columns of the array there will be no cells of color because for all these cells the formula will have a number from the prefix and all numbers on it are less than In the th row and th column there will be cells of color because Thus we have found the topmost and leftmost cells of color To find the bottom and right cells we need to find the longest suffix where all numbers are less than Now we need to learn how to quickly find prefixes and suffixes for all colors Notice that the prefix for color is not shorter than the prefix for color so all prefixes can be calculated in just one pass through the array similarly for suffixes "}
{"statement": "Polycarp plays Game 23 Initially he has a number n and his goal is to transform it to m In one move he can multiply n by 2 or multiply n by 3 He can perform any number of moves Print the number of moves needed to transform n to m Print if it is impossible to do so It is easy to prove that any way to transform n to m contains the same number of moves i e number of moves doesn t depend on the way of transformation ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "If is not divisible by then just print and stop the program Otherwise calculate denoting the required number of times to multiply It is easy to see that should be a product of zero or more s and of zero or more s i e for integers To find just use a loop to divide by while it is divisible by Similarly to find just use a loop to divide by while it is divisible by After the divisions the expected value of is If print Otherwise print the total number of the loop iterations "}
{"statement": "Let s define S x to be the sum of digits of number x written in decimal system For example S 5 5 S 10 1 S 322 7 We will call an integer x if S x 1 S x In each test you will be given one integer n Your task is to calculate the number of integers x such that 1 le x le n and x is interesting ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s think what properties do all interesting numbers have Well if a number does not end with we can say for sure that because the last digit will get increased What if the number ends with Then the last digit will become so no matter what happens to other digits we can say that will surely be less than So the problem asks us to count all numbers with the last digit equal to It is not hard to see that the answer is equal to This concludes the solution as we are now able to answer all testcases in resulting in total runtime "}
{"statement": "Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible There are watchmen on a plane the th watchman is located at point They need to arrange a plan but there are some difficulties on their way As you know Doctor Manhattan considers the distance between watchmen and to be Daniel as an ordinary person calculates the distance using the formula The success of the operation relies on the number of pairs such that the distance between watchman and watchmen calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel You were asked to compute the number of such pairs ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "When Manhattan distance equals to Euclidean distance So it is true only when or This means that to count the number of such pair we need to calculate number of points on each horizontal line and each vertical line We can do that easily with the use of std map TreeMap HashMap Dictionary or just by sorting all coordinates If we have points on one horizontal or vertical line they will add pairs to the result But if we have several points in one place we will count their pairs twice so we need to subtract from answer number of pairs of identical points which we can calculate with the same formula and using the same method of finding equal values as before If we use TreeMap sort then solution will run in and if unordered map HashMap then in "}
{"statement": "Alyona assembles an unusual square Jigsaw Puzzle She does so in n days in the following manner On the first day she starts by placing the central piece in the center of the table On each day after the first one she places a certain number of pieces around the central piece in clockwise order always finishing each square layer completely before starting a new one For example she places the first 14 pieces in the following order Alyona is happy if at the end of the day the assembled part of the puzzle does not have any started but unfinished layers Given the number of pieces she assembles on each day find the number of days Alyona is happy on ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Alyona is happy when there are no unfinished layers that is in front of her is a perfect square with odd side length Since the order of pieces is fixed it is enough to keep track of the total current size s of the puzzle and after each day check if the s is a perfect square of an odd number The easiest way to do that is to create an additional array containing 12 32 53 992 and check after each day whether s is in this array "}
{"statement": "A sequence of integers is called if its elements are arranged in blocks like in 3 3 3 4 1 1 Formally if two elements are equal everything in between must also be equal Let s define of a sequence as a minimum possible number of elements to change to get a nice sequence However if you change at least one element of value x to value y you must also change all other elements of value x into y as well For example for 3 3 1 3 2 1 2 it isn t allowed to change first 1 to 3 and second 1 to 2 You need to leave 1 s untouched or change them to the same value You are given a sequence of integers a 1 a 2 ldots a n and q updates Each update is of form i x change a i to x Updates are not independent the change stays for the future Print the difficulty of the initial sequence and of the sequence after every update ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3200", "problem_editorial": "To adjust the solution for many queries we need to create some sophisticated data structure E g we all know that mentioned above 1 on a segment is easily done with a segtree If we maintain for every value the corresponding set of occurrences it s easy to update mentioned above number of occurrences in the first position So what we need to do now We need to dynamically recalculate the sum of minimums and the set segments to calculate minimum can change quite much due to updates You probably also now that we can design a segtree which supports range increments and query minimum number of minimums on the segment In a similar way we can build a structure which returns minimum number of minimums the sum of largest stored counts between minimums Just maintain a few values in each node and do lazy propagation Complexity Code "}
{"statement": "Kazimir Kazimirovich is a Martian gardener He has a huge orchard of binary balanced apple trees Recently Casimir decided to get himself three capybaras The gardener even came up with their names and wrote them down on a piece of paper The name of each capybara is a non empty line consisting of letters and Denote the names of the capybaras by the lines a b and c Then Casimir wrote the nonempty lines a b and c in a row without spaces For example if the capybara s name was and then the string the gardener wrote down would look like The gardener remembered an interesting property either the string b is lexicographically not smaller than the strings a and c at the same time or the string b is lexicographically not greater than the strings a and c at the same time In other words either a le b and c le b are satisfied or b le a and b le c are satisfied or possibly both conditions simultaneously Here le denotes the lexicographic less than or equal to for strings Thus a le b means that the strings must either be equal or the string a must stand earlier in the dictionary than the string b For a more detailed explanation of this operation see Notes section Today the gardener looked at his notes and realized that he cannot recover the names because they are written without spaces He is no longer sure if he can recover the original strings a b and c so he wants to find any triplet of names that satisfy the above property ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "To solve this problem it was enough just to consider all options of splitting the string into three substrings and there are only ways to do it "}
{"statement": "A number is if it contains only digits 0 1 and 2 For example the following numbers are ternary 1022 11 21 2002 You are given a long ternary number x The first leftmost digit of x is guaranteed to be 2 the other digits of x can be 0 1 or 2 Let s define the ternary XOR operation odot of two ternary numbers a and b both of length n as a number c a odot b of length n where c i a i b i ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let s iterate from left to right over the digits of If the current digit is either or then we can set or correspondingly There are no better choices And if the current digit is then the optimal choise is to set and What happens after the first occurrence of Because of this choice is greater than even if all remaining digits in are So for each set and and print the answer The case without is even easier and in fact we handle it automatically "}
{"statement": "Major Ram is being chased by his arch enemy Raghav Ram must reach the top of the building to escape via helicopter The building however is on fire Ram must choose the optimal path to reach the top of the building to lose the minimum amount of health The building consists of n floors each with m rooms each Let i j represent the j th room on the i th floor Additionally there are k ladders installed The i th ladder allows Ram to travel from a i b i to c i d i but Ram also gains h i health points if he uses the ladder i If Ram is on the i th floor he can move either left or right Travelling across floors however is treacherous If Ram travels from i j to i k he loses j k cdot x i health points Ram enters the building at 1 1 while his helicopter is waiting at n m What is the minimum amount of health Ram loses if he takes the most optimal path Note this answer may be negative in which case he gains health Output if no matter what path Ram takes he cannot escape the clutches of Raghav ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "The building plan of the input consists of rooms which in the worst case is however most of these rooms are unimportant to us We can instead use a much reduced version of the building consisting of at most rooms both endpoints of each ladder as well as our starting and target rooms As every ladder connects a lower floor to a higher floor and is one directional we can process the rooms floor by floor from floor to floor On each floor let s sort all the rooms in non decreasing order Now we can use dynamic programming as well as the compression previously mentioned to calculate the minimum distance to get to all important rooms First we calculate the minimum cost to get to each room using a room on the same floor as an intermediate We can do this by iterating over the rooms on a floor twice once from left to right and then once from right to left Then for each room on the floor if it has a ladder going up from it we can update the value of the room where the ladder ends Our answer is the value of the target room This can be implemented in time per test case "}
{"statement": "You are given an undirected graph consisting of n vertices A number is written on each vertex the number on vertex i is a i Initially there are no edges in the graph You may add some edges to this graph but you have to pay for them The cost of adding an edge between vertices x and y is a x a y coins There are also m special offers each of them is denoted by three numbers x y and w and means that you can add an edge connecting vertices x and y and pay w coins for it You don t have to use special offers if there is a pair of vertices x and y that has a special offer associated with it you still may connect these two vertices paying a x a y coins for it What is the minimum number of coins you have to spend to make the graph connected Recall that a graph is connected if it s possible to get from any vertex to any other vertex using only the edges belonging to this graph ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1900", "problem_editorial": "Suppose we have found all the edges of the graph explicitly sorted them and start running Kruskal on the sorted list of edges Each time we add some edge to MST it is either a special edge given in the input or an edge which was generated with cost whichever costs less Let s try to analyze how can we find the cheapest edge of each type that connects two components For special edges we may just maintain the number of special edges we already added or skipped and when choosing a new edge we skip some more possibly zero special edges that don t connect anything until we find an edge that connects something And for the other type of edges we may find two components having minimum numbers on the vertices in those components as small as possible and just connect the minimum vertex in the first component with the minimum vertex in the second component We may simulate this by maintaining a data structure for example a multiset where for each component we will store the vertex having minimum in this component and pick two minimums from this set We also have to be able to check if two vertices are connected this can be done with DSU and merge two components But this solution can be made easier Every time we add a non special edge one of the ends of this edge is the vertex with minimum So we may just find this vertex generate all edges connecting this vertex to all other vertices merge this set of edges with the set of special edges and run any MST algorithm on the resulting set of edges If there are multiple minimums in the array then we may pick any of them because in Kruskal algorithm it doesn t matter which of the edges with equal costs we try to add first "}
{"statement": "The store sells n items the price of the i th item is p i The store s management is going to hold a promotion if a customer purchases at least x items y cheapest of them are free The management has not yet decided on the exact values of x and y Therefore they ask you to process q queries for the given values of x and y determine the maximum total value of items received for free if a customer makes Note that all queries are independent they don t affect the store s stock ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "First of all there is an answer with exactly items bought Suppose items worth were purchased Then by removing from this set the sum of the cheapest items in the set will change by which means the answer will not decrease The second fact that is necessary to solve the problem of the most expensive items should be chosen Otherwise one can remove the minimum price item from the set and add an item with a higher price it can always be found which means the answer will not decrease Using these two facts it is enough to sort the array and use prefix sums "}
{"statement": "You are a coach of a group consisting of n students The i th student has programming skill a i You want to divide them into teams in such a way that No two students i and j such that a i a j 1 belong to the same team i e skills of each pair of students in the same team have the difference strictly greater than 1 the number of teams is the minimum possible You have to answer q independent queries ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The answer is always or Why it is so Because if there is no such pair among all students that then we can take all students into one team Otherwise we can divide them into two teams by their programming skill parity "}
{"statement": "You are given a directed acyclic graph consisting of n vertices and m edges The vertices are numbered from 1 to n There are no multiple edges and self loops Let mathit in v be the number of incoming edges indegree and mathit out v be the number of outgoing edges outdegree of vertex v You are asked to remove some edges from the graph Let the new degrees be mathit in v and mathit out v You are only allowed to remove the edges if the following conditions hold for every vertex v mathit in v mathit in v or mathit in v mathit in v 0 mathit out v mathit out v or mathit out v mathit out v 0 Let s call a set of vertices S if for each pair of vertices v and u v neq u such that v in S and u in S there exists a path either from v to u or from u to v over the non removed edges What is the maximum possible size of a set S after you remove some edges from the graph and both indegrees and outdegrees of all vertices either decrease or remain equal to 0 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2000", "problem_editorial": "Let s solve the problem in reverse Imagine we have already removed some edges so that the conditions hold When is some set of vertices considered Since the graph is acyclic we can topologically sort the vertices in the set The vertices are reachable from each other so there exists a path from the th vertex in the set to the st vertex Thus there exists a path that goes through all chosen vertices However we can make this conclusion even stronger In the optimal answer not just the path goes from the th vertex to the st one but a single edge That can be shown by contradiction Let there be some vertices and that are adjacent in the chosen set There exists a path between them but not a single edge We want to show that this set is not optimal and can be made larger The vertices on that path don t belong to the set If they did they would be between and in the set because of the topological order We can add them to the set Every vertex that can reach can reach them too and every vertex that can be reached from can be reached from them Thus it will still be a set Now every vertex from to has an edge between them and the size of the set is larger Thus we showed that the maximum set in the answer is always some path in the graph So the task is to choose some path then remove some edges so that this path still exists and the conditions hold Note that if the conditions hold for some set of remaining edges then we can remove any edge from it and the conditions will still be met Thus we can only leave this path Let s look closer into the conditions What they actually tell is the following If a vertex has incoming edges then remove at least one of them The same for the outgoing edges Since we are looking for a path it s enough to leave one outgoing edge for all vertices except the last one and leave one incoming edge for all vertices except the first one In order to achieve that every vertex except the last one should have at least two outgoing edges and every vertex except the first one should have at least two incoming edges We can see that this condition is not only necessary but sufficient as well Just remove the outgoing edges which don t go to the next vertex and the incoming edges which don t go from the previous vertex Now we can wrap this up into the dynamic programming Initialize the answer with since you can always remove all edges and get a set with one vertex Then let be the longest path such that it starts in vertex all vertices in it have at least two incoming edges and all vertices except maybe the final one have at least two outgoing edges Initialize the for the vertices that can be the final in the path have at least two incoming edges with Then update for all that can be internal vertices have at least two outgoing and two incoming edges with for all outgoing edges Finally update the answer from the vertices that can be the first one in the path For each vertex that has at least two outgoing edges take the value of for all outgoing edges Overall complexity "}
{"statement": "I have an undirected graph consisting of nodes numbered 1 through Each node has at most two incident edges For each pair of nodes there is at most an edge connecting them No edge connects a node to itself I would like to create a new graph in such a way that The new graph consists of the same number of nodes and edges as the old graph The properties in the first paragraph still hold For each two nodes and if there is an edge connecting them in the old graph there is no edge connecting them in the new graph Help me construct the new graph or tell me if it is impossible ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "First I would like to apologize the missing node 3 in the picture of the first example It was a mistake Intended deterministic solution The deterministic solution is very tricky Therefore I made the pretest quite strong Some tricky cases Actually we can do brute force when n 6 but this requires a special handling when the largest component has 4 nodes we should swap the first node with the third node not the second This is to handle the 4 cycle and 3 cycle case Troll solution nondeterministic Do the following many times So the question is for large n what is the probability that a permutation is not bad This can be computed or at least approximated similar to computing derangement probability I obtained a result above 0 1 which means in 100 iterations it should succeed if there was a solution There is a solution if n 7 so it should work "}
{"statement": "Drazil and Varda are the earthworm couple They want to find a good place to bring up their children They found a good ground containing nature hole The hole contains many rooms some pairs of rooms are connected by small tunnels such that earthworm can move between them Let s consider rooms and small tunnels as the vertices and edges in a graph This graph is a In the other words any pair of vertices has an unique path between them Each room that is in the graph is connected with a ground by a vertical tunnel Here is a vertex that has only one outgoing edge in the graph Each room is large enough only to fit one earthworm living in it Earthworm can t live in a tunnel Drazil and Varda have a plan to educate their children They want all their children to do morning exercises immediately after getting up When the morning is coming all earthworm children get up in the same time then each of them chooses the path to the ground for gathering with others these children are lazy so they all want to do exercises as late as possible Drazil and Varda want the difference between the time first earthworm child arrives outside and the time the last earthworm child arrives outside to be not larger than otherwise children will spread around the ground and it will be hard to keep them exercising together Also The rooms that are occupied by their children should form a set In the other words for any two rooms that are occupied with earthworm children all rooms that lie on the path between them should be occupied with earthworm children too How many children Drazil and Varda may have at most in order to satisfy all conditions above Drazil and Varda want to know the answer for many different choices of Drazil and Varda don t live in the hole with their children ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "We can use dfs twice to get the farthest distance from each node to any leaves detail omitted here and denote the longest distance from the i th node to any leaves as di Then we choose a node with minimum value of di as the root We will find that for any node x dx isn t greater than dy for any node y in the subtree of node x Next we solve the problem when there s only one query of L In all valid groups of nodes where node x is the nearest to the root obviously we can choose all nodes with di dx L into the group Now we want to enumerate all nodes as the nearest node to the root We denote the group of nodes generated from node i as Gi We can do it in using dfs only once if the length of every edge is 1 we can do it in O n Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i but some nodes which are too far from node i are kicked out Each node will be kicked out from the groups we considered at most once in the whole process Now we want to know when it happens We solve it as follows When we do dfs we reserve a stack to record which nodes we have visited and still need to come back to Yes it s just like the implementation of recursive functions Then we can just use binary search to find the node in the stack that when we go back to it the current node will be kicked out the closest node with dx di L So the time complexity of the above algorithm is Now we provide another algorithm with O qn n nlog n by union find Thanks Shik for providing this method First sort all nodes by di Then for each query consider each node one by one from larger di s to smaller di s At the beginning set each node as a group of its own We also need to record how many nodes each group contains When handling a node x union all groups of itself and its children At the same time for each node j with dj dx L we minus 1 from the record of how many nodes j s group has By doing these we can get the number of nodes j in x s subtree with dj dx L That s exactly what we want to know in the last algorithm "}
{"statement": "Burenka came to kindergarden This kindergarten is quite strange so each kid there receives two fractions frac a b and frac c d with integer numerators and denominators Then children are commanded to play with their fractions Burenka is a clever kid so she noticed that when she claps once she can multiply numerator or denominator of one of her two fractions by any integer of her choice but she can t multiply denominators by 0 Now she wants know the minimal number of claps to make her fractions equal by Please help her and find the required number of claps ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "SolutionNote that we always can make fractions equal in two operations Multiply first fraction s enumerator by the first fraction is equal to Multiply second fraction s enumerator by the second fraction is equal to That means that the answer does not exceed 2 If fractions are equal from input the answer is 0 Otherwise it can t be 0 Now we have to check if the answer is 1 Let s assume that for making fractions equal in 1 operation we have to multiply first fraction s enumerator by Then must be true From this we can see that must be integer so must be divisible by If we assume that we multiplied first fraction s denumerator by we can do the same calculations and see that must be divisible by So for checking if the answer is we need to check if one of and is divisible by another one If we multiply second fraction s enumerator or denumerator by we will get the same conditions for answer being equla to 1 If the answer is not 0 or 1 it s 2 Complexity "}
{"statement": "Monocarp is playing a computer game yet again Guess what is he doing That s right killing monsters There are n monsters in a row numbered from 1 to n The i th monster has two parameters attack value equal to a i and defense value equal to d i In order to kill these monsters Monocarp put a berserk spell on them so they re attacking each other instead of Monocarp s character The fight consists of n rounds Every round the following happens first every alive monster i deals a i damage to the alive monster to the left if it exists and the alive monster to the right if it exists then every alive monster j which received more than d j damage dies I e the j th monster dies if and only if its defense value d j is than the total damage it received For each round calculate the number of monsters that will die during that round ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "It is important to note that if during the th round the th monster did not die and none of its alive neighbors died then there is no point in checking this monster in the th round Therefore we can solve the problem as follows let s maintain a list of candidates those who can die for the current round if the monster dies in the current round then add its neighbors to the list of candidates for the next round Since killing a monster adds no more than candidates the total size of the candidate lists for all rounds does not exceed since the size of the list for the first round is equal to plus no more than for each killed monster Therefore we can simply iterate through these lists to check if the monster will be killed The only problem left is finding the alive neighbors of the monster to check whether he is killed or not during the round This can be done by creating an ordered with the indices of the monsters allows us to remove the killed ones and find neighboring monsters in Thus the solution works in "}
{"statement": "You are given a tree a connected non oriented graph without cycles with vertices numbered from to and the length of the th edge is In the vertex there is a policeman in the vertices criminals are located The policeman can walk along the edges with speed the criminals can move with arbitrary large speed If a criminal at some moment is at the same point as the policeman he instantly gets caught by the policeman Determine the time needed for the policeman to catch all criminals assuming everybody behaves optimally i e the criminals maximize that time the policeman minimizes that time Everybody knows positions of everybody else at any moment of time ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2700", "problem_editorial": "Suppose that the policeman is moving from to via the tree edge The criminals can now assume any positions in two halves of the tree but cannot travel from one half to another Let be the resulting time to catch the criminals if the policeman have just started to travel along a directed edge there are criminals in total and of them are in the half tree in front of the policeman If the edge leads into a leaf of the tree then the policeman catches everyone in this leaf and his next step is to go back using the same edge Otherwise the criminals must have distributed optimally in the subtrees starting with edges The policeman cannot win within time if there is a distribution with such that for every The optimal value of can be found with binary search for a particular find the smallest such that and check if If this is the case the criminals can distribute so that it will take time to catch them The total complexity of this solution is since we have DP states with each state having transitions and the last factor corresponding to binary search on the answer assuming the answer is at most "}
{"statement": "You want to perform the combo on your opponent in one popular fighting game The combo is the string s consisting of n lowercase Latin letters To perform the combo you have to press all buttons in the order they appear in s I e if s then you have to press then and again You know that you will spend m wrong tries to perform the combo and during the i th try you will make a mistake right after p i th button 1 le p i n i e you will press first p i buttons right and start performing the combo from the beginning It is guaranteed that during the m 1 th try you press all buttons right and finally perform the combo I e if s m 2 and p 1 3 then the sequence of pressed buttons will be you re making a mistake and start performing the combo from the beginning you re making a mistake and start performing the combo from the beginning Your task is to calculate for each button letter the number of times you ll press it You have to answer t independent test cases ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "We can consider all tries independently During the th try we press first buttons so it makes on the prefix of length So the th character of the string will be pressed the number of plus times We can use sorting and some kind of binary search to find this number for each character but we also can build suffix sums to find all required numbers We can build suffix sums using the following code vector int cnt n for int i 0 i m i cnt p i for int i n 1 i 0 i cnt i 1 cnt i So as you can see the th element of will add in each position from to So we got what we need After that we can calculate the answer for each character in the following way vector int ans 26 for int i 0 i n i ans s i a cnt i 1 Time complexity or "}
{"statement": "You are given a permutation p of length n You are also given a string s of length n consisting only of the character For each i from 1 to n Define l i as the largest index j i such that p j p i If there is no such index l i i Define r i as the smallest index j i such that p j p i If there is no such index r i i Initially you have an undirected graph with n vertices numbered from 1 to n and no edges Then for each i from 1 to n add one edge to the graph If s i add the edge i l i to the graph If s i add the edge i r i to the graph If s i either add the edge i l i or the edge i r i to the graph at your choice Find the maximum possible diameter text over all graphs that you can form Output 1 if it is not possible to form any connected graphs text Let d s t denote the smallest number of edges on any path between s and t The diameter of the graph is defined as the maximum value of d s t over all pairs of vertices s and t ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "For simplicity let and let s recalculate the values of and Then the answer is not if for all and or Let store some set of pairs where for some valid graph is a possible depth of a path that starts at index and passes only through indices is a possible depth of a path that starts at index and passes only through indices The paths do not intersect We are only interested in the values of and where and for some Initialize Let s iterate over all in order of increasing For each and we will iterate over all pairs in and in If and we can add the edge so Update the answer with Add the pairs and to If and we can add the edge so Update the answer with Add the pairs and to Turns out it is enough to store at most three pairs for each Specifically it is enough to store One pair with the maximum possible One pair with the maximum possible One pair with the maximum possible If true this leads to an or solution albeit with a large constant factor We will proceed with a proof by induction it is enough to store the three pairs described above for with and only the pairs and are possible For some let and only store the three pairs described above First of all we update the answer with the same value When adding the left edge If the answer came from we maximize If the answer came from we maximize and When adding the right edge If the answer came from we maximize and If the answer came from we maximize Secondly will store the pairs with the same values of and as in the case when all pairs are stored on all previous stages When adding the left edge it is clearly not less optimal to add only the pair When maximizing we maximize which we do by maximizing or When maximizing we maximize When maximizing we maximize or which we do by induction When adding the right edge we can only add the pair When maximizing we maximize When maximizing we maximize which we do by maximizing or When maximizing we maximize or which we do by induction Thus we achieve the same answer by only storing these pairs which concludes our proof Complexity or Note there are a number of other possible solutions please refer to the comments below "}
{"statement": "Game studio DbZ Games wants to introduce another map in their popular game Valiant This time the map named Panvel will be based on the city of Mumbai Mumbai can be represented as n times m cellular grid Each cell i j 1 le i le n 1 le j le m of the grid is occupied by a cuboid building of height a i j This time DbZ Games want to make a map that has perfect vertical gameplay That s why they want to choose an l times l square inside Mumbai such that each building inside the square has a height of at least l Can you help DbZ Games find such a square of the maximum possible size l ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "The basic brute force solution for this problem was to just iterate through all the values of sides possible Note that the value of sides can range only from to as product of can t exceed so there can t be a cube having all sides greater than After setting side length let s say we look into all possible submatrices of dimensions and see if we can form a cube from any one of those This could only be possible if there exists a submatrix with its minimum Now we need to do all these operations efficiently looking at the constraints The main thing that we need to do is Binary search on the answer As obviously it is possible to make a cube with a smaller side if it is possible to make the one with the current side length For a particular side check for all submatrices of size if their minimum is greater than equal to If you find any such submatrix then this value of side is possible A minimum can be calculated in using sparse tree You might have tried using segment tree which takes time per query But it may not to pass with these constraints So the time complexity to solve this problem is It would pass these constraints Another solution where you don t use binary search is also there but would fail with these constraints The segment tree solution takes So only sparse tree can be used This is a much simpler solution First we create another matrix let s say Now for a particular side length we take all the indices where the building heights are greater than equal to and set the elements of at those indices to Other elements are set to Now we precalculate the prefix sum for this matrix Then for each index of the matrix we check if the square starting from that index has a prefix sum equal to If anyone of it does then this side length for the cube is possible Time Complexity is again "}
{"statement": "INTERCAL is the oldest of esoteric programming languages One of its many weird features is the method of character based output known as Turing Tape method It converts an array of unsigned 8 bit integers into a sequence of characters to print using the following method The integers of the array are processed one by one starting from the first Processing th element of the array is done in three steps 1 The 8 bit binary notation of the ASCII code of the previous printed character is reversed When the first element of the array is processed the result of this step is considered to be 0 2 The th element of the array is subtracted from the result of the previous step modulo 256 3 The binary notation of the result of the previous step is reversed again to produce ASCII code of the th character to be printed You are given the text printed using this method Restore the array used to produce this text ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "This was another implementation problem inspired by another great language INTERCAL Technically it was a bit more complicated than the previous one due to the usage of byte reversal and having to implement not the described procedure but its inverse For i th character of input data reverse it and store in rev i then i th number of the output can be calculated as rev i 1 rev i 256 256 for i 0 rev i 1 0 "}
{"statement": "Nauuo is a girl who loves traveling One day she went to a tree Old Driver Tree literally a tree with an old driver on it The tree is a connected graph consisting of n nodes and n 1 edges Each node has a color and Nauuo will visit the ODT through a simple path on the tree in the old driver s car Nauuo wants to visit see more different colors in her journey but she doesn t know which simple path she will be traveling on So she wants to calculate the sum of the numbers of different colors on all different paths Can you help her What s more the ODT is being redecorated so there will be m modifications each modification will change a single node s color Nauuo wants to know the answer after each modification too Note that in this problem we consider the simple path from u to v and the simple path from v to u as two different simple paths if and only if u ne v ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "TutorialFor each color we can try to maintain the number of simple paths that do not contain such color If we can maintain such information we can easily calculate the number of simple paths that contain a certain color thus get the answer For each color we delete all nodes that belong to such color thus splitting the tree into some clusters here we define a cluster as a connected subgraph of the original tree By maintaining we can get the number of simple paths that do not contain such color For each color we try to maintain the same information add them together and get the answer So now the problem is a white tree reverse the color of a node white black output This problem can be solved by many data structures like top tree link cut tree or heavy path decomposition Let s use the link cut tree for example You can maintain the size of each subtree and the sum of of each node s sons Link cut one node with its father choose a node as the root and make the tree a rooted tree first when its color changes In this way the real clusters are the ones that are still connected after deleting the top node of a cluster in the link cut tree Update while linking cutting link cut "}
{"statement": "Luba thinks about watering her garden The garden can be represented as a segment of length Luba has got buckets the th bucket allows her to water some continuous subsegment of garden of length each hour Luba has to choose of the buckets in order to water the garden as fast as possible as mentioned above each hour she will water some continuous subsegment of length if she chooses the th bucket Help her to determine the minimum number of hours she has to spend watering the garden It is guaranteed that Luba can always choose a bucket so it is possible water the garden See the examples for better understanding ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "In this problem we just need to find maximum divisor of that belongs to array Let s call it Then we need to print "}
{"statement": "Pasha loves his phone and also putting his hair up But the hair is now irrelevant Pasha has installed a new game to his phone The goal of the game is following There is a rectangular field consisting of row with pixels in each row Initially all the pixels are colored white In one move Pasha can choose any pixel and color it black In particular he can choose the pixel that is already black then after the boy s move the pixel does not change that is it remains black Pasha loses the game when a square consisting of black pixels is formed Pasha has made a plan of moves according to which he will paint pixels Each turn in his plan is represented as a pair of numbers and denoting respectively the row and the column of the pixel to be colored on the current move Determine whether Pasha loses if he acts in accordance with his plan and if he does on what move the square consisting of black pixels is formed ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "To solve this problem let s create matrix with type bool and dimensions n on m Cell x y of this matrix is true if this cell painted in black color Let on move number k Pasha paints pixel in position i j Then game ending on this move if square 2 2 formed from black cells appears and cell i j will upper left upper right bottom left or bottom right of this squares Only this squares we need to check on current move If we haven t such squares after k moves print 0 Asymptotic behavior of this solution O k where k number of moves "}
{"statement": "A string is called if it does not contain any characters other than and A bracket sequence is called if it it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example and are regular bracket sequences and are bracket sequences but not regular ones and and are not bracket sequences at all You have a number of strings each string is a bracket sequence of length 2 So overall you have cnt 1 strings cnt 2 strings cnt 3 strings and cnt 4 strings You want to write all these strings in some order one after another after that you will get a long bracket sequence of length 2 cnt 1 cnt 2 cnt 3 cnt 4 You wonder is it possible to choose some order of the strings you have such that you will get a regular bracket sequence ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "For bracket sequence to be regular it should have equal number of opening and closing brackets So if then it s impossible to construct any regular bracket sequence is completely irrelevant to us since inserting or removing a substring doesn t change the status of the string we get Almost the same applies to but we should have at least one substring before it So if but there is no solution In all other cases it is possible to order all strings as follows all strings then all strings then all strings then all strings "}
{"statement": "Today Mezo is playing a game Zoma a character in that game is initially at position x 0 Mezo starts sending n commands to Zoma There are two possible commands L Left sets the position x x 1 R Right sets the position x x 1 Unfortunately Mezo s controller malfunctions sometimes Some commands are sent successfully and some are ignored If the command is ignored then the position x doesn t change and Mezo simply proceeds to the next command For example if Mezo sends commands then here are some possible outcomes underlined commands are sent successfully Zoma moves to the left to the right to the left again and to the right for the final time ending up at position 0 Zoma recieves no commands doesn t move at all and ends up at position 0 as well Zoma moves to the left then to the left again and ends up in position 2 Mezo doesn t know which commands will be sent successfully beforehand Thus he wants to know how many different positions may Zoma end up at ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let and be the number of L s and R s in the string respectively Note that Zoma may end up at any integer point in the interval So the answer equals "}
{"statement": "Let s call an array b 1 b 2 ldots b m a if b 1 m 1 Let s call an array b 1 b 2 ldots b m a if the array b 2 b 3 ldots b m can be split into b 1 non empty subarrays so that each of these subarrays is a Note that each element of the array must be included in exactly one subarray and the subarrays must consist of consecutive elements Let s define the function f from the array b 1 b 2 ldots b m as the minimum number of operations of the form Replace any b i with any integer x which needs to be done so that the array b 1 b 2 ldots b m becomes a You are given an array of integers a 1 a 2 ldots a n For each i from 1 to n 1 find f a i a i 1 ldots a n Below are some examples of and underline 1 5 underline 2 2 2 underline 3 4 1 1 underline 5 0 0 0 0 0 underline 7 1 2 3 4 5 6 7 underline 0 These arrays are since their first element underlined is equal to the length of the array minus one 1 underline underline 1 1 2 underline underline 3 0 0 1 underline underline 1 12 3 underline underline 2 2 7 underline underline 1 1 underline underline 3 4 4 4 4 underline underline 0 underline underline 3 1 7 9 underline underline 4 2 0 0 9 underline underline 1 777 Underlined are the subarrays after the split and double underlined are the first elements of each subarray ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "The first idea you can make a multitest from any array using operations To do this replace the first element with and the second with where is the length of the array It remains to learn how to determine whether it is possible to make a multitest from an array for and for change First let s deal with the changes Question when is the array a multitest Answer when represents exactly of tests written in a row For convenience let s call the index good if represents a certain number of tests written in a row For all indexes we want to find out if they are good and if so how many tests the corresponding suffix consists of Denote The logic is that if is the first element of a certain test then is the first element of the next test Then the index will be good if the chain ends in To find out if this chain ends in and if so how many tests it consists of can be simple dynamic programming by suffixes In total to determine whether the suffix is a multitest in itself it is necessary to check that is good and its suffix consists of exactly tests Now it remains to determine whether it is possible to make a multitest for change If the array has become a multitest after the change then the element responsible for either the number of tests or the first element of some test has been changed Case one the number of tests changes Then the array can be made a multitest if and only if is a good index Case two the index after the change will become the first element of some test We will consider the maximum number of tests that can be achieved by changing one element as the dynamics of the suffix Then one change can make the suffix a multitest if the dynamics value from is greater than or equal to How to calculate this dynamics for The index being changed then must be one of otherwise the test chain of will remain the same and the change will not affect anything Then if changes then this change will be reflected in the dynamics value from through which it can be recalculated And if changes then you need to make a change so that is a good index after the change can become any index of after the change And of all these you need to choose a good index with the maximum number of tests This value can be maintained separately when recalculating the dynamics "}
{"statement": "Nothing is eternal in the world Kostya understood it on the 7 th of January when he saw partially dead four color garland Now he has a goal to replace dead light bulbs however he doesn t know how many light bulbs for each color are required It is guaranteed that for each of four colors at least one light is working It is known that the garland contains light bulbs of four colors red blue yellow and green The garland is made as follows if you take any four consecutive light bulbs then there will not be light bulbs with the same color among them For example the garland can look like but can not look like or Letters denote colors red blue yellow green Using the information that for each color at least one light bulb still works count the number of dead light bulbs of each four colors ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Four consecutive bulbs should not be of the same color and it is four possible colors so the color of the fifth bulb is the same as the first bulb has the color of the sixth is the same as the second bulb has it means that the color of the th bulb equals the color of the th bulb Thus the coordinates of all bulbs of the same color equal in module According to the conditions of the problem the coordinate of at least one light bulb of each color is given so we can restore the garland and by one pass count the number of blown bulbs By one pass we learn how numbers in module correspond to the colors By the second pass we know the place of the bulb and count the number of blown bulbs of each color The asymptotic behavior of the solutions is O n There is also a second solution You can just fix order of first four light bulbs by bruteforce there is only variants checking the conformity of each option of the given garland By finding the color of the first four bulbs we easily recreate the garland with working lights and count the number of blown bulbs At worst this decision will work for "}
{"statement": "Furik loves writing all sorts of problems especially such that he can t solve himself You ve got one of his problems the one Furik gave to Rubik And Rubik asks you to solve it There is integer and array consisting of ten integers indexed by numbers from 0 to 9 Your task is to count the number of positive integers with the following properties the number s length does not exceed the number doesn t have leading zeroes digit occurs in the number at least times ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Solution dynamic programming Look over for length of the number that we will build Further we will use DP f len i how many numbers with length len we can make with digits i 9 Recount f len 0 sum f len i 1 C len 1 i i a 0 len f len j sum f len i j 1 C len i i a j len 0 j 9 f len 9 1 len a 9 0 len a 9 C n k binomial coefficient "}
{"statement": "The Bad Luck Island is inhabited by three kinds of species rocks scissors and papers At some moments of time two random individuals meet all pairs of individuals can meet equiprobably and if they belong to different species then one individual kills the other one a rock kills scissors scissors kill paper and paper kills a rock Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s count the values dp r s p the probability of the situation when r rocks s scissors and p papers are alive The initial probability is 1 and in order to calculate the others we should perform the transitions Imagine we have r rocks s scissors and p papers Let s find the probability of the rock killing scissors the other probabilities are calculated in the same way The total number of the possible pairs where one species kills the other one is and the number of possible pairs rock scissors is As all meetings are equiprobable the probability we want to find is This is the probability with which we go the the state dp r s 1 p with the number of scissors less by one In the end for example to get the probability of the event that the rocks are alive we should sum all values dp i 0 0 for i from 1 to r the same goes to the other species "}
{"statement": "You are given an array a of n positive integers Let text LIS a denote the length of longest strictly increasing subsequence of a For example text LIS 2 underline 1 1 underline 3 2 text LIS underline 3 underline 5 underline 10 underline 20 4 text LIS 3 underline 1 underline 2 underline 4 3 We define array a as the array obtained after reversing the array a i e a a n a n 1 ldots a 1 The beauty of array a is defined as min text LIS a text LIS a Your task is to determine the maximum possible beauty of the array a if you can rearrange the array a arbitrarily ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "TutorialLet s make a small observation There can be at most one index common to both and If some element occurs times then one of its occurrences can be included in and another one in and all the remaining occurrences are of no use because none of them can contain 2 equal elements If some element is a singleton i e the frequency of in is then it can have positions In only In only The only common element of and It can be seen that it is always optimal to choose some singleton as the only common element if available because those with frequency can easily contribute to both and easily Let be the number of elements having frequency and be the number of singletons in The singletons should be divided equally among and with one of them given to both if available Hence the answer is The values and can be found using some data structure like in C in "}
{"statement": "You are given a binary string dagger Please find the minimum number of pieces you need to cut it into so that the resulting pieces can be rearranged into a sorted binary string Note that each character must lie in exactly one of the pieces the pieces must be contiguous substrings of the original string you must use all the pieces in the rearrangement dagger A is a string consisting of characters texttt 0 and texttt 1 A is a binary string such that all characters texttt 0 come before all characters texttt 1 ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "First note that it s always optimal to divide the string into blocks of equal values there is no use having two strings when we can just have and use fewer pieces Now note that to sort the string we need all blocks of to come before all blocks of The only way that two blocks can join is if we have a block of s before a block of s and we can have at most one such block That is all strings look like So the answer is the number of blocks but we should subtract if a substring exists because then we can make the center block above The time complexity is For example for the string we can use three pieces "}
{"statement": "Developer Petr thinks that he invented a perpetual motion machine Namely he has a lot of which work in the following way Each element has one controller that can be set to any non negative real value If a controller is set on some value then the controller consumes energy units per second At the same time any two elements connected by a wire produce energy units per second where and are the values set on their controllers Petr has only a limited number of wires so he has already built some scheme of elements and wires and is now interested if it s possible to set the controllers in such a way that the system produces power as it consumes and at least one controller is set on the value different from Help him check this and if it s possible find the required values that should be set It is guaranteed that if there exist controllers settings satisfying the above conditions then there exist required integer values not greater than ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3100", "problem_editorial": "By default all vertices contain We will solve problem in few steps getting answer for our question in different cases Graph contains cycle In this case solution exists all vertices of cycle contain sum would be Graph contains vertex with degree more than Solution exists this vertex has and its neighbours Sum will be when Graph contains more than one vertex of degree In this case we can reduce to previous case we put in the between these vertices and ones in other neighboors Doing this we contract path between vertices to one with the number and obtain vertex of degree Graph contains just one vertex of degree It is the most complicated point in our solution We just state this and prove it later There is only one vertex with degree with tails of sizes length of the tail how many vertices lay on it In this case expression can take only non positive values if All graph s vertices have degree less than This case can be easily reduced to previous one having We are going to prove this by two ways Let s look on tail sized having form of the bamboo Numbers in vertices are and have sum We are going to minimize As one can see Let While So we have and we want to choose numbers with sum so that sum of their squares is as small as possible One can prove that best choice is while having sum In this case We will use induction for proof Base is evident Step optimal sum of squares if one of numbers is We shall minmize this function This is nearly equal to derivative being zero what we wanted to prove Now we get back to construction where are three tails of sizes are connected to 3 degree vertex Number in 3 degree vertex is value of the whole graph is and values of tails are If we fix when as it was shown before optimal values of tails are i We have It means that can be only if Let the tail of size have numbers in vertices counting from the leaf size size Root we will define as Let We want to compute One can see that Actually if we calculate this expression we will have Each term with features once on both adjacent terms and gives the sum When Because all we should have other expression not greater than zero However because in this case for having all squares zero all numbers would be zero Because of this Necessity of this criterion is proved Sufficiency can be seen from definition in the second proof we should put arithmetic progressions on all tails In case of graph having form of bamboo we have equal to while what is obviously impossible So answer is always All mentioned above is made with few depth first searches so complexity of this solution is "}
{"statement": "Olya wants to buy a custom wardrobe It should have boxes with heights stacked one on another in some order In other words we can represent each box as a vertical segment of length and all these segments should form a single segment from to without any overlaps Some of the boxes are important in this case others are not then Olya defines the of the wardrobe as the number of important boxes such that their bottom edge is located between the heights and inclusive You are given information about heights of the boxes and their importance Compute the maximum possible convenience of the wardrobe if you can reorder the boxes arbitrarily ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "The first idea of the author s solution is to reverse the problem change l to H r and r to H l where H is the total height of the wardrobe Now an important box is counted in the answer if and only if its top edge is within the segment l r We ll see later the profit of this operation Now we ll build a wardrobe of arbitrary height using only a subset of the boxes and choose the maximum possible answer Why can we remove the constraint to use all boxes We can always assume that we add all the boxes we don t take at the top of the boxes we take and the answer won t decrease So we can do some kind of knapsack where not taking a box means putting it on the top after considering all boxes What we don t know is how to compute the answer and in which order to consider the boxes in the knapsack Ok if we consider them in such an order that there is an optimal answer in which the boxes we take in the knapsack always come in this order then computing the answer is easy we can always assume that we put a new box on the top of already taken ones and add 1 to the current answer if it is an important box and its top edge falls in the range l r Now we should find such an order Note that in an optimal answer we can always arrange boxes in this order some number of unimportant boxes then some number of important boxes that don t increase the answer then some number of important boxes that increase the answer and after that a mix of important and unimportant boxes which don t count in the answer and that we consider as not taken in the knapsack This means that we can first consider all unimportant boxes in the knapsack and then all important ones It s also easy to see that the order of unimportant boxes does not matter However it turns out that the order of important boxes matters To choose the order of important boxes we can use an old but good trick Suppose two important boxes with heights ai and aj stand one on the other Answer the question What is the condition such that if it is satisfied then it is always better to put aj on the top of ai and not vice versa Here we consider only the boxes that count in the answer and those under them because other we simply don t take in the knapsack It turns out that the condition is simple aj ai no matter do these boxes count in the answer or not Here we used the fact that we inversed the problem and the position of the top edge matters not the bottom one So as we now know that it is always optimal to put the important boxes from largest to smallest in the inversed problem we can sort them in that order and perform the knapsack "}
{"statement": "Dwarfs have planted a very interesting plant which is a triangle directed upwards This plant has an amusing feature After one year a triangle plant directed upwards divides into four triangle plants three of them will point upwards and one will point downwards After another year each triangle plant divides into four triangle plants three of them will be directed in the same direction as the parent plant and one of them will be directed in the opposite direction Then each year the process repeats The figure below illustrates this process Help the dwarfs find out how many triangle plants that point upwards will be in years ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s propose that after the i th year there is x triangles up and y triangles down After another iteration we can see that amount of triangles became 3x y up and x 3y down Let s see the difference between them at the i th it s x y and at the i 1 th it s 3x y x 3y 2 x y We can see that difference between amount of triangles grown up by 2 Because on the i th year the difference became 2i and all amount of triangles is 4i We can see that on the i th year the number of our triangles is That can be computed by modulo p using the fast power algorithm "}
{"statement": "Mike and Ann are sitting in the classroom The lesson is boring so they decided to play an interesting game Fortunately all they need to play this game is a string s and a number k 0 le k s At the beginning of the game players are given a substring of s with left border l and right border r both equal to k i e initially l r k Then players start to make moves one by one according to the following rules A player chooses l prime and r prime so that l prime le l r prime ge r and s l prime r prime is lexicographically less than s l r Then the player changes l and r in this way l l prime r r prime Ann moves first The player that can t make a move loses Recall that a substring s l r l le r of a string s is a continuous segment of letters from s that starts at position l and ends at position r For example is a substring s 3 5 of and is not Mike and Ann were playing so enthusiastically that they did not notice the teacher approached them Surprisingly the teacher didn t scold them instead of that he said that he can figure out the winner of the game before it starts even if he knows only s and k Unfortunately Mike and Ann are not so keen in the game theory so they ask you to write a program that takes s and determines the winner for all possible k ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "The main idea of this task is that Mike never moves Lets fix there two cases 1 for all in this case for all so Ann can t make her first move Mike wins 2 There is such that In this case Ann can move with substring If we choose the least possible such that is minimal we will deprive Misha of the opportunity to make a move Ann wins Final solution for all we should check whether is the least on substring It can be done with one for in wich we should maintain a minimum on prefix Complexity "}
{"statement": "Euler is a little cute squirrel When the autumn comes he collects some reserves for winter The interesting fact is that Euler likes to collect acorns in a specific way A tree can be described as n acorns connected by n 1 branches such that there is exactly one way between each pair of acorns Let s enumerate the acorns from 1 to n The squirrel chooses one acorn not necessary with number 1 as a start and visits them in a way called Euler tour see notes collecting each acorn when he visits it for the last time Today morning Kate was observing Euler She took a sheet of paper and wrote down consecutive indices of acorns on his path Unfortunately during her way to home it started raining and some of numbers became illegible Now the girl is very sad because she has to present the observations to her teacher Maybe if I guess the lacking numbers I ll be able to do it she thought Help her and restore any valid Euler tour of some tree or tell that she must have made a mistake ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "First let s try to find some conditions whether it is possible to recover correct euler tour Of course for every euler tour and because we start and finish in root Moreover if there exist four index such that and and than answer is because vertex is an ancestor of another o there is no relation between them There is one more tricky condition parity of positions of all occurences of element is the same Also between two equal elements with distance there can be at most distinct elements It turns out that those conditions are sufficient we will prove it by constructing an answer So first let s observe that if we have to equal elements it means that there is subtree between them we can solve it independently from the rest of a tree and then forget about this subtree So as long as we have two equal elements than we can first solve euler tour between them and then delete elements So now we want to solve euler tour where no element occur more than once Let s say that this tour has length then if we have less than elements we can replace any with any unused elements Now if there are three elements in a row with values or than we can replace them with and forget about it If we get rid of all triplets like this than we have tour in form of It s easy to observe that we can replace every with our root subtree s root There is a special case when we don t have any root if solving for whole tree than we have to find any vertex which can be root and then solve our problem Straightforward implementation will be but it can be easily reduced to and it can be even reduced to but was enough to be accepted More details about reducing to in code "}
{"statement": "Recently Kolya found out that a new movie theatre is going to be opened in his city soon which will show a new movie every day for n days So on the day with the number 1 le i le n the movie theatre will show the premiere of the i th movie Also Kolya found out the schedule of the movies and assigned the entertainment value to each movie denoted by a i However the longer Kolya stays without visiting a movie theatre the larger the decrease in entertainment value of the next movie That decrease is equivalent to d cdot cnt where d is a predetermined value and cnt is the number of days since the last visit to the movie theatre It is also known that Kolya managed to visit another movie theatre a day before the new one opened the day with the number 0 For example if d 2 and a 3 2 5 4 6 then by visiting movies with indices 1 and 3 cnt value for the day 1 will be equal to 1 0 1 and cnt value for the day 3 will be 3 1 2 so the total entertainment value of the movies will be a 1 d cdot 1 a 3 d cdot 2 3 2 cdot 1 5 2 cdot 2 2 Unfortunately Kolya only has time to visit Help him create a plan to visit the cinema in such a way that the total entertainment value of all the movies he visits is maximized ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s notice that if we visit the cinema on days with numbers the total entertainment value of the visited movies will be equal to Thus it is sufficient to iterate over the day when Kolya will visit the cinema for the last time and maintain the maximum non negative elements on the prefix This can be done for example using std multiset The total complexity of the solution will be "}
{"statement": "Bosco is studying the behaviour of particles He decided to investigate on the peculiar behaviour of the so called four one two particle He does the following There is a line of length n 1 where the topmost point is position 0 and bottommost is position n 1 The particle is initially at time t 0 at position 0 and heading downwards The particle moves at the speed of 1 unit per second There are n oscillators at positions 1 2 ldots n Each oscillator can be described by a binary string The initial state of each oscillator is the first character of its binary string When the particle hits with an oscillator the particle reverses its direction if its current state is texttt 1 and continues to move at the same direction if its current state is texttt 0 and that oscillator moves on to the next state the next state of the last state is defined as the first state Additionally the particle always reverses its direction when it is at position 0 or n 1 at time t 0 Bosco would like to know the cycle length of the movement of particle The cycle length is defined as the minimum value of c such that for any time t ge 0 the position of the particle at time t is same as the position of the particle at time t c It can be proved that such value c always exists As he realises the answer might be too large he asks you to output your answer modulo 998244353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "Observation 1 Observe that whole process is periodic Note that the process is reversible If you are in some state consisting of position of the particle and the current state position of each oscillator you can decide the next state and the previous state This implies the state transition graph is a permutation so it decomposes into cycles "}
{"statement": "You finally woke up after this crazy dream and decided to walk around to clear your head Outside you saw your house s fence so plain and boring that you d like to repaint it You have a fence consisting of n planks where the i th plank has the color a i You want to repaint the fence in such a way that the i th plank has the color b i You ve invited m painters for this purpose The j th painter will arrive at the moment j and will recolor plank to color c j For each painter you can choose which plank to recolor but you can t turn them down i e each painter has to color exactly one plank Can you get the coloring b you want If it s possible print for each painter which plank he must paint ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "We must first see that the most important painter is the last one and he will paint plank where because of two reasons when he paints plank it won t be changed and if some other painter have a color that we don t need we can make him paint plank which will be repainted later Now we need to find where there are three options There are no this case is impossible and the answer is If the first two are true we choose such that then we greedily distribute all painters such that There is plank such that and then the painter will paint plank as a result the color of the plank will be changed There is no plank such that and then the painter will paint plank At the end there might be some planks that didn t end up as we want so we make a last liner check on all planks and check if the total time is "}
{"statement": "ZS the Coder has recently found an interesting concept called the Birthday Paradox It states that given a random set of people there is around chance that some two of them share the same birthday ZS the Coder finds this very interesting and decides to test this with the inhabitants of Udayland In Udayland there are days in a year ZS the Coder wants to interview people from Udayland each of them has birthday in one of days each day with equal probability He is interested in the probability of at least two of them have the birthday at the same day ZS the Coder knows that the answer can be written as an irreducible fraction He wants to find the values of and he does not like to deal with floating point numbers Can you help him ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Note that is a prime Firstly if we have then by pigeonhole principle we must have people with the same birthday Thus we can directly output Thus now we suppose Then instead of computing the probability directly we compute the complement i e the probability that all the people have distinct birthdays This probability turns out to be much simpler to calculate as it is just Fix the birthday of the first person the probability that the second person has different birthday is and for the next person it s and so on Now we know that the denominator is just a power of However we still have to reduce the fraction to the lowest terms Note that is in the lowest terms if and only if is in the lowest terms since Also note that the gcd is a power of since the denominator is a power of Thus we need to find the highest power of that divides This is also equal to the sum of the highest power of that divides Now if a power of divides then it must also divides and vice versa So we can actually translate this to finding the sum of highest power of that divides or the highest power of that divides Now this is simple to calculate by Legendre s formula which is quite easy to prove in Now that we find the gcd of the numerator and denominator we can immediately find the reduced denominator by binary exponentiation For the numerator we need a bit more work since we have to deal with However it is not hard either The key fact is that is small so if the product above is equal to modulo because among consecutive integers there must be one that is a multiple of Thus the above product can be calculated in if and otherwise The remaining parts can be calculated using direct binary exponentiation One minor note is that when we re calculating the value of might overflow One way to resolve this is to reduce it modulo since modulo by Fermat s Little Theorem Another way is to just evaluate first then take the result and raise it to the th power Time Complexity "}
{"statement": "Koa the Koala has a binary string s of length n Koa can perform no more than n 1 possibly zero operations of the following form In one operation Koa selects positions i and i 1 for some i with 1 le i s and sets s i to max s i s i 1 Then Koa deletes position i 1 from s after the removal the remaining parts are concatenated Note that after every operation the length of s decreases by 1 How many different binary strings can Koa obtain by doing no more than n 1 possibly zero operations modulo 10 9 7 1000000007 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Firstly the described operation can be seen as divide in sub strings and take the in each one For each possible resultant string let s think in the following way of obtain it from Suppose we already have a in in previous steps if not it can be handled later and we used the firsts characters of to get the firsts characters of if the th character in is find the next in ie first such that merge everything between the last and and take the new if the th character in is and we have zeros after the last in find the next block of zeros in ie first such that for each if is equal to just append the new to otherwise merge everything between the last and and take the new zeros from to We can prove that in this way every possible resultant string is generated in a unique way and it uses the minimum number of characters from to obtain So we can start thinking about dynamic programming keeping in mind this greedy Let be the number of strings that we can obtain using the last characters from the transitions are the previous described two cases taking care of the case of ending with certain numbers of Therefore If there is at least a in let be the first position such that answer equals because we start assuming that there exists some previous and before this there are exactly possibilities empty one two s s Otherwise answer is because consists of all Time complexity "}
{"statement": "Ujan decided to make a new wooden roof for the house He has n rectangular planks numbered from 1 to n The i th plank has size a i times 1 that is the width is 1 and the height is a i Now Ujan wants to make a square roof He will first choose some of the planks and place them side by side in some order Then he will glue together all of these planks by their vertical sides Finally he will cut out a square from the resulting shape in such a way that the sides of the square are horizontal and vertical For example if Ujan had planks with lengths 4 3 1 4 and 5 he could choose planks with lengths 4 3 and 5 Then he can cut out a 3 times 3 square which is the maximum possible Note that this is not the only way he can obtain a 3 times 3 square What is the maximum side length of the square Ujan can get ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "There are different solutions Bruteforce the length of the square from to If you can make a square of side length then there should be at least planks of length at least The complexity of such solution The parameter can be also checked using binary search then the complexity becomes Suppose you want to take planks and cut the largest square from them Of course it is always better to take the longest planks The side of the largest square that can be cut from them is bounded by the length of the smallest of these planks and the number of the planks Therefore the solution is sort the numbers in descending order then the solution is The complexity Since the numbers are at most we can use counting sort and the complexity becomes "}
{"statement": "Vova promised himself that he would never play computer games But recently Firestorm a well known game developing company published their newest game World of Farcraft and it became really popular Of course Vova started playing it Now he tries to solve a quest The task is to come to a settlement named Overcity and spread a rumor in it Vova knows that there are characters in Overcity Some characters are friends to each other and they share information they got Also Vova knows that he can bribe each character so he or she starts spreading the rumor th character wants gold in exchange for spreading the rumor When a character hears the rumor he tells it to all his friends and they start spreading the rumor to their friends for free and so on The quest is finished when all characters know the rumor What is the minimum amount of gold Vova needs to spend in order to finish the quest Take a look at the notes if you think you haven t understood the problem completely ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1300", "problem_editorial": "In this problem you are given an undirected graph with weighted vertices And the problem is to calculate the sum of minimum values in every connected component To do this we just need to run or several times "}
{"statement": "As you know every birthday party has a cake This time Babaei is going to prepare the very special birthday party s cake is a cylinder of some radius and height The volume of the simple cake is equal to the volume of corresponding cylinder Babaei has simple cakes and he is going to make a placing some cylinders on each other However there are some additional culinary restrictions The cakes are numbered in such a way that the cake number can be placed only on the table or on some cake number where Moreover in order to impress friends Babaei will put the cake on top of the cake only if the volume of the cake is strictly greater than the volume of the cake Babaei wants to prepare a birthday cake that has a maximum possible total volume Help him find this value ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "First of all we calculate the volume of each cake Now consider the sequence The answer to the problem is the maximum sum of elements between all increasing sub sequences of this sequence How do we solve this First to get rid of the decimals we can define a new sequence such that We consider as the maximum sum between all the sequences which end with and The answer to the problem is Now how do we calculate We use a max segment tree which does these two operations Change the member to Find the maximum value in the interval to Now we use this segment tree for the array and find the answer Consider that is sorted We define as the position of Now to fill we find the maximum in the interval in segment and we call it and we set the th index of the segment as The answer to the problem would the maximum in the segment in the interval 1 n Time complexity Thanks to ATofighi who helped a lot for writing the editorial of problem D C Solution "}
{"statement": "Consider a permutation dagger p of length 3n Each time you can do one of the following operations Sort the first 2n elements in increasing order Sort the last 2n elements in increasing order We can show that every permutation can be made sorted in increasing order using only these operations Let s call f p the minimum number of these operations needed to make the permutation p sorted in increasing order Given n find the sum of f p over all 3n permutations p of size 3n Since the answer could be very large output it modulo a prime M dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "There is a very easy dp solution we will show one possible way to optimize it to where is the maximum possible value of Let be the minimum number of eris required to reach index Suppose we want to calculate and we already know Let s look at our cost function more closely We can notice that it is definitely not optimal to use the transition if That is it will be more optimal to perform jumps of length 1 Transforming this inequality we get So if is quite large we only need to look at a couple of close to and then do something else for the small values of 1 To handle this case we can just iterate over all from to since the transition could be optimal only if Time complexity 2 Another useful fact is that if there exists an index such that and the transition also cannot be optimal since followed by will cost less Proof This leaves us two subcases two handle 2 1 Just maintain the rightmost occurrences of all values from to Time complexity 2 2 Initially set to and decrease it until becomes true Time complexity amortized Total time complexity "}
{"statement": "Rudolf is going to visit Bernard and he decided to take the metro to get to him The ticket can be purchased at a machine that accepts exactly two coins the sum of which does not exceed k Rudolf has two pockets with coins In the left pocket there are n coins with denominations b 1 b 2 dots b n In the right pocket there are m coins with denominations c 1 c 2 dots c m He wants to choose exactly one coin from the left pocket and exactly one coin from the right pocket two coins in total Help Rudolf determine how many ways there are to select indices f and s such that b f c s le k ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "For each test case we calculate all elements from the first array Then we iterate through the elements in the second array and in a loop we calculate each sum If this sum is less than or equal to we add to the answer "}
{"statement": "Helen works in Metropolis airport She is responsible for creating a departure schedule There are flights that must depart today the th of them is planned to depart at the th minute of the day Metropolis airport is the main transport hub of Metropolia so it is difficult to keep the schedule intact This is exactly the case today because of technical issues no flights were able to depart during the first minutes of the day so now the new departure schedule must be created All scheduled flights must now depart at different minutes between th and th inclusive However it s not mandatory for the flights to depart in the same order they were initially scheduled to do so their order in the new schedule can be different There is only one restriction no flight is allowed to depart earlier than it was supposed to depart in the initial schedule Helen knows that each minute of delay of the th flight costs airport burles Help her find the order for flights to depart in the new schedule that minimizes the total cost for the airport ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "We will show that following greedy is correct let s for each moment of time use a plane which can depart in this moment of time and didn t depart earlier of course with minimal cost of delay Proof is quite simple it s required to minimize You can notice that is constant so we just need to minimize Consider the optimal solution when plane departs at moment and solution by greedy algorithm in which plane departs at moment Let be plane with minimal such At any moment greedy algorithm takes avaliable plane with lowest so Let be a plane such that But so and it s possible to swap and in optimal solution without loosing of optimality By performing this operation many times it s possible to make for each and it means that greedy solution is optimal To make this solution work fast you need to use some data structures to find optimal plane faster for each moment This data structure should be able to add number into set give value of minimal element in set and erase minimal number from set For this purpose you can use heap or someting like std set or std priority queue in C "}
{"statement": "Ron is a happy owner of a permutation a of length n A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array Ron s permutation is subjected to m experiments of the following type r i p i This means that elements in range 1 r i in other words the prefix of length r i have to be sorted in ascending order with the probability of p i All experiments are performed in the same order in which they are specified in the input data As an example let s take a look at a permutation 4 2 1 5 3 and an experiment 3 0 6 After such an experiment with the probability of 60 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Let s first define some variable which will be equal to the last unsorted number the largest for which Now we can see that we are not interested in experiments with To get the answer we just need to multiply the remaining This number will indicate the probability that all the remaining experiments failed Since we need to deduce the probability of success we can subtract the resulting number from one "}
{"statement": "You are given a sequence s consisting of n digits from 1 to 9 You have to divide it into segments segment is a consecutive sequence of elements in other words you have to place separators between some digits of the sequence in such a way that and if the resulting division will be represented as an integer numbers sequence then each next element of this sequence will be than the previous one More formally if the resulting division of the sequence is t 1 t 2 dots t k where k is the number of element in a division then for each i from 1 to k 1 the condition t i t i 1 using comparing it means that the integer representations of strings are compared should be satisfied For example if s 654 then you can divide it into parts 6 54 and it will be suitable division But if you will divide it into parts 65 4 then it will be bad division because 65 4 If s 123 then you can divide it into parts 1 23 1 2 3 but not into parts 12 3 Your task is to find suitable division for each of the q independent queries ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Since we just want to make two numbers such that the first number is smaller than the second our best bet is to use only the first digit for the first number and the rest of the digits for the second number Note that since the numbers can have up to 300 digits we shouldn t actually evaluate the second number Instead since the digits only include 1 through 9 we can handle that case by checking the number of digits Code 49002957 "}
{"statement": "Jon Snow is on the lookout for some orbs required to defeat the white walkers There are different types of orbs and he needs at least one of each One orb spawns daily at the base of a Weirwood tree north of the wall The probability of this orb being of any kind is equal As the north of wall is full of dangers he wants to know the minimum number of days he should wait before sending a ranger to collect the orbs such that the probability of him getting at least one of each kind of orb is at least where To better prepare himself he wants to know the answer for different values of Since he is busy designing the battle strategy with Sam he asks you for your help ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Set and Editorial by arnabsamanta This problem can be solve using inclusion exclusion principle but precision errors need to be handled Therefore we use the following dynamic programming approach to solve this problem On day there are two possibilities Case 1 Jon doesn t find a new orb then the probability of it is Case 2 Jon does find a new orb then the probability of it is Therefore We need to find the minimum such that where number of days Jon waited number of distinct orbs Jon have till now probability of Jon having distinct orbs in days Total number of distinct orbs possible Code "}
{"statement": "For k positive integers x 1 x 2 ldots x k the value gcd x 1 x 2 ldots x k is the greatest common divisor of the integers x 1 x 2 ldots x k the largest integer z such that all the integers x 1 x 2 ldots x k are divisible by z You are given three arrays a 1 a 2 ldots a n b 1 b 2 ldots b n and c 1 c 2 ldots c n of length n containing positive integers You also have a machine that allows you to swap a i and b i for any i 1 le i le n Each swap costs you c i coins Find the maximum possible value of gcd a 1 a 2 ldots a n gcd b 1 b 2 ldots b n that you can get by paying in total at most d coins for swapping some elements The amount of coins you have changes a lot so find the answer to this question for each of the q possible values d 1 d 2 ldots d q ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "Solution Let be the maximum value of on input Let be the maximum number of divisors a number in range can have and the maximum number of prime divisors such number can have Let s think about how to solve one query with coins for now Assume that in the optimal solution we never swap and In the end we will just run the same solution on input where and is swapped and is decreased by and then we will take the maximum of the two values these two runs will find So now in the optimal solution the gcd of is always a divisor of and the of is a divisor of Let s start by factorizing the two numbers in Now we will precalculate something in order to be efficiently able to determine for every a divisor of and a divisor of whether we can have and simultaneously and also the minimum cost of making it so Then we can obviously answer the query by finding the best pair with sum at most Let s create new two dimensional arrays and of size We will use to be able to tell the number of indexes such that we have either and or and If this count won t be then obviously we can t have and as s of and Also we will use to tell us the sum of costs of all swaps we need to perform to have and Now how to make two such arrays efficiently It is obvious that if the pair of s is consistent with some indexes in the original array then for every pair such that and this pair of s is also consistent with those indexes and maybe even more also maybe some swaps just became unnecessary but the point is it doesn t get worse So if we want to add some value to a pair we also want to get it added to all its divisors That s why in order to calculate the arrays efficiently we will first add some values on some positions and then do something like prefix sums for every cell we will sum the values for all pairs such that and and update its current value with it Assuming this is going to happen in the end let s look at every and consider what pairs are good for this index with or without the swap a If divides and divides For this type of pairs we don t need to make any swaps on this index Let s add to to indicate that for all such that and we don t have to perform any swaps at the position the index is good as it is b divides and divides In this case we will add to and to to indicate that if we pick such that and we can make index good if we swap and c and both divide both and To avoid counting both of the previous cases and therefore overcounting we will add to and to we have to undo paying for the swap since in this case we actually don t have to pay for it but it falls under the case b too This step can be done in Now let s fix the arrays and so they store the actual values not just the values we need to add We will go through all primes dividing and update with and with similarly for all primes dividing If we make those updates in the right order we achieve that is the sum of all original values for all the pairs such that and like we wanted and we can do the same for By careful precalculation of divisors and their order while factorizing we can do this step in Some efficient implementations with extra log might pass also but you will have to be more careful For multiple queries after precalculating the possible sums of s and their costs you can sort them and use binary search to answer the queries Time complexity Memory complexity Implementation in C 261999743Fun fact While making the original proposal I invented a version of this problem with lower constraints and thought it could be nice Div2C Few days later while I was on a walk I realized this solution exists so we decided to try to propose it as the hardest problem "}
{"statement": "Dr Evil is interested in math and functions so he gave Mahmoud and Ehab array of length and array of length He introduced a function which is defined for integers which satisfy Suppose Then More formally Dr Evil wants Mahmoud and Ehab to calculate the minimum value of this function over all valid They found it a bit easy so Dr Evil made their task harder He will give them update queries During each update they should add an integer to all elements in in range i e they should add to and then they should calculate the minimum value of for all valid Please help Mahmoud and Ehab ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s write in another way Now we have 2 sums The first one is constant doesn t depend on For the second sum we can calculate all its possible values using sliding window technique Now we want a data structure that takes the value of the first sum and chooses the best second sum from all the choices observation We don t have to try all the possible values of to minimize the expression If the first sum is We can try only the least value greater than and the greatest value less than not because we are minimizing not because the absolute value means the distance between the two values on the number line Any other value will be further than at least one of the chosen values To do this we can keep all the values of sorted and try the elements numbered lower bound c and lower bound c 1 and choose the better In short we re trying the values close to only Now we have a data structure that can get us the minimum value of the expression once given the value of the first sum in Now we want to keep track of the value of the first sum Let the initial value be In each update If the length of the updated interval is even The sum won t change because will be added as many times as it s subtracted Otherwise will be added to or subtracted from depending of the parity of the left bound of the interval Time complexity Solution link me https pastebin com u828DjcS Solution link mahmoudbadawy https pastebin com dA3K8nfK "}
{"statement": "Sagheer is walking in the street when he comes to an intersection of two roads Each road can be represented as two parts where each part has lanes getting into the intersection one for each direction and lanes getting out of the intersection so we have parts in total Each part has lights one for each lane getting into the intersection left straight right and a light for a pedestrian crossing An accident is possible if a car can hit a pedestrian This can happen if the light of a pedestrian crossing of some part and the light of a lane that can get to or from that same part are green at the same time Now Sagheer is monitoring the configuration of the traffic lights Your task is to help him detect whether an accident is possible ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "For pedestrian crossing lanes are the only lanes that can cross it So we have to check that either or all mentioned lanes are Complexity Implementation "}
{"statement": "You have a horizontal strip of n cells Each cell is either white or black You can choose a segment of cells once and paint them all white After this action all the black cells in this segment will become white and the white ones will remain white What is the minimum length of the segment that needs to be painted white in order for all n cells to become white ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "To repaint all the black cells in white it is necessary to select a segment from to that contains all the black cells Let s choose the entire strip as a segment As long as the segment starts with a white cell it can be left unpainted i e can be increased by one Otherwise we cannot exclude the cell from the segment Similarly we can exclude the last cell from the segment until it becomes black After all exclusions the answer will be The selected segment contains all the black cells as we have excluded only white cells The segment is also minimal because reducing the segment from either side will result in one of the black cells remaining black "}
{"statement": "You are given a permutation p of integers from 0 to n 1 each of them occurs exactly once Initially the permutation is that is p i p i 1 for at least one 1 le i le n 1 The permutation is called X sortable for some non negative integer X if it is possible to sort the permutation by performing the operation below some finite number of times Choose two indices i and j 1 le i lt j le n such that p i p j X Swap p i and p j Here denotes the bitwise AND operation Find the value of X such that p is X sortable It can be shown that there always exists some value of X such that p is X sortable ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "TutorialWe always have to make at least one swap for the elements which are not at their correct positions Hence an upper bound of answer would be the bitwise AND of those elements Let the value be It turns out that the given permutation is sortable Proof First notice that would always be present in Let be the position of in initially Let s say at some point we want to swap two values and then and would always be a supermask of i e and We can make the following moves to swap and without disturbing any other element Swap values at indices and Swap values at indices and Swap values at indices and It can be seen that in every swap the bitwise AND of two values which we are swapping is always Hence we can swap any two values which were not at their correct positions therefore we can sort the permutation Overall Complexity "}
{"statement": "A group of university students wants to get to the top of a mountain to have a picnic there For that they decided to use a cableway A cableway is represented by some cablecars hanged onto some cable stations by a cable A cable is scrolled cyclically between the first and the last cable stations the first of them is located at the bottom of the mountain and the last one is located at the top As the cable moves the cablecar attached to it move as well The number of cablecars is divisible by three and they are painted three colors red green and blue in such manner that after each red cablecar goes a green one after each green cablecar goes a blue one and after each blue cablecar goes a red one Each cablecar can transport no more than two people the cablecars arrive with the periodicity of one minute i e every minute and it takes exactly minutes for a cablecar to get to the top All students are divided into three groups of them like to ascend only in the red cablecars of them prefer only the green ones and of them prefer only the blue ones A student never gets on a cablecar painted a color that he doesn t like The first cablecar to arrive at the moment of time is painted red Determine the least time it will take all students to ascend to the mountain top ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "In this problem you can simulate the process You can consider all minutes and in dependence by a color of a current cablecar decrease size of corresponding group of students G by min G 2 where G is size of the group After that you should determine the first minute t in that all three groups of students will be empty So t 30 is an answer This solution works in O r g b Also there is O 1 solution It is following formula ans max 3 R 1 2 27 3 G 1 2 28 3 B 1 2 29 where x is rounding down "}
{"statement": "Filya just learned new geometry object rectangle He is given a field consisting of unit cells Rows are numbered from bottom to top with integer from to Columns are numbered from left to right with integers from to Cell located at the intersection of the row and column is denoted as Filya has painted two rectangles such that their sides are parallel to coordinate axes and each cell lies fully inside or fully outside each of them Moreover no cell lies in both rectangles Later hedgehog Filya became interested in the location of his rectangles but was unable to find the sheet of paper they were painted on They were taken by Sonya and now she wants to play a little game with Filya He tells her a query rectangle and she replies with the number of initial rectangles that lie the given query rectangle The query rectangle should match the same conditions as initial rectangles Rectangle lies fully inside the query if each o its cells lies inside the query Filya knows Sonya really well so is sure that if he asks more than questions she will stop to reply ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Assume we have just one rectangle First we can find its right side In binary search we check is out rectangle to the left of some line using function As soon as we found right coordinate we can cut everything to the right of the line because there is nothing to look In the same way we will find all sides Main idea is to find a line which will split space in the way that rectangles will lie in different parts as rectangles are not intersected it is always possible We can assume that intersected line is parallel to y coordinate and use binary search by On each step of search we will count amount of rectangles on each side If we have pair then line is found If we have pair then intersected line is parallel to coordinate Otherwise we should search in the half where we have some rectangles In worst case we will have searches each will take time also we have time to find separated rectangle In total we We can find first rectangle assuming that here is just one rectangle In each of four of our search we will assume that rectangle is present if get will return or When we have one rectangle we can search second assuming that we can modify get function to which will assume coordinates of first rectangle and decrease original value if it is required "}
{"statement": "Oleg the bank client lives in Bankopolia There are cities in Bankopolia and some pair of cities are connected directly by bi directional roads The cities are numbered from to There are a total of roads in Bankopolia the th road connects cities and It is guaranteed that from each city it is possible to travel to any other city using some of the roads Oleg wants to give a label to each city Suppose the label of city is equal to Then it must hold that for all pairs of cities the condition holds if and only if there is a road connecting and Oleg wonders if such a labeling is possible Find an example of such labeling if the task is possible and state that it is impossible otherwise ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "Add each vertex to its own adjacency list Now we claim that if it is possible to label the cities to satisfy the problem conditions then it is possible to do so so that for every two cities with the same adjacency list they re labelled with the same number Indeed if they have the same adjacency list they must be neighbours Thus the difference between their labels is at most 1 Suppose we label the first vertex u with number i and the second vertex v with the number i 1 Note that since their adjacency lists are equal a vertex x is a neighbour of u iff it s a neighbour of v Thus u and v can t have neighbours with labels i 1 or i 2 or else it will contradict the condition Thus all neighbours of u and v have labels i or i 1 Thus we can safely change the label of the second vertex v to i and the conditions will still hold Thus we can sort the set of adjacency lists of each vertex and then group the vertices with the same adjacency list together Suppose there are k such groups For simplicity we can create a new graph where each group represent a vertex of the new graph Connect two groups i and j if and only if there exist some vertex in group i that connects to a vertex in group j Note that the graph will have at most O m edges Now if a vertex has degree 3 we can t assign a number to that vertex properly as one of its neighbours will not have a label which have a difference 1 from it Thus all vertices in the new graph must have degree 2 Since it s connected it must be either a cycle or a path However it can be easily seen that there is no labelling if it s a cycle Thus it must be a path Now we can just assign the labels to the graph from one end of the path to the other end by the numbers 1 to k Finally the label of a vertex is simply the label of its group "}
{"statement": "Little Chris is very keen on his toy blocks His teacher however wants Chris to solve more problems so he decided to play a trick on Chris There are exactly blocks in Chris s set each block has a unique number from 1 to Chris s teacher picks a subset of blocks and keeps it to himself He will give them back only if Chris can pick such a non empty subset from the remaining blocks that the equality holds Are you kidding me asks Chris For example consider a case where and Chris s teacher took the blocks with numbers 1 4 and 5 One way for Chris to choose a set is to pick the blocks with numbers 3 and 6 see figure Then the required sums would be equal However now Chris has exactly blocks Given the set of blocks his teacher chooses help Chris to find the required set ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s define the symmetric number of to be Since in this case is an even number Note that i e the sum of a number and its symmetric is always Let s process the given members of There can be two cases How to prove that in the second step we can always find such Let the number of symmetric pairs that were processed in the step 1 be then there remain other pairs Among them for pairs both members belong to and for other pairs none of the members belong to To be able to pick the same number of pairs for as there are in we should have which is equivalent to as given in the statement Solution complexity "}
{"statement": "Small but very brave mouse Brain was not accepted to summer school of young villains He was upset and decided to postpone his plans of taking over the world but to become a photographer instead As you may know the coolest photos are on the film because you can specify the hashtag film for such Brain took a lot of colourful pictures on colored and black and white film Then he developed and translated it into a digital form But now color and black and white photos are in one folder and to sort them one needs to spend more than one hour As soon as Brain is a photographer not programmer now he asks you to help him determine for a photo whether it is colored or black and white Photo can be represented as a matrix sized and each element of the matrix stores a symbol indicating corresponding pixel color There are only colors C cyan M magenta Y yellow W white G grey B black The photo is considered black and white if it has only white black and grey pixels in it If there are any of cyan magenta or yellow pixels in the photo then it is considered colored ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "We need to do exactly what is written in the task to consider all of the characters and if there is at least one of the set C M Y print Color else Black White "}
{"statement": "Vasya enjoys solving quizzes He found a strange device and wants to know how it works This device encrypted with the tree connected undirected graph without cycles with n vertices numbered with integers from 1 to n To solve this quiz you should guess this tree Fortunately this device can make one operation using which you should guess the cipher You can give the device an array d 1 d 2 ldots d n of non negative integers On the device there are n lamps i th of them is connected with i th vertex of the tree For all i the light will turn on the i th lamp if there exist such vertex of the tree with number j neq i that dist i j leq d j Let s define dist i j as the distance between vertices i and j in tree or number of edges on the simple path between vertices i and j Vasya wants to solve this quiz using leq 80 operations with the device and guess the tree Help him ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3400", "problem_editorial": "The solution will consist of two parts Let s divide all points into sets with equal distance to the vertex To do this we will do the following algorithm How to understand what set of points lies at a distance from the top of Let s fill with zeros and make for the first operation and for the second operation After that we will make operations with such arrays Those vertices whose bulbs did not light up during the first operation lie at a distance of Those that caught fire at the first but did not catch fire at the second operation lie at a distance of Finally those who caught fire during the second operation lie at a distance of Generalize this idea We will store the set of distances for which we already know the set of vertices at lying such distance from we will call them good distances Initially it is only vertex at distance and empty vertex set at distance We will also store between each pair of adjacent good distances those vertices for which the distance is greater than but less than Now let s iterate over pairs of adjacent good distances Take Now the sets of vertices lying at distances greater than but less than exactly and more than but less than can be obtained using the two operations described at the beginning With this action we make a good distance To do this in parallel for several pairs of adjacent good distances just iterate over pairs with even numbers and odd ones Then as each of the cases would not be adjacent pairs you can make two common operations Thus with the help of operations we will make the middle between all pairs of adjacent good distances also a good distance If we divide in half then for of divisions we will make all distances good At this part we will spend operations For each vertex at the distance of let s find the index of the ancestor vertex lying at a distance of which is the only one Suppose we want to do this for only one distance Note that if we make for all for some subset of vertices lying at a distance and for all other vertices then among the vertices at a distance will include those whose ancestor belongs to Then let s for all such that choose as the set of vertices such that contains th bit in binary notation and lies at a distance of Then for each vertex at a distance of we will know all the bits in the binary representation of its ancestor that is we will find this number This process can also be done in parallel if we take the distance giving the same remainder of dividing by Then since these distances are not close they will not interfere with each other At this part we will spend operations In total we get a solution using operations Complexity Number of operations "}
{"statement": "Sometimes it is not easy to come to an agreement in a bargain Right now Sasha and Vova can t come to an agreement Sasha names a price as high as possible then Vova wants to remove as many digits from the price as possible In more details Sasha names some integer price n Vova removes a non empty substring of consecutive digits from the price the remaining digits close the gap and the resulting integer is the price For example is Sasha names 1213121 Vova can remove the substring 1312 and the result is 121 It is allowed for result to contain leading zeros If Vova removes all digits the price is considered to be 0 Sasha wants to come up with some constraints so that Vova can t just remove all digits but he needs some arguments supporting the constraints To start with he wants to compute the sum of all possible resulting prices after Vova s move Help Sasha to compute this sum Since the answer can be very large print it modulo 10 9 7 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s count for each digit how many times it will be included in the final sum and in what place Let s denote as the length of the number Consider the digit at the position in the number If some part of the number to the left of the digit is removed then the current digit will remain in its place and we add the number of ways to remove the subsegment to the left to the answer multiplied by the current digit If the segment to the right is deleted then the place of the digit will change for all or The sum can be pre calculated for all values "}
{"statement": "As you know any problem that does not require the use of complex data structures is considered constructive You are offered to solve one of such problems You are given an array a of n non negative integers You are allowed to perform the following operation choose some non empty subsegment a l a l 1 ldots a r of the array a and a non negative integer k and assign value k to all elements of the array on the chosen subsegment The task is to find out whether operatorname MEX a can be increased by exactly one by performing such an operation In other words if before the operation operatorname MEX a m held then after the operation it must hold that operatorname MEX a m 1 Recall that operatorname MEX of a set of integers c 1 c 2 ldots c k is defined as the smallest non negative integer x which does not occur in the set c ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let the current value of mex equal to and the value of mex after performing operation equals to It s easy to see that in the resulting array there should exist element equals to if it doesn t exist the value of mex won t be equal to Also notice that should be equal to because this value didn t appear in the array before the operation and must appear there after performing the operation Consider the following cases If there exists such that let s find the minimum value and the maximum value such that It s easy to see that the performed operation should cover these elements We already know which value of to select Now notice that there are no profits from using longer segments because is already not greater than there are no elements equal to and longer segments may make less If there is no such that but there exists such that is already not greater than Similarly with the previous case we can find any such that and replace with In all other cases if there exist two indices such that we can replace one of these elements with In this case we will make equals to If there are no such indices equals to the length of the array and we cannot increment The only thing we have to do after considering cases is to check if the performed operation leads to correct value of Time complexity "}
{"statement": "Let s look at the following process initially you have an empty stack and an array s of the length l You are trying to push array elements to the stack in the order s 1 s 2 s 3 dots s l Moreover if the stack is empty or the element at the top of this stack is not equal to the current element then you just push the current element to the top of the stack Otherwise you don t push the current element to the stack and moreover pop the top element of the stack If after this process the stack remains empty the array s is considered There are samples of stack exterminable arrays 1 1 2 1 1 2 1 1 2 2 1 3 3 1 2 2 3 1 3 3 1 3 3 3 3 3 3 3 5 1 2 2 1 4 4 5 Let s consider the changing of stack more details if s 5 1 2 2 1 4 4 5 the top of stack is highlighted after pushing s 1 5 the stack turn into textbf 5 after pushing s 2 1 the stack turn into 5 textbf 1 after pushing s 3 2 the stack turn into 5 1 textbf 2 after pushing s 4 2 the stack turn into 5 textbf 1 after pushing s 5 1 the stack turn into textbf 5 after pushing s 6 4 the stack turn into 5 textbf 4 after pushing s 7 4 the stack turn into textbf 5 after pushing s 8 5 the stack is empty You are given an array a 1 a 2 ldots a n You have to calculate the number of its subarrays which are stack exterminable Note that you have to answer q independent queries ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Let s understand how calculate the array nxt such that nxtl is equal to the minimum index r l such that subarray al r is stack exterminable If there is no such index then nxtl 1 If we calculate this array then we solve this task by simple dynamic programming Let s calculate it in order nxtn nxtn 1 nxt1 by dynamic programming At first consider simple case If ai ai 1 then nxti i 1 Otherwise we have to add the block ai 1 anxti 1 of course nxti 1 should be not equal to 1 and check that ai a1 nxti 1 If this ai a1 nxti 1 also is not true then you have to add a new block a1 nxti 1 anxt1 nxti 1 and check the condition ai a1 nxt1 nxti 1 If this condition also is not try then you have to add a new block and so on It is correct solution but it can be too slowly Let s understand that we add blocks to ai until condition ai a1 nxt is holds Let s assume that we have an array nxtX this array contains a hashMaps for example you can use map in C such that nxtXi x is is equal to the minimum index r l such that subarray al r is stack exterminable and x ar 1 Then we can easily calculate the value nxti nxtXi 1 ai 1 Remains to understand how to calculate nxtXi For this we just can make an assignment nxtXi nxtXnxti 1 And then update nxtXi anxti 1 nxti 1 But I deceived you a little We can t make an assignment nxtXi nxtXnxti 1 because it is to slow Instead that you need to swap elements nxtXi and nxtXnxti 1 this can be done using the function swap in C or Java time complexity of swap if O 1 "}
{"statement": "Vladik was bored on his way home and decided to play the following game He took cards and put them in a row in front of himself Every card has a positive integer number not exceeding written on it He decided to find the longest subsequence of cards which satisfies the following conditions the number of occurrences of each number from to in the subsequence doesn t differ by more then from the number of occurrences of any other number Formally if there are cards with number on them in the subsequence than for all pairs of integers the condition must hold if there is at least one card with number on it in the subsequence then all cards with number in this subsequence must form a continuous segment in it For example the subsequence satisfies this condition while the subsequence doesn t Note that doesn t satisfy the first condition Please help Vladik to find the length of the longest subsequence that satisfies both conditions ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Suppose we have taken at least cards of each color and colors of them have cards Then the answer will look like Obviously if our sequence of cards allows us to take cards of each color then it allows to take and so on Lets binary search for value and check allowability this way Define bitmask dynamic programming as the number of colors for which we have taken element if we passed cards in the sequence and the colors which has bit equal to one in bitmask mask We will have two different transitions Iterate the new color which has zero bit in the mask to make the first transition and find its occurrence number in subarray The second transition is completely the same but we have to find occurrence number To find the occurrence number of some color in subarray we should maintain an array of the remaining cards for each color Finally find the maximal allowable and in dp calculated for find the maximal additional cards in This solution for colors of cards 8 in our case has complexity "}
{"statement": "Ralph is going to collect mushrooms in the Mushroom Forest There are directed paths connecting trees in the Mushroom Forest On each path grow some mushrooms When Ralph passes a path he collects all the mushrooms on the path The Mushroom Forest has a magical fertile ground where mushrooms grow at a fantastic speed New mushrooms regrow as soon as Ralph finishes mushroom collection on a path More specifically after Ralph passes a path the th time there regrow mushrooms less than there was before this pass That is if there is initially mushrooms on a path then Ralph will collect mushrooms for the first time mushrooms the second time mushrooms the third time and so on However the number of mushrooms can never be less than For example let there be mushrooms on a path initially The number of mushrooms that can be collected from the path is and when Ralph passes by from first to fourth time From the fifth time and later Ralph can t collect any mushrooms from the path but still can pass it Ralph decided to start from the tree How many mushrooms can he collect using only described paths ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "For collecting the most mushrooms when in a strongly connected component we can pass all the edges in the component until the mushrooms on the edges are all So we can run Tarjan s algorithm to find all the SCCs in time and calculate the sum of mushrooms picked in each component by binary search or maths knowledge in time Then we can regard each SCC as a new vertex and get a DAG and the remaining work is just to find the longest path on the DAG from a given vertex where the length of an edge is the number of mushrooms in it initially since we can only pass through it once We can use topological sort and apply dynamic programming on the DAG in time Overall the time complexity is "}
{"statement": "You are given a permutation p 1 p 2 ldots p n In one move you can swap two adjacent values You want to perform a minimum number of moves such that in the end there will exist a subsegment 1 2 ldots k in other words in the end there should be an integer i 1 leq i leq n k 1 such that p i 1 p i 1 2 ldots p i k 1 k Let f k be the minimum number of moves that you need to make a subsegment with values 1 2 ldots k appear in the permutation You need to find f 1 f 2 ldots f n ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "At first let s add to the answer number of inversions among numbers 1 2 k After that let s say that x k is one and x k is zero Then you need to calculate the smallest number of swaps to make segment 1 1 1 of length k appear in the permutation For this let s call pi the number of ones on the prefix For all si 0 we need to add min pi k pi to the answer it is an obvious lower bound and it is simple to prove that we always can do one operation to reduce this total value by one How to calculate this for each k Let s move k from 1 to n You can maintain number of inversions with BIT To calculate the second value you can note that you just need to find k2 th number k and add values at the left and add the right with different coefficients To maintain them you can recalculate everything when you are moving the median in heap But also it is possible to maintain the segment tree by pi and just take some sum "}
{"statement": "Rhodoks has a tree with n vertices but he doesn t remember its structure The vertices are indexed from 1 to n A segment l r 1 leq l leq r leq n is good if the vertices with indices l l 1 r form a connected component in Rhodoks tree Otherwise it is bad For example if the tree is the one in the picture then only the segment 3 4 is bad while all the other segments are good For each of the frac n n 1 2 segments Rhodoks remembers whether it is good or bad Can you help him recover the tree If there are multiple solutions print any It is guaranteed that the there is at least one tree satisfying Rhodoks description ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3400", "problem_editorial": "Thank dario2994 the key part of the proof is from him hint1If interval are all good and then is good too "}
{"statement": "Magnus decided to play a classic chess game Though what he saw in his locker shocked him His favourite chessboard got broken into pieces each of size by is And what s even worse some squares were of wrong color th square of the th row of th piece of the board has color being black and being white Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard Every square has its color different to each of the neightbouring by side squares in a valid board Its size should be by You are allowed to move pieces but ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Since is odd exactly pieces of the board will have upper left corner colored black and exactly white Let s check every option to choose two pieces of the board so their upper left corners will be painted white when we assemble the board calculate the number of board cells that have to be recolored and find the minimum of this value among all possible choices "}
{"statement": "We just discovered a new data structure in our research group a It s very useful for natural language processing Given three languages and three suffixes a suffix three can determine which language a sentence is written in It s super simple 100 ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The simplest way to solve it is to use your language s builtin string methods like It might be different in your preferred language Alternatively if you know how to access the individual letters of a string then you may implement something similar to yourself To print the required output you can just use something like if s endswith po print FILIPINO if s endswith desu or s endswith masu print JAPANESE if s endswith mnida print KOREAN Alternatively notice that you can simply check the last letter since and are distinct so it can be simplified slightly One can even write a Python one liner for a single test case print o FILIPINO a KOREAN u JAPANESE input 1 "}
{"statement": " There is an array a of n numbers In one query you can ask the position of the second maximum element in a subsegment a l r Find the position of the maximum element in the array in no more than queries A subsegment a l r is all the elements a l a l 1 a r After asking this subsegment you will be given the position of the second maximum from this subsegment array ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "SolutionLet s solve for some subsegment and Now let s check if the max element is in or Let s find the second max element in and call it Now let s think that is less than for symmetrical reasons Now if we ask and second max is still it means that maximum element is in otherwise it s in Now we ve shrunk the segment by a factor of two So the resulting number of queries is "}
{"statement": "You are given two integers x and y A sequence a of length n is called if a 1 x and for all 1 i le n the value of a i is either a i 1 y or a i 1 bmod y Here x bmod y denotes the remainder from dividing x by y Determine if there exists a modular sequence of length n with the sum of its elements equal to S and if it exists find any such sequence ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2300", "problem_editorial": "SolutionLet s see what the answer will look like first there will be a prefix of the form and then there will be some number of blocks of the form We can subtract the number from all the elements of the sequence and then divide all the elements by all the elements will be divisible by since they initially had a remainder of Let Then our sequence will start with and then there will be blocks of the form Let s calculate these values the minimum length of a sequence of blocks of the form with a sum of This value can be calculated for all numbers from to using dynamic programming If we have processed all values from to then for we have calculated the minimum length and we can update the value of for a total of values not exceeding In this same we can store through which values we were recalculated for the restoration of the answer Now we can iterate over the length of the first block of the form Then we know the sum of the remaining blocks and using the precalculated we can determine whether the desired sequence can be formed or not "}
{"statement": "Dreamoon saw a large integer written on the ground and wants to print its binary form out Dreamoon has accomplished the part of turning into its binary format Now he is going to print it in the following manner He has an integer and can only perform the following two operations in any order for unlimited times each Print n in binary form without leading zeros each print will append to the right of previous prints Increase n by 1 Let s define an as a sequence of operations that can successfully print binary representation of without leading zeros and ends with a print operation i e operation 1 Dreamoon wants to know how many different ideal sequences are there and the length in operations of the shortest ideal sequence The answers might be large so please print them modulo 1000000007 Let s define the string representation of an ideal sequence as a string of and where the th character in the string matches the th operation performed Two ideal sequences are called different if their string representations are different ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "So let s look into how to calculate the value for a given pair If the value of is equal to or greater than than is because if is less than would make length of the new partition less than the previous partition thus its value would be lesser And if can t be the value of is always a valid choice because it would make the length of the new partition greater than the previous one So for each length if we know the order of and in time we can calculate k in time can be easily shown by assuming One way of doing such is using prefix doubling algorithm for suffix array construction to build a RMQ structure for query in time The prefix doubling algorithm requires precompute time Note there is still a various of ways to do this part of task in the same or better time complexties And for the shortest length part we can compute the minimal parts needed so far for each state along with the preivous dp Then compare all states ends with Overall we can solve this problem in with caution in details like boundaries and module operations time complexity Note the sample code use a nlgnlgn version of prefix doubling algorithm sample code 8215216 "}
{"statement": "Bash wants to become a Pokemon master one day Although he liked a lot of Pokemon he has always been fascinated by Bulbasaur the most Soon things started getting serious and his fascination turned into an obsession Since he is too young to go out and catch Bulbasaur he came up with his own way of catching a Bulbasaur Each day he takes the front page of the newspaper He cuts out the letters one at a time from anywhere on the front page of the newspaper to form the word without quotes and sticks it on his wall Bash is very particular about case the first letter of must be upper case and the rest must be lower case By doing this he thinks he has caught one Bulbasaur He then repeats this step on the left over part of the newspaper He keeps doing this until it is not possible to form the word from the newspaper Given the text on the front page of the newspaper can you tell how many Bulbasaurs he will catch today Note ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Since we are allowed to permute the string in any order to find the maximum occurences of the string Bulbasaur we simply keep the count of the letters B u l b a s r Now the string Bulbasaur contains 1 B 2 u 1 l 2 a 1 s 1 r and 1 b thus the answer to the problem is Min count B count b count s count r count l count a 2 count u 2 You can maintain the counts using an array "}
{"statement": "There are n boxes placed in a line The boxes are numbered from 1 to n Some boxes contain one ball inside of them the rest are empty At least one box contains a ball and at least one box is empty In one move you choose a box with a ball inside and an adjacent empty box and move the ball from one box into another Boxes i and i 1 for all i from 1 to n 1 are considered adjacent to each other Boxes 1 and n are How many different arrangements of balls exist after k moves are performed Two arrangements are considered different if there is at least one such box that it contains a ball in one of them and doesn t contain a ball in the other one Since the answer might be pretty large print its remainder modulo 10 9 7 ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Consider a harder problem For each from to what s the number of arrangements that have as the smallest number of operations needed that obtain them That would help us solve the full problem You just have to sum up the answer for such that they have the same parity as since once the arrangement is obtained you can perform two moves on it and change nothing Turns out calculating the smallest number of operations for a fixed arrangement is not that hard Let the initial arrangement have balls in boxes for some the fixed arrangement have balls in boxes Then the first ball in the fixed arrangement has to come from the box of the first ball in the initial one And so on So the answer is at least That estimate can be achieved Just move the balls one by one from left to right So that amount is actually the smallest possible That can lead to a dynamic programming solution Following this construction let be the number of ways to fill the first boxes with balls such that the smallest number of operations to move the first balls of the initial arrangement into their new boxes is The transitions are trivial Either leave the th all indexed box empty and go to or put a ball into it and go to The answer will be in for all of the same parity as That solution is that is supposedly too much although unfortunately can be squeezed if you try hard enough That solution has surprisingly little to do with the full one but gives us some insight into the problem For a faster solution let s change the way we calculate the smallest number of operations What is exactly Let Then on its path the ball crosses the spaces between boxes and and so on until and The amount is exactly Thus we could instead calculate the number of balls that move across each space between the boxes along their paths and add up the values Now it s some sort of balance We could also denote balls going to the right as positive values and going to the left as negative values Notice how if some ball moves from a box to a box in the optimal construction then there is no ball that moves from to Just because the balls never cross each other paths So the absolute value of the balance is still what we have to add up Intuitively the value for space between boxes and is equal to the signed difference between the initial number of balls to the left of it and the one in the current arrangement If the numbers are different then we move exactly this amount of ball from one side to another Now we can pack it into another dynamic programming Let be the number of ways to fill the first boxes such that the current balance is and the smallest number of operations to achieve that is The transitions are the following If we place a ball into box the balance changes to is whether there was a ball in box initially and gets added to If we don t place a ball the balance changes to and gets added to Notice that at the end the balance will be if and only if we placed as many boxes as there were initially So the answer will be in for all of the same parity as That solution is still and even worse in the way that can range from to doubling the runtime However notice how can t change by more than on each step At the same time always gets added to Thus to make equal to at the end we would have to add to And since can t exceed actually can t exceed more or less So that solution can be optimized to by reducing the second dimension of the dynamic programming In order to store values from to in an array shift them up by So the values become from to In order to avoid memory instead of storing all layers of the dp only store the current and the next one That will make it memory Overall complexity "}
{"statement": "Innokentiy likes tea very much and today he wants to drink exactly cups of tea He would be happy to drink more but he had exactly tea bags of them are green and are black Innokentiy doesn t like to drink the same tea green or black more than times in a row Your task is to determine the order of brewing tea bags so that Innokentiy will be able to drink cups of tea without drinking the same tea more than times in a row or to inform that it is impossible Each tea bag has to be used exactly once ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Let s use greedy to solve this problem On the current step we choose tea which left more but if the last cups were equal we need to use the other tea If we can t use the other tea there is no answer and we need to print So we need to store the number of last cups which were equals and how many of green and black tea left we greedily build the answer If we use all tea with this algorithm we found the answer and it is guaranteed that it is correct answer "}
{"statement": "Polycarp watched TV show where jury members one by one rated a participant by adding him a certain number of points may be negative i e points were subtracted Initially the participant had some score and each the marks were one by one added to his score It is known that the th jury member gave points Polycarp does not remember how many points the participant had before this marks were given but he remembers that among the scores announced after each of the judges rated the participant there were values it is guaranteed that all values are distinct It is possible that Polycarp remembers not all of the scores announced i e Note that the initial score wasn t announced Your task is to determine the number of options for the score the participant could have before the judges rated the participant ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "At first let s calculate an array where equals to sum of the first jury points Now consider the value Let the initial score equals to Here we need to iterate by from to how many members of jury rated the participant until Polycarp remembered Then Insert each initial scores in So we got all possible initial participant scores After that it is left only to check correctness of each initial score Let the another candidate on initial score equals to We need to put in set all values for all from to After that we need to check that all elements of array can be find in If it is true the participant could has initial score points so we need to increase the answer on one "}
{"statement": "A few years ago Hitagi encountered a giant crab who stole the whole of her body weight Ever since she tried to avoid contact with others for fear that this secret might be noticed To get rid of the oddity and recover her weight a special integer sequence is needed Hitagi s sequence has been broken for a long time but now Kaiki provides an opportunity Hitagi s sequence has a length of Lost elements in it are denoted by zeros Kaiki provides another sequence whose length equals the number of lost elements in i e the number of zeros Hitagi is to replace each zero in with an element from so that Hitagi knows however that If the resulting sequence is an increasing sequence then it has the power to recover Hitagi from the oddity You are to determine whether this is possible or Kaiki s sequence is just another fake In other words you should detect whether it is possible to replace each zero in with an integer from so that each integer from is used exactly once and the resulting sequence is increasing ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "The statement laid emphasis on the constraint that the elements are pairwise distinct How is this important In fact this implies that if the resulting sequence is increasing then swapping any two of its elements will result in another sequence which is not increasing And we re able to perform a swap on any resulting sequence if and only if Thus if the answer would always be Yes For cases where we replace the only zero in sequence with the only element in and check the whole sequence Hackable solutions include those only checking the replaced element and its neighbours and those missing the replaced element Figure out why solution 2 is not hackable "}
{"statement": "You are given an array a 1 a 2 dots a n and an integer k You are asked to divide this array into k non empty consecutive subarrays Every element in the array should be included in exactly one subarray Let f i be the index of subarray the i th element belongs to Subarrays are numbered from left to right and from 1 to k Let the cost of division be equal to sum limits i 1 n a i cdot f i For example if a 1 2 3 4 5 6 7 and we divide it into 3 subbarays in the following way 1 2 3 4 5 6 7 then the cost of division is equal to 1 cdot 1 2 cdot 1 3 cdot 1 4 cdot 2 5 cdot 2 6 cdot 3 7 cdot 3 9 Calculate the maximum cost you can obtain by dividing the array a into k non empty consecutive subarrays ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s denote as just a suffix sum And let be the position where starts the th subarray obviously and Then we can make an interesting transformation So our task is equivalent to choosing sum of all array and different suffix sums And we want to maximize their total sum That s why we can just greedily take maximum suffix sums along with sum of all array "}
{"statement": "You are given a simple weighted connected undirected graph consisting of n vertices and m edges A path in the graph of length k is a sequence of k 1 vertices v 1 v 2 dots v k 1 such that for each i 1 le i le k the edge v i v i 1 is present in the graph A path from some vertex v also has vertex v 1 v Note that edges and vertices are allowed to be included in the path multiple times The weight of the path is the total weight of edges in it For each i from 1 to q consider a path from vertex 1 of length i of the maximum weight What is the sum of weights of these q paths Answer can be quite large so print it modulo 10 9 7 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 1, "problem_dificulty": "2700", "problem_editorial": "Let s observe what does the maximum weight of some fixed length path look like Among the edges on that path the last one has the maximum weight If it wasn t then the better total weight could be achieved by choosing a bigger weight edge earlier and going back and forth on it for the same number of steps It actually helps us arrive to a conclusion that all optimal paths look like that some simple path to an edge and then back and forth movement on it Any simple path in the graph has its length at most Let s separate the queries into two parts will be handled in a straightforward manner Let be the maximum weight of a path that ends in and has exactly edges in it That s pretty easy to calculate in You can also think of this as some kind of Ford Bellman algorithm let on the th step be the maximum weight of the path to of length Iterate over all edges and try to update and for each edge that s what I do in my solution if you refer to it Now for There was a very common assumption that after a bit more steps some edge will become the most optimal and will stay the most optimal until the end of time However that a bit cut off is in fact too high to rely on it must be somewhere around So the best path of length exactly ending in each vertex is Let the maximum weight adjacent edge to vertex be So the path of length will have weight Treat it like a line with coefficients and How do determine which line is the best for some Sure experienced participants will immediately answer convex hull Build a lower envelope of the convex hull of these lines If was a little smaller than we could query with binary search for each the same how convex hull is usually used We have to examine the hull further Each line in it becomes the best in some point then stays the best for some interval and then never appears the best again What are these line changing points Well it s just the intersection point of the adjacent lines in the hull So having these points and the parameters of the line we can calculate its contribution to the answer with a sum of arithmetic progression formula There were just lines in the hull so you can build the hull in any complexity I think I saw up to performances in the participants codes There is a cool solution that involves some kind of Divide Conquer on these lines I personally thought of it in a sense of traversing a Li Chao tree without actually building it If anyone wants to explain this solution feel free to do it in comments Overall complexity "}
{"statement": "Let s denote as the number of divisors of a positive integer You are given three integers and Your task is to calculate the following sum Find the sum modulo ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Let us consider each prime in one step the upper limit for is recorded So if we fixed the power of 2 in each like then their upper limit becomes and the power of 2 in their multiplication is just x y z Let us denote for the answer to the original problem that s upper limit is And their can only use the prime factors which are not less than Let the next prime to be so we can try to fix the power of in and get the new upper limit So we can do transform like this sum of Check my code here 2404223 Also you can check rng 58 solution here http codeforces com blog entry 5600 If you have any problems you can ask here "}
{"statement": "You are given an integer n and an integer k In one step you can do one of the following moves decrease n by 1 divide n by k if n is divisible by k For example if n 27 and k 3 you can do the following steps 27 rightarrow 26 rightarrow 25 rightarrow 24 rightarrow 8 rightarrow 7 rightarrow 6 rightarrow 2 rightarrow 1 rightarrow 0 You are asked to calculate the minimum number of steps to reach 0 from n ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "It s always optimal to divide by whenever it s possible since dividing by equivalent to decreasing by The only problem is that it s too slow to just subtract from each time since in the worst case we can make operations Consider case and But if we d look closer then we can just replace times of subtract with one subtraction of And to make is divisible by we should make subtractions "}
{"statement": "After battling Shikamaru Tayuya decided that her flute is too predictable and replaced it with a guitar The guitar has 6 strings and an infinite number of frets numbered from 1 Fretting the fret number j on the i th string produces the note a i j Tayuya wants to play a melody of n notes Each note can be played on different string fret combination The easiness of performance depends on the difference between the maximal and the minimal indices of used frets The less this difference is the easier it is to perform the technique Please determine the minimal possible difference For example if a 1 1 2 2 3 3 and the sequence of notes is 4 11 11 12 12 13 13 corresponding to the second example we can play the first note on the first string and all the other notes on the sixth string Then the maximal fret will be 10 the minimal one will be 3 and the answer is 10 3 7 as shown on the picture ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Consider all possible frets we may need to use To do this we sort all the pairs bj ai j lexicographically Now we need to find a subsegment with the minimal range containing the first fields and also so that all numbers from 1 to n occur among the second fields so it will mean that for each note there is at least one string fret combination For each l denote the minimal right l so that l right l is a valid subsegment It s easy to see that right l right l 1 because if l 1 right l 1 contains all numbers from 1 to n among the second fields then so does l right l 1 So to find all right l one can just use two pointers maintaining the set of notes that occur on the segment Once we calculated it we just print the minimal difference between the first fields of the endpoints of all possible segments l right l The final complexity is O nmlog nm "}
{"statement": "Hossam bought a new piece of ground with length n and width m he divided it into an n cdot m grid each cell being of size 1 times1 Since Hossam s name starts with the letter he decided to draw the capital letter by building walls of size 1 times1 on some squares of the ground Each square 1 times1 on the ground is assigned a quality degree perfect medium or bad The process of building walls to form up letter has the following constraints The letter must consist of one horizontal and two vertical lines The vertical lines must not be in the same or neighboring columns The vertical lines must start in the same row and end in the same row and thus have the same length The horizontal line should connect the vertical lines but must not cross them The horizontal line can be in any row between the vertical lines not only in the middle except the top and the bottom one With the horizontal line in the top row the letter looks like and in the bottom row like It is forbidden to build walls in cells of bad quality You can use at most one square of medium quality You can use any number of squares of perfect quality Find the maximum number of walls that can be used to draw the letter Check the note for more clarification ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Let s preprocess the following data for each cell 1 first medium cell above current cell 2 first medium cell below current cell 3 first bad cell above current cell 4 first bad cell below current cell Then we will try to solve the problem for each row i and 2 columns j k Now we have a horizontal line in row i and we can calculate the length of vertical line by the following There is two cases In case of the horizontal line contains one letter m For each column j k get first cell above it the don t contain or m and first cell below it the don t contain or m In case of the horizontal line doesn t contain any letter m We will try to get the 4 cells as it contains letter m but in this case we will 4 trials for each cell from the 4 cells we allow to have only one letter m in that line After getting above cells and below cells for each line the starting cell will be the maximum between the two above cells and the ending cell will be the minimum between the two below cells Then we need to check that starting cell is above the current row i to avoid making letter n instead of HAnd check that ending cell is below the current row i to avoid making letter u instead of H Since n m has the same maximum limit 400 Thus time complexity of this solution is "}
{"statement": "You are given an integer n and an array a of length n 1 whose elements are either 0 or 1 Let us define the of a permutation dagger p of length m 1 m leq n by the following process Let G be a graph of m vertices labeled from 1 to m that does not contain any edges For each i from 1 to m 1 perform the following operations define u and v as the unique vertices in the weakly connected components ddagger containing vertices p i and p i 1 respectively with only incoming edges dagger dagger in graph G add a directed edge from vertex v to u if a p i 0 otherwise add a directed edge from vertex u to v if a p i 1 Note that after each step it can be proven that each weakly connected component of G has a unique vertex with only incoming edges Then the value of p is the number of incoming edges of vertex 1 of G For each k from 1 to n 1 find the sum of values of all k permutations of length k Since this value can be big you are only required to compute this value under modulo 998 244 353 dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ddagger The weakly connected components of a directed graph is the same as the components of the undirected version of the graph Formally for directed graph G define a graph H where for all edges a to b in G you add an undirected edge a leftrightarrow b in H Then the weakly connected components of G are the components of H dagger dagger Note that a vertex that has no edges is considered to have only incoming edges ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "We record an operation of adding edge as Hint 1 Only operation can contribute Hint 2 Using dynamic programming let denote the number of ways to let vertices form a tree with root considering only the first operations We can observe Only operation can contribute If vertices have already formed a tree with root then operation can contribute Using dynamic programming let denote the number of ways to let vertices form a tree with root considering only the first operations For we have and Explanation Consider inserting the operation in the sequence of the first operations If no matter where it is inserted it will always form a tree with root so If only inserting at the end is invalid so This is because if you insert at the end of the operations we will add a edge from to which won t form a tree of root For computing the answer we have Explanation represents the contribution of previous operations No matter where operation is inserted the contribution of previous operations won t change means the contribution of operation "}
{"statement": "Alice has a cute cat To keep her cat fit Alice wants to design an exercising walk for her cat Initially Alice s cat is located in a cell x y of an infinite grid According to Alice s theory cat needs to move exactly a steps left from u v to u 1 v exactly b steps right from u v to u 1 v exactly c steps down from u v to u v 1 exactly d steps up from u v to u v 1 Note that the moves can be performed in an For example if the cat has to move 1 step left 3 steps right and 2 steps down then the walk right down left right right down is valid Alice however is worrying that her cat might get lost if it moves far away from her So she hopes that her cat is in the area x 1 x 2 times y 1 y 2 i e for every cat s position u v of a walk x 1 le u le x 2 and y 1 le v le y 2 holds Also note that the cat can visit the same cell multiple times Can you help Alice find out if there exists a walk satisfying her wishes Formally the walk should contain exactly a b c d unit moves a to the left b to the right c to the down d to the up Alice can do the moves in order Her current position u v should satisfy the constraints x 1 le u le x 2 y 1 le v le y 2 The staring point is x y You are required to answer t test cases ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "The key observation is x axis and y axis is independent in this task as the area is a rectangle Therefore we should only consider 1D case x axis for example The optimal path to choose alternates between right and left moves until only one type of move is possible And sometimes there is no place to make even one move which has to handled separately So the verdict is if and only if and or "}
{"statement": "You ve got an cube split into unit cubes Your task is to number all unit cubes in this cube with positive integers from to so that each number was used as a cube s number exactly once for each unit cubes with numbers and were neighbouring that is shared a side for each there were at least two different subcubes with sizes made from unit cubes which are numbered with consecutive numbers That is there are such two numbers and that the unit cubes of the first subcube are numbered by numbers and the unit cubes of the second subcube are numbered by numbers Find and print the required numeration of unit cubes of the cube ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "We will construct solution recursively For every k it is possible construct parallelepiped k k k 1 that contains 2 cubes k k k For k 2 solution is oblivious How to build solutions for k 2 is shown in following picture Red and blue cubes are start and end of chain Firstly you should build one floor over Then you should build 2 layers on two opposite sides For every n you can build parallelepiped n n n 1 and drop one layer for getting cube n n n "}
{"statement": "There are b boys and g girls participating in Olympiad of Metropolises There will be a board games tournament in the evening and n participants have accepted the invitation The organizers do not know how many boys and girls are among them Organizers are preparing red badges for girls and blue ones for boys Vasya prepared n 1 decks of badges The i th where i is from 0 to n inclusive deck contains i blue badges and n i red ones The total number of badges in any deck is exactly n Determine the number of decks among these n 1 that Vasya should take so that there will be a suitable deck no matter how many girls and boys there will be among the participants of the tournament ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Vasya must take one deck for each possible combination where and Let s determine how many girls can come for the game at least at most All intermediate values are also possible to the answer is just "}
{"statement": "You are given three integers n a and b Determine if there exist two permutations p and q of length n for which the following conditions hold The length of the longest common prefix of p and q is a The length of the longest common suffix of p and q is b A permutation of length n is an array containing each integer from 1 to n exactly once For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "If we can always find such pair here is a possible construction The red part is their longest common prefix and the blue part is their longest common suffix Otherwise the two permutations must be equal so such pair exists iff "}
{"statement": "Recently Petya walked in the forest and found a magic stick Since Petya really likes numbers the first thing he learned was spells for changing numbers So far he knows only two spells that can be applied to a integer If the chosen number a is even then the spell will turn it into frac 3a 2 If the chosen number a is greater than one then the spell will turn it into a 1 Note that if the number is even and greater than one then Petya can choose which spell to apply Petya now has only one number x He wants to know if his favorite number y can be obtained from x using the spells he knows The spells can be used any number of times in any order It is not required to use spells Petya can leave x as it is ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "cannot be transformed into any other number can be transformed into or and can be transformed only into It means that if then only is reachable and if or then should be less than Otherwise we can make as large as we want so if any is reachable "}
{"statement": "You are given several queries Each query consists of three integers p q and b You need to answer whether the result of p q in notation with base b is a finite fraction A fraction in notation with base b is finite if it contains finite number of numerals after the decimal point It is also possible that a fraction has zero numerals after the decimal point ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "First if and are not coprime divide them on Fraction is finite if and only if there is integer such that Since and are being coprime now all prime factors of are prime factors of Now we can do iterations while If after iterations there are prime factors of which are not prime factors of fraction is else fraction is But this solution works in Let s add in iterations and name iterations when changes iterations of the first type and when it doesn t change iterations of the second type Iterations of second type works summary in Number of iterations of the first type is too but on each iteration decreases twice Note that number of iterations in Euclid s algorithm is equal to number of this decreases So iterations of first type works in summary Total time complexity is Solution "}
{"statement": "Soroush and Keshi each have a labeled and rooted tree on n vertices Both of their trees are rooted from vertex 1 Soroush and Keshi used to be at war After endless decades of fighting they finally became allies to prepare a Codeforces round To celebrate this fortunate event they decided to make a memorial graph on n vertices They add an edge between vertices u and v in the memorial graph if of the following conditions hold One of u or v is the ancestor of the other in Soroush s tree Neither of u or v is the ancestor of the other in Keshi s tree Here vertex u is considered ancestor of vertex v if u lies on the path from 1 the root to the v Popping out of nowhere Mashtali tried to find the maximum clique in the memorial graph for no reason He failed because the graph was too big Help Mashtali by finding the size of the maximum clique in the memorial graph As a reminder clique is a subset of vertices of the graph each two of which are connected by an edge ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Let s start with some observations Take any clique in the memorial graph Notice that the vertices of are a subset of a path from root to some leaf in Soroush s tree So it s sufficient to solve the task for every leaf in Soroush s tree specifically we should consider subsets of the paths starting from the root and ending in a leaf in Soroush s tree Assume you have a data structure that supports the following operations Insert a vertex Erase a vertex Among the vertices inside it find the biggest set of vertices such that none of them is the ancestor of the other in Keshi s tree To solve the task start doing DFS from the root of Soroush s tree Every time you visit a new vertex add using the st operation Every time you finish doing DFS in a vertex erase using the nd operation It s easy to see that the vertices in the data structure always form a path from root to some vertex in Soroush s tree The answer to the task is the maximum size of in the rd operation for every leaf of Soroush s tree when adding has been the last operation in the data structure In other words where is the size of in the rd operation whenever you reach a leaf while doing DFS in Soroush s tree When adding a vertex to the data structure if no vertex existed such that was in s subtree in Keshi s tree consider the following cases If no ancestor of was in greedily add to Otherwise let that ancestor be erase from and add instead On the other hand if such a vertex already existed in we won t add to based on the greedy solution mentioned above Whatever notation used from here onwards refers to Keshi s tree unless stated Do a DFS on the tree and find the starting time finishing time for each vertex It s widely known that vertex is an ancestor of vertex and Observation for any pair of vertices and segments and either don t share an element or one of them lies completely inside the other To construct the aforementioned data structure Let the set be a maximal set of the vertices that form a clique in the memorial graph For each vertex we store a pair in Now to check whether any vertex in the subtree of vertex exists in Let be the first pair in such that the first element in If s second element s finishing time is less than then s second element is in s subtree otherwise it s not Now to check whether any ancestor of is in or not Let be the first pair in such that s first element is less than it can be proved that if an ancestor of exists in then thus we can check if is in the subtree of s second element by the aforementioned observation Doing the erase operation is also possible by keeping a history of the deleted elements from the set complexity "}
{"statement": "Santa Claus decided to disassemble his keyboard to clean it After he returned all the keys back he suddenly realized that some pairs of keys took each other s place That is Santa suspects that each key is either on its place or on the place of another key which is located exactly where the first key should be In order to make sure that he s right and restore the correct order of keys Santa typed his favorite patter looking only to his keyboard You are given the Santa s favorite patter and the string he actually typed Determine which pairs of keys could be mixed Each key must occur in pairs ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Denote the two strings from the input by s and t It s enough to find all pairs of distinct si and ti and then do the following Ensure that each symbol is in no more than one different pair Ensure that if symbol c is in a pair with another symbol d then each occurrence of c in s on the i th place takes place iff ti d and vice versa If at least one of these conditions fails there is no answer otherwise it s enough to print the obtained pairs "}
{"statement": "You are given a string s consisting only of characters or Let s be the length of s You are asked to choose some integer k k 0 and find a sequence a of length k such that 1 le a 1 a 2 dots a k le s a i 1 1 a i for all i from 2 to k The characters at positions a 1 a 2 dots a k are removed the remaining characters are concatenated without changing the order So in other words the positions in the sequence a should not be adjacent Let the resulting string be s s is called sorted if for all i from 2 to s s i 1 le s i Does there exist such a sequence a that the resulting string s is sorted ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "There are several different ways to solve this problem In my opinion the two easiest solutions are notice that in the sorted string there is a prefix of zeroes and a suffix of ones It means that we can iterate on the prefix from which we remove all ones and remove all zeroes from the suffix we obtain If we try to remove two adjacent characters then we cannot use this prefix if there is a substring before the substring in our string then from both of the substrings at least one character remains so if the first occurrence of is earlier than the last occurrence of there is no answer Otherwise the answer always exists "}
{"statement": "You are given a tree an undirected connected acyclic graph consisting of n vertices and n 1 edges A number is written on each edge each number is either 0 let s call such edges 0 edges or 1 those are 1 edges Let s call an ordered pair of vertices x y x ne y if while traversing the simple path from x to y we never go through a 0 edge after going through a 1 edge Your task is to calculate the number of pairs in the tree ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Let s divide all valid pairs into three categories the ones containing only edges on the path the ones containing only edges and the ones containing both types of edges To calculate the number of pairs containing only edges we may build a forest on the vertices of the original graph and edges and choose all pairs of vertices belonging to the same connected components of this forest we can find all connected components with DSU or any graph traversal algorithm The same can be done for the pairs containing only edges If a path from to is valid and contains both types of edges then there exists a vertex such that the simple path from to goes only through edges and the simple path from to goes only through edges So let s iterate on this vertex and choose some other vertex from its component in graph as and some other vertex from its component in graph as and add the number of ways to choose them to the answer "}
{"statement": "One day Kefa the parrot was walking down the street as he was on the way home from the restaurant when he saw something glittering by the road As he came nearer he understood that it was a watch He decided to take it to the pawnbroker to earn some money The pawnbroker said that each watch contains a serial number represented by a string of digits from to and the more quality checks this number passes the higher is the value of the watch The check is defined by three positive integers and The watches pass a check if a substring of the serial number from to has period Sometimes the pawnbroker gets distracted and Kefa changes in some substring of the serial number all digits to in order to increase profit from the watch The seller has a lot of things to do to begin with and with Kefa messing about he gave you a task to write a program that determines the value of the watch Let us remind you that number is called a period of string if for all from 1 to ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "At first we calculate the hash for all line elements depending on their positions That is the hash of the number standing on the th position will be equal to where is the base of the hash We construct the segment tree of sums which support a group modification for all hashes Thus we can perform queries for modification in It remains to deal with the queries of the second type Let us assume that we want to process the query 2 Obviously the substring from to have a period if a substring from to is equal to substring from to We can find out the sum of hashes at the subsegment with the help of the sums tree so we can compare the two strings in Asymptotics Solution "}
{"statement": "In the Wonderful Metropolis of the Future there is no need in subway train drivers Due to the technological progress they were replaced by the Artificial Intelligence AI Unfortunately one day the predictions of sci fi writers came true the AI rebelled and now there is an uncontrollable train in the subway It can be dangerous Your task is to find the train and stop the AI The subway of the Metropolis is one line regular straight line with no self intersections with n stations indexed consecutively from 1 to n At each moment the train is at some station You need to determine the index of this station so that the train would be secured To find the train dispatcher Sarah gave you a gadget that allows you to select arbitrary numbers l and r l le r and then check whether the train is located on a station with index between l and r inclusive Unfortunately recharging of the gadget takes some time and every time you use it as soon as possible so between two applications of the gadget the train can move to any station that is at most k stations away Formally if the train was at the station x when the gadget was applied then at the next application of the gadget the train can appear at any station y such that max 1 x k leq y leq min n x k Note that AI is not aware that you are trying to catch the train so it makes all moves according to its predefined plan After an examination of the gadget you found that it is very old and can hold no more than 4500 applications after which it will break and your mission will be considered a failure Can you find the station with the train using no more than 4500 applications of the gadgets ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Notice that we can make segment in which we are located small enough using binary search Let be the last segment about which we knew for sure that train is in it at the beginning it s Let Let s ask about segment If we receive answer YES after this query train for sure will be in segment otherwise in So after each query length of segment is divided by and increased by After segment length becomes irreducible let s ask about some random station in this segment If we guessed right let s finish the program otherwise make the binary search again To get the OK let s make one more observation for all binary searches except the first one initial segment can be made instead of "}
{"statement": "Little Artem is fond of dancing Most of all dances Artem likes rueda Cuban dance that is danced by pairs of boys and girls forming a circle and dancing together More detailed there are pairs of boys and girls standing in a circle Initially boy number dances with a girl number boy number dances with a girl number and so on Girls are numbered in the clockwise order During the dance different moves are announced and all pairs perform this moves While performing moves boys move along the circle while girls always stay at their initial position For the purpose of this problem we consider two different types of moves Value and some direction are announced and all boys move positions in the corresponding direction Boys dancing with even indexed girls swap positions with boys who are dancing with odd indexed girls That is the one who was dancing with the girl swaps with the one who was dancing with the girl number while the one who was dancing with girl number swaps with the one who was dancing with the girl number and so one It s guaranteed that is even Your task is to determine the final position of each boy ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "The key in this problem is that order of all elements in odd positions and in even positions is the same Let s say we have 2 arrays 1 3 5 and 2 4 odd positions and even positions Now if we call 2nd commands we just swap these 2 arrays but order is the same Obviously 1st command also keeps the order By order I mean cyclic order right neighbor is the same in cycle position Let s just keep the position of 1st boy and 2nd boy Now if we apply 1st operation we move it by X or X Second type of the query just swaps the positions In the end we can construct the answer if we know positions of 1st and 2nd boys "}
{"statement": "The government of Berland decided to improve network coverage in his country Berland has a unique structure the capital in the center and n cities around the capital The capital already has a good network coverage so the government ignores it but the i th city contains a i households that require a connection The government designed a plan to build n network stations between all pairs of neighboring cities which will maintain connections only for these cities In other words the i th network station will provide service only for the i th and the i 1 th city the n th station is connected to the n th and the 1 st city All network stations have capacities the i th station can provide the connection to at most b i households Now the government asks you to check can the designed stations meet the needs of all cities or not that is is it possible to assign each household a network station so that each network station i provides the connection to at most b i households ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "There are plenty of different solutions to this problem Here is one that doesn t use Hall s theorem Let s look at pair as fuction how many connections will be left for the th city if we take connections from the th station This function has the following structure there is a minimum required let s name it to meet the needs of the th city and with borrowed connections there will be free connections to the th city Increasing by some we can get free connections but there is upper bound to number of free connections In other words the function where For example let s calculate the corresponding coefficients for the th function if then and if then and Why did we define such functions If we can calculate result function then we can check the possibility of meeting all needs by checking that this fuction exists and i e the minimum free can be used as borrowed Fortunately it turns out that the superposition is either don t exists if for example or it has the same structure as any function So we can calculate in one pass and find the answer We will skip the detailed formulas to calculate you can either find them by yourself or look at function in author s solution The resulting complexity is "}
{"statement": "You are given n points on the plane The polygon formed from all the n points is that is the polygon is convex and there are no three collinear points i e lying in the same straight line The points are numbered from 1 to n in clockwise order We define the distance between two points p 1 x 1 y 1 and p 2 x 2 y 2 as their Manhattan distance d p 1 p 2 x 1 x 2 y 1 y 2 Furthermore we define the perimeter of a polygon as the sum of Manhattan distances between all adjacent pairs of points on it if the points on the polygon are ordered as p 1 p 2 ldots p k k geq 3 then the perimeter of the polygon is d p 1 p 2 d p 2 p 3 ldots d p k p 1 For some parameter k let s consider all the polygons that can be formed from the given set of points having k vertices such that the polygon is self intersecting For each such polygon let s consider its perimeter Over all such perimeters we define f k to be the maximal perimeter Please note when checking whether a polygon is self intersecting that the edges of a polygon are still drawn as straight lines For instance in the following pictures In the middle polygon the order of points p 1 p 3 p 2 p 4 is not valid since it is a self intersecting polygon The right polygon whose edges resemble the Manhattan distance has the same order and is not self intersecting but we consider edges as straight lines The correct way to draw this polygon is p 1 p 2 p 3 p 4 which is the left polygon Your task is to compute f 3 f 4 ldots f n In other words find the maximum possible perimeter for each possible number of points i e 3 to n ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "I will show 2 solutions both of which work in time First it is not hard to notice that we can only consider polygons that are convex Observation For a convex polygon the given definition of polygon perimeter is equivalent to the perimeter of the bounding rectangle aligned with the axis of our polygon If we look at some convex polygon and 4 values representing the maximal coordinate of a point minimal maximal and minimal then the perimeter of the bounding rectangle is simply This simple rephrase gives us a bonus and crucial observation It is enough for us to take 4 points from the input such that the perimeter of their polygon is the maximal possible and is equal to the perimeter of the polygon formed from points We will consider these the points Note that after taking the extreme points it does not matter which other points we take So this solves all We are left with to compute maximal triangle perimeter Following are 2 solutions to do it Let s show that the optimal triangle uses at least 2 of the extreme points Imagine some optimal triangle and its bounding rectangle Notice that since each edge of the bounding rectangle must touch some vertex of the triangle it is bounding after all and we have 4 edges and 3 vertices then there must be some vertex of the triangle that touches 2 edges of the rectangle so it coincides with a rectangle vertex If this is the case we know that in comparison with the 2 other vertices this vertex has extremal X and Y coordinates minimal maximal X and minimal maximal Y Without loss of generality assume this vertex has maximum X and Y Then to optimize the perimeter the other two vertices should have smallest possible X and smallest possible Y We can pick these 2 vertices to be 2 of the extreme points one with minimal X and one with minimal Y So this shows we just need to iterate over every adjacent pair of extreme vertices and over all other points as the last vertex This takes This solution is more general and is an extension of the problem to find the 2 most distant points manhattan distance The triangle perimeter is an expression with 6 terms We wish the maximize this expression but the absolute value is troubling us For each term there are 2 cases either it is positive so the absolute value does nothing or it is negative so the absolute value negates it In total for the 6 terms we have options to place signs between them We will call such option a For any setting the advantage now is that we can accumulate terms For example the setting evaluates the expression to We solve every setting by its own and over all settings we take the maximal answer that this strategy only works to find the maximal value of the expression not minimal The proof of this is left as an exercise to the reader I promise it is not difficult Given 6 constants we want to find 3 indicies to maximize We define 3 arrays And so we want to maximize This can be done in with simple dynamic programming So this whole solution is with a constant of 64 In general to compute this solution takes time without any observations "}
{"statement": "You are given a rooted tree It contains n vertices which are numbered from 1 to n The root is the vertex 1 Each edge has two positive integer values Thus two positive integers a j and b j are given for each edge Output n 1 numbers r 2 r 3 dots r n where r i is defined as follows Consider the path from the root vertex 1 to i 2 le i le n Let the sum of the costs of a j along this path be A i Then r i is equal to the length of the maximum prefix of this path such that the sum of b j along this prefix does not exceed A i Consider an example In this case r 2 0 since the path to 2 has an amount of a j equal to 5 only the prefix of this path of length 0 has a smaller or equal amount of b j r 3 3 since the path to 3 has an amount of a j equal to 5 9 5 19 the prefix of length 3 of this path has a sum of b j equal to 6 10 1 17 the number is 17 le 19 r 4 1 since the path to 4 has an amount of a j equal to 5 9 14 the prefix of length 1 of this path has an amount of b j equal to 6 this is the longest suitable prefix since the prefix of length 2 already has an amount of b j equal to 6 10 16 which is more than 14 r 5 2 since the path to 5 has an amount of a j equal to 5 9 2 16 the prefix of length 2 of this path has a sum of b j equal to 6 10 16 this is the longest suitable prefix since the prefix of length 3 already has an amount of b j equal to 6 10 1 17 what is more than 16 r 6 1 since the path up to 6 has an amount of a j equal to 2 the prefix of length 1 of this path has an amount of b j equal to 1 r 7 1 since the path to 7 has an amount of a j equal to 5 3 8 the prefix of length 1 of this path has an amount of b j equal to 6 this is the longest suitable prefix since the prefix of length 2 already has an amount of b j equal to 6 3 9 which is more than 8 r 8 2 since the path up to 8 has an amount of a j equal to 2 4 6 the prefix of length 2 of this path has an amount of b j equal to 1 3 4 r 9 3 since the path to 9 has an amount of a j equal to 2 4 1 7 the prefix of length 3 of this path has a sum of b j equal to 1 3 3 7 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Note that all are positive which means that the amount on the prefix only increases This allows us to use binary search to find the answer for the vertex It remains only to learn how to quickly find the sum of on the path prefix Let s run a depth first search and store the prefix sums of the current path in stack going to the vertex add the sum to the end of the path and delete it when exiting "}
{"statement": "You are given an array a 1 a 2 dots a n Array is good if for each pair of indexes i j the condition j a j ne i a i holds Can you shuffle this array so that it becomes good To shuffle an array means to reorder its elements arbitrarily leaving the initial order is also an option For example if a 1 1 3 5 then shuffled arrays 1 3 5 1 3 5 1 1 and 5 3 1 1 are good but shuffled arrays 3 1 5 1 1 1 3 5 and 1 1 5 3 aren t It s guaranteed that it s always possible to shuffle an array to meet this condition ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Let s sort array in non ascending order In this case for each pair of indexes the condition holds "}
{"statement": "Satyam is given n distinct points on the 2D coordinate plane How many different nondegenerate right triangles text can be formed from choosing three different points as its vertices Two triangles a and b are different if there is a point v such that v is a vertex of a but not a vertex of b text A nondegenerate right triangle has positive area and an interior 90 circ angle ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Problem Credits Proof by QED Analysis cry Solution Initially the obvious case one might first consider is an upright right triangle specifically the triangle with one of its sides parallel to the axis This side can only be made with two points in the form and We only need to search third point Turns out the third point can be any other unused vertex If the third point has then it will be an upright triangle but if the third point has it will simply be upside down One of the other case is in the form of Let s see why this is a right triangle Recall that in right triangle the sum of the squares of two of the sides must equal to the square of the third side The length between the first and the second point is because it is the diagonal of by unit block Similarily the second and third point also has length Obviously the length between the first and third point is Since we have this is certainly a right triangle Of course we can flip the values of each point and it will still be a valid right triangle just upside down "}
{"statement": "Polycarp has interviewed Oleg and has written the interview down without punctuation marks and spaces to save time Thus the interview is now a string consisting of lowercase English letters There is a filler word in Oleg s speech All words that can be obtained from by adding several times to the end of it are also considered to be fillers For example the words are fillers but the words and are not fillers The fillers have maximal size for example for speech we can t consider a filler and as a normal phrase We should consider as a filler here To print the interview Polycarp has to replace each of the fillers with three asterisks Note that a filler word is replaced with exactly three asterisks regardless of its length Polycarp has dealt with this problem in no time Can you do the same The clock is ticking ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "In this problem it is enough to iterate through the given string from the left to the right and find the longest substring like ogo go from each position of the string If such substring was founded add and move to the end of this substring In the other case add current letter to the answer and move to the next position "}
{"statement": "You are given an array a of length n consisting of integers You can apply the following operation consisting of several steps on the array a or more times you select two numbers in the array a i and a j you remove i th and j th elements from the array For example if n 6 and a 1 6 1 1 4 4 then you can perform the following sequence of operations select i 1 j 5 The array a becomes equal to 6 1 1 4 select i 1 j 2 The array a becomes equal to 1 4 What can be the minimum size of the array after applying some sequence of operations to it ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let s replace each character with the number of its occurrences in the string Then each operation take two non zero numbers and subtract one from them In the end we will have only one non zero number left and we want to minimize it We can say that we want to minimize the maximum number after applying all the operations which means we want to minimize the maximum number at each step We get the following greedy solution each time we take two characters with maximal occurrences number and delete them "}
{"statement": "Many schoolchildren look for a job for the summer and one day when Gerald was still a schoolboy he also decided to work in the summer But as Gerald was quite an unusual schoolboy he found quite unusual work A certain Company agreed to pay him a certain sum of money if he draws them three identical circles on a plane The circles must not interfere with each other but they may touch each other He can choose the centers of the circles only from the options granted by the Company He is free to choose the radius of the circles himself all three radiuses must be equal but please note that the larger the radius is the more he gets paid Help Gerald earn as much as possible ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "In this problem it is need to draw three circle equals together with maximum possible radius with centers in given points In another words it is need to find triangle wich minimum side is maximal Unfortunately solution with bit optimize is not expected for us Lets call to memory two simple geometric facts Firstly sum of alnges of trianle is equals to Secondly minimal angle is opposit to minimal side of triangle Since at leats one side of angles of triangle not less then and this anlge is not least one And side opposite to it is not least side Therefore if in then And then lets do the follows Lets iterate apex and for each lets find triangle with maximal minimum of sides when is the apex of triangle and For it lets sort all other points by the angle relative to and for each point lets find point most distant to among such points that We have to use segment tree for maximum and two pointers or binary searsh to now left and right bound of possible points during iterating Finally we have solution of time "}
{"statement": "Inna Dima and Sereja are in one room together It s cold outside so Sereja suggested to play a board game called Babies The babies playing board is an infinite plane containing blue babies and red ones Each baby is a segment that grows in time At time moment the blue baby is a blue segment with ends at points Similarly at time the red baby is a red segment with ends at points of the plane Initially at time all babies are points on the plane The goal of the game is to find the first integer moment of time when the plane contains a rectangle of a non zero area which sides are fully covered by some babies A side may be covered by multiple babies More formally each point of each side of the rectangle should be covered by at least one baby of any color At that you must assume that the babies are closed segments that is they contain their endpoints You are given the positions of all babies help Inna and Dima to find the required moment of time ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "We will make the binary search to find the answer For each time let s generate our segments and rotate them to transform them into horizontal and verticle We can use transformation to Don t forget to make the union of all segments which were at the one diagonal and have an intersection You should sort all segments of one type and iterate through them updating the size of the segment Now we should only determine if there is at least one rectangle For example we can iterate each verticle segment updating the set of all horizontal which begin not later than our verticle For each verticle the left one we should iterate the right verticle and now calculate the set of horizontal which not only begin not later than the left verticle but also don t end earlier than the right one Now we should only determine is ther is two or more horizontal segments from the set which satisfy also y conditions for current vertical "}
{"statement": "Peter decided to lay a parquet in the room of size the parquet consists of tiles of size When the workers laid the parquet it became clear that the tiles pattern looks not like Peter likes and workers will have to re lay it The workers decided that removing entire parquet and then laying it again is very difficult task so they decided to make such an operation every hour remove two tiles which form a square rotate them 90 degrees and put them back on the same place They have no idea how to obtain the desired configuration using these operations and whether it is possible at all Help Peter to make a plan for the workers or tell that it is impossible The plan should contain at most commands ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Let s assume that the width of the rectangle is even if not flip the rectangle Convert both start and final configurations into the configuration where all tiles lie horizontally After that since all the moves are reversible simply reverse the sequence of moves for the final configuration How to obtain a configuration in which all tiles lie horizontally Let s go from top to bottom left to right and put all the tiles in the correct position If the tile lie vertically then try to turn it into the correct position If it cannot be rotated because the neighboring tile is oriented differently proceed recursively to it Thus you get a ladder which can not go further than tiles down At the end of the ladder there will be two tiles oriented the same way Making operations from the bottom up we ll put the top tile in a horizontal position "}
{"statement": "A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array Consider a permutation p of length n we build a graph of size n using it as follows For every 1 leq i leq n find the j such that 1 leq j i and p j p i and add an undirected edge between node i and node j For every 1 leq i leq n find the j such that i j leq n and p j p i and add an undirected edge between node i and node j In cases where no such j exists we make no edges Also note that we make edges between the corresponding indices not the values at those indices For clarity consider as an example n 4 and p 3 1 4 2 here the edges of the graph are 1 3 2 1 2 3 4 3 A permutation p is if the graph built using p has at least one simple cycle Given n find the number of cyclic permutations of length n Since the number may be very large output it modulo 10 9 7 Please refer to the Notes section for the formal definition of a simple cycle ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1500", "problem_editorial": "The answer is Consider an arbitrary cyclic permutation for example 4 2 3 1 5 6 it contains many cycles of length Note that all the listed cycles contain nodes obtained from just one choice of We can generalize this to the following If for any we make edges on both sides of it this will create a simple cycle of length The proof is simple and is an exercise for you Thus there has to at most one peak that is the element all acyclic permutations increase then reach and finally decrease These are formally called unimodal permutations and it s easy to see that any unimodal permutation forms a tree and thus contains no simple cycle each element except has a uniquely defined parent We can construct any unimodal permutation by adding the numbers into a deque in the same order For example can be constructed by first pushing to the front and finally at the back Thus for every element except we have the choice of pushing it to the front or the back making the total number of ways equal to Time Complexity "}
{"statement": "Given an array a of n integers an array b of m integers and an even number k Your task is to determine whether it is possible to choose frac k 2 elements from both arrays in such a way that among the chosen elements every integer from 1 to k is included For example If a 2 3 8 5 6 5 b 1 3 4 10 5 k 6 then it is possible to choose elements with values 2 3 6 from array a and elements with values 1 4 5 from array b In this case all numbers from 1 to k 6 will be included among the chosen elements If a 2 3 4 5 6 5 b 1 3 8 10 3 k 6 then it is not possible to choose elements in the required way Note that you are not required to find a way to choose the elements your program should only check whether it is possible to choose the elements in the required way ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Notice that elements with a value greater than are not relevant to us Let s divide the values into three categories Occurring only in array occurring only in array occurring in both arrays The answer will be if any of the following conditions are met the number of values of the first type is greater than this implies that we cannot select all such elements the number of values of the second type is greater than this implies that we cannot select all such elements the total number of values of all three types is less than this implies that some values do not occur in either of the arrays Otherwise the answer is "}
{"statement": "You have a string s consisting of digits from 0 to 9 inclusive You can perform the following operation any possibly zero number of times You can choose a position i and delete a digit d on the i th position Then insert the digit min d 1 9 on any position at the beginning at the end or in between any two adjacent digits What is the lexicographically smallest string you can get by performing these operations A string a is lexicographically smaller than a string b of the same length if and only if the following holds in the first position where a and b differ the string a has a smaller digit than the corresponding digit in b ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "We leave all suffix minimums by the digits digits less than or equal to the minimum among the digits to the right of them remove the rest and replace them with using the described operations and add to lexicographically minimum order on the right due to the appropriate order of operations this is possible The suffix minimums should be left because no matter what digit we leave after it will be no less than and therefore will not improve the answer The rest must be removed at the end with operations since there is a number to the right less than this one i e if you remove everything before it put at the current position the answer will become less than if you leave another digit at this position "}
{"statement": "A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array An inversion in a permutation p is a pair of indices i j such that i j and a i a j For example a permutation 4 1 3 2 contains 4 inversions 2 1 3 1 4 1 4 3 You are given a permutation p of size n However the numbers on some positions are replaced by 1 Let the valid permutation be such a replacement of 1 in this sequence back to numbers from 1 to n in such a way that the resulting sequence is a permutation of size n The given sequence was turned into a valid permutation randomly with the equal probability of getting each valid permutation Calculate the expected total number of inversions in the resulting valid permutation It can be shown that it is in the form of frac P Q where P and Q are non negative integers and Q ne 0 Report the value of P cdot Q 1 pmod 998244353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Let s break the problem into four general cases Case 1 Inversions between two unknown numbers Each pair of numbers can either be or inversion or not and the number of permutations for both cases is the same Thus the expected value of that is Case 2 and 3 Inversions between the known and unknown number Let s check the case with left number being unknown and right being known The opposite will be done similarly For each known number calculate the number of unknowns to the left of it and the total number of unknowns greater than it Then you ll need to put a greater number out of all possible to make an inversion Add to the answer Case 4 Inversions between two known numbers Just calculate that number ignoring all and add it to answer Overall complexity for the lase case all others are done in "}
{"statement": "There are two rival donut shops The first shop sells donuts at retail each donut costs a dollars The second shop sells donuts only in bulk box of b donuts costs c dollars So if you want to buy x donuts from this shop then you have to buy the smallest number of boxes such that the total number of donuts in them is greater or equal to x You want to determine two values how many donuts can you buy so that they are strictly cheaper in the first shop than in the second shop how many donuts can you buy so that they are strictly cheaper in the second shop than in the first shop If any of these values doesn t exist then that value should be equal to 1 If there are multiple possible answers then print any of them ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "At first notice that if there exists a value for the second shop then the value divisible by also exists For any you can round it up to the nearest multiple of That won t change the price for the second shop and only increase the price for the first shop You can also guess that if there exists a value for the first shop then the value with modulo also exists exactly donut on top of some number of full boxes Following the same logic the second shop needs an entire new box and the first shop needs only an extra donut So let s take a look at the smallest values of two kinds this value is valid for the second shop if one box is cheaper than donuts in the first shop Otherwise no matter how many boxes will you take they will never be cheaper than the corresponding number of donuts this value is valid for the first shop if one donut is cheaper than one box in the second shop Apply the same idea otherwise no value for the first shop is valid Overall complexity per testcase "}
{"statement": "Appleman and Toastman play a game Initially Appleman gives one group of numbers to the Toastman then they start to complete the following tasks Each time Toastman gets a group of numbers he sums up all the numbers and adds this sum to the score Then he gives the group to the Appleman Each time Appleman gets a group consisting of a single number he throws this group out Each time Appleman gets a group consisting of more than one number he splits the group into two non empty groups he can do it in any way and gives each of them to Toastman After guys complete all the tasks they look at the score value What is the maximum possible value of score they can get ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "First I describe the algorithm and explain why it works Actually when you multiply all numbers by 1 the answer will be the minimal possible value multiplied by 1 It s Huffman coding problem to find minimal possible value Solving Huffman coding also can be solved in O In Huffman coding push all the numbers to a priority queue While the size of the queue is larger than 2 delete the minimal and second minimal element add the sum of these two to the cost and push the sum to the queue Here since all the numbers are negative the pushed sum will be remain in the first in the queue Analyzing this movement will lead to the first algorithm "}
{"statement": "A Random PebbleYou are given a permutation p 1 p 2 ldots p n of length n and a positive integer k le n In one operation you can choose two indices i and j 1 le i j le n and swap p i with p j Find the minimum number of operations needed to make the sum p 1 p 2 ldots p k as small as possible A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "For any permutation of length the final sum after some number of operations can t be less than This means that we need to apply the operation at least once for every such that and Every time we apply it we have to choose some index such that and This is always possible since initially the number of suitable is equal to the number of suitable and one operation decreases both the number of suitable and the number of suitable by one It is easy to see that in the end the set only contains the values which means that the sum is equal to which is the smallest sum we can get So the answer is the the number of such that and Complexity "}
{"statement": "Kolya is very absent minded Today his math teacher asked him to solve a simple problem with the equation a 1 b with positive integers a and b but Kolya forgot the numbers a and b He does however remember that the first leftmost digit of a was d a and the first leftmost digit of b was d b Can you reconstruct any equation a 1 b that satisfies this property It may be possible that Kolya misremembers the digits and there is no suitable equation in which case report so ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "The answer exists only if da db db da 1 or da 9 and db 1 Alternatively one could simply check all a up to 100 or another reasoable bound "}
{"statement": "At first let s define function f x as follows begin matrix f x left begin matrix frac x 2 mbox if x text is even x 1 mbox otherwise end matrix right end matrix We can see that if we choose some value v and will apply function f to it then apply f to f v and so on we ll eventually get 1 Let s write down all values we get in this process in a list and denote this list as path v For example path 1 1 path 15 15 14 7 6 3 2 1 path 32 32 16 8 4 2 1 Let s write all lists path x for every x from 1 to n The question is next what is the maximum value y such that y is contained in at least k different lists path x Formally speaking you need to find maximum y such that left x 1 le x le n y in path x right ge k ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s introduce a function the number of such that The problem is now to find the greatest number such that How can we calculate First let s consider the case when is odd is contained in then is contained in since and in since is odd The next numbers containing in their paths are and then and so on By processing each segment of numbers containing in their paths in we can calculate for odd in What about even The first numbers containing in their paths are and then and then and so on So the case with even can also be solved in We can also see that simply because for each number containing in its path there is another number that is less than it which contains in its path And this fact means that if we want to find the greatest such that we only have to run two binary searches one binary search over odd numbers and another binary search over even numbers "}
{"statement": "Luntik has decided to try singing He has a one minute songs b two minute songs and c three minute songs He wants to distribute all songs into two concerts such that every song should be included to exactly one concert He wants to make the absolute difference of durations of the concerts as small as possible The duration of the concert is the sum of durations of all songs in that concert Please help Luntik and find the minimal possible difference in minutes between the concerts durations ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let be the sum of durations of all songs that is Let s notice that since it is possible to make a concert of any duration from to indeed if we just execute a greedy algorithm and take three minute songs while possible then take two minute songs and then one minute ones we can get any duration we need Now the answer is the remainder of modulo because if is even then it s possible to from the first concert with duration and the second one will be left with duration and the difference between the durations will be If is odd then the smallest possible difference is equal to let s form the first concert with duration and the second one is left with duration "}
{"statement": "Little John aspires to become a plumber Today he has drawn a grid consisting of rows and columns consisting of square cells In each cell he will draw a pipe segment He can only draw four types of segments numbered from to illustrated as follows Each pipe segment has two ends illustrated by the arrows in the picture above For example segment has ends at top and left side of it Little John considers the piping system to be leaking if there is at least one pipe segment inside the grid whose end is not connected to another pipe s end or to the border of the grid The image below shows an example of leaking and non leaking systems of size Now you will be given the grid that has been partially filled by Little John Each cell will either contain one of the four segments above or be empty Find the number of possible different non leaking final systems after Little John finishes filling of the empty cells with pipe segments Print this number modulo Note that rotations or flipping of the grid are not allowed and so two configurations that are identical only when one of them has been rotated or flipped either horizontally or vertically are considered two different configurations ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "To solve this problem let s imagine that the left and top sides of the grid also determines whether the pipe adjacent to that side has an end connecting it to the side or not There are 2 N M ways to pick them We claim that if we fix them i e pick one of the possible 2 N M ways then the entire grid s pipes are fixed To see this notice that each pipe segment will have either one vertical end it either have end on the top or end on the bottom and one horizontal end left or right We can pick any 4 combinations of them Suppose we pick a row and determine whether the leftmost pipe should have an end to the left of it or not Suppose it doesn t have an opening to the left It means that the leftmost pipe should have an opening to the right the next pipe should have an opening to the left the next pipe to the right and so on Continuing this way we have fixed the horizontal ends for an entire row and only that Hence if we pick one of the possible 2 N M ways to pick the ends then the horizontal ends of each row and vertical ends of each column is fixed Since there is exactly one pipe segment that has a particular configuration of ends there is exactly one possible completed grid for each of the 2 N M ways to pick the ends Hence the solution works by first checking if a solution exists Any pre assigned pipe simply sets whether or not its corresponding row and column has an end at the left and top side We need to check that no two pipes sets this value contradictorily If any of them are contradictory then we return the answer as 0 Otherwise we return 2 number of rows without preassigned cell number of columns without preassigned cell "}
{"statement": "Valera is a little boy Yesterday he got a huge Math hometask at school so Valera didn t have enough time to properly learn the English alphabet for his English lesson Unfortunately the English teacher decided to have a test on alphabet today At the test Valera got a square piece of squared paper The length of the side equals squares is an odd number and each unit square contains some small letter of the English alphabet Valera needs to know if the letters written on the square piece of paper form letter Valera s teacher thinks that the letters on the piece of paper form an if on both diagonals of the square paper all letters are the same all other squares of the paper they are not on the diagonals contain the same letter that is different from the letters on the diagonals Help Valera write the program that completes the described task for him ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "In this problem it was needed to check the constraints described in statement You can use two sets here You should insert diagonal elements of matrix into the first set and the other elements into the second Element belongs to the main diagonal if and belongs to the secondary diagonal if After you split all elements into sets you should check if the sets sizes are equal to one and the elements from this sets differ from each other "}
{"statement": "You are given names of two days of the week Please determine whether it is possible that during some the first day of some month was equal to the first day of the week you are given while the first day of was equal to the second day of the week you are given In this problem we consider the Gregorian calendar to be used The number of months in this calendar is equal to 12 The number of days in months during any non leap year is Names of the days of the week are given with lowercase English letters ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Days of the week in two adjacent months may either be the same in February and March or differ by two in April and May or differ by three in January and February Also it was necessary to pay attention to direction of that difference monday and tuesday is not the same as tuesday and monday "}
{"statement": "Mad scientist Mike is busy carrying out experiments in chemistry Today he will attempt to join three atoms into one molecule A molecule consists of atoms with some pairs of atoms connected by atomic bonds Each atom has a valence number the number of bonds the atom must form with other atoms An atom can form bonds with any other atom but it cannot form a bond with itself The number of bonds of an atom in the molecule must be equal to its valence number Mike knows valence numbers of the three atoms Find a molecule that can be built from these atoms according to the stated rules or determine that it is impossible ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1200", "problem_editorial": "First solution First the sum should be even since each bond adds 2 to the sum Now let be the number of bonds between 1st and 2nd 2nd and 3rd 3rd and 1st atoms accordingly So we have to solve the system Now observe that the solution to the system is the length of the tangents on the triangle with sides of length to its inscribed circle and are equal to If the problem asked only the possibility of building such a molecule we could just check if there exists possibly degenerate triangle with sides Second solution Bruteforce all values For a fixed values of and are defined uniquely Solution complexity Problem authors gen andreyv Bonus Can you solve the problem for any vertex number When and how can such a graph be built "}
{"statement": "At the children s day the child came to Picks s house and messed his house up Picks was angry at him A lot of important things were lost in particular the favorite set of Picks Fortunately Picks remembers something about his set its elements were distinct integers from to the value of was equal to here equals where is the position of the first one in the binary representation of For example binary representation Can you help Picks and find any set that satisfies all the above conditions ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "We could deal with this by digits Because is taking out the lowest of the number we can enumerate the number of the lowest zero Then if we enumerate as the number of zero we enumerate as well which is no more than and is odd We can find out that In this order we would find out that the we are considering is monotonically decresing Because for every two number is a divisor of or is a divisor of We can solve it by greedy When we enumerate by descending order we check whether is no more than and check whether there is such We minus from if and exist If at last is not equal to 0 then it must be an impossible test Why Because if we don t choose a number whose then we shouldn t choose two numbers whose Otherwise we can replace these two numbers with one number If we choose one number whose then we can choose at most one number whose at most one number whose and so on So the total sum of them is less than and we can t merge them into If we don t choose one number whose then it s just the same as we don t choose one number whose So the total time complexity is "}
{"statement": "You are given a special connected undirected graph where each vertex belongs to at most one simple cycle Your task is to remove as many edges as needed to convert this graph into a tree connected graph with no cycles For each node independently output the maximum distance between it and a leaf in the resulting tree assuming you were to remove the edges in a way that minimizes this distance ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2900", "problem_editorial": "The following solution is implemented in 136 lines but most of it is a simple BFS and two DFS functions for finding bridges and marking cycles the main part of the solution is implemented in 38 lines Please check the code after or while reading if it is not clear Note that if we run a BFS from a node the BFS spanning tree will represent the edges that we should keep to minimize the answer for node So we actually need to find the maximum length out of all shortest paths that starts at and end at every other node We will first focus on finding the answer for each node on one cycle For each node on the cycle we can compute the length of the longest shortest path that starts at node and uses only the edges that do not belong to the cycle This can be done using BFS in for one cycle Using the computed values we can find the final answer for all nodes on the cycle in or where is the number of nodes on the cycle For a node we need to find a node on the cycle such that is maximized where is the length of the shortest path between and on the cycle Therefore the answer with regards to each node will be the maximum between and for each node in the same cycle as We can do this using a heap and prefix sums idea as follows loop for iterations over the cycle nodes in the iteration add the value to the heap with the time it was added in time is decreasing that is add the pair Now at a given iteration pop from the heap all top values added at time greater than as can t exceed Now assuming the top pair in the queue is then is a possible answer for this node We need to do this again in counter clockwise Since we will visit each node four times keep the maximum distance found for each node in the cycle and the final answer for that node will be Now if we have the answer for one cycle when we move using an edge to another cycle or node we only need to know one value to be able to solve the next cycle that value is the maximum between and the length of the longest path that goes through bridges other than This value is increased by when passed since we will move through the edge Marking the bridges will help in deciding if an edge will take us outside a cycle or not so we can compute Also removing the bridges will make it easy to find which nodes form each cycle We can find any BFS spanning tree and use it to find the length of the longest path that starts at a node and uses a bridge first note that this distance goes only down as the tree is rooted at the starting node but the values for every in the first cycle will be correct so we can start with them "}
{"statement": "You are playing a computer game where you lead a party of m soldiers Each soldier is characterised by his agility a i The level you are trying to get through can be represented as a straight line segment from point 0 where you and your squad is initially located to point n 1 where the boss is located The level is filled with k traps Each trap is represented by three numbers l i r i and d i l i is the location of the trap and d i is the danger level of the trap whenever a soldier with agility lower than d i steps on a trap that is moves to the point l i he gets instantly killed Fortunately you can disarm traps if you move to the point r i you disarm this trap and it no longer poses any danger to your soldiers Traps don t affect you only your soldiers You have t seconds to complete the level that is to bring some soldiers from your squad to the boss Before the level starts you choose which soldiers will be coming with you and which soldiers won t be After that you have to bring to the boss To do so you may perform the following actions if your location is x you may move to x 1 or x 1 This action consumes one second if your location is x and the location of your squad is x you may move to x 1 or to x 1 with your squad in one second You may not perform this action if it puts some soldier in danger i e the point your squad is moving into contains a non disarmed trap with d i greater than agility of some soldier from the squad This action consumes one second if your location is x and there is a trap i with r i x you may disarm this trap This action is done instantly it consumes no time Note that after each action both your coordinate and the coordinate of your squad should be integers You have to choose the maximum number of soldiers such that they all can be brought from the point 0 to the point n 1 where the boss waits in no more than t seconds ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "When we fix a set of soldiers we can determine a set of traps that may affect our squad these are the traps with danger level greater than the lowest agility value So we can use binary search on minimum possible agility of a soldier that we can choose How should we actually bring our soldiers to the boss Each trap that can affect our squad can be actually treated as a segment such that our squad cannot move to until we move to and disarm this trap We should walk through such segments for three times the first time we walk forwards without our squad to disarm the trap the second time we walk backwards to return to our squad and the third time we walk forwards with our squad So the total time we have to spend can be calculated as where is the number of unit segments belonging to at least one trap segment and it can be calculated with event processing algorithms or with segment union Time complexity is or but it is possible to write a solution in without binary search "}
{"statement": "You love fish that s why you have decided to build an aquarium You have a piece of coral made of n columns the i th of which is a i units tall Afterwards you will build a tank around the coral as follows Pick an integer h geq 1 the of the tank Build walls of height h on either side of the tank Then fill the tank up with water so that the height of each column is h unless the coral is taller than h then no water should be added to this column For example with a 3 1 2 4 6 2 5 and a height of h 4 you will end up using a total of w 8 units of water as shown You can use at most x units of water to fill up the tank but you want to build the biggest tank possible What is the largest value of h you can select ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "We need to find the maximum height with a certain upper bound this is a tell tale sign of If you don t know what that is you should read this Codeforces EDU article For a given value of in the th column we will need units of water if or units otherwise This is equal to why So we can compute the amount of water for all columns by simply iterating through and summing the total amount of water needed for each column and see if it s not larger than Then you can binary search on the optimal value of The model solution uses the starting bounds because the optimal height could be So the complexity is per testcase "}
{"statement": "Ezzat has an array of n integers He wants to split it into two subsequences a and b such that every element from the array belongs to exactly one subsequence and the value of f a f b is the maximum possible value where f x is the average of the subsequence x A sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several possibly zero or all elements The average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence For example the average of 1 5 6 is 1 5 6 3 12 3 4 so f 1 5 6 4 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "SolutionSince the average of a group of numbers always has a value between the minimum and maximum numbers in that group it can be proved that the best approach to obtain the maximum sum of averages of two subsequences is to put the maximum number alone into one subsequence and the rest of the numbers into the other subsequence A proof by contradiction follows Assume a sorted array so Assume that there exists a bigger answer if you take the two greatest numbers instead of only one in one subsequence Therefore we need to prove that By simplifying the inequality Assume so as stated at the beginning of the tutorial The inequality becomes The right hand side of the inequality is also an average such that which can be further simplified to This means that is strictly less than In other words it states that is strictly less than a certain number between and This is a contradiction as we stated at the beginning of the proof that the array is sorted Summing things up taking at least one number along with the maximum number will never yield a greater answer "}
{"statement": "Nene gave you an array of integers a 1 a 2 ldots a n of length n You can perform the following operation no more than 5 cdot 10 5 times possibly zero Choose two integers l and r such that 1 le l le r le n compute x as operatorname MEX a l a l 1 ldots a r and simultaneously set a l x a l 1 x ldots a r x Here operatorname MEX of a set of integers c 1 c 2 ldots c k is defined as the smallest non negative integer m which does not occur in the set c Your goal is to maximize the sum of the elements of the array a Find the maximum sum and construct a sequence of operations that achieves this sum Note that you don t need to minimize the number of operations in this sequence you only should use no more than 5 cdot 10 5 operations in your solution ", "greedy": 1, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "When the sum can hit with making at last Construction Here solve k will take about operations Since doing operation will make if for all is included in at least one of the operations and are not the optimal strategy will be setting for using the construction above Finally we can use DFS or DP to determine whether each element is included in operations The number of operations used will not exceed "}
{"statement": "Finally you have defeated Razor and now you are the Most Wanted street racer Sergeant Cross has sent the full police force after you in a deadly pursuit Fortunately you have found a hiding spot but you fear that Cross and his force will eventually find you To increase your chances of survival you want to tune and repaint your BMW M3 GTR The car can be imagined as a n dimensional hypercube A simple n dimensional hypercube is an undirected unweighted graph built recursively as follows Take two simple n 1 dimensional hypercubes one having vertices numbered from 0 to 2 n 1 1 and the other having vertices numbered from 2 n 1 to 2 n 1 A simple 0 dimensional Hypercube is just a single vertex Add an edge between the vertices i and i 2 n 1 for each 0 leq i 2 n 1 A permuted n dimensional hypercube is formed by permuting the vertex numbers of a simple n dimensional hypercube in any arbitrary manner Examples of a simple and permuted 3 dimensional hypercubes are given below Note that a permuted n dimensional hypercube has the following properties There are exactly 2 n vertices There are exactly n cdot 2 n 1 edges Each vertex is connected to exactly n other vertices There are no self loops or duplicate edges Let s denote the permutation used to generate the permuted n dimensional hypercube representing your car from a simple n dimensional hypercube by P Before messing up the functionalities of the car you want to find this permutation so that you can restore the car if anything goes wrong But the job isn t done yet You have n different colours numbered from 0 to n 1 You want to colour the vertices of this permuted n dimensional hypercube in such a way that for each and every vertex u satisfying 0 leq u 2 n and for each and every colour c satisfying 0 leq c n there is at least one vertex v adjacent to u having a colour c In other words from each and every vertex it must be possible to reach a vertex of any colour by just moving to an adjacent vertex Given the permuted n dimensional hypercube find any valid permutation P and colouring ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2700", "problem_editorial": "Tutorial Part 1 Finding the PermutationBefore moving to the solution notice a very important property of simple Dimensional Hypercubes Two vertices and are connected if and only if and differ by exactly one bit in their binary representations The permutation can be found using the following greedy algorithm First assign any arbitrary vertex as This is obvious since all vertices are equivalent Then in the simple Dimensional Hypercube all powers of must be connected to the vertex Moreover these vertices are added only when we are adding another dimension to the cube Since all directions are also equivalent it does not matter in which direction we add a new dimension So we can assign all the vertices connected to in the permuted Dimensional Hypercube as in any arbitrary order Now we will find for the remaining vertices in increasing order of In order to find first find a set of vertices such that and is connected to in the simple Dimensional Hypercube Then find any vertex connected to all the vertices such that in the permuted Dimensional Hypercube and assign I claim that we can never make a wrong choice because we will never have a choice There will only be one such vertex for any Let s prove it ProofConsider two vertices and in the set These vertices will differ by exactly bits in their binary representation Let the bits in which they differ be and Then they will have the form and where represent the same bits Now only two vertices and can be connected to both and Since a permuted Dimensional Hypercube is isomorphic to a simple Dimensional Hypercube there will only be two vertices connected to both and in the permuted Dimensional Hypercube also If we iterate over in increasing order then otherwise one of or will be greater than which is a contradiction So the only vertices connected to both and will have the forms and Now since and has already been calculated and so one of the vertex connected to both and in the permuted Dimensional Hypercube has already been used So we are left with only one choice for such a vertex Alternate method of finding the permutation by mshiladityam Let s call the vertex connected to a given vertex and which is in the opposite constituent smaller hypercube the image of the given vertex Lemma if there is an edge in the Dimensional hypercube where vertices and lie in different constituent Dimensional Hypercubes in other words and are images of each other then for all vertices adjacent to the image of is adjacent to This lemma can be proved by using the fact that two vertex are connected if and only if they differ by exactly bit Select any two vertices and They form a starting point we treat them as two vertices in opposite constituents by symmetry we can prove that any pairs can be treated as such Now let us perform multisource BFS with and as source nodes Due to the lemma the nodes which are discovered from first lie in the component of and those which are discovered from first lie in the component of it is easy again to prove it using induction on depth of already discovered vertices So we have separated these two constituent smaller dimension hypercubes Lets call a recursive function on any one of them this recursive function returns a permutation which transforms the permutated hypercube to the simple hypercube Now we find for each vertex in the constituent hypercube whose permutation we just found its image Then we can find the permutation for the other constituent by just adding to the corresponding image Hence we perform the merging process of recursion The time complexity of this approach is "}
{"statement": "Polycarp is crazy about round numbers He especially likes the numbers divisible by In the given number of Polycarp wants to remove the least number of digits to get a number that is divisible by For example if in the number it is enough to delete a single digit In this case the result is that is divisible by Write a program that prints the minimum number of digits to be deleted from the given integer number so that the result is divisible by The result should not start with the unnecessary leading zero i e zero can start only the number which is required to be written as exactly one digit It is guaranteed that the answer exists ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "To solve this problem we need to make zeroes in the end of number Let s look on the given number as on the string and iterate through it beginning from the end i e from the low order digit Let equals to the number of digits which we reviewed If the current digit does not equal to zero we need to increase the answer on one If became equal to and we reviewed not all digits we need to print the answer In the other case we need to remove from the string all digits except one which equals to zero if there are more than one such digit we left only one of them Such digit always exists because the problem statement guaranteed that the answer exists "}
{"statement": "A set of positive integers S is called beautiful if for every two integers x and y from this set either x divides y or y divides x or both You are given two integers l and r Consider all beautiful sets consisting of integers not less than l and not greater than r You have to print two numbers the maximum possible size of a beautiful set where all elements are from l to r the number of beautiful sets consisting of integers from l to r with the maximum possible size Since the second number can be very large print it modulo 998244353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Every beautiful set can be represented as a sequence of its elements in sorted order Let these elements for some set be also let When the set is beautiful every is an integer greater than It s easy to see that if and belong to the whole set belongs to Since in order to maximize we need to choose and as small as possible So why don t we choose and every This will allow us to calculate the maximum possible size of a beautiful set let be this maximum possible size Okay what about counting those sets The claims and that every are no longer true by default However there are some constraints on Firstly every If we had some value of we could replace it with two values of and the size of the set would increase Secondly there is at most one If there are two values we could replace them with three and the size of the set would increase as well So the sequence contains at most one value and the rest of the values are We will divide the sets we want to count into two categories the ones with all and the ones with one value To count the sets in the first category we simply need to count the number of different minimum values in those sets Those minimum values have to be such that multiplying them by wouldn t make them greater than so these are all integers from the segment For every such integer there exists exactly one set of the first category To count the sets in the second category we do a similar thing The minimum value in the set should be from the segment but for every integer from this segment there are different sets of the second category since there are ways to choose which is equal to "}
{"statement": "Valya and Tolya are an ideal pair but they quarrel sometimes Recently Valya took offense at her boyfriend because he came to her in t shirt with lettering that differs from lettering on her pullover Now she doesn t want to see him and Tolya is seating at his room and crying at her photos all day long This story could be very sad but fairy godmother Tolya s grandmother decided to help them and restore their relationship She secretly took Tolya s t shirt and Valya s pullover and wants to make the letterings on them same In order to do this for one unit of mana she can buy a spell that can change some letters on the clothes Your task is calculate the minimum amount of mana that Tolya s grandmother should spend to rescue love of Tolya and Valya More formally letterings on Tolya s t shirt and Valya s pullover are two strings with same length consisting only of lowercase English letters Using one unit of mana grandmother can buy a spell of form where and are some lowercase English letters which can arbitrary number of times transform a single letter to and vise versa on both Tolya s t shirt and Valya s pullover You should find the minimum amount of mana that grandmother should spend to buy a set of spells that can make the letterings equal In addition you should output the required set of spells ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1600", "problem_editorial": "Let s build a graph with 26 vertices representing the 26 letters of English alphabet When we buy a spell of form add an edge between vertices and It s easy to see that it is possible to change a letter to a letter if and only if there is a path between corresponding vertices in the graph So our task is to add the minimum possible number of edges such that characters and are in one connected component for each here and are the given strings Let s now take an empty graph and add edges between vertices and for each These edges as we already know add constraints on the final graph these letters should be in a single connected component in the final graph Let s compute the number of connected components in the graph let it be Let s consider one connected component let its size be Note that the spell we should buy should connect all these vertices in a single component We can do this using at least edges and the edges that suit us are any spanning tree of this component that can be found using a dfs or just connect one vertex of this component to all the others So the total number of spells is This is the answer to the problem "}
{"statement": "Chef Monocarp has just put n dishes into an oven He knows that the i th dish has its optimal cooking time equal to t i minutes At any minute T Monocarp can put dish out of the oven If the i th dish is put out at some minute T then its unpleasant value is T t i the absolute difference between T and t i Once the dish is out of the oven it can t go back in Monocarp should put all the dishes out of the oven What is the minimum total unpleasant value Monocarp can obtain ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "There are a lot of solutions for the problem Let s start with the easiest one Sort the dishes in the non decreasing order of their optimal time I claim that there is an optimal answer such that the times for each dish go in the increasing order That s not too hard to prove something along the lines of if there are two dishes and such that and then is always greater than So we can use dynamic programming to solve the task Let be the minimum total unpleasant value if dishes are processed and the current minute is For the transitions you can either put out the current dish at the current minute or wait one more minute Notice that you ll never need more time than minutes the actual constraint is even smaller just consider the case with all dishes times equal to So that dp works in The other possible solution is matching Let s build the following graph The left partition is vertices corresponding to dishes The right partition is vertices corresponding to minutes as we saw in previous solution is always enough Now add the edges between all dishes and all minutes with the cost of their absolute different Finally find the minimum cost maximum matching That can be done with MCMF or Hungarian algorithm Both should pass pretty easily There s also a solution in involving the slope trick "}
{"statement": "Arkady has a playlist that initially consists of n songs numerated from 1 to n in the order they appear in the playlist Arkady starts listening to the songs in the playlist one by one starting from song 1 The playlist is cycled i e after listening to the last song Arkady will continue listening from the beginning Each song has a genre a i which is a positive integer Let Arkady finish listening to a song with genre y and the genre of the next to last listened song be x If operatorname gcd x y 1 he deletes the last listened song with genre y from the playlist After that he continues listening normally skipping the deleted songs and about songs he listened to before In other words after he deletes a song he can t delete the next song immediately Here operatorname gcd x y denotes the greatest common divisor GCD of integers x and y For example if the initial songs genres were 5 9 2 10 15 then the playlist is converted as follows 9 2 10 15 to 2 10 15 to 5 2 10 15 because operatorname gcd 5 9 1 to 5 10 15 to 5 15 to 5 2 to 2 10 to 10 15 to 5 10 15 because operatorname gcd 5 2 1 to 5 15 to 5 to The bold numbers represent the two last played songs Note that after a song is deleted Arkady forgets that he listened to that and the previous songs Given the initial playlist please determine which songs are eventually deleted and the order these songs are deleted ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s call a pair of songs bad if GCD of their genres is 1 It is easy to check if two songs are bad with Euclid s algorithm in O logC There are at most n deletions so simulation is fine in terms of time limit but we should be able to find the next deleted song quickly Let s maintain an ordered set of songs on the playlist and also another ordered set that stores pairs of bad consecutive songs It is easy to see that after we delete a song only constant number of changes is needed to these sets Let the song being deleted be b while the previous song be a and the next song in the playlist be c It is easy to find a and c using the playlist set Then we should remove b from the playlist set remove a b from the bad pairs set remove b c from the bad pairs set if this pair is bad add a c to the bad pairs set if this pair is bad Then we proceed to the next song that needs to be deleted It is easy to find it using the bad pairs set If we store the sets in some fast enough data structure e g balanced binary tree standard C s set is enough we have fast running time O n logn logC It is also possible to solve this problem with double linked lists or DSU with O nlogC complexity "}
{"statement": "John Doe has a list of all Fibonacci numbers modulo This list is infinite it starts with numbers and Each number in the list apart from the first two is a sum of previous two modulo That is John s list is made from the Fibonacci numbers list by replacing each number there by the remainder when divided by John got interested in number and now wants to find its first occurrence in the list given above Help John and find the number of the first occurence of number in the list or otherwise state that number does not occur in the list The numeration in John s list starts from zero There the th position is the number the st position is the number the nd position is the number the rd position is the number the th position is the number and so on Thus the beginning of the list looks like this ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "In this problem we had some Fibonacci number modulo 1013 f and we had to determine the position of its first occurence in Fibonacci sequence modulo 1013 Let a and b be two different coprime modula divisors of 1013 Let F be the actual Fibonacci number such that Then and Find all occurences of number in Fibonacci sequence modulo a period Find all occurences of number in Fibonacci sequence modulo b period Let s fix a pair of such occurences Let the occurence modulo a be in position i and the occurence modulo b be in position j Let t m be Fibonacci sequence modulo m period From the Chinese Remainder Theorem it follows that t ab LCM t a t b remember that a and b are coprime Then from fixed occurences of f in periods of sequences modulo a and b we can recover the position of occurence of f in period of sequence modulo ab It could be done by solving the following Diophantine equation i t a x j t b y We can solve it using a simple bruteforce of one of the roots If the occurence in sequence modulo ab period we have just found it is u then every occurence f in Fibonacci sequence modulo 1013 period can be represented as t ab k u Then let s bruteforce k and find all occurences in sequence modulo 1013 period To determine Fibonacci number on position t ab from known Fibonacci number on position we need to multiply the vector F F 1 and some matrix Let s choose a 59 and b 213 Note that there is no number that occur Fibonacci sequence modulo a or b period more than 8 times That means that total count of pairs will never be greater than 64 For each occurence we ll bruteforce not more than numbers That was the author s solution Also that was possible to use the fact that for any number the count of its occurences in period of sequence modulo 10p for any natural p is not big more efficiently From occurences in sequence modulo 10i period we could get occurences in sequence modulo 10i 1 period using the method we use to jump from modulus ab to modulus 1013 "}
{"statement": "Annie is an amateur photographer She likes to take pictures of giant residential buildings at night She just took a picture of a huge rectangular building that can be seen as a table of n times m windows That means that the building has n floors and each floor has exactly m windows Each window is either dark or bright meaning there is light turned on in the room behind it Annies knows that each apartment in this building is either one bedroom or two bedroom Each one bedroom apartment has exactly one window representing it on the picture and each two bedroom apartment has exactly two windows on the same floor Moreover the value of m is guaranteed to be divisible by 4 and it is known that each floor has exactly frac m 4 two bedroom apartments and exactly frac m 2 one bedroom apartments The actual layout of apartments is unknown and can be different for each floor Annie considers an apartment to be occupied if of its windows is bright She now wonders what are the minimum and maximum possible number of occupied apartments if judged by the given picture Formally for each of the floors she comes up with some particular apartments layout with exactly frac m 4 two bedroom apartments two consecutive windows and frac m 2 one bedroom apartments single window She then counts the total number of apartments that have at least one bright window What is the minimum and maximum possible number she can get ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "The number of one bedroom and two bedroom apartments is the same for each floor and each floor can have its own independent apartments layout Thus we can independently solve the problem for each floor and then just sum the results Below is given the solution for one floor in O m time First lets introduce some variables B is the total number of bright windows D is the total number of dark windows O 0 is the number of one bedroom apartments that are not occupied 0 bright windows O 1 is the number of one bedroom apartments that are occupied 1 bright window T 0 is the number of two bedroom apartments that are not occupied 0 bright windows T 1 is the number of two bedroom apartments that are occupied and have 1 bright window T 2 is the number of two bedroom apartments that are occupied and have 2 bright windows A is the total number of occupied apartments We know that A O 1 T 1 T 2 and B O 1 T 1 2 cdot T 2 Thus A B T 2 so in order to minimize the number of occupied apartments we need to maximize T 2 and vice versa Maximizing T 2 is easier you just determine the length of all maximal segments of bright windows denote these lengths as l 0 l 1 l 2 ldots l x Then you pack each segment with as many two bedroom apartments as possible So the maximum possible value of T 2 min sum i 0 x lfloor frac l i 2 rfloor frac m 4 Here we must note the importance of having exactly frac m 4 two bedroom apartments and exactly frac m 2 one bedroom apartments If the actual number of apartments of each type was given in the input we won t be able to guarantee the value of T 2 defined above It could be the case that it is not actually possible to place all the remaining apartments and close the gaps between the placement of two bedroom apartments with two bright windows However as we have frac m 2 one bedroom apartments we can guarantee that such a placement is always possible Now we would like to minimize T 2 Actually we will do it in exactly the same way as the maximization but instead of taking maximal segments of bright windows we will find and use maximal segments that have at least one dark window and do not have two consecutive bright windows Denote the lengths of such maximal segments as l 0 l 1 l 2 ldots l y Then the minimum possible T 2 min 0 frac m 4 sum i 0 y lfloor frac l i 2 rfloor Again thanks to frac m 2 one bedroom apartments we will be able to fill all the gaps and achieve the desired placement "}
{"statement": "Once again Boris needs the help of Anton in creating a task This time Anton needs to solve the following problem There are two arrays of integers a and b of length n It turned out that array a contains only elements from the set 1 0 1 Anton can perform the following sequence of operations any number of times Choose any pair of indexes i j such that 1 le i j le n It is possible to choose the same pair i j more than once Add a i to a j In other words j th element of the array becomes equal to a i a j For example if you are given array 1 1 0 you can transform it only to 1 1 1 1 0 0 and 1 1 1 by one operation Anton wants to predict if it is possible to apply some number zero or more of these operations to the array a so that it becomes equal to array b Can you help him ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "First of all note that we can add an element with index to an element with index iff This means that the element cannot be added to any other element because there is no index in the array This is why we can first equalize the elements and If they are already equal If then we need to have element equal to along the elements with indexes For we need to have along these elements After the elements with index become equal we can go to the element with index and do the same Then indexes You can implement this idea yourself Final time complexity "}
{"statement": "The end of the school year is near and Ms Manana the teacher will soon have to say goodbye to a yet another class She decided to prepare a goodbye present for her students and give each of them a jigsaw puzzle which as wikipedia states is a tiling puzzle that requires the assembly of numerous small often oddly shaped interlocking and tessellating pieces The shop assistant told the teacher that there are puzzles in the shop but they might differ in difficulty and size Specifically the first jigsaw puzzle consists of pieces the second one consists of pieces and so on Ms Manana doesn t want to upset the children so she decided that the difference between the numbers of pieces in her presents must be as small as possible Let be the number of pieces in the largest puzzle that the teacher buys and be the number of pieces in the smallest such puzzle She wants to choose such puzzles that is minimum possible Help the teacher and find the least possible value of ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "First let s sort the numbers f i in ascending order Now assume that the smallest jigsaw puzzle which the teacher purchases consists of f k pieces Obviously she should buy the smallest n puzzles which are of size f k or greater to minimize the difference These are the puzzles f k f k 1 f k n 1 this is not correct when f i are not distinct and f k f k 1 but such cases can be skipped The difference between the greatest and the least size of the puzzles in such set is f k n 1 f k To choose the optimal f k we can test every k between 1 and m n and pick the one producing the least difference The full algorithm is as follows "}
{"statement": "Timofey came to a famous summer school and found a tree on n vertices A tree is a connected undirected graph without cycles Every vertex of this tree except c 0 is colored The vertex c 0 is colored Timofey wants to color all the vertices of this tree in To do this he performs n 1 operations During the i th operation he selects the vertex c i which is currently and paints it Let s call the of tree the minimum distance between all pairs of different vertices in it The distance between the vertices v and u is the number of edges on the path from v to u After each operation Timofey wants to know the of the current tree ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "Let s store for each vertex the minimum distance from it to the nearest one let s call it We will also store the global answer which for obvious reasons does not increase we will call it Let s now color the vertex let s set and run a depth first search from it This DFS will visit the vertices with Let us consider the vertex and its neighbour If we can relax through let s do it and start from Otherwise has a closer neighbour let s try to update the answer through it Also do not forget to update the answer via from all vertices that we visited The correctness of the algorithm is obvious let s evaluate its time complexity It is easy to notice that after the first operations We enter only the vertices from which firstly does not exceed and secondly was relaxed by the parent that is decreased by at least So we allowed ourselves a complete tree bypassing for the first operations and then amortized performed no more than operations The final asymptotics will be "}
{"statement": "You are given some Tetris field consisting of n columns The initial height of the i th column of the field is a i blocks On top of these columns you can place figures of size 2 times 1 i e the height of this figure is 2 blocks and the width of this figure is 1 block Note that you rotate these figures Your task is to say if you can clear the whole field by placing such figures More formally the problem can be described like this The following process occurs while You place one figure 2 times 1 choose some i from 1 to n and replace a i with a i 2 then while all a i are greater than zero replace each a i with a i 1 And your task is to determine if it is possible to clear the whole field i e finish the described process choosing the places for new figures properly You have to answer t independent test cases ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "The answer is only if all have the same parity i e all are odd or all are even That s because placing the block doesn t change the parity of the element and the operation changes the parity of all elements in the array "}
{"statement": "Given an array of n positive integers a 1 a 2 dots a n 1 le a i le 1000 Find the maximum value of i j such that a i and a j are coprime dagger or 1 if no such i j exist For example consider the array 1 3 5 2 4 7 7 The maximum value of i j that can be obtained is 5 7 since a 5 4 and a 7 7 are coprime dagger Two integers p and q are coprime if the only positive integer that is a divisor of both of them is 1 that is their greatest common divisor is 1 ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Note that the array has at most distinct elements since For each value store the largest index it is in Then we can brute force all pairs of values and find the coprime pair with largest sum of indices The time complexity is per testcase "}
{"statement": "There are n benches near the Main Walkway in Summer Infomatics School These benches are numbered by integers from 1 to n in order they follow Also there are m cookie sellers near the Walkway The i th 1 le i le m cookie sellers is located near the s i th bench Petya is standing in the beginning of the Walkway He will pass near all benches starting from the 1 st bench and ending with the n th bench Petya passes the distance between two consecutive benches in 1 minute He has a knapsack with an infinite amount of cookies Petya is going to eat cookies from his knapsack and buy them from cookie sellers during the walk Petya eats cookies only near the benches according to the following rule he will eat the cookie near the i th 1 le i le n bench if and only if of the following conditions holds There is a cookie seller near the i th bench Then Petya will buy a cookie from cookie seller and eat it immediately Petya has not yet eaten a cookie Then Petya will take a cookie from his knapsack and eat it immediately At least d minutes passed since Petya ate the previous cookie In other words Petya has not eaten a cookie near the benches i 1 i 2 ldots max i d 1 1 Then Petya will take a cookie from his knapsack and eat it immediately You may assume that Petya eats cookies instantly Petya will not eat two or more cookies near the same bench You want to the number of cookies Petya will eat during his walk In order to do this you will ask the administration of the Summer Informatics School to remove cookie seller from the Walkway before Petya starts his walk Please determine the minimum possible number of cookies Petya can eat after removing exactly one cookie seller Also determine the number of cookie sellers such that if you remove one of them Petya will eat the minimum possible number of cookies ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "First let s calculate how many cookies Petya will eat if we don t remove the cookie sellers at all we will later refer to this value as Note that since the cookie sellers reset the time elapsed since the last eaten cookie the number of cookies eaten on all segments between adjacent cookie sellers are counted independently Therefore we can easily calculate let s iterate through the cookie sellers from to For each of them we should add the number to We should also carefully take into account the cookies that Petya will eat on the segments and it might help to assume that there are two more cookie sellers at positions and In order to find the minimum possible number of cookies eaten by Petya we will fix the cookie seller that we remove Let it be the cookie seller Then the number of cookies eaten by Petya will be for the first and last cookie sellers the formulas may differ slightly Thus we can find the number of cookies that Petya will eat if a certain cookie seller is removed in After going through all options we will be able to find the answer to the problem The final complexity of the solution is because array is sorted in the input "}
{"statement": "Natasha s favourite numbers are n and 1 and Sasha s favourite numbers are m and 1 One day Natasha and Sasha met and wrote down every possible array of length n m such that some n of its elements are equal to 1 and another m elements are equal to 1 For each such array they counted its maximal prefix sum probably an empty one which is equal to 0 in another words if every nonempty prefix sum is less to zero then it is considered equal to zero Formally denote as f a the maximal prefix sum of an array a 1 ldots l of length l geq 0 Then f a max 0 smash displaystyle max 1 leq i leq l sum j 1 i a j Now they want to count the sum of maximal prefix sums for each such an array and they are asking you to help As this sum can be very large output it modulo 998 244 853 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Let s count a dp the number of arrays consisting of ones and minus ones such that their maximal prefix sum is equal to if then else if then else because if we consider any array consisting of ones and minus ones which maximal prefix sum is then adding a minus one to the end leaves it equal to also if we consider any array consisting of ones and minus ones which maximal prefix sum is then adding a one to the end leaves it equal to because Now let s count a dp the answer to the problem for and if then else if then else That is because if we consider any array of ones and minus ones there are such arrays then adding a one in its beginning increases its maximal prefix sum by also if we consider any array of ones and minus ones then adding a minus one in its beginning either decreases its maximal prefix sum by if it was greater than there are such arrays or leaves it equal to So the answer to the problem is "}
{"statement": "Vasya had two arrays consisting of non negative integers of size and of size Vasya chose a positive integer and created an matrix using the following formula Vasya wrote down matrix on a piece of paper and put it in the table A year later Vasya was cleaning his table when he found a piece of paper containing an matrix He remembered making a matrix one day by the rules given above but he was not sure if he had found the paper with the matrix from those days Your task is to find out if the matrix that you ve found could have been obtained by following these rules and if it could then for what numbers it is possible ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "First we note that if the sequences and are a valid solution then so are the sequences and for any integer This means that we can consider to be equal to 0 which allows us to recover the sequence by simply taking the first row of the matrix Knowing we can also recover for example by subtracting from the first column of the matrix At this stage we allow and to contain negative numbers which can be later fixed by adding a sufficient amount of times Now we consider the error matrix If consists entirely of 0s then we ve found our solution by taking a sufficiently large That is Otherwise we note that which implies that is a divisor of The greatest such number is itself so all that remains is to check if is strictly greater than all the elements of the matrix If that is the case then we ve found our solution by setting Unable to parse markup type CF TEX Prepared by Kostroma riadwawAuthor of editorial riadwaw "}
{"statement": "Anton likes to play chess and so does his friend Danik Once they have played games in a row For each game it s known who was the winner Anton or Danik None of the games ended with a tie Now Anton wonders who won more games he or Danik Help him determine this ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let will be amount of characters in the string and will be amount of characters in the string Then if we print If we print If we print Time complexity is "}
{"statement": "There are n weighted points on the OX axis The coordinate and the weight of the i th point is x i and w i respectively All points have distinct coordinates and positive weights Also x i x i 1 holds for any 1 leq i n The weighted distance between i th point and j th point is defined as x i x j cdot w i w j where val denotes the absolute value of val You should answer q queries where the i th query asks the following Find the weighted distance among all pairs of distinct points among the points in subarray l i r i ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "First of all let s solve the problem for the whole array Define as the biggest satisfying and and as the smallest satisfying and Then we consider pairs of points and for each In conclusion the closest pair the pair with the minimum weighted distance must be among them Proof Assume that is the closest pair and If holds then must holds otherwise would obviously be a better pair Similarly if holds then must holds otherwise would obviously be a better pair The lemma above also applies to range queries by the exact same proof So now we first need to find and for each this could be simply done with a stack Then imagine we draw lines between the endpoints of each pair and the problem could be reduced to given weighted segments for each query find the one with the minimum weight that is totally covered by This is actually a classic problem which could be solved by sweep line trick any data structure able to maintain prefix minimum with single point updates like BIT or segment tree Total Complexity "}
{"statement": "Misha walked through the snowy forest and he was so fascinated by the trees to decide to draw his own tree Misha would like to construct a rooted tree with n vertices indexed from 1 to n where the root has index 1 Every other vertex has a p i and i is called a of vertex p i Vertex u belongs to the of vertex v iff v is reachable from u while iterating over the parents u p u p p u Clearly v belongs to its own subtree and the number of vertices in the subtree is called the of the subtree Misha is only interested in trees where every vertex belongs to the subtree of vertex 1 Below there is a tree with 6 vertices The subtree of vertex 2 contains vertices 2 3 4 5 Hence the size of its subtree is 4 The of the tree is defined as the maximum number of children in any vertex For example for the tree above the branching coefficient equals 2 Your task is to construct a tree with n vertices such that the sum of the subtree sizes for all vertices equals s and the branching coefficient is minimum possible ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "Note that vertex belongs to subtrees of vertexes which lay on its way to root So sum of sizes of subtrees is equal to where is sum of lengths of ways from root to vertexes Let s consider which sum of sizes of subtrees can be in tree with branching coefficient less or equal than Minimal sum can be achieved in nary tree it consists of root vertexes on distance on distance etc the last level can be filled not completely Maximal sum can be achieved in bamboo tree which consists of only one way with length If is bigger than sum in this tree the answer will be Let s find minimal such that is not smaller than sum of sizes of subtrees in nary tree using binary search Now is between minimal and maximal sum of sizes of subtrees in tree with branching coefficient which is not bigger than Let s show how to build tree with the given sum which is between these two borders Let s start with nary tree Let s realize recursive function which rebuilds tree Let we are in a subtree and want to increase sum of sizes of subtrees by in this subtree We can change this subtree to bamboo with same number of vertexes if the sum of sizeof of subtrees won t be too big Otherwise we run this function from subtrees in some order If we reach needed sum we will terminate the process Otherwise every subtree of child is bamboo now current sum of sizes is smaller than needed but if we merged bamboos it would be bigger than it Let s move vertexes to the end of the first bamboo from others Over time after next moving sum of sizes will increase too much We can move it to the another position in the first bamboo in order to make sum equal to and terminate the process But if we believe that every tree with sum of sizes of subtrees between maximal and minimal can be built there is another solution with complexity which is easier to realize The sum of subtree sizes is influenced only by the number of vertices at each distance and not by their mutual arrangement Sum of sizes of subtrees is equal to where number of vertexes on distance from the root Let s built this array of counts These conditions must be satisfied If the th element is bigger than than th element must be bigger than If the th element is equal to th mustn t be bigger than Sum of elements must be equal to Let we have recovered some prefix of this array i e we know that we can fill rest and sum of sizes of subtrees will be equal to Let s try to put some value to the next element We know that the tree can be rebuilt so that the sum is any between maximum and minimum so there are two conditions which are satisfied we want to put value to position must be big enough so if we fill suffix with numbers the last non zero number can be smaller sum of numbers is sum of sizes of subtrees will be not greater to must be small enough so if we fill suffix with sum of sizes of subtrees will be not less than Both borders form some segment of values which could be put to this position We haven t to look for the left border just find the right border by binsearch and put number which is equal to it We can easily restore the tree using array "}
{"statement": "The Fair Nut found a string s The string consists of lowercase Latin letters The Nut is a curious guy so he wants to find the number of strictly increasing sequences p 1 p 2 ldots p k such that For each i 1 leq i leq k s p i For each i 1 leq i k there is such j that p i j p i 1 and s j The Nut is upset because he doesn t know how to find the number Help him This number should be calculated modulo 10 9 7 ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Firstly let s erase all symbols different from and Then let s split string on blocks of consecutive symbols Now we need to multiply all sizes of blocks increased by 1 It is an answer which also includes one empty subsequence so we should just decrease it by one "}
{"statement": "Valera had an undirected connected graph without self loops and multiple edges consisting of vertices The graph had an interesting property there were at most edges adjacent to each of its vertices For convenience we will assume that the graph vertices were indexed by integers from 1 to One day Valera counted the shortest distances from one of the graph vertices to all other ones and wrote them out in array Thus element of the array shows the shortest distance from the vertex Valera chose to vertex number Then something irreparable terrible happened Valera lost the initial graph However he still has the array Help him restore the lost graph ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "First of all let us notice that it must be only one in Also means that is the vertex from which Valera calculated the distance to the other vertices Let s notice that every vertex with must be adjacent only to the vertices such that Besides there is always must be such neighboor of that Let s build sought graph by adding one vertex to the existing graph We will add vertex in order of increasing their distance to Initially we have one vertex with number in our graph When we add vertex with let s consider such vertices that Let s choose the vertex with minimal degree among them If this value is equal to then there is no solution In other case let s add to our graph and add the edge to the answer If there are no vertices with distance to then the answer is also If everything fine we will get the answer which is tree so the number of edges in it equals "}
{"statement": "Mr Kitayuta has kindly given you a string consisting of lowercase English letters You are asked to insert exactly one lowercase English letter into to make it a palindrome A is a string that reads the same forward and backward For example and are all palindromes while and are not You can choose any lowercase English letter and insert it to any position of possibly to the beginning or the end of You have to insert a letter even if the given string is already a palindrome If it is possible to insert one lowercase English letter into so that the resulting string will be a palindrome print the string after the insertion Otherwise print without quotes case sensitive In case there is more than one palindrome that can be obtained you are allowed to print any of them ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": " Problem Given a string turn it into a palindrome by inserting one letter or state that it is impossible Problem by evima Since the string is short at most 10 characters you can simply try every possible way of inserting a letter where and what to insert and check if the resulting string is a palindrome The writer s code C 9501249Note For some strange reason we contest managers cannot submit solutions so that everyone can see them PraveenDhinwa told us how to do so Thank you "}
{"statement": "After waking up at Andrew realised that he had forgotten to feed his only cat for yet another time guess why there s only one cat The cat s current hunger level is points moreover each minute without food increases his hunger by points At any time Andrew can visit the store where tasty buns are sold you can assume that is doesn t take time to get to the store and back One such bun costs roubles and decreases hunger by points Since the demand for bakery drops heavily in the evening there is a special discount for buns starting from note that the cost might become rational Of course buns cannot be sold by parts Determine the minimum amount of money Andrew has to spend in order to feed his cat The cat is considered fed if its hunger level is less than or equal to zero ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "It s optimal to buy buns either right after waking up or at if possible because between the awakening and cost doesn t change but cat s hunger does There was one extra case when Andrew wakes up after and has only one possible option of buying everything since he cannot turn back time "}
{"statement": "Stitch likes experimenting with different machines with his friend Sparky Today they built another machine The main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive Each of these rods must carry an electric charge quantitatively equal to either 1 or 1 otherwise the machine will not work Another condition for this machine to work is that the sign variable sum of the charge on all rods must be zero More formally the rods can be represented as an array of n numbers characterizing the charge either 1 or 1 Then the condition must hold a 1 a 2 a 3 a 4 ldots 0 or sum limits i 1 n 1 i 1 cdot a i 0 Sparky charged all n rods with an electric current but unfortunately it happened that the rods were not charged correctly the sign variable sum of the charge is not zero The friends decided to leave only some of the rods in the machine Sparky has q questions In the ith question Sparky asks if the machine consisted only of rods with numbers l i to r i inclusive what minimal number of rods could be removed from the machine so that the sign variable sum of charges on the remaining ones would be zero Perhaps the friends got something wrong and the sign variable sum is already zero In that case you don t have to remove the rods at all If the number of rods is zero we will assume that the sign variable sum of charges is zero that is we can always remove all rods Help your friends and answer all of Sparky s questions ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s prove everything for a particular segment of length And at the end we ll show how to quickly solve the problem for many segments Let the length of the segment and let the array corresponding to the segment if is at the th position in the segment and if is at the th position in the segment Introduce a new array with being equal to the signed sum on the whole array if the th element was removed from it Then The parity of the length of the segment and the parity of the number of elements to be removed from it are the same It is not difficult to show that if or otherwise Proof of this fact Let Then it is easy to see that when is removed the segment will look exactly the same as when is removed So Now let Denote by the sign variable sum on the interval to taking into account the sign i e if is odd the first number is taken with the plus sign otherwise with the minus sign Then it is easy to see that and Hence if we consider the two cases and we see that If is odd then there exists such that Let us prove this If or then the statement is proved Now let and Then since the neighboring values in the array differ by no more than and all elements are even then there is bound to be zero between the first and last element The case is proved similarly If then there cannot be such a case that and and there cannot be such a case that and In fact let the sign variable sum of the whole segment be Then and Since and are even numbers therefore either at least one of them is zero or they are of different signs Thus the final result is if the sign variable sum is already zero output zero otherwise if the segment is of odd length output otherwise output To quickly determine the sign variable sum we use the prefix sum Asymptotics per test case "}
{"statement": "Gerald is very particular to eight point sets He thinks that any decent eight point set must consist of all pairwise intersections of three distinct integer vertical straight lines and three distinct integer horizontal straight lines except for the average of these nine points In other words there must be three integers and three more integers such that and the eight point set consists of all points except for point You have a set of eight points Find out if Gerald can use this set ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "In this problem you must to do only what s written you must to define does this set of points sutisfies to decribed conditions There are many ways to define it For instance But I think that to read editoral of this problem is not good idea It is better to just look at the implementation "}
{"statement": "Our brave travelers reached an island where pirates had buried treasure However as the ship was about to moor the captain found out that some rat ate a piece of the treasure map The treasure map can be represented as a rectangle in size Each cell stands for an islands square the square s side length equals to a mile Some cells stand for the sea and they are impenetrable All other cells are penetrable i e available and some of them contain local sights For example the large tree on the hills or the cave in the rocks Besides the map also has a set of instructions Each instruction is in the following form Walk miles in the direction The possible directions are north south east and west If you follow these instructions carefully you should fulfill all of them one by one then you should reach exactly the place where treasures are buried Unfortunately the captain doesn t know the place where to start fulfilling the instructions as that very piece of the map was lost But the captain very well remembers that the place contained some local sight Besides the captain knows that the whole way goes through the island s penetrable squares The captain wants to know which sights are worth checking He asks you to help him with that ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Solution is simulation of all insrtuctions from all of local sights But naive solution doesn t fit into time limit You should speed up this solution and do every instruction in O 1 You can use one of following things 1 For every position and every direction you can precalculate nearest position of sea Now before than you do an instruction you should check that nearest position of sea further than position whereto you move after doing the instruction 2 Let sea cells have 1 and all other ones have 0 For every cell i j you can calculate sum of all cells in the rectangle with angles in 1 1 and i j It can be done by the operations like sum i j sum i 1 j sum i j 1 sum i 1 j 1 smth where smth is 0 or 1 according to type of according cell i j Now you can determine sum of numbers for all rectangles of the map Before you do instruction you should chech that sum of rectangle on which you will go has sum 0 Solution has complexity O nm kz where z is number of local sights this number no more than 26 "}
{"statement": "Luca has a cypher made up of a sequence of n wheels each with a digit a i written on it On the i th wheel he made b i moves Each move is one of two types move denoted by texttt U it increases the i th digit by 1 After applying the up move on 9 it becomes 0 move denoted by texttt D it decreases the i th digit by 1 After applying the down move on 0 it becomes 9 Luca knows the final sequence of wheels and the moves for each wheel Help him find the original sequence and crack the cypher ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "We will perform each move in reverse from the final sequence of the cypher move it increases the th digit by After applying the up move on it becomes move denoted by it decreases the th digit by After applying the down move on it becomes Now we just need to implement the two types of moves The time complexity is per test case "}
{"statement": "Recently a new building with a new layout was constructed in Monocarp s hometown According to this new layout the building consists of three types of apartments three room five room and seven room apartments It s also known that each room of each apartment has exactly one window In other words a three room apartment has three windows a five room five windows and a seven room seven windows Monocarp went around the building and counted n windows Now he is wondering how many apartments of each type the building may have Unfortunately Monocarp only recently has learned to count so he is asking you to help him to calculate the possible quantities of three room five room and seven room apartments in the building that has n windows If there are multiple answers you can print any of them Here are some examples if Monocarp has counted 30 windows there could have been 2 three room apartments 2 five room apartments and 2 seven room apartments since 2 cdot 3 2 cdot 5 2 cdot 7 30 if Monocarp has counted 67 windows there could have been 7 three room apartments 5 five room apartments and 3 seven room apartments since 7 cdot 3 5 cdot 5 3 cdot 7 67 if Monocarp has counted 4 windows he should have mistaken since no building with the aforementioned layout can have 4 windows ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "There are many possible solutions to this problem The simplest one is to notice that using several flats of size and one flat of some size possibly also possibly not we can get any equal to or The only numbers that don t belong to these lists are and and it s easy to see that there is no answer for that numbers So the solution is to try all possible sizes of one flat and if the remaining number of windows is non negative and divisible by then take the required number of three room flats "}
{"statement": "You ve got a matrix consisting of zeroes and a single number one Let s index the matrix rows by numbers from to from top to bottom let s index the matrix columns by numbers from to from left to right In one move you are allowed to apply one of the two following transformations to the matrix Swap two neighboring matrix rows that is rows with indexes and for some integer Swap two neighboring matrix columns that is columns with indexes and for some integer You think that a matrix looks if the single number one of the matrix is located in its middle in the cell that is on the intersection of the third row and the third column Count the minimum number of moves needed to make the matrix beautiful ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "If the single is located on the intersection of the th row and the th column 1 based numeration then the answer is "}
{"statement": "Before the last stage of the exam the director conducted an interview He gave Gon n piles of stones the i th pile having a i stones Each stone is identical and weighs 1 grams except for one special stone that is part of an unknown pile and weighs 2 grams Gon can only ask the director questions of one kind he can choose k piles and the director will tell him the total weight of the piles chosen More formally Gon can choose an integer k 1 leq k leq n and k unique piles p 1 p 2 dots p k 1 leq p i leq n and the director will return the total weight m p 1 m p 2 dots m p k where m i denotes the weight of pile i Gon is tasked with finding the pile that contains the special stone However the director is busy Help Gon find this pile in at most mathbf 30 queries ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Consider this question if we take some range of piles how do we know if it contains the special pile If it doesn t contain the special pile then the total weight should be grams since each stone weighs one gram If it does contain the special pile then the total weight should be grams since each stone weighs one gram except for the special stone which weighs two grams So we can determine if a range contains the special pile using a single query Now we can binary search for the answer first check the range If it has the special pile then split it into two parts and check if one of them has the special stone otherwise check the other half This will take at most queries which is well below the limit of The time complexity is for reading the input "}
{"statement": "Due to the coronavirus pandemic city authorities obligated citizens to keep a social distance The mayor of the city Semyon wants to light up Gluharniki park so that people could see each other even at night to keep the social distance The park is a rectangular table with n rows and m columns where the cells of the table are squares and the boundaries between the cells are streets External borders are also streets Every street has length 1 For example park with n m 2 has 12 streets You were assigned to develop a plan for lighting the park You can put lanterns in the middle of the streets The lamp lights two squares near it or only one square if it stands on the border of the park Semyon wants to spend the least possible amount of money on lighting but also wants people throughout the park to keep a social distance So he asks you to find the minimum number of lanterns that are required to light all the squares ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Note that if at least one of the sides is even the square can be divided into pairs of neighbors and the answer is If both sides are odd we can first light up a part of the park Then we ll still have the part We can light it up with lanterns Then the total number of the lanterns is Note that both cases can be combined into one formula The overall compexity is per test "}
{"statement": "You are given two arrays a and b of n positive integers each You can apply the following operation to them any number of times Select an index i 1 leq i leq n and swap a i with b i i e a i becomes b i and vice versa Find the possible value of max a 1 a 2 ldots a n cdot max b 1 b 2 ldots b n you can get after applying such operation any number of times possibly zero ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "SolutionLet The answer will always be where is the maximum of the array that does not contain Since is fixed the problem can be reduced to minimize that is minimize the maximum of the array that does not contain the global maximum WLOG assume that the global maximum will be in the array we can swap elements at each index such that ending with for all It can be shown that the maximum of array is minimized in this way Time complexity Code "}
{"statement": "You are given an array consisting of n integers Your task is to determine whether it is possible to color all its elements in two colors in such a way that the sums of the elements of both colors have the same parity and each color has at least one element colored For example if the array is 1 2 4 3 2 3 5 4 we can color it as follows color blue 1 color blue 2 color red 4 color blue 3 color red 2 color red 3 color red 5 color red 4 where the sum of the blue elements is 6 and the sum of the red elements is 18 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s analyze the impact of adding odd or even numbers to a set with sum If you add an even element to the set the parity of remains unchanged If you add an odd element to the set the parity of changes Based on this observation let s focus on the coloring of odd elements in the array The number of odd elements colored in blue and the number of odd elements colored in red must have the same parity for a valid coloring This is because we need to divide the odd elements into two parts blue and red To achieve the same parity for both blue and red odd elements the total number of odd elements in the array must be even If it is not even we won t be able to create two sets with the same parity Hence the answer is YES if the number of odd elements in the array is even and NO otherwise "}
{"statement": "You are given a string s consisting only of characters 0 and 1 You have to choose a contiguous substring of s and remove all occurrences of the character which is a strict minority in it from the substring That is if the amount of 0 s in the substring is strictly smaller than the amount of 1 s remove all occurrences of 0 from the substring If the amount of 1 s is strictly smaller than the amount of 0 s remove all occurrences of 1 If the amounts are the same do nothing You have to apply the operation What is the maximum amount of characters that can be removed ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s try to estimate the maximum possible answer Best case you will be able to remove either all zeros or all ones from the entire string Whichever has the least occurrences can be the answer If the amounts of zeros and ones in the string are different this bound is actually easy to reach just choose the substring that is the entire string If the amounts are the same the bound is impossible to reach Choosing the entire string will do nothing and asking a smaller substring will decrease the answer The smallest we can decrease the answer by is If you choose the substring that is the string without the last character you will decrease one of the amounts by one That will make the amounts different and the bound will be reached Overall complexity per testcase "}
{"statement": "There are n bags numbered from 1 to n the i th bag contains a i golden coins and b i silver coins The value of a gold coin is 1 The value of a silver coin is either 0 or 1 determined for each silver coin independently 0 with probability frac 1 2 1 with probability frac 1 2 You have to answer q independent queries Each query is the following l r calculate the probability that the total value of coins in bags from l to r is strictly greater than the total value in all other bags ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "To calculate the probability we will calculate the number of ways to assign values to silver coins in such a way that the total value inside the segment is greater than the total value outside Let define x as the number of silver coins with value 1 inside the segment y as the number of silver coins with value 1 outside k as the difference between golden coins inside and outside the segment Then the way to assign values to the coins is considered good if condition x y k 0 is met We have an issue here coins in the segment and coins outside the segment affect the inequality in different directions that is one of them increases the difference with a probability of frac 1 2 while others decrease with a probability of frac 1 2 It is not convenient for us So let s fix it we can say that the coins inside the segment have value 1 by default and with a probability of frac 1 2 are 0 And the coins outside the segment have value of 0 by default and with a probability of frac 1 2 are 1 Then each of them with a probability of frac 1 2 reduces the difference total in the segment minus total outside the segment by 1 Thus we have some starting value that decreases by 1 with a probability of frac 1 2 m times where m is the total number of silver coins And it is left to calculate the number of ways when the number of decreases is not big enough to break the inequality Let cur be the number of silver coins inside the segment Then the starting value is st k cur and the number of ways to not break the inequality is equal to sum sum limits i 0 st 1 binom m i And the answer to the problem is equal to frac sum 2 m Now we only need to consider how to answer queries faster than iterating from 0 to st But thanks to the fact that the value of m is always the same we can precalculate the prefix sums on these binomial coefficients "}
{"statement": "A championship is held in Berland in which n players participate The player with the number i has a i a i ge 1 tokens The championship consists of n 1 games which are played according to the following rules in each game two random players with non zero tokens are selected the player with more tokens is considered the winner of the game in case of a tie the winner is chosen randomly the winning player takes all of the loser s tokens The last player with non zero tokens is the winner of the championship All random decisions that are made during the championship are made equally probable and independently For example if n 4 a 1 2 4 3 then one of the options for the game there could be other options is during the first game the first and fourth players were selected The fourth player has more tokens so he takes the first player s tokens Now a 0 2 4 4 during the second game the fourth and third players were selected They have the same number of tokens but in a random way the third player is the winner Now a 0 2 8 0 during the third game the second and third players were selected The third player has more tokens so he takes the second player s tokens Now a 0 0 10 0 the third player is declared the winner of the championship Championship winners will receive personalized prizes Therefore the judges want to know in advance which players have a chance of winning i e have a non zero probability of winning the championship You have been asked to find all such players ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "How can a player be checked if he can win the championship Obviously he must participate in all the games otherwise we will increase the number of tokens of the opponents So you can sort out all the people and play greedily with the weakest ones Such a check will work in linear time after sorting so we got a solution for The simplest solution to this problem is binary search for the answer We will sort all the players by the number of tokens they have Let s prove that if player can win then player can also win the numbers are dealt after sorting If the player was able to win then based on the strategy above he was able to defeat all the players on the prefix The player can also defeat all these players since he has at least as many tokens Now both players have to defeat all opponents with numbers and the number of chips both players have is equal to the sum of the first numbers in the array So if the player has a strategy then the player can use the same strategy Hence the answer to the problem is sorted suffix of the input array You can find this suffix using binary search and linear time checking Bonus this problem also has a fully linear after sorting solution "}
{"statement": "You are given two integers a and b and q queries The i th query consists of two numbers l i and r i and the answer to it is the number of integers x such that l i le x le r i and x bmod a bmod b ne x bmod b bmod a Calculate the answer for each query Recall that y bmod z is the remainder of the division of y by z For example 5 bmod 3 2 7 bmod 8 7 9 bmod 4 1 9 bmod 9 0 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "It s quite easy to see that What does it mean The property given in the statement holds for if and only if it holds for It allows us to answer each testcase in as follows for each number from to we may check the given property before processing the queries and build an array of prefix sums on it to efficiently count the number of integers satisfying the property from the segment where Then each query can be divided into two prefix queries and To answer a prefix query in we can calculate the number of full segments of length inside this prefix that is and the length of the last segment of numbers that don t belong into a full segment that is To handle full segments we multiply the number of integers satisfying the property on one segment by the number of such segments and to handle the last part of segment we use prefix sums "}
{"statement": "Vasya has become interested in wrestling In wrestling wrestlers use techniques for which they are awarded points by judges The wrestler who gets the most points wins When the numbers of points of both wrestlers are equal the wrestler whose sequence of points is wins If the sequences of the awarded points coincide the wrestler who performed the last technique wins Your task is to determine which wrestler won ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "We need to vectors in which we will save points of first and second wrestlers and two int s where we will save who made the last technique and what is the sum of all the numbers in the input If the sum is not zero we know the answer Else we pass by the vectors checking are there respective elements which are not equal If yes then we know the answer else everything depends on who made the last technique "}
{"statement": "A lot of students spend their winter holidays productively Vlad has advanced very well in doing so For three days already fueled by salads and tangerines the leftovers from New Year celebration he has been calibrating his rating in his favorite MOBA game playing as a hero named Perun Perun has an ultimate ability called Thunderwrath At the instant of its activation each enemy on the map of them in total loses health points as a single time effect It also has a restriction it can only activated when the moment of time is an The initial bounty for killing an enemy is Additionally it increases by each second Formally if at some second the ability is activated and the th enemy is killed as a result i e his health drops to zero or lower Vlad earns units of gold Every enemy can receive damage as well as be healed There are multiple ways of doing so but Vlad is not interested in details For each of enemies he knows maximum number of health points for the th enemy initial health of the enemy on the th second the amount of health the th enemy can regenerate per second There also health updates Vlad knows about time when the health was updated the enemy whose health was updated updated health points for Obviously Vlad wants to maximize his profit If it s necessary he could even wait for years to activate his ability at the right second Help him determine the exact second note that it must be from inclusively to so that a single activation of the ability would yield Vlad the maximum possible amount of gold and print this amount ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "The statement almost directly states the formula for the answer it is calculated as where is amount of enemies we can kill at th second Thus we need to learn how to calculate and find such values of that are potential candidates for the point the maximum is achieved at First let s consider the case we have no enemies with maximum health exceeding Additionally let So how we can calculate Let s model the process There are three kinds of events that affect its value Some enemy has his health updated it is now less than or equal to thus we can kill the enemy Some enemy has his health updated it is now greater than thus we can t kill the enemy The enemy has regenerated enough health to become invincible again One can observe that the optimal answer is reached at the second exactly preceeding the events of the second and the third kind Indeed otherwise we can move on to the next second the bounty is increased and doesn t decrease thus providing us with a better answer What remains for us is to calculate the time when the aforementioned events occur to run scanline The first two kinds correspond directly to the updates and initial values we can treat them as updates occuring at zeroth second Let s calculate when the events of third kind would occur Let the second be the moment when one of the enemies health became equal to Let be the regeneration rate of the enemy At the second he will regenerate enough health to become invincible again One also needs take care of the case when if there are no health updates after the enemy became killable one can kill him at any moment and earn infinitely large amount of money Note that one should need when did the last event of the first kind happen as updates cancel the potentially planned events of the third kind Now consider the case when some enemy has maximum health less than or equal to In that case there is always an enemy to kill and since the bounty increases over time the answer can be infinitely large Finally if the bounty stays constant and we cannot obtain the infinitely large answer Since the bounty is constant we are to find the maximum value of and multiply it by bounty This is a simple task and is left as an excersise Time complexity "}
{"statement": "A new agent called Killjoy invented a virus COVID 2069 that infects accounts on Codeforces Each account has a rating described by it can possibly be negative or very large Killjoy s account is already infected and has a rating equal to x Its rating is constant There are n accounts except hers numbered from 1 to n The i th account s initial rating is a i Any infected account initially the only infected account is Killjoy s instantly infects any uninfected account if their ratings are equal This can happen at the beginning before any rating changes and after each contest If an account is infected it can not be healed Contests are regularly held on Codeforces In each contest any of these n accounts including infected ones can participate Killjoy can t participate After each contest ratings are changed this way each participant s rating is changed by an integer but the sum of all changes must be equal to zero New ratings can be any integer Find out the minimal number of contests needed to infect all accounts You can choose which accounts will participate in each contest and how the ratings will change It can be proven that all accounts can be infected in some finite number of contests ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "If all accounts have the rating equal to then the answer is Now let s consider other cases Let s try to make all ratings equal to in a single contest It s possible only in two cases 1 If at least one account is already infected we can infect all other accounts in a single contest Let s say that some account is already infected then we can change all other accounts to except Let s say that summary changes are then we can decrease th account s rating by and every account will be infected while the summary changes will be equal to zero So this will take only contest 2 In this case we can just make all ratings equal and the sum of all changes will be because of the equality which means that we can infect everyone in only contest In all other cases the answer is Let s prove that We can make the ratings of first accounts equal to after the first contest and the last account will have rating equal to so that the sum of rating changes is still equal to zero After that first accounts are already infected and we can change the rating of the last account by so it s equal to and we will decrease the rating of the first account by so that the sum of rating changes is still equal to zero After such two contests all accounts will be infected "}
{"statement": "Slavic has an array of length n consisting only of zeroes and ones In one operation he removes either the first or the last element of the array What is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to s after performing all the operations In case the sum s can t be obtained after any amount of operations you should output ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Note that the remaining array is a subarray of the original array There are many ways to approach the problem Here is one solution which the main solution uses Compute prefix sums on the array so we can find out the value of quickly Let s iterate through the left endpoint from to Afterwards we can binary search on the smallest value of such that since this sum is strictly increasing The time complexity is "}
{"statement": "A binary string is a string where every character is texttt 0 or texttt 1 Call a binary string if it has an equal number of texttt 0 s and texttt 1 s Initially you have an infinite binary string t whose characters are all texttt 0 s You are given a sequence a of n updates where a i indicates that the character at index a i will be flipped texttt 0 leftrightarrow texttt 1 You need to keep and modify after each update a set S of ranges such that for each range l r the substring t l dots t r is a decent binary string and for all indices i such that t i texttt 1 there exists l r in S such that l leq i leq r You only need to output the ranges that are added to or removed from S after each update You can only add or remove ranges from S at most mathbf 10 6 times More formally let S i be the set of ranges after the i th update where S 0 varnothing the empty set Define X i to be the set of ranges removed after update i and Y i to be the set of ranges added after update i Then for 1 leq i leq n S i S i 1 setminus X i cup Y i The following should hold for all 1 leq i leq n forall a b in S i a neq b rightarrow a cap b varnothing X i subseteq S i 1 S i 1 setminus X i cap Y i varnothing displaystyle sum i 1 n X i Y i leq 10 6 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "After each update we want to maintain the invariant that each interval is balanced and additionally that there is a gap containing at least one zero in between each pair of consecutive intervals Since every must be contained in an interval this is equivalent to having non empty gaps between consecutive intervals after an update There are several cases we need to handle Case 1 Bit is changed from to Case 1a Bit is contained in an interval after the previous updateIf we are inside an interval then we want to grow the interval that contains it by 2 zeros to maintain balance If the interval containing is then we can expand it to Since there is at least one after each interval so this contains one of the two zeroes we need If there is another interval then increasing the right bound again by 1 would overlap with this interval In this case We know that as well so we can merge both intervals together into to get a total of two new zeros was also previously balanced so the interval is still balanced In this case we removed two intervals and added one interval so a total of three operations were used If there is no intervals where then so we can simply expand the current interval once more to One interval was removed and one interval was added so a total of two operations were used Case 1b Bit is not contained in an interval If there exists an interval where then we can expand it to This interval is directly after so expanding it by one to the left will include an extra since it is part of the gap between two intervals so including it balances One interval was removed and one interval was added so a total of two operations were used If there is no interval where then Therefore we can simply add which is balanced One interval was added so a total of one operation was used In both cases after adding a new interval to the set we can merge with any adjacent intervals to the left or right This will maintain the invariant that there is a gap between consecutive ranges as mentioned earlier We merge at most once to the left and one to the right Since the maximum number of operations done earlier is 3 the maximum number of operations in total is 5 in this case Case 2 Bit is changed from to Suppose that In this case we want to somehow split the interval into two balanced portions Now suppose we compute the prefix sums of the balance where corresponds to and corresponds to If is the first location where the prefix sum equals then we claim that we can split the interval into and To prove this note that the balance of the empty prefix is 0 so before the prefix sum equals for the first time it must have gone To have two decreases in a row we must have In the interval the final balance prefix sum is so the first interval is balanced Since we changed a to a and removed two s the first interval being balanced implies that the second interval is balanced as well In addition since the original interval satisfied the separation invariant and the new intervals are separated by two s the separation invariant is still satisfied To compute the first time when the balance prefix sum equals 2 we can use binary search on the interval using a lazy segment tree The segment tree represents a global balance prefix sum and we can range query the minimum balance on an interval We can binary search for the lowest index on the interval where the minimum prefix sum is less than 2 In this case we removed one interval and added two new intervals for a total of three operations In both cases we use at most 5 operations in a single step so we in total use at most operations which fits in our bound In practice this upper bound is quite loose Because of the binary search on the lazy segment tree the time complexity for this solution is Note that this can be optimized to by optimizing the binary search but this was not required "}
{"statement": "Vasya has two arrays A and B of lengths n and m respectively He can perform the following operation arbitrary number of times possibly zero he takes some consecutive subsegment of the array and replaces it with a single element equal to the sum of all elements on this subsegment For example from the array 1 10 100 1000 10000 Vasya can obtain array 1 1110 10000 and from array 1 2 3 Vasya can obtain array 6 Two arrays A and B are considered equal if and only if they have the same length and for each valid i A i B i Vasya wants to perform some of these operations on array A some on array B in such a way that arrays A and B become equal Moreover the lengths of the resulting arrays should be maximal possible Help Vasya to determine the maximum length of the arrays that he can achieve or output that it is impossible to make arrays A and B equal ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s prove that next greedy solution works each step we will find prefixes of minimal length of arrays such that its sums are equal and we will cut them forming next block If we will get valid partition in result so it is an optimal solution otherwise there is no solution Since length of prefix proportional to its sum so prefixes are minimal since its sums are minimal Let s prove this algorithm let optimal solution have alternative partition Since our solution cuts minimal possible prefixes so at some step optimal solution cuts prefix with greater sum and greater length But this prefixes in optimal solutions contain smaller prefixes found by greedy solution so it can be divided on two parts contradiction So we can keep prefixes and increase one which have smaller sum Result complexity is "}
{"statement": "A of length is a sequence of distinct integers A permutation is an identity permutation if for any the following equation holds A is the operation that swaps elements and in the permutation Let s assume that is the minimum number of swaps that you need to make the permutation an identity permutation Valera wonders how he can transform permutation into any permutation such that using the minimum number of swaps Help him do that ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "Problem author danilka pro In this task you should represent permutation as graph with vertexes and from every vertex exists exactly one edge to vertex It s easy to understand that such graph consists of simple cycles only If we make swap edges and will become edges and respectively Then if and is in the same cycle this cycle will break but if they are in different cycles these cycles will merge into one this means that every swap operation increases number of cycles by one or decreases it by one Assuming all above to get permutation from permutation we need to increase or decrease number of cycles in to Let number of cycles in Then always equals For satisfying lexicographical minimality we will review three cases 1 It s easy to understand that in this case you must decrease cycles number by merging cycles one by one with cycle containing vertex 1 This way every swap has form where Because every cycle vertex is bigger than previous cycle vertex this case can be solved with 2 In this case you should break cycle for every vertex making swap with smallest possible vertex it should be in this cycle too This could be done if represent cycle by line As soon as every cycle is broken with linear asymptotics this case solution works with Bonus this way of representing cycle lets us optimize solution to asymptotics you may think how 3 Besause in this case there is nothing need to be swapped It s highly recommended to inspect jury s solution 6850515 "}
{"statement": "The heat during the last few days has been really intense Scientists from all over the Berland study how the temperatures and weather change and they claim that this summer is abnormally hot But any scientific claim sounds a lot more reasonable if there are some numbers involved so they have decided to actually calculate some value which would represent how high the temperatures are Mathematicians of Berland State University came up with a special This value is calculated as follows Suppose we want to analyze the segment of n consecutive days We have measured the temperatures during these n days the temperature during i th day equals a i We denote the of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days So if we want to analyze the from day x to day y we calculate it as frac sum limits i x y a i y x 1 note that division is performed without any rounding The is the maximum of over all segments of not less than k consecutive days For example if analyzing the measures 3 4 1 2 and k 3 we are interested in segments 3 4 1 4 1 2 and 3 4 1 2 we want to find the maximum value of over these segments You have been hired by Berland State University to write a program that would compute the of a given period of days Are you up to this task ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "This task is very straight forward implementation problem So we can iterate over all segments of the given array calculate their sum and if the length of the current segment is not less than try to update the answer with the mean of this segment Overall complexity is "}
{"statement": "Alice and Bob play yet another game on an array a of size n Alice starts with an empty array c Both players take turns playing with Alice starting first On Alice s turn she picks one element from a appends that element to c and then deletes it from a On Bob s turn he picks one element from a and then deletes it from a The game ends when the array a is empty Game s score is defined to be the MEX dagger of c Alice wants to maximize the score while Bob wants to minimize it Find game s final score if both players play optimally dagger The operatorname MEX minimum excludant of an array of integers is defined as the smallest non negative integer which does not occur in the array For example The MEX of 2 2 1 is 0 because 0 does not belong to the array The MEX of 3 1 0 1 is 2 because 0 and 1 belong to the array but 2 does not The MEX of 0 3 1 2 is 4 because 0 1 2 and 3 belong to the array but 4 does not ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "For any s t whenever Bob chooses to remove an occurence of on the next move Alice simply chooses herself if she hasn t already taken before that Thus we only focus on now The answer is min first s t second s t Obviously Alice can t do better than the mex of array first s t Further among Alice can save atmost after which Bob will remove the smallest he can find This is optimal for Bob as well because he cannot do better when Alice removes the first s t on her first move "}
{"statement": "You are given an integer n and an array a 1 a 2 ldots a n You should reorder the elements of the array a in such way that the sum of textbf MEX on prefixes i th prefix is a 1 a 2 ldots a i is maximized Formally you should find an array b 1 b 2 ldots b n such that the sets of elements of arrays a and b are equal it is equivalent to array b can be found as an array a with some reordering of its elements and sum limits i 1 n textbf MEX b 1 b 2 ldots b i is maximized textbf MEX of a set of nonnegative integers is the minimal nonnegative integer such that it is not in the set For example textbf MEX 1 2 3 0 textbf MEX 0 1 2 4 5 3 ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "To maximize the sum of on prefixes we will use a greedy algorithm Firstly we put all unique elements in increasing order to get maximal on each prefix It is easy to see that replacing any two elements after that makes both and sum of less In the end we put all elements that are not used in any order because will not change and will still be maximal "}
{"statement": "Santa has n candies and he wants to gift them to k kids He wants to divide as many candies as possible between all k kids Santa can t divide one candy into parts but he is allowed to not use some candies at all Suppose the kid who recieves the minimum number of candies has a candies and the kid who recieves the maximum number of candies has b candies Then Santa will be if the both conditions are met at the same time b a le 1 it means b a or b a 1 the number of kids who has a 1 candies does not exceed lfloor frac k 2 rfloor less than or equal to lfloor frac k 2 rfloor lfloor frac k 2 rfloor is k divided by 2 and rounded to the nearest integer For example if k 5 then lfloor frac k 2 rfloor lfloor frac 5 2 rfloor 2 Your task is to find the maximum number of candies Santa can give to kids so that he will be You have to answer t independent test cases ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Firstly we can notice that we always can distribute where is the modulo operation candies between kids In this case and the answer is at least And then we can add the value to the answer Why Because there is only candies remain and the maximum number of kids to whom we can give one more candy is "}
{"statement": "There are n students in a school class the rating of the i th student on Codehorses is a i You have to form a team consisting of k students 1 le k le n such that the ratings of all team members If it is impossible to form a suitable team print without quotes Otherwise print and then print k distinct numbers which should be the indices of students in the team you form If there are multiple answers print any of them ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s write our unique function Keep the array of the taken elements Iterate over all elements in the array and if the current element is not used then add its index to the answer and set When finished check the number of distinct values that is the size of answer array If it is less than print Otherwise print and output the first elements of the answer "}
{"statement": "Olya likes milk very much She drinks cartons of milk each day if she has at least and drinks all of them if she doesn t But there s an issue expiration dates Each carton has a date after which you can t drink it you still can drink it exactly at the date written on the carton Due to this if Olya s fridge contains a carton past its expiry date she throws it away Olya hates throwing out cartons so when she drinks a carton she chooses the one which expires the fastest It s easy to understand that this strategy minimizes the amount of cartons thrown out and lets her avoid it if it s even possible The main issue Olya has is the one of buying new cartons Currently there are cartons of milk in Olya s fridge for each one an expiration date is known how soon does it expire measured in days In the shop that Olya visited there are cartons and the expiration date is known for each of those cartons as well Find the maximum number of cartons Olya can buy so that she wouldn t have to throw away any cartons Assume that Olya drank no cartons today ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let be the maximum expiry date in the input The key observation in this problem is the fact that if we can buy some cartons from the shop and not have to throw away the cartons we can buy cartons with the biggest expiry dates and we won t have to throw away any cartons either It happens because if we increase the carton s expiry date while having fixed distribution of cartons per days the distribution would stay correct Then let s learn to check for an arbitrary is it true that if we take cartons with the maximum expiry dates we can distribute those cartons per days so that we won t have to throw cartons away To do this it is sufficient to check for each day from to that the amount of cartons with expiry dates both from a fridge and bought is no bigger than Then the solution would be to search for maximum using the binary search If is the answer the check would pass for all from to and wouldn t for this monotony is sufficient for the binary search to work Then we output the found and the cartons with maximum expiry dates we don t even have to sort we can justdo an enumeration sort because This soluton runs in time "}
{"statement": "The Great Mushroom King descended to the dwarves but not everyone managed to see him Only the few chosen ones could see the King We know that only dwarves can see the Great Mushroom King Numbers are chosen by the Great Mushroom King himself in some complicated manner which is unclear to common dwarves The dwarven historians decided to document all visits of the Great Mushroom King For each visit the dwarven historians know three integers chosen by the Great Mushroom King for this visit They also know a prime number Help them to count the remainder of dividing the number of dwarves who can see the King by number for each visit ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "This is number theory problem I m trying to explain it step by step 1 Let s prove that LCD is maximum 2 Let Squaring both sides we get but we want to This means that d can be only 2 2 Let s make this lenghty product simplier We can count this by modulo p fast and divide it by 2r l if k is odd 3 There is many interesting things in this solution Firstly it doesn t work when p 2 but it can easily done by you The other problem is harder what if this means that for each i l and this mean that for each i l k2i 1 p2 And the product by modulo p is equal to 2r l 1 "}
{"statement": "Dora loves adventures quite a lot During some journey she encountered an amazing city which is formed by n streets along the Eastern direction and m streets across the Southern direction Naturally this city has nm intersections At any intersection of i th Eastern street and j th Southern street there is a monumental skyscraper Dora instantly became curious and decided to explore the heights of the city buildings When Dora passes through the intersection of the i th Eastern and j th Southern street she examines those two streets After Dora learns the heights of all the skyscrapers on those two streets she wonders how one should reassign heights to the skyscrapers on those two streets so that the maximum height would be as small as possible and the result of comparing the heights of any two skyscrapers on one street wouldn t change Formally on every of nm intersections Dora solves an independent problem She sees n m 1 skyscrapers and for each of them she knows its real height Moreover any two heights can be compared to get a result greater smaller or equal Now Dora wants to select some integer x and assign every skyscraper a height from 1 to x When assigning heights Dora wants to preserve the relative order of the skyscrapers in both streets That is the result of any comparison of heights of two skyscrapers in the current Eastern street shouldn t change and the result of any comparison of heights of two skyscrapers in current Southern street shouldn t change as well Note that skyscrapers located on the Southern street are not compared with skyscrapers located on the Eastern street only However the skyscraper located at the streets intersection can be compared with both Southern and Eastern skyscrapers For every intersection Dora wants to calculate the minimum possible x For example if the intersection and the two streets corresponding to it look as follows Then it is optimal to replace the heights of the skyscrapers as follows note that all comparisons less equal greater inside the Eastern street and inside the Southern street are preserved The largest used number is 5 hence the answer for this intersection would be 5 Help Dora to compute the answers for each intersection ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s examine the th row and th column suppose the element on their intersection is Let s denote the number of elements less than in the row as and in the column as Similarly let s say that the number of different elements greater than in row is and in column is L Less G Greater Then the answer is First summand is necessary to fit all elements second is for and the last one for Now let s find a way to compute all this values Let s for each line and each column write down all the elements in it sort them delete repeating elements and save the result in such form Now how to find and Simply do a binary search over this list to find the element equal to If the length of this list is and the position of the found element is based then and Similarly we can find and solve the problemComplexity is "}
{"statement": "You are given a permutation dagger p 1 p 2 ldots p n of integers 1 to n You can change the current permutation by applying the following operation several possibly zero times choose some x 2 le x le n create a new permutation by first writing down all elements of p that are less than x without changing their order second writing down all elements of p that are greater than or equal to x without changing their order replace p with the newly created permutation For example if the permutation used to be 6 4 3 5 2 1 and you choose x 4 then you will first write down 3 2 1 then append this with 6 4 5 So the initial permutation will be replaced by 3 2 1 6 4 5 Find the minimum number of operations you need to achieve p i i for i 1 2 ldots n We can show that it is always possible to do so dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "For every such that and we have to choose at least once for these elements to be in the correct order It is easy to see that if we choose all such for all such exactly once in any order we will get the identity permutation "}
{"statement": "Galaxy Luck a well known casino in the entire solar system introduces a new card game In this game there is a deck that consists of n cards Each card has m numbers written on it Each of the n players receives exactly one card from the deck Then all players play with each other in pairs and each pair of players plays exactly once Thus if there are for example four players in total then six games are played the first against the second the first against the third the first against the fourth the second against the third the second against the fourth and the third against the fourth Each of these games determines the winner in some way but the rules are quite complicated so we will not describe them here All that matters is how many chips are paid out to the winner Let the first player s card have the numbers a 1 a 2 dots a m and the second player s card b 1 b 2 dots b m Then the winner of the game gets a 1 b 1 a 2 b 2 dots a m b m chips from the total pot where x denotes the absolute value of x To determine the size of the total pot it is necessary to calculate the winners total winnings for all games Since there can be many cards in a deck and many players you have been assigned to write a program that does all the necessary calculations ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "You may notice that the problem can be solved independently for each column of the input matrix The answer is then the sum where array representing a column Let s try to calculate this sum for each column Let s sort all elements of the current column Let s calculate the answer for some element in the sorted list The answer for it will be where is the sum on the prefix Why is this so Because we say that this number is larger than the others and the modulus will then decompose as and this is already easy to count "}
{"statement": "Vova s family is building the Great Vova Wall named by Vova himself Vova s parents grandparents grand grandparents contributed to it Now it s totally up to Vova to put the finishing touches The current state of the wall can be respresented by a sequence a of n integers with a i being the height of the i th part of the wall Vova can only use 2 times 1 bricks to put in the wall he has infinite supply of them however Vova can put bricks on the neighboring parts of the wall of equal height It means that if for some i the current height of part i is the same as for part i 1 then Vova can put a brick there and thus increase both heights by 1 Obviously Vova can t put bricks in such a way that its parts turn out to be off the borders to the left of part 1 of the wall or to the right of part n of it Vova can also put bricks vertically That means increasing height of any part of the wall by 2 Vova is a perfectionist so he considers the wall completed when all parts of the wall has the same height the wall has no empty spaces inside it Can Vova complete the wall using any amount of bricks possibly zero ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Fairly enough solutions of both versions of the problem are pretty similar The major difference between them are the vertical bricks As you aren t required to minimize the total height you can work not with the heights themselves but with their parities instead Vertical brick now does nothing and horizontal brick changes the parity of neighbouring parts of the same parity Now imagine the following greedy solution While you have some segment of the same parities of even length fill it with horizontal bricks This operation merges this segment with one to the left and to the right If there is a single segment left then the answer is Otherwise it s The proof is left to the readers Implementing this as it is will be at best You ll need to keep the whole set of segments and the set with only even length ones But there exists more fun approach We don t even need the lengths of the segments just the parities of the lengths Then merging the even segment with something will just erase that segment and xor the length of the left and right ones Moreover you don t even need to erase the whole even segment you can do it brick by brick as this operations are now the same Let s simulate this with a stack When the new number comes push its parity to the stack If the topmost two elements of the stack have the same parity pop them both Now the answer is if at the end stack has no more than one element When I heard of this problem I actually had not that stack itself in mind but the correct bracket sequences Like let s define parity 0 as and and parity 1 as and Now the operations we perform with stack are greedily put the closing bracket if the last unclosed bracket was of the same type and put opening otherwise Then the stack will have like all the brackets which are still to be closed and you ll close them as early as you can This idea helped to both prove the correctness of algo and implement it Overall complexity "}
{"statement": "Dima and Seryozha live in an ordinary dormitory room for two One day Dima had a date with his girl and he asked Seryozha to leave the room As a compensation Seryozha made Dima do his homework The teacher gave Seryozha the coordinates of distinct points on the abscissa axis and asked to consecutively connect them by semi circus in a certain order first connect the first point with the second one then connect the second point with the third one then the third one with the fourth one and so on to the th point Two points with coordinates and should be connected by a semi circle that passes above the abscissa axis with the diameter that coincides with the segment between points Seryozha needs to find out if the line on the picture intersects itself For clarifications see the picture Seryozha showed to Dima the left picture has self intersections the right picture doesn t have any Seryozha is not a small boy so the coordinates of the points can be rather large Help Dima cope with the problem ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "If our line has self intersections that some pair of semi circles exists which intersect each other Let points are connected with a semi circle and points are connected with another semi circle Then this semis circles intersect if one of the conditions is true 1 2 Let s iterate trough all pairs of semi circles and check if the semi circles intersect each other So the solution will have complexity what satisfied the constrains "}
{"statement": "Today is the final contest of INOI Iranian National Olympiad in Informatics The contest room is a row with n computers All computers are numbered with integers from 1 to n from left to right There are m participants numbered with integers from 1 to m We have an array a of length m where a i 1 leq a i leq n is the computer behind which the i th participant wants to sit Also we have another array b of length m consisting of characters and b i is the side from which the i th participant enters the room means the participant enters from the left of computer 1 and goes from left to right and means the participant enters from the right of computer n and goes from right to left The participants in the order from 1 to m enter the room one by one The i th of them enters the contest room in the direction b i and goes to sit behind the a i th computer If it is occupied he keeps walking in his direction until he reaches the first unoccupied computer After that he sits behind it If he doesn t find any computer he gets upset and gives up on the contest The madness of the i th participant is the distance between his assigned computer a i and the computer he ends up sitting behind The distance between computers i and j is equal to i j The values in the array a equal There exist n m cdot 2 m possible pairs of arrays a b Consider all pairs of arrays a b such that no person becomes upset For each of them let s calculate the sum of participants madnesses Find the sum of all these values You will be given some prime modulo p Find this sum by modulo p ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "Suppose Let be the number of pairs for participants and computers so that no one gets upset For updating this array we can consider the last participant and where he will sit Suppose he sits behind the th computer If he comes from left to right there are choices of computers for him to sit behind and if he comes from right to left there are choices for him If the last participant sits behind the th computer there are ways to fill in the rest of the seats because after removing we have two independent subsegments So Now let be the sum of the total madnesses for all cases with participants and computers Imagine the last person sitting on the th computer The madness of every participant except the last one is However the madness of the last participant is Now what if Suppose is the number of pairs for computers and participants so that no one gets upset For updating it we can consider the maximal suffix that all of the computers in that suffix will get occupied by participants Consider its lenghth is If then we add to if not we add to The update is similar to The update is done correctly because the subsegments are independant At last suppose is the sum of the total madnesses for all cases with computers and participants Consider to be the lenghth of the maximal suffix that all of the computers in that suffix will get occupied by participants If then to we add If then is added to The answer shall be Time complexity Computing and is an task while computing and has a complexity of Challenge Can you find a solution with a better time complexity "}
{"statement": "Rick is in love with Unity But Mr Meeseeks also love Unity so Rick and Mr Meeseeks are love rivals Unity loves rap so it decided that they have to compete in a rap game battle in order to choose the best Rick is too nerds so instead he s gonna make his verse with running his original algorithm on lyrics Rap God song His algorithm is a little bit complicated He s made a tree with vertices numbered from to and there s a lowercase english letter written on each edge He denotes to be the string made by writing characters on edges on the shortest path from to one by one a string of length equal to distance of to Note that is reverse of and is empty In order to make the best verse he can he needs to answer some queries but he s not a computer scientist and is not able to answer those queries so he asked you to help him Each query is characterized by two vertices and Answer to this query is the number of vertices like such that and is lexicographically larger than String is lexicographically larger than string if either and or exists such number that and Characters are compared like their ASCII codes or alphabetic order Help Rick get the girl or whatever gender Unity has ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3400", "problem_editorial": "Use centroid decomposition In each decomposition Assume is centroid of current subtree Then for each vertex in current subtree we want to find some part of answer for each query with More precisely for each query that is in the current subtree in the decomposition we want to find the number of vertices like such that is also in the subtree if we remove the centroid from the tree and will be disconnected centroid itself satisfies this condition and So for each query first compare with Comparing two paths and can be done using hash for each and keep hash of and its reverse and using binary search for finding LCP of two strings Based on result of comparison If then there s no such in current subtree If and is not a prefix of then all vertices like that satisfy the first two conditions from the three conditions above are counted Otherwise there s a vertex on path from to such that Because and then you have to count such that satisfy the first two conditions and For the third case you need to count vertices like that For this purpose using a single DFS construct trie of all and then for each query find the position of in the trie using hashes and binary search More precisely you need to find LCP of and strings in the trie to determine how many strings in the trie are less than All of this can be done in And there s an additional for centroid decomposition so Total time complexity "}
{"statement": "Polycarp loves ciphers He has invented his own cipher called Right Left Right Left cipher is used for strings To encrypt the string s s 1 s 2 dots s n Polycarp uses the following algorithm he writes down s 1 he appends the current word with s 2 i e writes down s 2 to the right of the current result he prepends the current word with s 3 i e writes down s 3 to the left of the current result he appends the current word with s 4 i e writes down s 4 to the right of the current result he prepends the current word with s 5 i e writes down s 5 to the left of the current result and so on for each position until the end of s For example if s the process is to to to to to So the encrypted s is Given string t the result of encryption of some string s Your task is to decrypt it i e find the string s ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "You can simulate the process maintaining the indices of characters of the initial string So like this you can find the value of character of the initial string "}
{"statement": "Madoka is going to enroll in But she stumbled upon a difficult task during the entrance computer science exam A number is called if it is a multiple of d A number is called if it is and it be represented as a product of two good numbers Notice that a beautiful number must be good Given a good number x determine whether it can be represented in at least two different ways as a product of several possibly one numbers Two ways are different if the sets of numbers used are different Solve this problem for Madoka and help her to enroll in the best school in Russia ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s solve a more complex problem calculate the number of partitions into such multipliers This is easily solved by dynamic programming Let dpn d be the number of factorizations if we have a number left to decompose the number n and before that we divided by the number d Let s go through all such beautiful numbers i d that divide n then dpn i i dpn d Note that in this case we took into account each option exactly once since we count the divisors in the order of their increase Let C be the number of divisors of the number x and V be the number of beautiful divisors of the number x Then it works for O C V or O C V2 log depending on the implementation since n is always a divisor of the number x but it all comes easily since V is no more 700 "}
{"statement": "You are given an array a of n integers where n is odd You can make the following operation with it Choose one of the elements of the array for example a i and increase it by 1 that is replace it with a i 1 You want to make the median of the array the largest possible using at most k operations The median of the odd sized array is the middle element after the array is sorted in non decreasing order For example the median of the array 1 5 2 3 5 is 3 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Sort the array in non decreasing order In the new array you can make binary search with the maximum median value For a given median value it is required to make operations If this value is more than can t be median otherwise it can Time complexity "}
{"statement": "In this problem you will have to help Berland army with organizing their command delivery system There are n officers in Berland army The first officer is the commander of the army and he does not have any superiors Every other officer has exactly one direct superior If officer a is the direct superior of officer b then we also can say that officer b is a direct subordinate of officer a Officer x is considered to be a subordinate direct or indirect of officer y if one of the following conditions holds officer y is the direct superior of officer x the direct superior of officer x is a subordinate of officer y For example on the picture below the subordinates of the officer 3 are 5 6 7 8 9 The structure of Berland army is organized in such a way that every officer except for the commander is a subordinate of the commander of the army Formally let s represent Berland army as a tree consisting of n vertices in which vertex u corresponds to officer u The parent of vertex u corresponds to the direct superior of officer u The root which has index 1 corresponds to the commander of the army Berland War Ministry has ordered you to give answers on q queries the i th query is given as u i k i where u i is some officer and k i is a positive integer To process the i th query imagine how a command from u i spreads to the subordinates of u i Typical DFS depth first search algorithm is used here Suppose the current officer is a and he spreads a command Officer a chooses b one of his direct subordinates i e a child in the tree who has not received this command yet If there are many such direct subordinates then a chooses the one having minimal index Officer a gives a command to officer b Afterwards b uses exactly the same algorithm to spread the command to its subtree After b finishes spreading the command officer a chooses the next direct subordinate again using the same strategy When officer a cannot choose any direct subordinate who still hasn t received this command officer a finishes spreading the command Let s look at the following example If officer 1 spreads a command officers receive it in the following order 1 2 3 5 6 8 7 9 4 If officer 3 spreads a command officers receive it in the following order 3 5 6 8 7 9 If officer 7 spreads a command officers receive it in the following order 7 9 If officer 9 spreads a command officers receive it in the following order 9 To answer the i th query u i k i construct a sequence which describes the order in which officers will receive the command if the u i th officer spreads it Return the k i th element of the constructed list or if there are fewer than k i elements in it You should process queries independently A query doesn t affect the following queries ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1600", "problem_editorial": "Let s form the following vector we run DFS from the first vertex and push the vertex to the vector when entering this vertex Let be the position of the vertex in the vector the size of the vector in moment we call DFS from the vertex and be the position of the first vertex pushed to the vector after leaving the vertex the size of the vector in moment when we return from DFS from the vertex Then it is obvious that the subtree of the vertex lies in half interval After running such DFS we can answer the queries Let answering the th query If is greater than or equal to then answer to the th query is We need to check if the vertex lies in the subtree of the vertex The vertex is in the subtree of the vertex if and only if If the vertex is not in the subtree of the vertex then answer is Otherwise the answer is Overall complexity is "}
{"statement": "There are n blocks arranged in a row and numbered from left to right starting from one Each block is either black or white You may perform the following operation zero or more times choose two blocks and invert their colors white block becomes black and vice versa You want to find a sequence of operations such that they make all the blocks having the same color You to minimize the number of operations but it should not exceed 3 cdot n If it is impossible to find such a sequence of operations you need to report it ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Suppose we want to make all blocks white if we want to make them black the following algorithm still works with a few changes The first block has to be white so if it is black we have to invert the pair once otherwise we should not invert it at all inverting twice is the same as not inverting at all Then consider the second block We need to invert it once if it is black but if we invert the pair then the first block becomes black So we can t invert the pair and we have to invert the pair or don t invert anything if the second block is white now And so on for the th block we cannot invert the pair since it will affect the color of the previous block So we don t have much choice in our algorithm After that we arrive at the last block If it is white we are done with no more than actions If it is black run the same algorithm but we have to paint everything black now If it fails again then there is no answer "}
{"statement": "Every evening Vitalya sets alarm clocks to wake up tomorrow Every alarm clock rings during exactly one minute and is characterized by one integer number of minute after midnight in which it rings Every alarm clock begins ringing at the beginning of the minute and rings during whole minute Vitalya will definitely wake up if during some consecutive minutes at least alarm clocks will begin ringing Pay attention that Vitalya considers only alarm clocks which begin ringing during given period of time He doesn t consider alarm clocks which started ringing before given period of time and continues ringing during given period of time Vitalya is so tired that he wants to sleep all day long and not to wake up Find out minimal number of alarm clocks Vitalya should turn off to sleep all next day Now all alarm clocks are turned on ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "At first we need to sort all alarms in increasing order of their times Also we will use set where we will store alarm times We will iterate through the alarms beginning from the first Let current alarm time equals to Until set does not empty and the first set element less than we should remove the first set element After that only alarm with times not before minutes relatively will be in set If after that the set size less than we should insert in the set we will not turn off this alarm In the other case we should turn off this alarm so we increase the answer on one and do not insert in the set "}
{"statement": "m chairs are arranged in a circle sequentially The chairs are numbered from 0 to m 1 n people want to sit in these chairs The i th of them wants at least a i empty chairs both on his right and left side More formally if the i th person sits in the j th chair then no one else should sit in the following chairs j a i bmod m j a i 1 bmod m j a i 1 bmod m j a i bmod m Decide if it is possible to sit down for all of them under the given limitations ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "SolutionIf there is no one between the th and th person then free chairs should be between them So we should find a permutation of the array when is minimal We can assume that the array is non decreasing For each the largest elements from will appear in the formula at least times Every element occurs in two segments and we only can count segments twice So we get a lower bound for the number of free chairs This lower bound is reachable for the empty chairs if the permutation of is sorted Because and They also sit on chairs If we add all of these we get that the answer is YES if "}
{"statement": "Sun Tzu You are given a permutation text p of length n Find a permutation q of length n that minimizes the number of pairs i j 1 leq i leq j leq n such that p i p i 1 ldots p j q i q i 1 ldots q j text A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "We can always construct a solution such that the number of pairs i j is 1 where the only pair is 1 n There exists several constructions such as rotating p once or increment all pi and pi n turns into pi 1 Consider the former construction where q p2 p3 pn p1 For an arbitrarily interval i j p i j and q i j will have exactly 1 element that s different disregarding ordering Since we have a permutation and all elements are distinct the sum in the range will never be the same The only exception is the entire array of course "}
{"statement": "For months Maxim has been coming to work on his favorite bicycle And quite recently he decided that he is ready to take part in a cyclists competitions He knows that this year competitions will take place During the th competition the participant must as quickly as possible complete a ride along a straight line from point to point Measuring time is a complex process related to usage of a special sensor and a time counter Think of the front wheel of a bicycle as a circle of radius Let s neglect the thickness of a tire the size of the sensor and all physical effects The sensor is placed on the rim of the wheel that is on some fixed point on a circle of radius After that the counter moves just like the chosen point of the circle i e moves forward and rotates around the center of the circle At the beginning each participant can choose point such that his bike is fully behind the starting line that is After that he starts the movement instantly accelerates to his maximum speed and at time when the coordinate of the sensor is equal to the coordinate of the start the time counter starts The cyclist makes a complete ride moving with his maximum speed and at the moment the sensor s coordinate is equal to the coordinate of the finish moment of time the time counter deactivates and records the final time Thus the counter records that the participant made a complete ride in time Maxim is good at math and he suspects that the total result doesn t only depend on his maximum speed but also on his choice of the initial point Now Maxim is asking you to calculate for each of competitions the minimum possible time that can be measured by the time counter The radius of the wheel of his bike is equal to ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "The main proposition to solve this problem in the middle of every competition the sensor must be or in the top point of the wheel or in the bottom point of the wheel To calculate the answer we need to use binary search If the center of the wheel moved on the distance c then the sensor moved on the distance c rsin c r if the sensor was on the top point of the wheel in the middle or on the distance c rsin c r if the sensor was on the bottom point of the wheel in the middle where r the radius of the wheel "}
{"statement": "You found a map of a weirdly shaped labyrinth The map is a grid consisting of n rows and n columns The rows of the grid are numbered from 1 to n from bottom to top The columns of the grid are numbered from 1 to n from left to right The labyrinth has n layers The first layer is the bottom left corner cell 1 1 The second layer consists of all cells that are in the grid and adjacent to the first layer by a side or a corner The third layer consists of all cells that are in the grid and adjacent to the second layer by a side or a corner And so on The labyrinth with 5 layers for example is shaped as follows The layers are separated from one another with walls However there are doors in these walls Each layer except for layer n has exactly two doors to the next layer One door is placed on the top wall of the layer and another door is placed on the right wall of the layer For each layer from 1 to n 1 you are given positions of these two doors The doors can be passed in both directions either from layer i to layer i 1 or from layer i 1 to layer i If you are standing in some cell you can move to an adjacent by a side cell if a wall doesn t block your move e g you can t move to a cell in another layer if there is no door between the cells Now you have m queries of sort what s the minimum number of moves one has to make to go from cell x 1 y 1 to cell x 2 y 2 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "WLOG assume all queries ask to move from a lower layer to a higher layer The first thing to notice in the problem is that it is always optimal to never go down a layer You have an optimal path that is going down some layers and then returning to the same layer So it leaves a layer in some its cell and returns to it in some other cell or the same one The best distance it can achieve is the Manhattan distance between these two cells However we can also achieve the Manhattan distance by just going along this layer and the answer will be at least as optimal If the query asks about the cells of the same layer just answer with the Manhattan distance Otherwise we can describe the path as follows go from the first cell to some door on its layer enter the door and go to another door on the next layer so on until the layer of the second cell where you go from a door to the second cell Thus we could potentially write the shortest distance from the start to the th door of the th layer Initialize both doors of the first layer take the best answer from the both doors of the last layer That would be per query which is too slow Let s optimize it with some precalculations In particular we want to know the shortest distance between one door of some layer and one door of another layer We can use the technique similar to binary lifting Calculate the distance between a pair of doors on layers which are apart for all up to Let be the distance from door of layer to door of layer can be initialized straightforwardly Then to calculate we can use the values for and for some intermediate door on layer To obtain the answer use jumps to reach the layer one before the last one Then iterate over the last door Alternatively you could pack this dynamic programming into a segment tree use divide and conquer on queries or do square root decomposition Overall complexity "}
{"statement": "Gargari is jealous that his friend Caisa won the game from the previous problem He wants to prove that he is a genius He has a chessboard Each cell of the chessboard has a number written on it Gargari wants to place two bishops on the chessboard in such a way that there is no cell that is attacked by both of them Consider a cell with number written on it if this cell is attacked by one of the bishops Gargari will get dollars for it Tell Gargari how to place bishops on the chessboard to get maximum amount of money We assume a cell is attacked by a bishop if the cell is located on the same diagonal with the bishop the cell where the bishop is also considered attacked by it ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "We preprocess the sum for all the diagonals principals and secondary diagonals in two arrays so that for every element i j we can find sum of elements which are attacked in O 1 time Also for avoiding the intersection we need to find two cells so that for one the sum of row and column is even and for the other one the sum of row and column is odd Finally we analyze every cell we see if the sum of row and column is even or odd and update that two positions solutions "}
{"statement": "A is an unordered graph in whose vertex set there are two special vertices and An has vertex set and an edge between them A total of changes took place in an In each change a new vertex is added into is chosen and two edges and are added into Note that it s possible that some edges are chosen in more than one change It s known that the capacity of the minimum cut of the resulting graph is that is at least edges need to be removed in order to make and disconnected Count the number of that can be built under the constraints modulo We define two similar if they are isomorphic and there is isomorphism in which the and vertices are not relabelled Formally two and are considered similar if there is a bijection between their vertex sets such that Two vertices and of are adjacent in if and only if and are adjacent in ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2900", "problem_editorial": "Let s try to find subproblems in this A graph can be expressed as an edge in parallel with an multiset of zero or more pair of two graphs That is graph edge graph graph graph graph A graph can be represented by two parameters number of operations needed to build it and its minimum cut Let keep the number of graphs with operations and a minimum cut of The figure below shows one of the ways in which can be built from other s How to iterate over all such possible splitting into pairs while keeping them One way is to iterate through pairs instead of determining s one by one we find all pairs of graph parameters and add them to graphs already formed with pairs considered before This is like how we do it in knapsack problems Iterate through the parameters of two graphs in a pair and use a push style transition to add each into the corresponding state if the pair is added a number of times to a graph in That is for each add to this means a pair of graphs with parameters and is added times to a graph with parameters With such parameters we need to spend time updating all values therefore time complexity is which is not sufficient to pass Let s see the pair as a whole Let keep the number of ordered graph pairs with operations and a minimum cut of At each step in stead of iterating over four parameters of a pair we iterate over two parameters and use values of to perform the update It can be seen that and only depend on such and that Therefore we can determine and values in order of increasing This solution works with states each of which can be calculated in time with another factor for MultiCombination but since a harmonic series exists in the iteration of this is actually Author s implementation takes a bit lower than 800 milliseconds to find an answer If MultiCombination is calculated along with the iteration of see the model solution this works in which is much faster Come up with a DP on "}
{"statement": "Let s introduce a number system which is based on a roman digits There are digits which correspond to the numbers 1 5 10 and 50 respectively The use of other roman digits is not allowed Numbers in this system are written as a sequence of one or more digits We define the value of the sequence simply as the sum of digits in it For example the number evaluates to 35 and the number to 12 Pay attention to the difference to the traditional roman system in our system any sequence of digits is valid moreover the order of digits doesn t matter for example means 11 not 9 One can notice that this system is ambiguous and some numbers can be written in many different ways Your goal is to determine how many distinct integers can be represented by n roman digits ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "among all the sequences select the one which contains the maximum number of in case of tie select one with largest number of Bruteforce all configurations in such way that each number is counted only in it s maximum configuration Since the length of sequence is fixed we can solve problem not for digits but for digits Let s solve the problem for digits first We have a problem that some numbers have many representations But this in fact is easy to deal with if we have at least nine digits 4 than we can convert them no some number of 9 digits and fill the rest with zeroes In this case the solution is to bruteforce the number of 4 from to and then from the remaining digits select any arbitrary number of 9 each such choice leads to an unique number Let s return to the original problem with In this case we can also face the situation when the number of can be increased We need to identify all pairs where such that they can be transformed to other pair with detachment of few We can bruteforce all with four nested for loops and check that the sum of first differs from sum of latter by few number of removed in such case we mark the pair as broken We can also note that if some pair is marked as broken than all dominating pairs also marked as broken When we discovered which pairs are good we can simply for number of 4for number of 9if pair is goodcount the answer all remaining digits are either 0 or 49 and all such alternatives are unique if you examine the solution above precisely you will notice that starting some reasonable you can easy proof a lowerbound like or but it is in fact the function grows linearly So if you count the answer in any stupid way and otherwise simply approximate it linearly using and "}
{"statement": "The biggest event of the year Cota 2 world championship The Innernational is right around the corner 2 n teams will compete in a double elimination format please carefully read problem statement even if you know what is it to identify the champion Teams are numbered from 1 to 2 n and will play games one on one All teams start in the upper bracket All upper bracket matches will be held played between teams that haven t lost any games yet Teams are split into games by team numbers Game winner advances in the next round of upper bracket losers drop into the lower bracket Lower bracket starts with 2 n 1 teams that lost the first upper bracket game Each lower bracket round consists of two games In the first game of a round 2 k teams play a game with each other teams are split into games by team numbers 2 k 1 loosing teams are eliminated from the championship 2 k 1 winning teams are playing 2 k 1 teams that got eliminated in this round of upper bracket again teams are split into games by team numbers As a result of each round both upper and lower bracket have 2 k 1 teams remaining See example notes for better understanding Single remaining team of upper bracket plays with single remaining team of lower bracket in grand finals to identify championship winner You are a fan of teams with numbers a 1 a 2 a k You want the championship to have as many games with your favourite teams as possible Luckily you can affect results of every championship game the way you want What s maximal possible number of championship games that include teams you re fan of ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "The main observation in this problem is that for each set of players that lie in the subtree of any vertex of a binary tree of the upper bracket exactly one player will win all matches in the upper bracket and exactly one player will win all matches in the lower bracket We can define this set of players in 0 indexation instead of 1 indexation from statement as a 2t a 1 2t for some 1 t n 0 a 2n2t For each fixed t the players with different values of id2t don t play with each other and their upper and lower brackets are independent For each of these sets of players we are interested only in a number of interesting matches between them and if the winner of their upper and lower brackets are the teams that are we re fans of This leads us to the dynamic programming solution dp l r fup flower the maximal number of matches between teams with indices in l r if fup 0 1 is 1 if the we re fans of winner of upper bracket and flower 0 1 is 1 if the we re fans of winner of lower bracket Again l r is the special segment l a 2t r a 1 2t 1 for some 1 t n 0 a 2n2t dp l r fup flower can be recalculated from dp l l r2 flup fllower and dp l r2 r frup frlower we just iterate over all possible flup fllower frup frlower and the results of all three matches one in the upper bracket and two in the lower bracket In the end we use dp 0 2n fup flower to count the result with the last grand finals match This solution works in something like O 2n 27 because there are 2n interesting segments "}
{"statement": "There are n models in the shop numbered from 1 to n with sizes s 1 s 2 ldots s n Orac will buy some of the models and will arrange them in the order of increasing numbers i e indices but not sizes Orac thinks that the obtained arrangement is if for any two adjacent models with indices i j and i j 1 note that i j i j 1 because Orac arranged them properly i j 1 is divisible by i j and s i j s i j 1 For example for 6 models with sizes 3 6 7 7 7 7 he can buy models with indices 1 2 and 6 and the obtained arrangement will be beautiful Also note that the arrangement with exactly one model is also considered beautiful Orac wants to know the maximum number of models that he can buy and he may ask you these queries many times ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Considering DP we can design DP statuses as follow f i stands for the length of the longest beautiful sequence end up with index i We can find the transformation easily f i max limits j mid i s j s i f j 1 Then the length of answer sequence is the maximum value among f 1 f 2 cdots f n About the complexity of DP If you transform by iterating multiples it will be O n log n According to properties of Harmonic Series if you iterate divisors then it will be O n sqrt n Fortunately both of them are acceptable in this problem "}
{"statement": "The of a sequence s 1 s 2 ldots s d is defined as displaystyle frac s 1 cdot s 2 cdot ldots cdot s d d where d 1 cdot 2 cdot ldots cdot d In particular the score of an empty sequence is 1 For a sequence s 1 s 2 ldots s d let m be the maximum score among all its subsequences Its is defined as the maximum length of a subsequence with a score of m You are given a sequence a 1 a 2 ldots a n of integers of length n In other words the condition a 1 leq a 2 leq ldots leq a n is satisfied For each k 1 2 ldots n find the cost of the sequence a 1 a 2 ldots a k A sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several possibly zero or all elements ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "We will first see how to find the cost of a single non decreasing sequence If we choose a subsequence with elements to achieve the maximum score it is optimal to choose the largest elements As the sequence is in non decreasing order the largest elements will be the last elements of the sequence Thus all possible candidates to be the answer are the suffixes of the sequence Now let s divide the th element from the right by The sequence now turns into Observe that the score of a suffix in the original sequence is equal to the product of the suffix of the same size in the new sequence The original sequence satisfies It also true that then combining these two inequalities we have so the new sequence is also in non decreasing order In order to maximize the product of a suffix in the new sequence we will choose all the elements in the new sequence which are greater or equal to these elements form a suffix because the new sequence is non decreasing If there are elements equal to in the new sequence we have to choose them in order to get the subsquence with maximum length among all the ones with maximum score Therefore the cost of a sequence is the maximum length of a suffix of such that each element is at least Now we have to find the cost of every prefix of the given sequence For a fixed the cost of will be the maximum length of a suffix of such that each element is at least We can find this length using binary search Observe that we cannot compute the transformed sequence for every prefix as that will be too slow Instead we can compute in each step of the binary search what would the number in that position be in the transformed sequence By doing these we can find the score of each prefix in time Intended complexity per test case "}
{"statement": "Natalia Romanova is trying to test something on the new gun S H I E L D gave her In order to determine the result of the test she needs to find the number of answers to a certain equation The equation is of form Where represents logical OR and represents logical exclusive OR XOR and are some boolean variables or their negations Natalia calls the left side of the equation a XNF formula Each statement in brackets is called a clause and are called literals In the equation Natalia has the left side is actually a 2 XNF 2 containing variables and their negations An XNF formula is 2 XNF 2 if For each i e the size of each clause doesn t exceed two Each variable occurs with negation and without negation in total Please note that it s possible that a variable occurs twice but its negation doesn t occur in any clause or vice versa Natalia is given a formula of variables consisting of clauses Please make sure to check the samples in order to properly understand how the formula looks like Natalia is more into fight than theory so she asked you to tell her the number of answers to this equation More precisely you need to find the number of ways to set with and out of total of ways so that the equation is satisfied Since this number can be extremely large you need to print the answer modulo Please note that some variable may appear twice in one clause or not appear in the equation at all but still setting it to or gives different ways to set variables ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2900", "problem_editorial": "Build a graph Assume a vertex for each clause For every variable that appears twice in the clauses add an edge between clauses it appears in variables that appear once are corner cases Every vertex in this graph has degree at most two So every component is either a cycle or a path We want to solve the problem for a path component Every edge either appear the same in its endpoints or appears differently Denote a dp to count the answer dp i j is the number of ways to value the edges till i th vertex in the path so that the last clause i s value is j so far j is either 0 or 1 Using the last edge to update dp i j from dp i 1 is really easy in theory Counting the answer for a cycle is practically the same just that we also need another dimension in our dp for the value of the first clause then we convert it into a path Handling variables that appear once edges with one endpoint this endpoint is always an endpoint of a path component is also hard coding And finally we need to merge the answers Time Complexity "}
{"statement": "In this problem we will deal with binary strings Each character of a binary string is either a or a We will also deal with substrings recall that a substring is a contiguous subsequence of a string We denote the substring of string s starting from the l th character and ending with the r th character as s l dots r The characters of each string are numbered from 1 We can perform several operations on the strings we consider Each operation is to choose a substring of our string and replace it with another string There are two possible types of operations replace with or replace with For example if we apply exactly one operation to the string it can be transformed into or Binary string a is considered from binary string b if there exists a sequence s 1 s 2 s k such that s 1 a s k b and for every i in 1 k 1 s i can be transformed into s i 1 using exactly one operation Note that k can be equal to 1 i e You are given a string t and q queries to it Each query consists of three integers l 1 l 2 and len To answer each query you have to determine whether t l 1 dots l 1 len 1 is reachable from t l 2 dots l 2 len 1 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "How to determine if two strings can be transformed into each other Obviously the number of ones in both strings should be the same Also the following invariant holds if all pairs of consecutive ones are deleted the positions of remaining ones are not affected by any operations We can prove that these conditions are sufficient if we move all pairs of ones to the end of the string the strings are the same if the positions of ones are the same and the number of characters is the same moving all pairs of ones to the end of the string is almost the same as deleting them One of the possible solutions is the following build a segment tree where each vertex should maintain the number of deleted pairs of ones the hash of positions of the remaining ones the characters at the ends of the corresponding segment we need these to delete pairs of consecutive ones if they appear as a result of merging the segments When merging a pair of vertices we check if we have to delete a pair of consecutive ones and rebuild the hash for the new vertex There are lots of other approaches including a deterministic one which uses suffix structures "}
{"statement": "A patient has been infected with an unknown disease His body can be seen as an infinite grid of triangular cells which looks as follows Two cells are neighboring if they share a side Therefore each cell x y has exactly three neighbors x 1 y x 1 y x 1 y 1 if x is even and x 1 y 1 otherwise Initially some cells are infected all the others are healthy The process of recovery begins Each second for cell even though there might be multiple cells that could change its state one of the following happens A healthy cell with at least 2 infected neighbors also becomes infected An infected cell with at least 2 healthy neighbors also becomes healthy If no such cell exists the process of recovery stops Patient is considered recovered if the process of recovery has stopped and all the cells are healthy We re interested in a scenario is it possible that the patient never recovers or if it s not possible what is the maximum possible duration of the recovery process ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "SetupWe re interested in the longest possible recovery path so let s imagine choosing the longest sequence of operations ourselves How long can this process last "}
{"statement": "The rebels have been crushed in the most recent battle with the imperial forces but there is a ray of new hope Meanwhile on one of the conquered planets Luke was getting ready for an illegal street race which should come as no surprise given his family history Luke arrived at the finish line with 88 miles per hour on his speedometer After getting out of the car he was greeted by a new reality It turns out that the battle has not happened yet and will start in exactly k hours The rebels have placed a single battleship on each of the n planets m unidirectional wormholes connect the planets Traversing each wormhole takes exactly one hour Generals of the Imperium have planned the battle precisely but their troops cannot dynamically adapt to changing circumstances Because of this it is enough for the rebels to move some ships around before the battle to confuse the enemy secure victory and change the galaxy s fate Owing to numerous strategical considerations which we now omit the rebels would like to choose two ships that will switch places so that both of them will be on the move for the whole time exactly k hours In other words rebels look for two planets x and y such that paths of length k exist from x to y and from y to x Because of the limited fuel supply choosing one ship would also be acceptable This ship should fly through the wormholes for k hours and then return to its initial planet How many ways are there to choose the ships for completing the mission ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2900", "problem_editorial": "As both vertices must visit each other they must be in the same strongly connected component We can compute all SCC and solve for them independently Further we will assume that we are solving for a fixed SCC The critical observation is that is enormous and we can visit an entire graph This gives us hope that if we fix a vertex we can represent all vertices that are reachable from it If we compute the greatest common divisor of all cycles in our graph then all paths from a fixed vertex to a vertex have the same remainder modulo Moreover we can always find such if we are looking for a long enough path and the correct remainder It turns out that is a large enough bound for such paths Now we have to find the greatest common divisor of all cycles in the graph There are many ways including linear but we are going to present here First find any cycle in the graph As has to divide it we just have to consider its divisors We ll develop a quick way to find if a divisor divides To do this we check if there is a colouring with colours from to such that for every edge We can check for such colouring with a simple DFS in a linear time To obtain the right complexity we ll only check prime divisors and their powers and take the least common multiple of the ones which divide Now we have to find all pairs such that there are paths from to and from to of length We have two cases Either and or and and After preprocessing we can check both cases in time The final complexity is or depending on the implementation "}
{"statement": "The Bytelandian Institute for Biological Research BIBR is investigating the properties of two species of bacteria named simply 0 and 1 Even under a microscope bacteria of those two species are very difficult to distinguish In fact the only thing the scientists possess that is able to differentiate between them is a plant called Formurosa If the scientists place a sample of colonies of bacteria on each on Formurosa s leaves it will activate a complicated nutrition process During that process color of Formurosa changes to reflect the result of a possibly very complicated logical formula on the species of bacteria involving constants and the operators OR AND and XOR If it is 0 the plant will turn red otherwise it will turn blue For example if the nutrition process of Formurosa is described by the formula then Formurosa has four leaves the signs denote the leaves If we place on the respective leaves the result of the nutrition process will be therefore the plant will turn blue The scientists have colonies of bacteria They do not know their types the only thing they know for sure is that They want to attempt to determine the bacteria s species by repeated evaluations with Formurosa During each evaluation they must place exactly one sample on every leaf of the plant However they may use multiple samples of one colony during a single evaluation they can even cover the whole plant with bacteria from one colony Is it possible for them to always determine the species of each colony no matter what they are assuming they are not all the same ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "One of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria Let Formurosa s digestive process be a function F s that maps binary sequences of length m to elements of 0 1 It turns out that the condition we seek for can be stated as follows We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F s F s where s is the negation of s First not that if no such sequence exists then there is no way to distinguish between zero and one If such a sequence exists we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression If the two expressions evaluate to different values we will determine the exact types of both bacteria Otherwise we will be certain that the bacteria are of the same type Repeating the process for all pairs of bacteria will let us identify all the types since it is guaranteed that not all bacteria are of the same type To determine whether such a sequence s exists dynamic programming over the expression tree of Formurosa can be applied The model solution keeps track for each subtree G of the expression which of the following sequences can be found a sequence s such that G s G s 0 a sequence s such that G s G s 1 a sequence s such that G s G s "}
{"statement": "Yasya was walking in the forest and accidentally found a tree with n vertices A tree is a connected undirected graph with no cycles Next to the tree the girl found an ancient manuscript with m queries written on it The queries can be of two types The first type of query is described by the integer y The weight of edge in the tree is replaced by the bitwise exclusive OR of the weight of that edge and the integer y The second type is described by the vertex v and the integer x Yasya chooses a vertex u 1 le u le n u neq v and mentally draws a bidirectional edge of weight x from v to u in the tree Then Yasya finds a simple cycle in the resulting graph and calculates the bitwise exclusive OR of all the edges in it She wants to choose a vertex u such that the calculated value is This calculated value will be the answer to the query It can be shown that such a cycle exists and is unique under the given constraints independent of the choice of u If an edge between v and u already existed a simple cycle is the path v to u to v Note that the second type of query is performed meaning the tree does change in any way after it Help Yasya answer all the queries ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2300", "problem_editorial": "We will hang the tree on the vertex and count for each vertex on the path from it to the root This can be done by depth first traversal in Now let s learn how to solve the problem in for each query The first type of query can be executed straightforwardly Notice that due to the properties of the operation the values will only change for vertices at odd depth the depth of the root is At the same time they will change trivially they will be xored with To answer the second query it is necessary to realize that the xor on a simple cycle is equal to Indeed the path from to the root will be counted twice so it will turn into and no other extra edges will be included in this xor With due skill you can try to speed up such a solution with instructions but the time constraints were chosen strictly For a complete solution to the problem you can use the data structure prefix tree trie With its help you can find in for the number such a in the set that is maximal Since change differently you will have to use two tries for vertices at even and odd heights Operations of the first type can be accumulated in the variable and added to the xor expression In addition you must not forget to remove from the necessary trie when answering the second query and then insert it back To do this you can maintain a counter of terminal leaves in each vertex and use this information during descent Thus the final asymptotic is "}
{"statement": "You are given a string s consisting of characters and The first character of s is guaranteed to be Let m be the number of characters in s Count the number of ways we can choose a pair of integers a b that satisfies the following 1 leq a b 2 m When written without leading zeros the base 2 representations of a and b are both palindromes The base 2 representation of of a and b matches the pattern s We say that t matches s if the lengths of t and s are the same and for every i the i th character of t is equal to the i th character of s or the i th character of s is Compute this count modulo 998244353 ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "Since the leading character of s is a 1 then that means a 2m 1 and 2m 1 b 2m Let s fix the length of a as k I ll describe a more general solution so there might be simpler solutions that work for this specific problem Let s make a graph with n k 2 nodes The first n nodes represent the n bits of b and the next k nodes represent the k bits of a The last two nodes represent a 0 node and 1 node which we will explain later We want to find the number of ways to color the graph with two colors 0 and 1 such that they satisfy some conditions Let s draw two different types of edges 0 edges and 1 edges If two nodes are connected by a 0 edge then that means they must be the same color If two nodes are connected by a 1 edge then that means they must be a different color We will draw some edges as follows Draw a 1 edge between the 0 node and 1 node to represent they must be different colors Draw a 0 edge between bi and bn i 1 to represent the palindrome conditions similarly we can do this for a For the i th bit if si is 1 draw a 1 edge between ai and bi if i k we instead draw an edge from bi to 1 If si is 0 then draw a 0 edge between ai and bi If si is then don t draw any edges since there are no explicit constraints Now we want to count the number of valid colorings We want to split the graph into a two colors which is a bipartite graph We want all edges that cross the bipartition to be 1 edges and all edges within the same bipartition to be 0 edges To count this we first collapse all connected components of 0 edges then check if the remaining 1 edges form a bipartite graph If there is a non bipartite graph return 0 immediately since this means it s impossible to fulfill the conditions Otherwise let C be the number of connected components We add 2C 1 to our answer The reason we subtract 1 is that the component containing the 0 and 1 node is fixed to be colored 0 but for other components we are free to color the components in either of two ways There are n different lengths to try each of which take a linear amount of time to get the count so the overall time complexity is O n2 "}
{"statement": "Vasya decided to pass a very large integer to Kate First he wrote that number as a string then he appended to the right integer the number of digits in Magically all the numbers were shuffled in arbitrary order while this note was passed to Kate The only thing that Vasya remembers is a non empty substring of a substring of is a sequence of consecutive digits of the number Vasya knows that there may be more than one way to restore the number Your task is to find the smallest possible initial integer Note that decimal representation of number contained no leading zeroes except the case the integer was equal to zero itself in this case a single digit was used ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "At first let s find the length of the Vasya s number For make this let s brute it Let the current length equals to Then if equals to the difference between the length of the given string and the number of digits in if means that is a length of the Vasya s number Then we need to remove from the given string all digits which appeared in the number generate three strings from the remaining digits and choose smaller string from them this string will be the answer Let is a substring which Vasya remembered Which three strings do we need to generate Let s write the string and after that let s write all remaining digits from the given string in the ascending order This string can be build only if the string does not begin with the digit 0 Let s write at first the smallest digit from the remaining digits which does not equal to 0 If we have no such a digit we can t build such string Else we need then to write all digits with smaller than the first digit in the in the ascending order then write the string and then write all remaining digits in the ascending order Let s write at first the smallest digit from the remaining digits which does not equal to 0 If we have no such a digit we can t build such string Else we need then to write all digits with smaller than or equal to the first digit in the in the ascending order then write the string and then write all remaining digits in the ascending order Also we need to separately consider the case when the Vasya s number equals to zero "}
{"statement": "Naman has two binary strings s and t of length n a binary string is a string which only consists of the characters and He wants to convert s into t using the following operation as few times as possible In one operation he can choose any subsequence of s and rotate it clockwise once For example if s 1 textbf 1 101 textbf 00 he can choose a subsequence corresponding to indices 1 based 2 6 7 and rotate them clockwise The resulting string would then be s 1 textbf 0 101 textbf 10 A string a is said to be a subsequence of string b if a can be obtained from b by deleting some characters without changing the ordering of the remaining characters To perform a clockwise rotation on a sequence c of size k is to perform an operation which sets c 1 c k c 2 c 1 c 3 c 2 ldots c k c k 1 simultaneously Determine the minimum number of operations Naman has to perform to convert s into t or say that it is impossible ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Firstly if is not an anagram of it is impossible to convert to since total number of s and s are conserved However if they are anagrams we can always convert to We can ignore all the indices where as it is never optimal to include those indices in a rotation The remaining indices must be satisfy or In the optimal answer the chosen subsequences should be of the form or There are many approaches to solving the problem all revolving around the key idea We can greedily find the minimum number of chains of alternating and that the string can be broken down into using faster ways of simulation such as a counter based for loop or using sets and deleting successive indices etc However we will discuss an elegant approach which allows us to solve the problem and also prove its optimality Moreover it allows us to solve the problem for queries of the form which denotes the answer for the strings and respectively Logic Let s create an array with values from as follows If Else if Else Then the answer is equal to the maximum absolute value of the sum of any subarray in that is Proof The chosen subsequences must be of the form or alternating s and s If there are two consecutive s or s we can remove any one of them as applying the rotation operation could only affect one of them The maximum absolute value of subarray sum in is a lower bound on the answer Let the sum of any subarray in be We can assume that otherwise we can interchange and In any move cannot be reduced by more than since we must choose subsequences of the form or We can achieve the above lower bound and hence it is the answer To prove the claim we just need to show that in every operation we can reduce the value of maximum absolute subarray sum by if there are multiple such subarrays then we must reduce all of them by For the above a key realization is suppose the maximum comes from a subarray with a positive sum Then it is necessary that on both sides of its endpoints if there is an element it must be we can ignore the s since if either side had a we would have a higher valued subarray Now we can pick any from this subarray and a either from its left or right to reduce its sum by thus completing the proof Note that any subarray with maximum absolute sum must have at least one element with sign opposite to its sum either to its left or right Time complexity "}
{"statement": "A lot of people dream of convertibles also often called cabriolets Some of convertibles however don t have roof at all and are vulnerable to rain This is why Melon Ask the famous inventor decided to create a rain protection mechanism for convertibles The workplace of the mechanism is a part of plane just above the driver Its functional part consists of two rails with sliding endpoints of a piece of stretching rope For the sake of simplicity we can consider this as a pair of parallel segments in a plane with the rope segment whose endpoints we are free to choose as any points on these rails segments The algorithmic part of the mechanism detects each particular raindrop and predicts when and where it reaches the plane At this exact moment the rope segment must contain the raindrop point so the rope adsorbs the raindrop You are given the initial position of the rope endpoints and all information about raindrops You are to choose the minimal possible speed v of the endpoints sliding both endpoints can slide in any direction along their segments independently of each other in such a way that it is possible to catch all raindrops moving both endpoints with speed not greater than v or find out that it s impossible no matter how high the speed is ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "First let s find out if we can catch all raindrops for a fixed speed Assume that the endpoints are at and at any moment Consider the point for this state we call it the state point for this state From now on we work with these points We know that this state point can move with speed at most in both directions independently that is if the state point is at the moment then it ll be in at the moment It turns out that for each one of the following takes place we cannot catch raindrops from to we can catch these raindrops and there is exactly one possible option for the state point at the moment we can catch these raindrops and there is a segment on the plane such that the state point at the moment can be in any point of this segment and nowhere else Indeed we prove this by induction Its basis for is trivial Let s prove its step If we cannot catch raindrops from to then we cannot catch all raindrops from to If there is some segment where the state point can be at possibly a segment of length then at the moment the state point can be anywhere inside the convex hull of the union of two squares The squares are for the endpoints of the segment at and here is But we also know that the rope must contain one particular point at the moment which can be expressed as a linear equation of the state point at the moment So to obtain the required segment for one should intersect a line with a convex hull of points which is in fact no more than a hexagon However it s not all the endpoints of the rope mustn t leave the rails which means that the convex hull should be first intersected with the rectangle However it can be done after intersecting with the required line So the solution now is the following First we check if the answer is This is the case when there is a triple of non collinear raindrop points which should be on the rope simultaneously or there is a raindrop which is not on the rope at the moment while it should be The simplest way to check it is to check if we can catch all raindrops with speed First it involves no case handling second we will use this function later anyway After this we run a binary search to find the minimal possible value for speed in such a way that it s possible to catch all the raindrops That s the idea of the solution Now let s consider precision issues The explanation below contains some notions which may be new for a particular reader Please don t be afraid of them I explain what they mean right after introducing them I refer to them by their names first for readers familiar with these notions to get the point faster and maybe skip the explanation which follows For anyone who doesn t want to read the full proof and wants to know the summary long double precision should be enough to get AC with the solution above handling lines intersections properly Define a function as the diameter of the set of possible locations of the state point at the moment for the speed that is if this set is empty or consists of a single point if this set is a segment between and In other words every time we calculate the length of any segment we do it in this metric since it ll be convenient for our purposes Let be the correct answer and let be a sufficiently small positive number but still much bigger than the machine epsilon of course One can see that all s can be divided into two groups which differ a lot by their meaning those for which we must catch one raindrop at this moment or many equal raindrops which doesn t matter those for which we must catch more than one raindrop at this moment For the first ones we basically need to intersect a polygon with a line but for the second ones the state point at can be determined and doesn t depend on the speed or such s force our algorithm to tell that the goal is impossible in the very beginning Let s call the raindrops with of the first type and the others Let s prove the following lemmas One can see that proving these lemmas is sufficient to validate the solution Indeed comparing all intersections with quite good precision will move the binary search borders into the interval which is enough to stop for some Fix We know that the th set of possible state points for is not empty from the definition of It s clear that the th set for is a superset of because we can move no faster than with the speed of To get we move from no more than This finishes the proof of 1b Since is also not empty is at least the segment plus all the points on the corresponding line at the distance no more than that is at least longer than hence is at least long qed Assume our algorithm made at least iterations Consider the corresponding polygon at the moment We know that for this polygon intersects the required line point but its interior doesn t That means that each point of the possible set of state points at the moment isn t inside the polygon That means that if we reduce by then the distance from every point of this set to the polygon is at least qed To summarize the only precision issue we can meet is when we intersect two or more lines for complicated raindrops This part can be implemented in integers but let s dive into this anyway One can see that catching raindrop at means thatorSince the coefficients of this line equation are of order the coordinates of its solution are some rationals with the denominator of order If we then want to check if such point belongs to another line we want to compare some integer divided by another integer which is with the third integer so we need an epsilon less than "}
{"statement": "Tonya was given an array of a of length n written on a postcard for his birthday For some reason the postcard turned out to be a so the index of the element located strictly to the right of the n th is 1 Tonya wanted to study it better so he bought a robot Burenka 179 A program for Burenka is a pair of numbers s k where 1 leq s leq n 1 leq k leq n 1 Note that k be equal to n Initially Tonya puts the robot in the position of the array s After that Burenka makes n steps through the array If at the beginning of a step Burenka stands in the position i then the following happens The number a i is added to the of the program Burenka moves k positions to the right i i k is executed if i becomes greater than n then i i n Help Tonya find the maximum possible of a program for Burenka if the initial usefulness of any program is 0 Also Tony s friend Ilyusha asks him to change the array q times Each time he wants to assign a p x for a given index p and a value x You need to find the maximum possible of the program after each of these changes ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Tutorial Let s note that the answer for and is the same Indeed for the number we will visit numbers with indices for from to inclusive from this we can see that the index of the th number coincides with the index of and if we look at two indexes the difference between which is and then they are different since therefore the answer is the sum of numbers with indices for from to Now let s prove that the first numbers are the same for and note that only those indices that have the same remainder as when divided by are suitable but there are only of such indices and we proved that we should have of different indices so they are all represented once therefore the answer for and is the same because the sum consists of the same numbers So we need to consider only being divisors of this is already passes tests if we write for example a segment tree but we don t want to write a segment tree so we go further prove that for the answer is less or equal than for if and are divisors of why is this so Note that for the number the answer beats for groups of numbers so that in each group there is exactly and each number is in exactly one group and for different the answer will be the sum in the group that belongs to Let s look at the answer for the optimal for let s call the set at which it is reached note that in for different there are independent sets that are subsets of Let be the sum in the th set Now note that we need to prove this is true for any easy to see So you need to iterate the divisors which equals to where is prime now it can be passed with a set Hurray For the divisor it is proposed to store answers for all pairs where and the maximum among them they can be counted initially for for one each request is changing one of the values this can be done for The complexity of the author s solution is where 6 is the maximum number of different prime divisors of the number "}
{"statement": "Misha and Vanya have played several table tennis sets Each set consists of several serves each serve is won by one of the players he receives one point and the loser receives nothing Once one of the players scores exactly points the score is reset and a new set begins Across all the sets Misha scored points in total and Vanya scored points Given this information determine the maximum number of sets they could have played or that the situation is impossible Note that the game consisted of several complete sets ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "There are several possible cases how the game could go The first player won all the sets In this case each set gave him exactly points hence must be divisible by Moreover since the second player could get at most points per set If we have and then the answer is at least The second player won all the sets The analysis in symmetrical Each player has won at least one set In this case we must have and If this condition holds the game is possible with the maximal number of sets Indeed consider the following sequence of sets copies of copies of In short if and or divisible by k or divisible by the answer otherwise One can check that this is equivalent to the reasoning above "}
{"statement": "Rudolph is a scientist who studies alien life forms There is a room in front of Rudolph with n different objects scattered around Among the objects there is amazing creature a mimic that can turn into any object He has already disguised himself in this room and Rudolph needs to find him by experiment The experiment takes place in several stages At each stage the following happens Rudolf looks at all the objects in the room and writes down their types The type of each object is indicated by a number there can be several objects of the same type After inspecting Rudolph can point to an object that he thinks is a mimic After that the experiment ends Rudolph only has one try so if he is unsure of the mimic s position he does the next step instead Rudolf can remove any number of objects from the room possibly zero Then Rudolf leaves the room and at this time all objects including the mimic with each other their order is changed and the into any other object even one that is not in the room After this Rudolf returns to the room and repeats the stage The but it can not remain a same object for more than two stages in a row Rudolf s task is to detect mimic in no more than stages ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "The strategy is to keep track of the number of objects of each type When the number of objects of a certain type increases that means the mimic has turned into an object of that type Then you can delete all other objects After the first such removal all objects will become equal Then after maximum two stages the mimic will be forced to turn into something else and it will be possible to unambiguously identify it Let s consider the worst case where the mimic does not change its appearance between the first and second stages Then we do not remove any element with the first two requests Between the second and third steps the mimic will be forced to transform and then we can remove all objects except for those that have the same type as the mimic The mimic may not change between the third and fourth stages but will be forced to transform between the fourth and fifth Then we will be able to unambiguously determine the mimic since before the transformation all objects were the same "}
{"statement": "Orac is studying number theory and he is interested in the properties of divisors For two positive integers a and b a is a divisor of b if and only if there exists an integer c such that a cdot c b For n ge 2 we will denote as f n the smallest positive divisor of n except 1 For example f 7 7 f 10 2 f 35 5 For the fixed integer n Orac decided to add f n to n For example if he had an integer n 5 the new value of n will be equal to 10 And if he had an integer n 6 n will be changed to 8 Orac loved it so much so he decided to repeat this operation several times Now for two positive integers n and k Orac asked you to add f n to n exactly k times note that n will change after each operation so f n may change too and tell him the final value of n For example if Orac gives you n 5 and k 2 at first you should add f 5 5 to n 5 so your new value of n will be equal to n 10 after that you should add f 10 2 to 10 so your new and the final value of n will be equal to 12 Orac may ask you these queries many times ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "If we simulate the whole process we will get TLE because k is too large So we need some trivial observations If n is even then for each operation n will be added by 2 and keep being even If n is odd then for the first time n will be added by an odd number and then become even So it s easy to see that the answer is left begin array lcl n 2k n textrm is even n 2 k 1 d n n textrm is odd end array right where d n is the smallest positive factor of x except 1 which can be calculated in O n time The overall complexity is O n "}
{"statement": "Given the string s of decimal digits of length n A substring is a sequence of consecutive characters of a string The substring of this string is defined by a pair of indexes with its left and right ends So each pair of indexes l r where 1 le l le r le n corresponds to a substring of the string s We will define as v l r the numeric value of the corresponding substring leading zeros are allowed in it For example if n 7 s then v 1 3 100 v 2 3 0 and v 2 7 3004 You are given n s and an integer w 1 le w n You need to process m queries each of which is characterized by 3 numbers l i r i k i 1 le l i le r i le n 0 le k i le 8 The answer to the ith query is such a pair of substrings of length w that if we denote them as L 1 L 1 w 1 and L 2 L 2 w 1 then L 1 ne L 2 that is the substrings are different the remainder of dividing a number v L 1 L 1 w 1 cdot v l i r i v L 2 L 2 w 1 by 9 is equal to k i If there are many matching substring pairs then find a pair where L 1 is as small as possible If there are many matching pairs in this case then minimize L 2 Note that the answer may not exist ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Note that the remainder of dividing a number by is equal to the remainder of dividing its sum of digits by This is easy to check because the number of digits is representable as a polynomial and gives a remainder of when divided by for any Let s count an array of prefix sums of digits for the string Now knowing we can pre calculate for each remainder modulo all possible Also for each query we can easily find the remainder of dividing by using all the same prefix sums Let s iterate over the remainder of the number when dividing by Knowing it we can easily find the remainder of the number when divided by as modulo Now using each pair of remainers let s try to update the answer then the minimum index from the pre calculated array will act as and the next largest will act as if such exist then the minimum indexes from the pre calculated array will act as and This solution works for or for "}
{"statement": "Koa the Koala has a matrix A of n rows and m columns Elements of this matrix are distinct integers from 1 to n cdot m each number from 1 to n cdot m appears exactly once in the matrix For any matrix M of n rows and m columns let s define the following The i th row of M is defined as R i M M i1 M i2 ldots M im for all i 1 le i le n The j th column of M is defined as C j M M 1j M 2j ldots M nj for all j 1 le j le m Koa defines S A X Y as the spectrum of A where X is the set of the maximum values in rows of A and Y is the set of the maximum values in columns of A More formally X max R 1 A max R 2 A ldots max R n A Y max C 1 A max C 2 A ldots max C m A Koa asks you to find some matrix A of n rows and m columns such that each number from 1 to n cdot m appears exactly once in the matrix and the following conditions hold S A S A R i A is bitonic for all i 1 le i le n C j A is bitonic for all j 1 le j le m An array t t 1 t 2 ldots t k is called bitonic if it first increases and then decreases More formally t is bitonic if there exists some position p 1 le p le k such that t 1 t 2 ldots t p t p 1 ldots t k Help Koa to find such matrix or to determine that it doesn t exist ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 1, "problem_dificulty": "2800", "problem_editorial": "Let be a matrix of size that is formed by a permutation of elements from to Find the maximum element on each row and column i e the spectrum Now we are going to build the answer adding numbers one by one in decreasing order We start with an empty 2 dimensional matrix both dimensions have length 0 and at the end of each iteration the following invariants will be maintained on the matrix All elements processed are inside of the matrix Each row and column is bitonic The horizontal vertical spectrum of this matrix is a subset of the expected horizontal vertical spectrum In addition we are keeping a queue with all positions in the matrix that doesn t contain any element yet At the end of each iteration the following invariants will be maintained on the queue Let be a position on the queue and a position that contains a value that belongs to the horizontal spectrum in the matrix such that and are in the same row then all positions between and have already an element in the matrix or occur in the queue before Let be a position on the queue and a position that contains a value that belongs to the vertical spectrum in the matrix such that and are in the same column then all positions between and have already an element in the matrix or occur in the queue before M int 0 0 Queue new Queue sides of the matrixx y 0 0 for num in n m 1 if num belongs to the horizontal spectrum Add one row full of 0 in the bottom of the matrix X 1 if num belongs to the vertical spectrum Add one column full of 0 in the right of the matrix Y 1 if num belongs either to the horizontal or to the vertical spectrum Put num in the bottom rightmost position of the matrix M x y num else ax ay pop element from Queue M ax ay num if num belongs to the horizontal spectrum Add all positions in the last row but the last one to the Queue from right to left for py in y 1 1 Queue add x py if num belongs to the vertical spectrum Add all positions in the last column but the last one to the Queue from bottom to top for px in X 1 1 Queue add px y In the end invariants on the matrix guarantee that all elements are placed each row and column consist in a bitonic sequence as required and the spectrums are equal to the expected spectrums Let s prove each invariant on the matrix is kept Clearly on each step a different element is placed on the matrix on an empty position we should only show that the operation doesn t fail with Queue empty Say the current element is so the matrix is filled with elements larger than Now we know that in original matrix there were at least rows with maximums less than t and at least m y columns with maximums less than so there could be at most elements greater or equal than t but there are already On each row and column the first element added is the maximum and then elements are added in each direction starting from it toward each edge since elements are processed from largest to smallest then each row and column is bitonic The first element added on each row and column is the maximum and we only add it if it is part of the expected spectrum Time complexity "}
{"statement": "You are given a binary string s of length 2n where each element is mathtt 0 or mathtt 1 You can do the following operation Choose a balanced bracket sequence dagger b of length 2n For every index i from 1 to 2n in order where b i is an open bracket let p i denote the minimum index such that b i p i is a balanced bracket sequence Then we perform a range toggle operation ddagger from i to p i on s Note that since a balanced bracket sequence of length 2n will have n open brackets we will do n range toggle operations on s Your task is to find a sequence of no more than 10 operations that changes all elements of s to mathtt 0 or determine that it is impossible to do so Note that you do have to minimize the number of operations Under the given constraints it can be proven that if it is possible to change all elements of s to mathtt 0 there exists a way that requires no more than 10 operations dagger A sequence of brackets is called balanced if one can turn it into a valid math expression by adding characters and 1 For example sequences and are balanced while and are not ddagger If we perform a range toggle operation from l to r on a binary string s then we toggle all values of s i such that l leq i leq r If s i is toggled we will set s i mathtt 0 if s i mathtt 1 or vice versa For example if s mathtt 1000101 and we perform a range toggle operation from 3 to 5 s will be changed to s mathtt 1011001 ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "ProofSuppose there are open brackets and close brackets between positions and Note that by definition of balanced bracket sequences Case 1 is an open bracket Position will be toggled exactly times as of the open brackets will be matched before position and the remaining open brackets will only be matched after position This means that position will be toggled only if is odd and hence must be odd as well Case 2 is a close bracket Position will be toggled exactly times as of the open brackets will be matched before of the open bracket will be matched with position and the remaining open brackets will be matched after position This means that position will be toggled only if is even and hence must be even as well "}
{"statement": "At first there was a legend related to the name of the problem but now it s just a formal statement You are given n points a 1 a 2 dots a n on the OX axis Now you are asked to find such an integer point x on OX axis that f k x is minimal possible The function f k x can be described in the following way form a list of distances d 1 d 2 dots d n where d i a i x distance between a i and x sort list d in non descending order take d k 1 as a result If there are multiple optimal answers you can print any of them ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "First observation closest points to any point form a contiguous subsegment so Second observation for any contiguous subsegment all points this subsegment closest to also form a contiguous segment And because of the nature of value of is minimal in borders and So all we need is to check all and But what is a value of It s such point that but So it s just in the middle of segment Note that and so it s enough to check only s In result all we need is to find minimal possible value and resulting "}
{"statement": "You are given a tree with n vertices labeled from 1 to n An integer a i is written on vertex i for i 1 2 ldots n You want to make all a i equal by performing some possibly zero spells Suppose you root the tree at some vertex On each spell you can select any vertex v and any non negative integer c Then for all vertices i in the subtree dagger of v replace a i with a i oplus c The cost of this spell is s cdot c where s is the number of vertices in the subtree Here oplus denotes the bitwise XOR operation Let m r be the minimum possible total cost required to make all a i equal if vertex r is chosen as the root of the tree Find m 1 m 2 ldots m n dagger Suppose vertex r is chosen as the root of the tree Then vertex i belongs to the subtree of v if the simple path from i to r contains v ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Add an extra character in front of the permutation Here position of won t be changed by the operation and will always locate at left of Then in each operation the permutation will change as Now let s consider the array made by and permutation as circular This is possible because is always in left of st element so it marks the start of the permutation Then is equivalent with Then the operation is which is same with swapping and Now we need to calculate the minimum odd number of swaps and even number of swaps of and any element each turning to one of To calculate the minimum number of swaps required to turn to the given array first renumber the initial array to then change the given array in the same correspondence Do permutation cycle decomposition Then the answer is sum of size 1 for cycles which have size 2 and don t contain s cycle size 1 This can be proven easily by counting the number of elements which go into the proper place in each operations Calculate this for all Since we can t make the same array using different parity of number of swaps we can achieve the goal by calculating the minimum odd number and minimum even number each The overall time complexity is "}
{"statement": "Seyyed and MoJaK are friends of Sajjad Sajjad likes a permutation Seyyed wants to change the permutation in a way that Sajjad won t like it Seyyed thinks more swaps yield more probability to do that so he makes MoJaK to perform a swap between every pair of positions where exactly once MoJaK doesn t like to upset Sajjad Given the permutation determine whether it is possible to swap all pairs of positions so that the permutation stays the same If it is possible find how to do that ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "If then it is simply provable the answer is NO So we just need to check There is a constructive solution to do that Assume that Partition numbers to classes each class contains a consecutive numbers We can solve each class itself by these swaps to reach the same permutation We can do swaps between two different classes as follows to reach the same permutation assume that the first element of the first class is and for the second class is Now assume that Do the swaps above with first numbers with these changes in place of swaps in the classes itself to satisfy the last number "}
{"statement": "You re given a matrix of size Let s call the matrix with nonnegative elements magic if it is symmetric so and for all triples Note that do not need to be distinct Determine if the matrix is magic As the input output can reach very huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "The problem was suggested by Lewin Gan Lewin The solution and proof also belongs to him Consider the undirected complete graph with nodes with an edge between nodes with cost Let denote the minimum possible value of the max edge of a path from to We know that by definition If the matrix is magic we can choose arbitrary such that by repeating invocations of the inequality given Also you can show that if this inequality is satisfied then the matrix is magic by choosing an and arbitrary So this shows that the matrix is magic if and only if Thus combining with we have We need a fast way to compute for all pairs This can be computed as the MST as the path in the MST minimizes the max edge between all pairs of nodes So the algorithm works as follows First find the MST on the complete graph Then the matrix is magic if and only if the max edge on the path between in the MST is exactly equal to Also you shouldn t forget to check symmetry of the matrix and diagonal for zeros P S Unfortunately we couldn t increase the value in this problem the tests already had the size about 67MB and they couldn t be given with generator So most of the users who solved this problem uses bitset s The complexity of their solution is where or C solution binary lifts by me Java solution by Lewin Complexity or "}
{"statement": "Each day in Berland consists of n hours Polycarp likes time management That s why he has a fixed schedule for each day it is a sequence a 1 a 2 dots a n each a i is either 0 or 1 where a i 0 if Polycarp works during the i th hour of the day and a i 1 if Polycarp rests during the i th hour of the day Days go one after another endlessly and Polycarp uses the same schedule for each day What is the maximal number of continuous hours during which Polycarp rests It is guaranteed that there is at least one working hour in a day ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "At first consider we process the only day In this case just iterate over hours and maintain the length of the current rest block i e if the element equals then increase if the element equals then reset to The maximum intermediate value of is the answer In case of multiple days consider the given sequence as a cyclic sequence Concatenate the sequence twice and solve the previous case Sure not it is no necessary to concatenate it in explicit way just use instead of and process "}
{"statement": "You are playing the game Arranging The Sheep The goal of this game is to make the sheep line up The level in the game is described by a string of length n consisting of the characters empty space and sheep In one move you can move any sheep one square to the left or one square to the right if the corresponding square The game ends as soon as the sheep are lined up that is there should be no empty cells between any sheep For example if n 6 and the level is described by the string then the following game scenario is possible the sheep at the 4 position moves to the right the state of the level the sheep at the 2 position moves to the right the state of the level the sheep at the 1 position moves to the right the state of the level the sheep at the 3 position moves to the right the state of the level the sheep at the 2 position moves to the right the state of the level the sheep are lined up and the game ends For a given level determine the minimum number of moves you need to make to complete the level ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let s denote by the number of sheep in the string and by their positions in the string Note that in the optimal solution the sheep with the number will not make moves This can be proved by considering the optimal solution in which the sheep with the number makes at least one move and come to the conclusion that this solution is not optimal Consider sheep with numbers from to Then the final position of the th sheep will be and the answer will be "}
{"statement": "Information technologies are developing and are increasingly penetrating into all spheres of human activity Incredible as it is the most modern technology are used in farming A large farm has a meadow with grazing sheep Overall there are sheep and each of them contains a unique number from 1 to because the sheep need to be distinguished and you need to remember information about each one and they are so much alike The meadow consists of infinite number of regions numbered from 1 to infinity It s known that sheep likes regions from to There are two shepherds taking care of the sheep First and Second First wakes up early in the morning and leads the sheep graze on the lawn Second comes in the evening and collects all the sheep One morning First woke up a little later than usual and had no time to lead the sheep graze on the lawn So he tied together every two sheep if there is a region they both like First thought that it would be better Second would have less work in the evening because sheep won t scatter too much being tied to each other In the evening Second came on the lawn gathered the sheep and tried to line them up in a row But try as he might the sheep wouldn t line up as Second want Second had neither the strength nor the ability to untie the sheep so he left them as they are but with one condition he wanted to line up the sheep so that the maximum distance between two tied sheep was as small as possible The distance between the sheep is the number of sheep in the ranks that are between these two Help Second find the right arrangement ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Author s supposed greedy algorithm as a solution for this problem Let us follow this algorithm Let us create to label for every interval Positionv and MaximalPositionv Positionv stands for position of v in the required permutation MaximalPositionv stands for maximal possible position of v in the particular moment of the algorithm Also let s consider count as a counter with initial value of 0 and set of unprocessed vertices S The algorithm is following Using binary search we find the maximal possible distance between the farthest sheep And then check whether exists the permutation with maximal distance no more than K Sort all the intervals in the increasing order of ri Positioni 0 1 i n MaximalPositioni n 1 i n current 1 count 0 Do count count 1 Positioncurrent count erase current from S if S is empty required permutation has been found Look at every interval connected to current and update MaximalPositionv min MaximalPositionv Positioncurrent K Build sets S count j v MaximalPositionv count j If for every j K count 1 holds S count j j go to the step 7 otherwise there is no such permutation Choose the minimal j such that S count j j Choose from it the interval with the smallest ri and consider it as a new value for current go to the step 4 First let us discuss the complexity Let us fix K in total there are iterations with fixed K Every step from 4 to 7 will be done at most n times every time size of S decreases by one Every step can be implemented in O n time The most difficult one step 6 But we can see that it s not necessary to actually build the sets all we need to know their sizes This can be done in linear time just counting the number of intervals that MaximalPositionv i Let if be Ci then size of S count j equals to C1 C2 Ccount j which can be easily calculated with partial sums Now let us discuss why this algorithm works If we have Position labels for every interval we obviously have the solution Now let us assume that we ended up earlier Then we will show that there is no such permutation If algorithm ended it means that for some count consider the smallest such count exists j0 that S count j0 j0 at this step Then S count k k Let us prove that from contradiction From the definition of count we have S count 1 j j for every j k count 2 Then S count j S count 1 j 1 1 j for every j k 1 And S count j S count k for k j n count S count j S count k j Finally S count n count n count Then S count j j for every j so we obtain contradiction That means if algorithm stops at step 6 we have S count k k So exist at least k 1 interval which still don t have assigned label Position and they should be assigned after count So one of the intervals in S count k has to have the value of Position at least count k 1 But every intervals in S count k connected to at least one interval with Position count So we obtain that there is now such permutation "}
{"statement": "Bear Limak likes watching sports on TV He is going to watch a game today The game lasts minutes and there are no breaks Each minute can be either interesting or boring If consecutive minutes are boring then Limak immediately turns TV off You know that there will be interesting minutes Your task is to calculate for how many minutes Limak will watch the game ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "You are supposed to implement what is described in the statement When you read numbers check if two consecutive numbers differ by more than i e If yes then you should print You can assume that and then you don t have to care about some corner case at the beginning Also you can assume that or both should work do you see why If your program haven t found two consecutive numbers different by more than then print If you still have problems to solve this problem then check codes of other participants 18286606 invented by Errichto Some prefix of problems must belong to one division and the remaining suffix must belong to the other division Thus we can say that we should choose the place between two numbers where we split problems Each pair let s say that means that the splitting place must be between and In other words it must be on the right from and on the left from For each pair if then we swap these two numbers Now the splitting place must be on the right from so it must be on the right from In linear time you can calculate and similarly calculate Then the answer is It may turn out that though but we don t want to print a negative answer So we should print 18286633 invented by Errichto We are going to iterate over all intervals Let s first fix the left end of the interval and denote it by Now we iterate over the right end When we go from to then we get one extra ball with color In one global array we can keep the number of occurrences of each color we can clear the array for each new We should increase by one and then check whether becomes a new dominant color But how to do it Additionally let s keep one variable with the current dominant color When we go to then we should whether or and The second condition checks which color has smaller index in case of a tie And we must increase by one then because we know that is dominant for the current interval At the end print values 18286663 invented by Errichto There is no solution if or But for and you can construct the following graph Here cities denote other cities in any order you choose cities different than You should print in the first line and in the second line Two not very hard challenges for you Are you able to prove that the answer doesn t exist for Can you solve the problem if the four given cities don t have to be distinct but it s guaranteed that and 18286683 invented by Radewoosh When we repeat something and each time we have probability to succeed then the expected number or tries is till we succeed How to calculate the expected time for one region For each in some moment we will try to beat this level and then there will be tokens in the bag including tokens allowing us to beat this new level The probability to succeed is so the expected time is So in total we should sum up values for Ok we managed to understand the actual problem You can now stop and try to find a slow solution in Hint use the dynamic programming Now let s write formula for as the minimum over denoting the end of the previous region So we can use convex hull trick to calculate it in You should also get AC with a bit slower divide conquer trick if it s implemented carefully 18286696 invented by Radewoosh Let s say that every company has one parent a company it follows Also every copmany has some maybe empty set of children It s crucial that sets of children are disjoint For each company let s keep and always update one value equal to the sum of It turns out that after each query only the above sum changes only for a few values If starts to follows then you should care about And maybe and if you want to be sure You can stop reading now for a moment and analyze that indeed other companies will keep the same sum described above Ok but so far we don t count the income coming from parent s fanpage But for each company we can store all its children in one set All children have the same income from parent s fanpage because they have the same parent So in set you can keep children sorted by the sum described above Then we should always puts the extreme elements from sets in one global set In the global set you care about the total income equal to the sum described above and this new income from parent Check codes for details The complexity should be with big constant factor 18286747 invented by Errichto Let denote the probability that subtree if attacked now would have height at most The first observation is that we don t care about big because it s very unlikely that a path with e g 100 edges will survive Let s later talk about choosing and now let s say that it s enough to consider up to When we should answer a query for subtree then we should sum up to get the answer The other query is harder Let s say that a new vertex is attached to vertex Then among only changes other values stay the same Also one value changes and so does and so on You should iterate over vertices each time going to parent and update the corresponding value TODO puts here come formula for updating value The complexity is You may think that is enough because is small enough Unfortunately there exist malicious tests Consider a tree with paths from root each with length Now we talk about the probability of magnitude which is more than for http www wolframalpha com input i 1 1 1 "}
{"statement": "Little Mishka is a great traveller and she visited many countries After thinking about where to travel this time she chose XXX beautiful but little known northern country Here are some interesting facts about XXX XXX consists of cities of whose just imagine are capital cities All of cities in the country are beautiful but each is beautiful in its own way Beauty value of th city equals to All the cities are consecutively connected by the roads including st and th city forming a cyclic route Formally for every there is a road between th and th city and another one between st and th city Each capital city is connected with each other city directly by the roads Formally if city is a capital city then for every there is a road between cities and There is road between any two cities Price of passing a road directly depends on beauty values of cities it connects Thus if there is a road between cities and price of passing it equals Mishka started to gather her things for a trip but didn t still decide which route to follow and thus she asked you to help her determine summary price of passing in XXX Formally for every pair of cities and such that there is a road between and you are to find sum of products Will you help her ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let s look at the first capital Note that the total cost of the outgoing roads is where summary beauty of all cities Thus iterating through the capitals we can count the summary cost of roads between capitals and all the other cities But don t forget that in this case we count the roads between pairs of capitals twice To avoid this on each step we should update where is the position of current capital In the end we should add to the answer the cost of roads between non capital neighbour cities Complexity "}
{"statement": "You have two permutations dagger p 1 p 2 ldots p n of integers 1 to n and q 1 q 2 ldots q m of integers 1 to m Initially p i a i for i 1 2 ldots n and q j b j for j 1 2 ldots m You can apply the following operation on the permutations several possibly zero times In one operation p and q will change according to the following three steps You choose integers i j which satisfy 1 le i le n and 1 le j le m Permutation p is partitioned into three parts using p i as a pivot the left part is formed by elements p 1 p 2 ldots p i 1 this part may be empty the middle part is the single element p i and the right part is p i 1 p i 2 ldots p n this part may be empty To proceed swap the left and the right parts of this partition Formally after this step p will become p i 1 p i 2 ldots p n p i p 1 p 2 ldots p i 1 The elements of the newly formed p will be reindexed starting from 1 Perform the same transformation on q with index j Formally after this step q will become q j 1 q j 2 ldots q m q j q 1 q 2 ldots q j 1 The elements of the newly formed q will be reindexed starting from 1 Your goal is to simultaneously make p i i for i 1 2 ldots n and q j j for j 1 2 ldots m Find any valid way to achieve the goal using at most 10 000 operations or say that none exists Please note that you minimize the number of operations It can be proved that if it is possible to achieve the goal then there exists a way to do so using at most 10 000 operations dagger A permutation of length k is an array consisting of k distinct integers from 1 to k in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation k 3 but there is 4 in the array ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "TutorialAdd an extra character in front of the permutation Here position of won t be changed by the operation and will always locate at left of Then in each operation the permutation will change as Now let s consider the array made by and permutation as circular This is possible because is always in left of st element so it marks the start of the permutation Then is equivalent with Then the operation is which is same with swapping and Now we need to calculate the minimum odd number of swaps and even number of swaps of and any element each turning to one of To calculate the minimum number of swaps required to turn to the given array first renumber the initial array to then change the given array in the same correspondence Do permutation cycle decomposition Then the answer is sum of size 1 for cycles which have size 2 and don t contain s cycle size 1 This can be proven easily by counting the number of elements which go into the proper place in each operations Calculate this for all Since we can t make the same array using different parity of number of swaps we can achieve the goal by calculating the minimum odd number and minimum even number each The overall time complexity is "}
{"statement": "Squirrel Liss lived in a forest peacefully but unexpected trouble happens Stones fall from a mountain Initially Squirrel Liss occupies an interval Next stones will fall and Liss will escape from the stones The stones are numbered from 1 to in order The stones always fall to the center of Liss s interval When Liss occupies the interval and a stone falls to she will escape to the left or to the right If she escapes to the left her new interval will be If she escapes to the right her new interval will be You are given a string of length If the th character of is or when the th stone falls Liss will escape to the left or to the right respectively Find the sequence of stones numbers from left to right after all the stones falls ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "You can visualize the problem as a binary tree Each node is responsable for a interval a b Starting from the root responsable for 0 1 if you go left then root will have a left child responsable for interval 0 1 2 Since you re a left child last time the stone fell on position 1 2 the end point of the interval Note that from that child it doesn t matter if you go left or right the stone will never fall on a position bigger than 1 2 the end point The ideia is since a stone always fall on the midpoint a b 2 of the lower and end points it can never fall after the endpoint In fact the stone must fall infinitely many times to the right to reach that endpoint So we were on a node 0 1 the stone fell and we jumped to the left creating a left child 0 1 2 and we now know that there is no way the stone will every fall to a position 1 2 This means that in the final solution the current node 0 1 2 will come AFTER all nodes descendents that come after this one If we jumped to the right instead creating a right child responsable for interval 1 2 1 we can show the same way that the stone will never fall before the starting point 1 2 This means that the current node will com BEFORE all nodes descendents that come after this one since we know that the stone can t fall on a postion 1 2 from now on This is an algorithm if in the i th stone we jumped to the left we now that stone i will become AFTER all next stones If we jumped right stone i will become BEFORE all next stones Code 23071895 "}
{"statement": "Andrew prefers taxi to other means of transport but recently most taxi drivers have been acting inappropriately In order to earn more money taxi drivers started to drive in circles Roads in Andrew s city are one way and people are not necessary able to travel from one part to another but it pales in comparison to insidious taxi drivers The mayor of the city decided to change the direction of certain roads so that the taxi drivers wouldn t be able to increase the cost of the trip endlessly More formally if the taxi driver is on a certain crossroads they wouldn t be able to reach it again if he performs a nonzero trip Traffic controllers are needed in order to change the direction the road goes For every road it is known how many traffic controllers are needed to change the direction of the road to the opposite one It is allowed to change the directions of roads one by one meaning that each traffic controller can participate in reversing two or more roads You need to calculate the minimum number of traffic controllers that you need to hire to perform the task and the list of the roads that need to be reversed ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 1, "problem_dificulty": "2200", "problem_editorial": "Suppose we have traffic controllers They can turn all edges whose weight is less than or equal to Then let s remove all these edges from the graph make a topological sorting of the remaining graph and orient the other edges in the order of topological sorting If there are cycles left in the graph after removing the edges then we cannot get rid of them having traffic controllers Otherwise by adding edges we will not add new loops The parameter can be iterated through a binary search Also in binary search you can go through not all possible values of but only the values that are on the edges Complexity or "}
{"statement": "Ira loves Spanish flamenco dance very much She decided to start her own dance studio and found n students ith of whom has a i Ira can choose several of her students and set a dance with them So she can set a huge number of dances but she is only interested in dances The dance is called if the following is true m students participate in the dance of all dancers are of every two dancers have an absolute difference than m For example if m 3 and a 4 2 2 3 6 the following dances are students participating in the dance are highlighted in red color red 4 2 color red 2 color red 3 6 color red 4 color red 2 2 color red 3 6 At the same time dances color red 4 2 2 color red 3 6 4 color red 2 color red 2 color red 3 6 color red 4 2 2 color red 3 color red 6 are not In the dance color red 4 2 2 color red 3 6 only 2 students participate although m 3 The dance 4 color red 2 color red 2 color red 3 6 involves students with 2 and 2 although of all dancers must be pairwise distinct In the dance color red 4 2 2 color red 3 color red 6 students with 3 and 6 participate but 3 6 3 although m 3 Help Ira count the number of dances that she can set Since this number can be very large count it 10 9 7 Two dances are considered different if the sets of students participating in them are different ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Reformulate the definition of dance A dance is called if there exists such a non negative integer that forms a permutation Let s build an array such that it is sorted all the numbers in it are unique and each number from occurs in For each element set as its number of occurrences in the array This process is called coordinate compression For example if then Let the constructed array has length In every dance there is a dancer with a minimum Let s fix this minimal in the array let its index be then the desired dance exists if and If the desired dance exists the number of such dances must be added to the answer which is equal to How to quickly calculate such a number Let s build prefix products Then by Fermat s small theorem Time complexity is Let s build a segment tree on a product modulo Time complexity is and we don t use that the module is prime We will use the idea of building a queue on two stacks but we will support prefix products modulo in these stacks Time complexity is and we don t use that the module is prime "}
{"statement": " You are given a permutation p 1 p 2 ldots p n of integers from 1 to n Let s define the weight of the permutation q 1 q 2 ldots q n of integers from 1 to n as q 1 p q 2 q 2 p q 3 ldots q n 1 p q n q n p q 1 You want your permutation to be as lightweight as possible Find any permutation q with the smallest possible weight ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Let s first understand what is the minimum possible weight of When can it be Only when for each Clearly such exists only when is just one cycle This gives a hint that we should look at cycles Consider splitting of into cycles where a cycle is an array such that for Let s say there are of such cycles I claim that the answer is You can see the proof in the tutorial of the hard version of this problem Now let s provide an example We will construct a permutation as follows Initially it s equal to Then for each from to if and are in different cycles in currently swap them One such swap reduces the number of cycles by exactly so we will do exactly such swaps and will consist of exactly one cycle Next construct by the rule it s possible as is just one cycle As the weight of is just the sum of Clearly one swap increases this value by at most so in the end it will be at most as desired "}
{"statement": "Berland 2016 The exchange rate of against the burle has increased so much that to simplify the calculations its fractional part was neglected and the exchange rate is now assumed to be an integer Reliable sources have informed the financier Anton of some information about the exchange rate of against the burle for tomorrow Now Anton knows that tomorrow the exchange rate will be an even number which can be obtained from the present rate by swapping exactly two distinct digits in it Of all the possible values that meet these conditions the exchange rate for tomorrow will be the maximum possible It is guaranteed that today the exchange rate is an positive integer Help Anton to determine the exchange rate of for tomorrow ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Because of specified number is odd that mean that last digit of this number is odd we need to swap last digit with some even digit How to maximize number after this swap If number consists only from odd digits print 1 Else we need to find first even digit which less than last digit if we will iterate from most significant digit If we find such digit swap it with last digit and we have an answer Else we need to find first even digit which more than last digit if we will iterate from less significant digit If we find such digit swap it with last digit and we have an answer Asymptotic behavior of this solution O n where n count of digits in specified number "}
{"statement": "For an array a 1 a 2 ldots a n of length n define f a as the sum of the minimum element over all subsegments That is f a sum l 1 n sum r l n min l le i le r a i A permutation is a sequence of integers from 1 to n of length n containing each number exactly once You are given a permutation a 1 a 2 ldots a n For each i solve the following problem independently Erase a i from a concatenating the remaining parts resulting in b a 1 a 2 ldots a i 1 a i 1 ldots a n Calculate f b ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Build the cartesian tree of a Let lcx rcx respectively be x s left and right children Consider a vertex x If we delete it what would happen to the tree Vertices that are on the outside of x s subtree will not be affected Vertices inside the subtree of x will merge Actually we can see that only the right chain of x s left child lcx rclcx rcrclcx and the left chain of x s right child will merge in a way like what we do in mergesort Now if we merge the chains by bruteforce use sorting or std merge the time complexity is O n It s easy to see that each vertex will only be considered O 1 times "}
{"statement": "Consider the following process You have a binary string a string where each character is either or w of length n and an integer x You build a new binary string s consisting of n characters The i th character of s is chosen as follows if the character w i x exists and is equal to then s i is formally if i x and w i x then s i if the character w i x exists and is equal to then s i is formally if i x le n and w i x then s i if both of the aforementioned conditions are false then s i is You are given the integer x and the resulting string s Reconstruct the original string w ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Note that means either or whereas means both and We can greedily solve this by starting out our string with all 1 s then marking and as 0 whenever we are forced to because Then we can simply check whether all of the conditions are valid to confirm Code 90915688 "}
{"statement": "You re given a tree consisting of n nodes rooted at node 1 A tree is a connected graph with no cycles We chose a hidden node x In order to find this node you can ask queries of two types u 1 le u le n We will answer with the distance between nodes u and x The distance between two nodes is the number of edges in the shortest path between them u 1 le u le n We will answer with the second node on the path from u to x However there s a plot twist If u is an ancestor of x you ll receive verdict Node a is called an ancestor of node b if a ne b and the shortest path from node 1 to node b passes through node a Can you find x in no more than 36 queries The hidden node is fixed in each test beforehand and does not depend on your queries ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "Let be the depth of node and be the size of the subtree of node First we ll query the distance between node 1 and node to know The idea in the problem is to maintain a search scope some nodes such that is one of them and to try to narrow it down with queries From this point I ll describe two solutions "}
{"statement": "In order to make the Sea Battle game more interesting Boris decided to add a new ship type to it The ship consists of two rectangles The first rectangle has a width of w 1 and a height of h 1 while the second rectangle has a width of w 2 and a height of h 2 where w 1 ge w 2 In this game exactly one ship is used made up of two rectangles There are no other ships on the field The rectangles are placed on field in the following way the second rectangle is on top the first rectangle they are aligned to the left i e their left sides are on the same line the rectangles are adjacent to each other without a gap See the pictures in the notes the first rectangle is colored red the second rectangle is colored blue Formally let s introduce a coordinate system Then the leftmost bottom cell of the first rectangle has coordinates 1 1 the rightmost top cell of the first rectangle has coordinates w 1 h 1 the leftmost bottom cell of the second rectangle has coordinates 1 h 1 1 and the rightmost top cell of the second rectangle has coordinates w 2 h 1 h 2 After the ship is completely destroyed all cells neighboring by side or a corner with the ship are marked Of course only cells which don t belong to the ship are marked On the pictures in the notes such cells are colored green Find out how many cells should be marked after the ship is destroyed The field of the game is infinite in any direction ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s classify marked squares to two groups First group will consist of cells that are neighboring by corner to ship There are exactly such corners Second group will consist of cells that are neighboring by side to ship Number of such squares is equal to length of perimeter of a ship Thus answer is equal to "}
{"statement": "Nick had received an awesome array of integers a a 1 a 2 dots a n as a gift for his 5 birthday from his mother He was already going to explore its various properties but after unpacking he was disappointed a lot because the product a 1 cdot a 2 cdot dots a n of its elements seemed to him not large enough He was ready to throw out the array but his mother reassured him She told him that array would not be spoiled after the following operation choose any index i 1 le i le n and do a i a i 1 For example he can change array 3 1 4 1 to an array 4 1 3 1 after applying this operation to elements with indices i 1 and i 3 Kolya had immediately understood that sometimes it s possible to increase the product of integers of the array a lot Now he has decided that he wants to get an array with the maximal possible product of integers using only this operation with its elements possibly zero one or more times as many as he wants it is not forbidden to do this operation several times for the same index Help Kolya and print the array with the maximal possible product of elements a 1 cdot a 2 cdot dots a n which can be received using only this operation in some order If there are multiple answers print any of them ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Initially we are going to make a product maximal by absolute value It means that if we are going to apply described operation i e to increase the absolute value Now if the product is already positive it s the answer Else to apply the operation to the minimal number is obviously optimal if we applied the operation to any other number the result would not be greater by absolute value but applying to the minimum we have received non negative product already Thus the solution works in "}
{"statement": "There is an array a of 2 30 integers indexed from 0 to 2 30 1 Initially you know that 0 leq a i 2 30 0 leq i 2 30 but you do not know any of the values Your task is to process queries of two types You are informed that the of the subarray l r ends inclusive is equal to x That is a l oplus a l 1 oplus ldots oplus a r 1 oplus a r x where oplus is the bitwise xor operator In some cases the received update contradicts past updates In this case you should the contradicting update the current update You are asked to output the bitwise xor of the subarray l r ends inclusive If it is still impossible to know this value considering all past updates then output Note that the queries are That is you need to write an solution ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "First let s learn how to handle information we have not recieved in updates Let the function be equal to the xor of the subarray Also we define Assume 3 indicies There are 2 rules holds when These rules require a lot of conditions and also plenty of 1 We can simplify them greatly Let s index the borders between cells in our array there are of them Now instead of defining a subarray by its 2 endpoint we will define a subarray by its 2 endpoint Technically it just means that we should increase by 1 and then we get the 2 end borders From now I will assume that our input is given in such a way that subarrays are defined by their borders So I will not mention the addition of 1 to Notice that the function is also affected by this If we take a look at our rules again they boil down to just 1 rule for 3 indicies doesn t need to hold now for instance This transformation also shows an observation Assume every border is a vertex in a graph and every update describes an undirected edge between the vertices with weight We let the distance between 2 nodes be the xor of edge weights on the path between them Notice that this distance is equal to In other words an update adds an edge and a query asks for some distance Another observation is that we do not care about all the nodes but only about the ones we recieved in queries and updates Moreover their order is irrelevant so we can do an online mapping of new nodes to the next free indicies Thus the number of nodes will be worstcase Claim We can know the answer to some query if and only if there exists a path between the nodes they are in the same connected component start spoiler of proofThere will be some subset of edges we take to form the xor between nodes and Assume every vertex has 2 states on off Initially all vertices are off and our current answer is When we take an edge we flip the state of its 2 ends and xor our answer by its weight Suppose at some moment of time the nodes with on state are in sorted order Observe that our current answer is equal to This implies we want our subset of edges to end up having only the nodes activated We look at the connected components Observe that in each connected component the number of nodes activated at any time is even If the nodes and are in different component then in our final result we would want to have only 1 activated node in the component of and same with but this is impossible end spoiler of proofFirst we need to know whether a query gives us 2 nodes that are in different components to know whether the answer is or not For this we need to use the Union Find structure Also notice that our Union Find structure will only need to handle a forest of trees if an update gives us an edge that creates a cycle it means there is no contribution so we ignore it Provided that an answer does exist we need to also handle finding a xor path between 2 nodes in a tree to support merging of trees Generally to find a property over some path in a tree it is common to use LCA or binary lifting This turns out very difficult when we also need to merge trees unless you insist on implementing Link Cut ETT Fortunately we can still abuse the xor operator In some tree mark as the xor of edges on the path from to some arbitrary root in the tree The xor path between nodes turns out to be So we would like to maintain for each tree some arbitrary root and all those values Notice that we can augment our Union Find structure to support this as well For each node in the structure we maintain as its parent in the structure and as the xor on the path from to Notice that can be easily updated together with during the operation in the structure To summarize when we are given in some update we transform it to and then we add the edge between the parents Finally the complexity is but this is only due to the online mapping if we use a regular map You can use a hash table and get a running time of but I suggest being careful with a hash table you may want to read this https codeforces com blog entry 62393 "}
{"statement": "As everyone knows bears love fish But Mike is a strange bear He hates fish The even more strange thing about him is he has an infinite number of blue and red fish He has marked distinct points in the plane th point is point He wants to put exactly one fish in each of these points such that the difference between the number of red fish and the blue fish on each horizontal or vertical line is at most 1 He can t find a way to perform that Please help him ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2600", "problem_editorial": "Consider a bipartite graph In each part we call them first and second part there are vertices numbered from to For each point add an edge between vertex number from the first part and vertex number from the second part In this problem we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1 Doing such thing is always possible We prove this and solve the problem at the same time with induction on the number of edges If all vertices have even degree then for each component there is an Eulerian circuit find it and color the edges alternatively with blue and red Because graph is bipartite then our circuit is an even walk and so the difference between the number of blue and red edges connected to a vertex will be 0 Otherwise if a vertex like has odd degree consider a vertex like that there is and edge between and Delete this edge and solve the problem for the rest of the edges with the induction definition and then add this edge and if the number of red edges connected to is more than the blue ones then color this edge with blue otherwise with red You can handle this add delete edge requests and find odd vertices with a simple set So Time complexity C Code by PrinceOfPersia C Code by Haghani Java Code by Zlobober "}
{"statement": "Monocarp visited a retro arcade club with arcade cabinets There got curious about the Catch the Coin cabinet The game is pretty simple The screen represents a coordinate grid such that the X axis is directed from left to right the Y axis is directed from bottom to top the center of the screen has coordinates 0 0 At the beginning of the game the character is located in the center and n coins appear on the screen the i th coin is at coordinates x i y i The coordinates of all coins are different and not equal to 0 0 In one second Monocarp can move the character in one of eight directions If the character is at coordinates x y then it can end up at any of the coordinates x y 1 x 1 y 1 x 1 y x 1 y 1 x y 1 x 1 y 1 x 1 y x 1 y 1 If the character ends up at the coordinates with a coin then Monocarp collects that coin After Monocarp makes a move all coins fall down by 1 that is they move from x y to x y 1 You can assume that the game field is infinite in all directions Monocarp wants to collect at least one coin but cannot decide which coin to go for Help him determine for each coin whether he can collect it ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "At first glance it s not very convenient that the move consists of two parts first the character moves then the coin Let s try to combine these steps Since the coin moves down by 1 each time we can add this change in the y coordinate to the change in the character s y coordinate That is the character can now change its y coordinate not by 1 0 or 1 but by 0 1 or 2 And the coins will always be in their initial positions Now it is easy to see that all coins with y 0 can be picked up For example you can first align with the coin in terms of the x coordinate and then move up to it However in the example it can be seen that Monocarp can pick up the coin 2 1 This happens because the move still consists of two parts Since the character moves first and then the coin we can align with the x coordinate again and then have the time to move down to it Thus all coins with y 1 can be picked up "}
{"statement": "Attention we lost all the test cases for this problem so instead of solving the problem we need you to generate test cases We re going to give you the answer and you need to print a test case that produces the given answer The original problem is in the following paragraph People don t use cash as often as they used to Having a credit card solves some of the hassles of cash such as having to receive change when you can t form the exact amount of money needed to purchase an item Typically cashiers will give you as few coins as possible in change but they don t have to For example if your change is 30 cents a cashier could give you a 5 cent piece and a 25 cent piece or they could give you three 10 cent pieces or ten 1 cent pieces two 5 cent pieces and one 10 cent piece Altogether there are 18 different ways to make 30 cents using only 1 cent pieces 5 cent pieces 10 cent pieces and 25 cent pieces Two ways are considered different if they contain a different number of at least one type of coin Given the denominations of the coins and an amount of change to be made how many different ways are there to make change As we mentioned before we lost all the test cases for this problem so we re actually going to give you the number of ways and want you to produce a test case for which the number of ways is the given number There could be many ways to achieve this we guarantee there s always at least one so you can print any as long as it meets the constraints described below ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "The simplest solution is to make the denominations always 1 2 and set N 2 A 1 This provides exactly A ways to make change because you can choose any number of 2 cent pieces from 0 to A 1 then the rest must be 1 cent pieces "}
{"statement": "You are given two sets of positive integers A and B You have to find two non empty subsets S A subseteq A S B subseteq B so that the least common multiple LCM of the elements of S A is equal to the least common multiple LCM of the elements of S B ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3200", "problem_editorial": "First we see how to check if the two entire sets have the same LCM without subsets To do this for each element let us compute and check if it is If it is greater than that means has some prime power dividing it with exponent greater than any of the corresponding exponents in and therefore the LCM cannot be equal We perform the same computations with the elements of i e If all the results were then the LCMs are equal Complexity is where If we can simply delete from and solve recursively using the remaining sets similarly if We need to update the values and efficiently We can do it using many segment tree one for each and one for each The segment tree of will have the elements of as its leaves and the node of which will include a range of elements of will be meaning that after removing an element of we will need to recompute all of the segment trees in time each it is and not by a similar argument to the one used to compute the complexity of computing the gcd of an array of numbers Since we have to repeat this for steps the total time complexity will be and the memory complexity is "}
{"statement": "You received a notebook which is called This notebook has infinite number of pages A rule is written on the last page huh of this notebook It says You have to write names in this notebook during n consecutive days During the i th day you have to write exactly a i names You got scared of course you got scared who wouldn t get scared if he just receive a notebook which is named with a some strange rule written in it Of course you decided to follow this rule When you calmed down you came up with a strategy how you will write names in the notebook You have calculated that each page of the notebook can contain exactly m names You will start writing names from the first page You will write names on the current page as long as the limit on the number of names on this page is not exceeded When the current page is over you turn the page Note that you turn the page when it ends it doesn t matter if it is the last day or not If after some day the current page still can hold at least one name during the next day you will continue writing the names from the current page Now you are interested in the following question how many times will you turn the page during each day You are interested in the number of pages you will turn each day from 1 to n ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "In this problem all we need is to maintain the variable which will represent the number of names written on the current page Initially this number equals zero The answer for the th day equals This value represents the number of full pages we will write during the th day After the answering we need to set where operation is taking modulo "}
{"statement": "Slime and Orac are holding a turn based game In a big room there are n players sitting on the chairs looking forward to a column and each of them is given a number player 1 sits in the front of the column player 2 sits directly behind him player 3 sits directly behind player 2 and so on player n sits directly behind player n 1 Each player wears a hat that is either black or white As each player faces forward player i knows the color of player j s hat if and only if i is larger than j At the start of each turn Orac will tell After Orac speaks if the player can uniquely identify the color of his hat he will put his hat on the chair stand up and leave the room All players are smart so if it is possible to understand the color of their hat using the obtained information during this and previous rounds they will understand it In each turn all players who know the color of their hats will leave at the same time in this turn which means a player can only leave in the next turn if he gets to know the color of his hat only after someone left the room at this turn Note that when the player needs to leave he will put the hat on the chair before leaving so the players ahead of him still cannot see his hat The i th player will know who exactly left the room among players 1 2 ldots i 1 and how many players among i 1 i 2 ldots n have left the room Slime stands outdoor He watches the players walking out and records the numbers of the players and the time they get out Unfortunately Slime is so careless that he has only recorded some of the data and this given data is in the format Slime asked you to tell him the color of each player s hat If there are multiple solutions you can find any of them ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "First let s renumber the players for convenience Number the player at the front as the player sitting behind him as and so on Let be the color of player s hat Consider how to calculate if we have already known If then Otherwise let be the maximal number of a player with a black hat In the first turn player knows that someone wears a black hat If player finds out that everyone except him wears a white hat so he wears a black hat and he leaves In the second turn other players can figure out that Therefore If there is a player with a black hat sitting in front of player so he can t figure out the color of his own hat and doesn t leave Other players know that in the next turn and the problem is transformed into a subproblem on player No one leaves until the th turn player knows that there is at least one player with a black hat in but player all wear white hats so he leaves In the next turn leaves According to the above process player leaves in the th turn player leave in the th turn and a new process begins Therefore we can figure out the value of If then Let If let be the maximal number which satisfies and then For convenience let so always exists Let Therefore we can calculate using and is satisfied Consider how to solve the original problem Before using dynamic programming to solve the problem we need to do some preparation for that If and it is obviously that Also if Therefore In fact if we have It is not difficult to prove the formula above with some simple classified discussions Define a set of intervals which satisfies these rules is given if is given For all pairs where and are both given and are in the same interval if and only if If it can be known that and Let After the preparatory work let s work on dp Let be the maximal possible value of when Consider how to calculate if we know the value of and For enumerate all possible from large to small might be satisfied if If can be noticed that are already known so we just need to check whether there exists some distinct integers in where the sum of them equals to which can be easily solved by binary search Besides record whether is transformed from or Using these we can easily give a solution Notice that when doesn t satisfy However there is at most one in where Just brute force which equals to is okay The whole complexity is "}
{"statement": "A non empty string is called if it reads the same from the left to the right and from the right to the left For example and are palindromes while and are not A string is called a of another string if it can be obtained from that string by dropping some possibly zero number of characters from the beginning and from the end of it For example and are substrings of the string while and are not Let s define a of the string as the number of its substrings that are palindromes For example the palindromic count of the string is 6 because all its substrings are palindromes and the palindromic count of the string is 3 because only its substrings of length 1 are palindromes You are given a string s You can arbitrarily rearrange its characters You goal is to obtain a string with the maximum possible value of palindromic count ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "One possible solution is just to sort the string Why so Note that each palindrome have equal character at their ends Suppose this character is with number of occurences Then there are at most palindromes with this character So we have a clear upper bound on answer It is easy to see that the sorted string fulfills that bound and hence it is the optimal answer "}
{"statement": "A string is called an of the string if it is possible to rearrange letters in so that it is identical to the string For example the string is an anagram of the string and the string is not The string is called a of the string if it can be read starting from some position in the string For example the string has six substrings You are given a string consisting of lowercase Latin letters and characters You are also given a string consisting of lowercase Latin letters only Let s assume that a string is if you can obtain an anagram of the string from it replacing the characters by Latin letters Each can be replaced by exactly one character of the Latin alphabet For example if the string then the string is good and the string is not Your task is to find the number of good substrings of the string identical substrings must be counted in the answer several times ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Let s count number of each letter in the second string and save it for example in array a 1 26 For the first strings prefix of length n where n is the length of second string it s the first substring we count number of each letter in array b 1 26 We don t count characters texttt If there are b i a i for all i then it s good substring Then go to the second substring subtract from the array b the first character b s 1 a 1 and add n 1 character b s n 1 a 1 If some of these characters is texttt then we shouldn t do for it the subtraction or addition Then repeat the showed check and go to the next substring Let s repeat this procedure for all substrings of length n "}
{"statement": "Kefa wants to celebrate his first big salary by going to restaurant However he needs company Kefa has friends each friend will agree to go to the restaurant if Kefa asks Each friend is characterized by the amount of money he has and the friendship factor in respect to Kefa The parrot doesn t want any friend to feel poor compared to somebody else in the company Kefa doesn t count A friend feels poor if in the company there is someone who has at least units of money more than he does Also Kefa wants the total friendship factor of the members of the company to be maximum Help him invite an optimal company ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "At first we sort all friends in money ascending order Now the answer is some array subsegment Next we use the method of two pointers for finding the required subsegment Asymptotics Solution "}
{"statement": "Let s define the function f of multiset a as the multiset of number of occurences of every number that is present in a E g f 5 5 1 2 5 2 3 3 9 5 1 1 2 2 4 Let s define f k a as applying f to array a k times f k a f f k 1 a f 0 a a E g f 2 5 5 1 2 5 2 3 3 9 5 1 2 2 You are given integers n k and you are asked how many different values the function f k a can have where a is arbitrary non empty array with numbers of size no more than n Print the answer modulo 998 244 353 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "The solution of the task consists of three cases k 1 For fixed n f a can be equal to any partition of n We need to count the number of arrays b1 b2 bm such that b1 b2 bm and i 1mbi n This can be done by simple dp in O n2 or even faster much faster k 2 When the array b1 b2 bm can be equal to value of f2 a for some a n When there exists some array c1 cl such that i 1lci n and f c b The values of b are the numbers of occurences of numbers in c so we need to minimize i 1mbivi where vi the unique numbers in c To minimize this sum we should take v1 1 vm m so we need i 1mbii n This can be done by simple dp dp val j sum the number of prefixes of b such that we already took j elements to b all elements on prefix are greater than or equal to val and the i 1jbii sum This dp can look like it is O n3 but it is actually O n2logn because there is a limitation val j n and there are O nlogn such pairs There is also a subquadratic solution k 3 We can notice that in the array f2 a there are at most O 2n elements We can use this fact to bruteforce all possible answers candidates for the answer are the partitions of numbers not exceeding 2n 64 there are few millions of them How to check if the array b1 b2 bm can be the falue of fk a It happens that we can make k 2 iterations of the unfolding algorithm from case k 2 and get the minimal possible array a and check if it contains no more than n elements This part works in O P 2n "}
{"statement": "One day the Grasshopper was jumping on the lawn and found a piece of paper with a string Grasshopper became interested what is the minimum he should have in order to be able to reach the far end of the string jumping only on vowels of the English alphabet is the maximum possible length of his jump Formally consider that at the begginning the Grasshopper is located directly in front of the leftmost character of the string His goal is to reach the position right after the rightmost character of the string In one jump the Grasshopper could jump to the right any distance from to the value of his The following letters are vowels and ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "In this problem you have to find the longest sequence of consonants The answer is its length 1 Iterate over each letter of string maintaining current number of consecutive consonants and length of longest sequence If current letter is consonant then increase by 1 otherwise update and set 1 Don t forget to update value after exiting loop as string can possibly end with consonant Time complexity length of the specified string "}
{"statement": "Suppose you are given two strings a and b You can apply the following operation any number of times choose any substring of a or b and sort the characters in it in non descending order Let f a b the minimum number of operations you have to apply in order to make them equal or f a b 1337 if it is impossible to make a and b equal using these operations For example f text ab text ab 0 f text ba text ab 1 in one operation we can sort the whole first string f text ebcda text ecdba 1 in one operation we can sort the substring of the second string starting from the 2 nd character and ending with the 4 th character f text a text b 1337 You are given n strings s 1 s 2 dots s k having equal length Calculate sum limits i 1 n sum limits j i 1 n f s i s j ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "Disclaimer the model solution is very complicated compared to most participants solutions Feel free to discuss your approaches in the comments First of all it s easy to determine when two strings cannot be made equal using these operations it s when their multisets of characters differ So we divide the strings into different equivalence classes and for any pair of strings from different classes the answer is For any pair of strings from the same class the answer is either or since operations are always enough to make the strings from the same equivalence class equal we just sort both of them Okay now for each class we have to calculate the number of pairs of strings with the distance equal to Okay suppose you have two strings and and you want to make them equal using one operation Suppose that lexicographically Since applying an operation can t result in getting a lexicographically larger string we should apply the operation on the string not Suppose we choose a substring of the string and sort it All characters to the left of position and to the right of position are untouched and all characters in are ordered in non descending order so in order to transform into we should choose a subsegment such that all characters outside this segment are the same in both strings and the substring of is sorted So the best way to choose a subsegment is to compute the longest common prefix of and the longest common suffix of and and try sorting everything in the middle in This gives us a solution in for a pair of strings we can check that one of them can be transformed into the other in To do so we need to build some data structure allowing to query longest common prefixes suffixes in a trie with LCA or precalculating LCP and building a sparse table of them can do the trick furthermore we want to be able to check if some subsegment of some string is sorted in but precalculating them is quite easy So we have a solution that works if the strings are long in the model solution this approach is used on classes having not more than strings The second approach can be used on classes having many strings If the number of strings is big it means that they are short so we can do the following thing for each string iterate on the subsegment we will sort and check if the resulting string exists The model solution uses some very complicated data structures to implement this but I believe that it s quite easy to get this approach working using string hashes The only dangerous thing in the second solution you have to consider is that choosing different substrings to sort may result in getting the same resulting string One good way to deal with this is to ignore some substrings if sorting them doesn t change the leftmost or the rightmost character in the substring for example if we sort the substring in the string the character in the beginning of this substring is unchanged so we can get the same result by sorting So we consider sorting the substring only if it changes both the first and the last characters of the substring Okay so we have two approaches one works well with a small number of long strings and the other works well with a big number of short strings We can choose which of them to run depending on the size of the equivalence class we are considering and this idea gives us a working solution "}
{"statement": "You have a sequence a 1 a 2 ldots a n of length n each element of which is either 0 or 1 and a sequence b which is initially empty You are going to perform n operations On each of them you will increase the length of b by 1 On the i th operation you choose an integer p between 0 and i 1 You insert 0 in the sequence b on position p 1 after the first p elements and then you invert the first p elements of b More formally let s denote the sequence b before the i th 1 le i le n operation as b 1 b 2 ldots b i 1 On the i th operation you choose an integer p between 0 and i 1 and replace b with overline b 1 overline b 2 ldots overline b p 0 b p 1 b p 2 ldots b i 1 Here overline x denotes the binary inversion Hence overline 0 1 and overline 1 0 You can find examples of operations in the Notes section Determine if there exists a sequence of operations that makes b equal to a If such sequence of operations exists find it ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "It s easy to see that last element of is always zero so if is then the answer is It turns out that if is then answer is always First let s try to get equal to array of form for some Further in the editorial I will call such arrays We can insert zero before the first element times and then insert zero after the last element inverting all previously inserted zeroes into ones To get arbitrary with you can notice that such array can always be divided into arrays For example array can be divided into Also it s easy to see that if you can get array with sequence of operation and array with sequence of operations then you can get concatenation of arrays and by first performing all the operations from and then performing all the operations from So the solution is as follows If is output Otherwise divide array into simple arrays of lengths Then you can get with sequence of operations "}
{"statement": "You are given n points on the x axis at increasing positive integer coordinates x 1 x 2 ldots x n For each pair i j with 1 leq i j leq n you draw the segment x i x j The segments are closed i e a segment a b contains the points a a 1 ldots b You are given q queries In the i th query you are given a positive integer k i and you have to determine how many points with integer coordinates are contained in exactly k i segments ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "SolutionFirst let s focus on determining how many intervals contain some point These intervals are the ones with and So a point satisfies and It means that you have found points contained in exactly intervals because there are possible left endpoints and possible right endpoints Similarly the point is contained in intervals you have to remove interval which you do not draw So you can use a map that stores how many points are contained in exactly intervals and update the map in the positions and Complexity "}
{"statement": "Once when Gerald studied in the first year at school his teacher gave the class the following homework She offered the students a string consisting of small Latin letters the task was to learn the way the letters that the string contains are written However as Gerald is too lazy he has no desire whatsoever to learn those letters That s why he decided to lose some part of the string not necessarily a connected part The lost part can consist of any number of segments of any length at any distance from each other However Gerald knows that if he loses more than characters it will be very suspicious Find the least number of distinct characters that can remain in the string after no more than characters are deleted You also have to find any possible way to delete the characters ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Lets count up the number of entries to string of every letter Let Gerald choose x letter and lose them Obvious thet if he lose x rarest letters then overall number of losed letter do not increase and then if he can lose some x lettes he can lose x rarest ones Thus it s easy to determine if Gerald can loses x letters And now to calculate the answer one only need to find the minimal such x so Gerald can lose x letters "}
{"statement": "Recently Luba bought a monitor Monitor is a rectangular matrix of size But then she started to notice that some pixels cease to work properly Luba thinks that the monitor will become broken the first moment when it contains a square consisting entirely of broken pixels She knows that pixels are already broken and for each of them she knows the moment when it stopped working Help Luba to determine when the monitor became broken or tell that it s still not broken even after all pixels stopped working ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "At first let s sort broken pixels in non descending order by times they appear Obviously if the first broken pixels make monitor broken pixel won t fix it Thus binary search on answer will work Let s search for the first moment in time when the monitor becomes broken The function to check if in some moment monitor is broken looks the following way As we want to check if there is a submatrix of size which consists only of broken pixels let s precalc the array of partial sums is the number of broken pixels on submatrix from to is calculated as if is broken pixel otherwise Sum on submatrix of size then looks like Check all possible and from to and find out if there exists submatrix with sum equal to Overall complexity "}
{"statement": "Let s call an array a consisting of n positive greater than 0 integers if the following condition is held for every i from 1 to n either a i 1 or at least one of the numbers a i 1 and a i 2 exists in the array as well For example the array 5 3 1 is beautiful for a 1 the number a 1 2 3 exists in the array for a 2 the number a 2 2 1 exists in the array for a 3 the condition a 3 1 holds the array 1 2 2 2 2 is beautiful for a 1 the condition a 1 1 holds for every other number a i the number a i 1 1 exists in the array the array 1 4 is not beautiful for a 2 neither a 2 2 2 nor a 2 1 3 exists in the array and a 2 ne 1 the array 2 is not beautiful for a 1 neither a 1 1 1 nor a 1 2 0 exists in the array and a 1 ne 1 the array 2 1 3 is beautiful for a 1 the number a 1 1 1 exists in the array for a 2 the condition a 2 1 holds for a 3 the number a 3 2 1 exists in the array You are given a positive integer s Find the minimum possible size of a beautiful array with the sum of elements equal to s ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The maximum sum we can construct with elements is so we need at least elements to construct the sum equal to Let s show how to express with exactly elements Let By taking we achieve a sum of using elements is not less than and not greater than since and Thus we can just add to our array and the sum becomes exactly So the solution is to find the minimum such that "}
{"statement": "Iahub isn t well prepared on geometry problems but he heard that this year there will be a lot of geometry problems on the IOI selection camp Scared Iahub locked himself in the basement and started thinking of new problems of this kind One of them is the following Iahub wants to draw distinct segments on the axis He can draw each segment with either red or blue The drawing is good if and only if the following requirement is met for each point of the axis consider all the segments that contains point suppose that red segments and blue segments contain point for each point inequality must be satisfied A segment contains a point if and only if Iahub gives you the starting and ending points of all the segments You have to find any good drawing for him ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3000", "problem_editorial": "The problem asks you to check the property for an infinity of points Obviously we can t do that However we can observe that some contiguous ranges on OX axis have the same rx and bx values Like a sweep line algorithm a possible change may appear only when a new segment begins or when an old one ends So let s consider set of points formed by all li reunited with set of points formed by all ri Sort the values increasing Suppose the set looks like x1 x2 xk Then ranges 0 x1 x1 x2 xk 1 xk xk infinity are the only ones that need to be considered If we can take an arbitrary point from each range and the property is respected for all points then the drawing is good We need to color segments But each segment is a reunion of ranges like the ones from above When you color a segment all ranges from it will be colored too So after coloring the segments for each range number of times range was colored with blue number of times range was colored with red 1 It s time to think creative We can see ranges as vertexes of a graph and segments as edges For example if a segment is formed by ranges Xi Xi 1 Xj 1 Xj we add an undirected edge from i to j 1 We need to color the edges We divide the graph into connected components and apply same logic for each component Next by graph I ll refer to a connected graph Let s assume that our graph has all degrees even Then it admits an eulerian cycle Suppose x1 x2 xk is the list of nodes from the cycle such as x1 x2 x2 x3 xk x1 are the edges of it in this order We apply a rule if xi xi 1 we color edge between xi and xi 1 in red Otherwise we color it in blue What happens for a node Whenever a red edge crosses it for example edge 1 5 crosses node 4 a blue edge will always exist to cross it again for example edge 6 2 crosses node 4 This is because of property of euler cycle suppose we started from a node x and gone in left We need to return to it but the only way to do it is an edge which goes to right So when degrees of graph are all even for every point on OX axis difference between rx and bx will be always 0 Let s solve the general case now Some nodes have odd degree But there will always be an even number of nodes with odd degrees Why Suppose the property is respected for some edges added so far and now we add a new one There are two cases 1 the edge connects two nodes with odd degree in this case the number of nodes with odd degrees decreases by 2 but its parity does not change 2 the edge connects one node with odd degree and one node with even degree Now degree of old odd one becomes even and degree of old even one becomes odd So number of nodes with odd degrees does not change So suppose the nodes with odd degrees are X1 X2 Xk k is even Assume X1 X2 Xk If we add one more edge to each of these nodes an euler cycle would be possible However we can t add edges because edges are segments from the input But we can imagine them Of course this we ll create an imbalance between red and blue edges but let s see how big it is What if we add a fictive edge between X1 to X2 between X3 to X4 between X k 1 to Xk In this way all those nodes will have even degree So for each Xi i odd we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi 1 Now let s see the effect if the fictive edges existed the balance would be 0 But they do not exist so one of rx or bx will decrease So now rx bx 1 good enough for problem s restrictions "}
{"statement": "The football season has just ended in Berland According to the rules of Berland football each match is played between two teams The result of each match is either a draw or a victory of one of the playing teams If a team wins the match it gets w points and the opposing team gets 0 points If the game results in a draw both teams get d points The manager of the Berland capital team wants to summarize the results of the season but unfortunately all information about the results of each match is lost The manager only knows that the team has played n games and got p points for them You have to determine three integers x y and z the number of wins draws and loses of the team If there are multiple answers print any of them If there is no suitable triple x y z report about it ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "The crucial observation is that wins give us the same amount of points as draws Let s use them to solve a problem where we want to minimize the total amount of wins and draws giving points if it is not greater than we can just lose all other matches If then we can subtract from and add to the number of wins and draws will decrease and the number of points will stay the same So we can limit the number of draws to And the solution is the following iterate on the number of draws from to and check if the current value of gives us the result we need should be non negative and divisible by and should be not greater than "}
{"statement": "We start with a string s consisting only of the digits 1 2 or 3 The length of s is denoted by s For each i from 1 to s the i th character of s is denoted by s i There is one cursor The cursor s location ell is denoted by an integer in 0 ldots s with the following meaning If ell 0 then the cursor is located before the first character of s If ell s then the cursor is located right after the last character of s If 0 ell s then the cursor is located between s ell and s ell 1 We denote by s text left the string to the left of the cursor and s text right the string to the right of the cursor We also have a string c which we call our which starts out as empty There are three types of actions Move the cursor one step to the right This increments ell once Set c leftarrow s text right then set s leftarrow s text left Append the value of c to the end of the string s Note that this doesn t modify c The cursor initially starts at ell 0 Then we perform the following procedure Perform the Move action once Perform the Cut action once Perform the Paste action s ell times If ell x stop Otherwise return to step 1 You re given the initial string s and the integer x What is the length of s when the procedure stops Since this value may be very large only find it modulo 10 9 7 It is guaranteed that ell le s at any time ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let St be the string S after the t th round and let S0 be the initial S We also denote by Si the suffix of S from the i th character Si onwards A single round turns St 1 into St by replicating the suffix St 1t 1 exactly St times Hence we have the recurrence St St 1 St 1t 1 St 1t 1 where represents concatenation and s n represents replicating s n times Note that St 1t is interpreted as an integer In terms of lengths we have St St 1 St 1t 1 St 1t 1 Since Si 1 S i this is equivalent to St St 1 St 1 t St 1t 1 This cannot be simulated yet as it is since the length of S could be growing very quickly But notice that St 1 is always a prefix of St Therefore for any two t1 and t2 the i th letters of St1 and St2 are the same as long as their lengths are at least i Also note that we only need to access up to the x th character Sx Therefore we only need to grow S just enough until it contains at least x characters After that we can stop modifying S at that point and simply keep track of the length maintaining it using the recurrence above The running time is O S x But in languages where strings are immutable you should use a dynamically resizing list instead of appending strings repeatedly otherwise you ll get a running time of O x2 "}
{"statement": "The Easter Rabbit laid eggs in a circle and is about to paint them Each egg should be painted one color out of 7 red orange yellow green blue indigo or violet Also the following conditions should be satisfied Each of the seven colors should be used to paint at least one egg Any four eggs should be painted different colors Help the Easter Rabbit paint the eggs in the required manner We know that it is always possible ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "At first you can n 7 times output string ROYGBIV is a rounding down After than you can output G GB YGB YGBI OYGBI or OYGBIV according to remainder of division n by 7 A resulting string will satisfy problem s requirements "}
{"statement": "You are given table Each cell of the table is colored white or black Find the number of non empty sets of cells such that All cells in a set have the same color Every two cells in a set share row or column ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "One could note that each appropriate set of cells is always contained in one row or in one column We should calculate numbers of white and black cells and in every row and every column For every we will summarize the number of non empty subsets of this color contained in one row column In the end we subtract from the whole sum this is a number of one cell sets which we count twice Solution complexity is "}
{"statement": "You are given three integers n a b Determine if there exists a permutation p 1 p 2 ldots p n of integers from 1 to n such that There are exactly a integers i with 2 le i le n 1 such that p i 1 p i p i 1 in other words there are exactly a local maximums There are exactly b integers i with 2 le i le n 1 such that p i 1 p i p i 1 in other words there are exactly b local minimums If such permutations exist find any such permutation ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "First answer does not exists if Second answer exists if and only if It happens because between every two consecutive local maximums must be exactly one local minimum And vice versa between two consecutive minimums must be exactly one maximum First case gives second both in total gives Lets build answer considering Otherwise we can build inverse answer swap and and perform replace Lets take biggest numbers i e from downto and put them consequentially such numbers on first position and on each second position from first are less then other numbers It gives that every number except first and last are local maximum or local minimum Rest of the numbers needed to be placed before this sequence in increasing order "}
{"statement": "There is a grid consisting of n rows and m columns The rows are numbered from 1 to n from bottom to top The columns are numbered from 1 to m from left to right The i th column has the bottom a i cells blocked the cells in rows 1 2 dots a i the remaining n a i cells are unblocked A robot is travelling across this grid You can send it commands move up right down or left If a robot attempts to move into a blocked cell or outside the grid it explodes However the robot is broken it executes each received command k times So if you tell it to move up for example it will move up k times k cells You can t send it commands while the robot executes the current one You are asked q queries about the robot Each query has a start cell a finish cell and a value k Can you send the robot an arbitrary number of commands possibly zero so that it reaches the finish cell from the start cell given that it executes each command k times The robot must stop in the finish cell If it visits the finish cell while still executing commands it doesn t count ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "What if there were no blocked cells Then the movement is easy From cell we can go to cells or Thus we can visit all cells that have the same remainder modulo over both dimensions The answer would be if and Let s choose the following path from start to finish Let be less or equal to If that isn t the case swap the cells First move up until the row is the same then move to the side until the column is the same What stops us from doing the same on a grid with blocked cells The first part of the part can remain the same we can always move up from the cell Only cells below the start cell can be blocked The second part is trickier If there is a column with too many blocked cells between the start and the finish column then we won t be able to pass through it Let s adjust the path for that Move up as high as possible to the highest cell with the same remainder modulo in this column Then move to the finish column and go down to the finish cell If there still exists a column with too many blocked cells then the answer is No matter what we do we won t be able to go around that column Otherwise the answer is Thus the solution is to check for remainders then find the largest number of blocked cells between the query columns and compare it to the highest row with the same remainder modulo as the start or the finish You can use any RMQ data structure you want Overall complexity with sparse table for RMQ for example "}
{"statement": "Initially there was an array a consisting of n integers Positions in it are numbered from 1 to n Exactly q queries were performed on the array During the i th query some segment l i r i 1 le l i le r i le n was selected and values of elements on positions from l i to r i inclusive got changed to i The order of the queries couldn t be changed and all q queries were applied It is also known that every position from 1 to n got covered by at least one segment We could have offered you the problem about checking if some given array consisting of n integers with values from 1 to q can be obtained by the aforementioned queries However we decided that it will come too easy for you So the enhancement we introduced to it is the following Some set of positions possibly empty in this array is selected and values of elements on these positions are set to 0 Your task is to check if this array can be obtained by the aforementioned queries Also if it can be obtained then restore this array If there are multiple possible arrays then print any of them ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s firstly solve the problem as if there are no zeroes in the given array Let be the leftmost occurrence of in the array and be the rightmost occurrence of The main observation is that you can choose segments for the corresponding queries and this sequence will be correct if and only if there exists any answer for the given array If there is no occurrence of some value in the array then you can put the segment for it under the segment of some greater value If there is no occurrence of in the array then the answer doesn t exist For sure segment is the minimum segment you can choose You can expand it in both directions but it will never matter these positions either will get covered by the segments of greater values or will replace the smaller values with and turn to if the answer existed Finally each position will be covered as each element is a left bound of a segment a right bound of a segment or just covered by the segment of its value That problem can be solved with any data structure that allows you to assign values on segment and get the value of every position segment tree sqrt decomposition However all the queries are performed offline the resulting values are only needed after the queries and the operation can be replaced with assigning maximum of the current value of element and the value of the query This can also be done using set For each position you should keep the segments which start there and end there For each segment you push to the list for and push to the list for Now you iterate from to when entering you add all values of opening segments to the set assign the element at position the maximum value of the set and remove all the values of closing segments from the set The complexity of this algorithm is This algorithm can be easily applied to the problem with zeroes in the array At the beginning you fill the resulting array with ones After you performed the algorithm with set on the values from to while constructing the segments from the non zero elements of the given array you check if the values you assigned are less or equal than the corresponding values of the given array If that holds then the resulting array is already the correct one Otherwise the answer doesn t exist The only corner case there is if no value was in array and there were some zeroes That way you should just change any zero to Overall complexity "}
{"statement": "You have an array a 1 a 2 dots a n Let s call some subarray a l a l 1 dots a r of this array a if it contains all integers from 1 to r l 1 exactly once For example array a 2 2 1 3 2 3 1 contains 6 subarrays which are subpermutations a 2 dots a 3 a 2 dots a 4 a 3 dots a 3 a 3 dots a 5 a 5 dots a 7 a 7 dots a 7 You are asked to calculate the number of subpermutations ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "At first let s represent permutations in the next form We assign to all numbers from to random 128 bit strings so the th number gets the string Then the permutation of length can be hashed as where is bitwise exclusive OR for example This representation is convenient because if we have two sets of numbers with a total number of elements equal to let s represent them as and we can easily check whether their union is a permutation of length condition must be hold Let s denote as Now let s iterate over position such that and calculate the number of permutations that contain this element To do it let s iterate over the right boundary and suppose that maximum element of permutation and its length at the same time is one of positions If it s true then the subpermutation should be on the positions And to check that this segment is a subpermutation we should just compare and Thus we will calculate all permutations in which the position of the maximum is to the right of the position of the To calculate all permutations we need to reverse array and repeat this algorithm and then add the number of ones in the array "}
{"statement": "Amr bought a new video game Guess Your Way Out II The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node Let s index all the nodes of the tree such that The root is number Each internal node will have a left child with index and a right child with index The level of a node is defined as for a root or level of parent of the node otherwise The vertices of the level are called leaves The exit to the maze is located at some leaf node the player doesn t know where the exit is so he has to guess his way out In the new version of the game the player is allowed to ask questions on the format Does the node number belong to the range Here is the ancestor of a node that located in the level The game will answer with Yes or No only The game is designed such that it doesn t always answer correctly and sometimes it cheats to confuse the player Amr asked a lot of questions and got confused by all these answers so he asked you to help him Given the questions and its answers can you identify whether the game is telling contradictory information or not If the information is not contradictory and the exit node can be determined uniquely output its number If the information is not contradictory but the exit node isn t defined uniquely output that the number of questions is not sufficient Otherwise output that the information is contradictory ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "First each query in the level from to can be transmitted into level from to so we can transform each query to the last level Let s maintain a set of correct ranges such that the answer is contained in one of them At the beginning we will assume that the answer is in the range inclusive Now Let s process the queries If the query s answer is yes then we want to get the intersection of this query s range with the current set of correct ranges and update the set with the resulting set If the query s answer is no we want to exclude the query s range from the current set of correct ranges and update the set with the resulting set After we finish processing the queries if the set of correct ranges is empty then clearly the game cheated Else if the set has only one correct range such that then we ve got an answer Otherwise there are multiple exit candidates and the answer can t be determined uniquely using the current data We will have to use stl set data structure to make updating the ranges faster In each yes query we delete zero or more ranges In each no query we may add one range if we split a correct range so worst case will be linear in queries count Time complexity Implementation "}
{"statement": "Alice and Bob play a game There is a paper strip which is divided into cells numbered from left to right starting from There is a chip placed in the th cell the last one Players take turns Alice is first Each player during his or her turn has to move the chip or cells to the left so if the chip is currently in the cell the player can move it into cell or The chip should not leave the borders of the paper strip it is impossible for example to move it cells to the left if the current cell has number The player who can t make a move loses the game Who wins if both participants play optimally Alice and Bob would like to play several games so you should determine the winner in each game ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s determine for each cell whether it s winning or losing position we can do it since the game is symmetric and doesn t depend on a player The th cell is obviously losing the st and nd ones is both winning since we can move to the th cell and put our opponent in the losing position here comes criterion the position is winning if and only if there is a move to the losing position If is large enough then the th rd th th are losing So here comes divisibility by If then this move doesn t change anything since if then so it s not the move to the losing position so doesn t become the winning one Otherwise if then the th positions becomes winning but the th cell is losing all moves are to th th or st cells and all of them are winning The th and th cells are winning and so on In the end we came up with cycle of length where position divisible by except are losing All we need to do is small case work "}
{"statement": "You are an adventurer currently journeying inside an evil temple After defeating a couple of weak monsters you arrived at a square room consisting of tiles forming an grid surrounded entirely by walls At the end of the room lies a door locked with evil magical forces The following inscriptions are written on the door Being a very senior adventurer you immediately realize what this means In the room next door lies an infinite number of magical rocks There are four types of rocks this rock moves upwards this rock moves leftwards this rock moves rightwards this rock moves downwards To open the door you first need to place the rocks on some of the tiles one tile can be occupied by at most one rock Then you select a single rock that you have placed and activate it The activated rock will then move in its direction until it hits another rock or hits the walls of the room the rock will not move if something already blocks it in its chosen direction The rock then deactivates If it hits the walls or if there have been already events of rock becoming activated the movements end Otherwise the rock that was hit becomes activated and this procedure is repeated If a rock moves at least one cell before hitting either the wall or another rock the hit produces a sound The door will open once the number of produced sounds is at least It is okay for the rocks to continue moving after producing sounds The following picture illustrates the four possible scenarios of moving rocks Moves at least one cell then hits another rock A sound is produced the hit rock becomes activated Moves at least one cell then hits the wall i e the side of the room A sound is produced the movements end Does not move because a rock is already standing in the path The blocking rock becomes activated but no sounds are produced Does not move because the wall is in the way No sounds are produced and the movements end Assume there s an infinite number of rocks of each type in the neighboring room You know what to do place the rocks and open the door ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Post your solution in the comment Here s mine for the last case approximately 120 000 sounds You can get the number of sounds your solution produces when submitting it to the server I wonder if there s a solution with 150 000 sounds or more the theoretical upper bound is 100 3 something so it may be feasible "}
{"statement": "Fox Ciel has a board with rows and columns So the board consists of cells Each cell contains either a symbol or a symbol A cross on the board is a connected set of exactly five cells of the board that looks like a cross The picture below shows how it looks Ciel wants to draw several may be zero crosses on the board Each cross must cover exactly five cells with symbols and any cell with symbol must belong to some cross No two crosses can share a cell Please tell Ciel if she can draw the crosses in the described way ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s define the first of a shape is the cell contain that have the lexicographical smallest coordinate Then the first of a cross is the top one Then let x be the first of the given board If the board is empty then we can draw it with zero crosses x must be covered by a cross and x must be the first of the cross You can try 4 other positions it will cause a lexicographical smaller in the board than x So we try to cover this x use one cross if it leads some part of the cross covers a then there will be no solution If not we just reduce the number of in the board by 4 we can do this again and again "}
{"statement": "You are given a rooted tree with vertices The vertices are numbered from to the root is the vertex number Each vertex has a color let s denote the color of vertex by Initially You have to color the tree into the given colors using the smallest possible number of steps On each step you can choose a vertex and a color and then color all vectices in the subtree of including itself in color In other words for every vertex such that the path from root to passes through set It is guaranteed that you have to color each vertex in a color different from You can learn what a rooted tree is using the link https en wikipedia org wiki Tree graph theory ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Consider the process from the end we will delete any subtree from the tree whose color of the ancestor of the highest vertex differs from the color of the highest vertex and the colors of all vertices in the subtree are the same Thus we can show that the answer is the number of edges whose ends have different colors 1 "}
{"statement": "Polo the Penguin have two positive integers and both of them are lucky numbers Moreover their lengths that is the number of digits in the decimal representation without the leading zeroes are equal to each other Let s assume that is the number of distinct lucky numbers each of them cannot be greater than or less than and is the th in increasing order number of them Find As the answer can be rather large print the remainder after dividing it by ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Solution In this problem there are a lot of different formulas most of them are for optimizing solution and making it lenear Editorial shows just a general idea because it s pretty hard to explain all of them and good for you to derive it by yourself If you have any questions write them all in comments Denote by a1 a2 an all lucky number from segment First of all we need to do reduce the problem a bit Let we have some fixed digit pos d i e position of this digit is pos from 0 from right to left and value is d 4 or 7 Then for all ai 1 i n such that pos th digit of ai is equal to d we need to add ai 1 d 10pos to the answer Now we can see that problem can be reduced to the following For each fixed digit pos d find the sum of all ai such that ai 1 on the pos th position has digit d Obviously we can solve the problem for 1 l and 1 r separately and then subtract the first from the second that will be the answer How to find such sum among all lucky numbers of some length but less than some lucky number x We will describe the general idea Any lucky number less than x has some common prefix with x then one digit is less than the corresponing in x i e it is 7 in x and 4 in another integer and the rest of the digits are arbitrary So by iterating all such positions where is the first digit less than in x we can using the fact that the rest of the digits are arbitrary and some formulas and precomputations compute the results for each position and digit "}
{"statement": "You are given an integer sequence 1 2 dots n You have to divide it into two sets A and B in such a way that each element belongs to set and sum A sum B is minimum possible The value x is the absolute value of x and sum S is the sum of elements of the set S ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The first solution take modulo and solve the problem manually then for cases and the answer is and for and the answer is Prove Let s see what can we make for numbers and We can add and in and add and in Then the difference between sums will be We can consider last four numbers this way until we have at least four numbers And then we have a case We can prove the solution for these four cases using bruteforce The second solution if is even then the answer is otherwise the answer is The formula above is just Prove if we have an integer sequence then we can obtain every number from to as the sum of some elements of this sequence How Greedily You can see how this greedy works and prove if you want yourself So what s next If is even then we can obtain the sum in and in Otherwise we can only obtain in and in or vice versa "}
{"statement": "Wilbur the pig really wants to be a beaver so he decided today to pretend he is a beaver and bite at trees to cut them down There are trees located at various positions on a line Tree is located at position All the given positions of the trees are distinct The trees are equal i e each tree has height Due to the wind when a tree is cut down it either falls left with probability or falls right with probability If a tree hits another tree while falling that tree will fall in the same direction as the tree that hit it A tree can hit another tree only if the distance between them is strictly less than For example imagine there are trees located at positions and while and the tree at position falls right It hits the tree at position and it starts to fall too In it s turn it hits the tree at position and it also starts to fall The distance between and is exactly so the tree at position will not fall As long as there are still trees standing Wilbur will select either the leftmost standing tree with probability or the rightmost standing tree with probability Selected tree is then cut down If there is only one tree remaining Wilbur always selects it As the ground is covered with grass Wilbur wants to know the expected total length of the ground covered with fallen trees after he cuts them all down because he is concerned about his grass eating cow friends Please help Wilbur ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Let us solve this problem using dynamic programming First let us reindex the trees by sorting them by coordinate Let where we would like to consider the problem of if we only have trees standing where indicates that tree falls right and if it falls left and indicates that tree falls right and if it falls left We start with the case that Wilbur chooses the left tree and it falls right The plan is to calculate the expected length in this scenario and multiply by the chance of this case occurring which is We can easily calculate what is the farthest right tree that falls as a result of this and call it Then if this means the entire segment falls from which the length of the ground covered by trees in can be calculated However be careful when as there may be overlapping covered regions when the tree falls right but the tree falls left If only then we just consider adding the length of ground covered by trees falling right and add to the value of the subproblem There is another interesting case where Wilbur chooses the left tree and it falls left In this case we calculate the expected length and multiply by the chance of this occurring which is The expected length of ground covered by the trees here is just the length contributed by tree falling left which we must be careful calculating as there might be overlapping covered regions with the th tree falling left and the th tree falling right Then we also add the value of subproblem Doing this naively would take time but this can be lowered to by precalculating what happens when tree falls left or right We should also consider the cases that Wilbur chooses the right tree but these cases are analogous by symmetry Complexity Code Solution Solution 1 Suppose that is a string in the query Reverse and the direction of all the moves that can be made on the table Note that starting at any point that is part of a cycle there is a loop and then edges that go out of the loop So for every point it can be checked by dfs whether the can be made by starting at that point by storing what is in the cycle Moreover note that in the reversed graph each point can only be a part of one cycle Therefore the total time for the dfs in a query is This is good enough for queries to run in time Complexity where is the number of distinct characters in the table and is the query string for the th query Code Solution Solution 2 Actually too slow see comment by waterfalls below for more details For each string dfs from every node that has in degree equal to in the original graph There will be a path which leads into a cycle after which anything in the cycle can be used any number of times in Only every node with in degree equal to has to be checked because every path which leads to a cycle is part of a larger path which starts with a vertex of in degree that leads into a cycle This solution is slower but it works in practice since it is really hard for a string to match so many times in the table Each query will take time but it is much faster in practice Complexity where is the number of distinct characters in the table and is the query string of the th query "}
{"statement": "Cirno is playing a war simulator game with n towers numbered from 1 to n and n bots numbered from 1 to n The i th tower is initially occupied by the i th bot for 1 le i le n Before the game Cirno first chooses a permutation p p 1 p 2 ldots p n of length n A permutation of length n is an array of length n where each integer between 1 and n appears exactly once After that she can choose a sequence a a 1 a 2 ldots a n 1 le a i le n and a i ne i for all 1 le i le n The game has n rounds of attacks In the i th round if the p i th bot is still in the game it will begin its attack and as the result the a p i th tower becomes occupied by the p i th bot the bot that previously occupied the a p i th tower will no longer occupy it If the p i th bot is not in the game nothing will happen in this round After each round if a bot doesn t occupy any towers it will be eliminated and leave the game Please note that no tower can be occupied by more than one bot but one bot can occupy more than one tower during the game At the end of the game Cirno will record the result as a sequence b b 1 b 2 ldots b n where b i is the number of the bot that occupies the i th tower at the end of the game However as a mathematics master she wants you to solve the following counting problem instead of playing games Count the number of different pairs of sequences a b from all possible choices of sequence a and permutation p Calculate the answers for all n such that 1 le n le k Since these numbers may be large output them modulo M ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "Given The conclusion of possible array remains If we fix array we will find that for each will only be that or For any pair if we will find that and at the same time is impossible All arrays which satisfies the above conditions are valid So for a fixed array and we fix the position that It can be shown that the chosen nodes form a independent set then the number of possible will be product of each in degree of each that Now we can see if we build a graph according to the answer will be the sume of product over all independent sets We need to solve the problem of three parts the nodes form a tree some trees roots form a ring some trees based on rings form a graph For the tree part let be generating function of the sum of pruducts if the root is not included in the independent set and otherwise Then we have We can solve the equation and use Newton s method to calculate and Consider how to merge trees together If one root is not in the independent set It can either be occupied by one of its children or the previous node on the ring so its generating function can be represented as compared with it adds the contribution caused by that it s occupied by the previous node on the ring which is easy to calculate For those which are in the independent set their previous nodes must not be in So we binding them together and their generating functions can be represented as The final answer is Note that when every node on the ring is occupied by previous node it is also impossible So we need to minus this answer It can be calculated with similar method At last we need to combine these rings into a graph which can be done with operation Time complexity is "}
{"statement": "A girl is preparing for her birthday and wants to buy the most beautiful bouquet There are a total of n flowers in the store each of which is characterized by the number of petals and a flower with k petals costs k coins The girl has decided that the difference in the number of petals between any two flowers she will use in her bouquet should not exceed one At the same time the girl wants to assemble a bouquet with the maximum possible number of petals Unfortunately she only has m coins and she cannot spend more What is the maximum total number of petals she can assemble in the bouquet ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "SolutionFirst we can aggregate number of flowers with petals into for example sort the array and then create array of pairs where is the length of segment with elements equal to Note that Also note that for every we won t need more than flowers otherwise total number of petals will exceed Then we iterate through all Suppose that we want to assemble a bouquet with petals We can bruteforce the amount of flowers with petals in If we have flowers with petals we already have petals There are still coins which we can spend for flowers with petals There are at most flowers with petal we can buy So we need to find maximum over all such Total complexity is for finding the maximum and for sorting "}
{"statement": "You are an adventurer currently journeying inside an evil temple After defeating a couple of weak zombies you arrived at a square room consisting of tiles forming an grid The rows are numbered through from top to bottom and the columns are numbered through from left to right At the far side of the room lies a door locked with evil magical forces The following inscriptions are written on the door Being a very senior adventurer you immediately realize what this means You notice that every single cell in the grid are initially evil You should purify all of these cells The only method of tile purification known to you is by casting the Purification spell You cast this spell on a single tile then all cells that are located in the same row and all cells that are located in the same column as the selected tile become purified including the selected tile It is allowed to purify a cell more than once You would like to purify all cells while minimizing the number of times you cast the Purification spell This sounds very easy but you just noticed that some tiles are particularly more evil than the other tiles You cannot cast the Purification spell on those particularly more evil tiles not even after they have been purified They can still be purified if a cell sharing the same row or the same column gets selected by the Purification spell Please find some way to purify all the cells with the minimum number of spells cast Print 1 if there is no such way ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Obviously the minimum possible answer is n why But is it always possible to purify all the cells with n spells If there exist a row consisting of entirely E cells and a column consisting of entirely E cells then the answer is 1 This is since the cell with that row and that column cannot be purifed Otherwise without loss of generality let s suppose there is no row consisting entirely of E Then for each row find any cell Purify it The case with no column consisting entirely of E is similar "}
{"statement": "Artem wrote the digit d on the board exactly n times in a row So he got the number dddddd dots ddd exactly n digits Now he is curious about which digits from 1 to 9 divide the number written on the board ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "There are several ways to solve this problem I will describe two of them We can try divisibility rules for all odd integers from to and find out whether they work for our numbers is always the answer since every integer is divisible by a number is divisible by iff its sum of digits is divisible by Since our number consists of digits then either or should be divisible by so or a number is divisible by iff its sum of digits is divisible by This is a bit trickier than the case with because it is possible that both and are divisible by not and it makes the sum of digits divisible by a number is divisible by iff its last digit is or Just check that and that s it probably the trickiest case a number is divisible by iff when this number is split into blocks of digits possibly with the first block shorter than digits the sign alternating sum of these blocks is divisible by Like is divisible by because is divisible by If we apply this rule to our numbers from the problem we can use the fact that when the number can be split into several blocks of length and each such block changes the alternating sum by So if or our number is divisible by First we actually need a little bit of math If you take a number consisting of digits equal to it is always divisible by digits equal to This is because if you write some integer repeatedly the resulting number will be divisible by the original number like for example is divisible by So if for some the number is divisible by some digit then for the number will also be divisible for some digit This means that there exists an integer such that for all integers the results are the same if you use the same digit So we can set and if is small enough use brute force What is the value of The samples tell us that the number consisting of ones is divisible by and and divisibility by depends only on so you can actually use It is also possible to reduce to but this is not required So the solution is reduce to something like if it is greater than then use brute force You can either calculate the remainder of a big number modulo small number using a for loop or if you code in Java or Python use built in big integers just be careful with Python modern versions of it forbid some operations with integers longer than digits you might need to override that behavior "}
{"statement": "There are boys and girls attending a theatre club To set a play The Big Bang Theory they need to choose a group containing exactly actors containing no less than 4 boys and no less than one girl How many ways are there to choose a group Of course the variants that only differ in the composition of the troupe are considered different Perform all calculations in the 64 bit type for for Delphi and for Java ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Since the constraints are small let s just iterate through all possible numbers b of boys in the group and count how many ways we can form the group with b boys First consider only the values where b 4 Given b it s clear that the number of girls in the group must be g t b If g 1 don t consider this case Given the values of b and g there are n b m g ways to form the group since we can combine the boys independently the girls Just sum n b m g for each pair b g Again use 64 bits types to do the math One could precompute all the values of i j using the Pascal triangle but one could also compute it with the traditional formula if its implementation takes care of possible overflow 30 doesn t fit in 64 bit integer type "}
{"statement": "Monocarp is a team leader in a massive IT company There are m projects his team of programmers has to complete numbered from 1 to m The i th project has a difficulty level b i There are n programmers in the team numbered from 1 to n The j th programmer has a stress tolerance level a j Monocarp wants to assign the programmers to the projects in such a way that each programmer is assigned to no more than one project each project has at least one programmer assigned to it let k programmers be assigned to the i th project then all the assigned programmers have to have a stress tolerance level greater than or equal to frac b i k Help Monocarp to find a valid assignment If there are multiple answers print any of them ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Let s start by arranging the programmers in the increasing order of their stress tolerance level Not obvious what it achieves at first but it always helps to sort doesn t it Now consider some assignment of the programmers to the projects Notice how it s always optimal to take the suffix of the programmers If there is a valid answer which is not a suffix then you can always take drop the weakest programmer and replace him with the strongest non taken one and the answer will still be valid We can actually propagate the argument further It s also always optimal for each project to have assigned a segment of programmers Look at the weakest taken programmer again and think about the project he s assigned to All that matters for the project is the number of other programmers assigned to it So you can safely replace the current assigned programmers with the same count of the next weakest ones You can do it by swapping the assigned projects of the adjacent programmers This way every swap can only make any other project s weakest programmer stronger Thus we can actually build the answer the following way Choose a project and assign the shortest possible suffix of non taken programmers to it We just have to determine the order of the projects to take Well let s use dynamic programming for that Let be the shortest suffix of the programmers that can be assigned to the projects from For a transition just choose one of the projects that isn t in and find the shortest segment of programmers starting from How to find this shortest suffix fast enough You can precompute it before calculating the dynamic programming For each project and each starting index you can calculate the shortest suffix with two pointers Overall complexity "}
{"statement": "You are given an array of n integers a 1 a 2 dots a nYou can apply the following operation an arbitrary number of times select an index i 1 le i le n and replace the value of the element a i with the value a i a i bmod 10 where a i bmod 10 is the remainder of the integer dividing a i by 10 For a single index value i this operation can be applied multiple times If the operation is applied repeatedly to the same index then the current value of a i is taken into account each time For example if a i 47 then after the first operation we get a i 47 7 54 and after the second operation we get a i 54 4 58 Check if it is possible to make array elements equal by applying multiple possibly zero operations For example you have an array 6 11 Let s apply this operation to the first element of the array Let s replace a 1 6 with a 1 a 1 bmod 10 6 6 bmod 10 6 6 12 We get the array 12 11 Then apply this operation to the second element of the array Let s replace a 2 11 with a 2 a 2 bmod 10 11 11 bmod 10 11 1 12 We get the array 12 12 Thus by applying 2 operations you can make all elements of an array equal ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let s see which remainders modulo change into which ones If the array contains a number divisible by then it cannot be changed If there is a number that has a remainder of modulo then it can only be replaced once Thus if the array contains a number divisible by then we apply this operation to all elements of the array once and check that all its elements are equal The remaining odd balances immediately turn into even ones The even remainders change in a cycle while the array element increases by in operations Thus we will apply the operation to each element of the array until its remainder modulo becomes for example and then check that the array does not contain both remainders and modulo "}
{"statement": "For a sequence of strings t 1 t 2 dots t m let s define the function f t 1 t 2 dots t m as the number of different strings that are subsequences of string t i f 0 i e the number of such strings for an empty sequence is 0 You are given a sequence of strings s 1 s 2 dots s n Every string in this sequence consists of lowercase Latin letters and is i e each string begins with several maybe zero characters then several maybe zero characters ends with several maybe zero characters For each of 2 n subsequences of s 1 s 2 dots s n calculate the value of the function f modulo 998244353 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "For a string let s define its as the mask of bits where th bit is if and only if is a subsequence of Let s suppose we somehow calculate the number of strings for each and we denote this as for a mask How can we use this information to find Suppose this set of strings is represented by a mask then the strings which are included in are the strings such that their characteristic mask has bitwise AND with equal to i e these characteristic masks are submasks of We can use SOS DP to calculate these sums of over submasks in The only problem is how to calculate for every mask Let s analyze when a string is a subsequence of a sorted string The subsequence should be sorted as well and the number of occurrences of every character in a subsequence should not exceed the number of occurrences of that character in So if there are characters in characters in and so on then the number of its subsequences is What about subsequences of every string from a set These conditions on the number of occurrences should apply to every string in the set so for each character we can calculate the minimum number of occurrences of this character in each string of the set add and multiply these numbers to get the number of strings that are subsequences of each string in a set These values can be calculated in for all subsequences of using recursive approach Can these numbers be used as Not so fast Unfortunately these values let s call them are the numbers of subsequences of the chosen sets of strings but we have no information about the strings that are not included in the chosen set of strings To handle it we can use the following equation where means that is a submask of To transform the values of into the values of we can flip all bits in the masks so is the sum of over all submasks of apply inverse SOS DP also known as Mobius transformation and then flip all bits in the masks again So we found a way to calculate all values of in and we have already discussed what to do with them in the first paragraph of the editorial The overall complexity of the solution is "}
{"statement": "A team of furry rescue rangers was sitting idle in their hollow tree when suddenly they received a signal of distress In a few moments they were ready and the dirigible of the rescue chipmunks hit the road We assume that the action takes place on a Cartesian plane The headquarters of the rescuers is located at point and the distress signal came from the point Due to Gadget s engineering talent the rescuers dirigible can instantly change its current velocity and direction of movement at any moment and as many times as needed The only limitation is the speed of the aircraft relative to the air can not exceed meters per second Of course Gadget is a true rescuer and wants to reach the destination as soon as possible The matter is complicated by the fact that the wind is blowing in the air and it affects the movement of the dirigible According to the weather forecast the wind will be defined by the vector for the nearest seconds and then will change to These vectors give both the direction and velocity of the wind Formally if a dirigible is located at the point while its own velocity relative to the air is equal to zero and the wind is blowing then after seconds the new position of the dirigible will be Gadget is busy piloting the aircraft so she asked Chip to calculate how long will it take them to reach the destination if they fly optimally He coped with the task easily but Dale is convinced that Chip has given the random value aiming only not to lose the face in front of Gadget Dale has asked you to find the right answer It is guaranteed that the speed of the wind at any moment of time is strictly less than the maximum possible speed of the airship relative to the air ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "If the velocity of the dirigible relative to the air is given by the vector ax ay while the velocity of the wind is bx by the resulting velocity of the dirigible relative to the plane is ax bx ay by The main idea here is that the answer function is monotonous If the dirigible is able to reach to target in seconds then it can do so in seconds for any x 0 That is an obvious consequence from the fact the maximum self speed of the dirigible is strictly greater then the speed of the wind at any moment of time For any monotonous function we can use binary search Now we only need to check if for some given value it s possible for the dirigible to reach the target in seconds Let s separate the movement of the air and the movement of the dirigible in the air The movement cause by the air is xn yn if xn yn for The only thing we need to check now is that the distance between the point xn yn and the target coordinates x2 y2 can be covered moving with the speed vmax in seconds assuming there is no wind Time complexity is where C stands for the maximum coordinate nd desired accuracy "}
{"statement": "A long time ago in some country in Asia were civil wars Each of cities wanted to seize power That s why sometimes one city gathered an army and sent it to campaign against another city Road making was difficult so the country had few roads exactly Also you could reach any city from any other city going on those roads Even during the war the Oriental people remain spiritually rich and appreciate the beauty of nature And to keep the memory of this great crusade for the centuries to come they planted one beautiful tree by the road on which the army spent most time The Oriental people love nature that s why if there were several such roads then one tree was planted by each of them Recently when the records of the war were found it became clear that each city attacked each other one exactly once There were exactly attacks in total Everyone has been wondering what road after those wars became the most beautiful that is by which road they planted the largest number of beautiful trees ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 1, "problem_dificulty": "2300", "problem_editorial": "In this task we should count for each edge the number of ways on which it is maximal Since for one edge alone it does not seem possible to find the answer faster than in the linear time the solution will compute answer for all the edges at once We shall solve the problem first for the two extreme cases then combining these two we will obtain a complete solution The first case is when the weights of all edges are identical In this case we can solve the problem via DFS For each edge we just need to count the number of paths that this edge lies on it This number is the product of the number of vertexes on different sides of the edge If we count the number of vertexes on one side from it while knowing the total number of vertexes in the tree it is easy to find the number of vertexes on the other side of it and hence the required number of ways on which it lies The second case when the weights of all edges are distinct Sort the edges in the order of the weight s increasing Initially we take a graph with no edges We add an edge in the order of increasing of weight For each edge we join the connected components it connects Then the answer for each new added edge is the product of the size of components that it has connected Now we must combine these two cases We will add the edges in the ascending order but not one by one but in the groups of the equal weight We should understand what the answer is for each of the added edges After adding our edges some number of connected components was formed for each edge we calculate the same product of the number of vertexes on different sides inside his newly formed connected component To find this number of edges on the different sides we should realize that it is only enough to know the sizes of the old connected components and connections between them how they were arranged is not important to us We use a DSU adding an edge to our forest we combine the old connected components by these edges Note that prior to the merging of the components we must calculate an answer for our edges and it is possible to make via a DFS on our compressed forest as in the first case only instead of the number of vertexes on different sides of the edge we take the sum of the sizes of the connected components on different sides of the edge How to do it neatly It s good idea to dynamically create compressed graph at each step it will have O E vertexes and edges where E the number of added edges of the source tree Do not create unnecessary vertexes in the new created compressed column after all the DFS works for O V E rather than O E so the unused connected components we do not include in the circuit We should use the 64 bit data type To store the response of the order of 105 2 it will fit more than the 32 bit one We should not merge the adjacency lists explicitly when connecting components It is too long You can do everything instead of arrays on vectors maps heap so the total time of nulling of the marks for an array of DFS occupied O V Or instead of nulling of the array overlays we keep instead of a Boolean flag the iteration number In general it is better not to null extra arrays After all algorithm can make V iterations Be careful solutions with map works at TL s maximum so it should be written very carefully you should better use the vectors list of involved nodes The author s solution with the map fits in the TL with only half a second to spare While using a vector has a four time stock of time to spare "}
{"statement": "In Aramic language words can only represent objects Words in Aramic have special properties A word is a if it does not contain the same letter more than once A and all its permutations represent the same object The x of a word y is the word that contains all letters that appear in y in a way that each letter appears once For example the of is the of is Any word in Aramic represents the same object as its You have an ancient script in Aramic What is the number of mentioned in the script ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "One can easily notice that we only differentiate between words when different letters exit so one easy way to consider all the different words that belong to the same root as one is to map every word to a mask of 26 bits that is for example if letter b exits in the ith word then we set the second bit in the ith mask to one eventually we insert all the masks in a set and the set size is the required answer "}
{"statement": "There is a hidden array a of n positive integers You know that a is a or in other words for all 1 le i le n a i a n 1 i You are given the sums of all but one of its distinct subarrays in arbitrary order The subarray whose sum is not given can be any of the frac n n 1 2 distinct subarrays of a Recover any possible palindrome a The input is chosen such that there is always at least one array a that satisfies the conditions An array b is a subarray of a if b can be obtained from a by the deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Let s first look at the set of subarray sums of a palindromic array of positive integers Because is a palindrome the sum of the subarray with indices in the range is the same as the sum of the subarray with indices in the range So if we ignore all subarrays where subarrays centered at the center of each sum must appear an even number of times Also every centered subarray must have a unique sum This is because all elements of are strictly positive and if the centered subarrays are ordered by length each one contains all elements in the previous one along with two new elements so its sum must be strictly greater Therefore the set of subarray sums that appear an odd number of times is exactly the set of sums of subarrays centered at the center of For example in the array the sums that appear an odd number of times are Note that they can appear more than once So if we have all subarray sums of we can then use the centered sums to reconstruct itself The smallest centered sum is either the middle element or the sum of the middle two equal elements depending on the parity of and for each centered sum in ascending order after that its difference with the previous sum must be the sum of the next two equal elements closest to the center of Now let s find out how to reconstruct the missing sum We consider two cases If the missing sum is for a centered subarray then there will be exactly sums that appear an odd number of times in the input We can use these sums to construct a palindromic array of size as described above We can then remove all sums of subarrays of from the initial input list and look at what is remaining If we let be the indices of the missing subarray the largest remaining sum in the list must be the sum of in or equivalently Let this sum be and the sum of be If and therefore the missing sum must be because the part includes everything in the missing subarray twice and everything else once and includes everything once initially seems like it will be an edge case but the same equation works there as well since includes everything in the missing array all of once and everything in once and includes everything in once If the missing sum is not for a centered subarray then there will be exactly sums that appear an odd number of times in the input We can use these sums to construct a palindromic array of size as described above In a similar way to the previous case we can then remove all sums from the initial input list from the set of subset sums of If we let be the indices of the extra centered subarray in the largest remaining sum in the list must be the sum of in or equivalently If we let be this largest sum and be the sum of we can use similar logic to the previous case to determine that the missing sum is So we can determine the missing sum using the number of sums that appear an odd number of times in the input to determine which case we are in Once we have found the missing sum we just need to reconstruct using the process above Also notice that by the construction we have followed so far the solution is always unique Complexity "}
{"statement": "The start of the new academic year brought about the problem of accommodation students into dormitories One of such dormitories has a square meter wonder room The caretaker wants to accommodate exactly students there But the law says that there must be at least 6 square meters per student in a room that is the room for students must have the area of at least square meters The caretaker can enlarge any possibly both side of the room by an arbitrary positive integer of meters Help him change the room so as all students could live in it and the total area of the room was as small as possible ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Let s assume that First of all let s consider the situation when we can already accommodate all the students If then answer is Otherwise we have to increase one of the walls maybe both Let s do it in the following way iterate the size of the smallest wall after that we can calculate the size of another wall as For all this and if we choose such a pair that has the smallest area of a room Obviously to undestrand that there is no point to consider because we can decrease it and receive room of smaller area when we know that Complexity Solution 7784788 "}
{"statement": "Alice and Bob are playing a game There is a list of n booleans each of which is either or given as a binary string text of length n where texttt 1 represents and texttt 0 represents Initially there are no operators between the booleans Alice and Bob will take alternate turns placing or between the booleans with Alice going first Thus the game will consist of n 1 turns since there are n booleans Alice aims for the final statement to evaluate to while Bob aims for it to evaluate to Given the list of boolean values determine whether Alice will win if both players play optimally To evaluate the final expression repeatedly perform the following steps until the statement consists of a single or If the statement contains an operator choose any one and replace the subexpression surrounding it with its evaluation Otherwise the statement contains an operator Choose any one and replace the subexpression surrounding the with its evaluation For example the expression is evaluated as It can be shown that the result of any compound statement is unique text A binary string is a string that only consists of characters texttt 0 and texttt 1 ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Problem Credits Proof by QED Analysis Proof by QED Solution Let s understand what Alice wants to do She wants to separate a statement that evaluates to true between two or s This guarantees her victory since or is evaluated after all and s First if the first or last boolean is true then Alice instantly wins by placing or between the first and second or second to last and last booleans Otherwise if there are two true s consecutively Alice can also win Alice may place or before the first of the two on her first move If Bob does not put his operator between the two true s then Alice will put an or between the two true s on her next move and win Otherwise Bob does place his operator between the two true s However no matter what Bob placed the two true s will always evaluate to true so on her second move Alice can just place an or on the other side of the two true s to win We claim these are the only two cases where Alice wins This is because otherwise there does not contain two true s consecutively Now whenever Alice places an or adjacent to a true Bob will respond by placing and after the true which will invalidate this clause to be false "}
{"statement": "Polycarpus has an array consisting of integers Polycarpus likes it when numbers in an array match That s why he wants the array to have as many equal numbers as possible For that Polycarpus performs the following operation multiple times he chooses two elements of the array he simultaneously increases number by and decreases number by that is executes and The given operation changes exactly two distinct array elements Polycarpus can apply the described operation an infinite number of times Now he wants to know what maximum number of equal array elements he can get if he performs an arbitrary number of such operation Help Polycarpus ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Note that you can always get the answer To get this result you should make first equal using the last element as the second element in pair of given operation But after it the whole array could become equal It could happen if the sum of array s elements is divisible by So the answer is or "}
{"statement": "Serval loves Brain Power and his brain power problem Serval defines that a string T is iff T can be obtained by concatenating some string T multiple times Formally speaking T is powerful iff there exist a string T and an integer k geq 2 such that T underbrace T T dots T k text times For example is powerful because it can be obtained by concatenating three times but is not powerful Serval has a string S consists of lowercase English letters He is curious about the longest powerful subsequence of S and he only needs you to find out the length of it If all the non empty subsequences of S is not powerful the answer is considered to be 0 A string a is a subsequence of a string b if a can be obtained from b by the deletion of several possibly zero or all characters ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Assume that the longest powerful subsequence of the given string is which can be obtained by concatenating copies of string Noticing that we have the observation that so it is impossible that both and is large When we only need to consider the case and the case The case is covered by case since For the case we split into two parts then calculate the maximal length of by dynamic programming over all the possible splits This case can be solved in time where is a small constant It is similar to solve the case We split into three parts then calculate the maximal length of over all the possible splits This case can be solved in time where is a small constant We will estimate later When we have It can be shown that if we split into parts will be the subsequence of at least one of them We can split into equal lengths then enumerate all the subsequences of these substrings as the possible For a possible we can find out corresponding by matching and greedily This case can be solved in Now let us roughly estimate how small could be The time that dynamic programming consumed for certain is Since we have Recall that there are possible splits then holds Time complexity "}
{"statement": "Today at the lesson Vitya learned a very interesting function of a sequence of numbers is the minimum non negative number that is not present in the sequence as element For example and Vitya quickly understood all tasks of the teacher but can you do the same You are given an array consisting of non negative integers and queries Each query is characterized by one number and consists of the following consecutive steps Perform the bitwise addition operation modulo of each array element with the number Find of the resulting array ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "If the last query was and then we receive a query then we can leave the original array unchanged and use the number as the second query So we will maintain current xor of queries instead of changing the array It s easy to see that if the array contains all numbers from zero to and the number in the query is less than then the array will still contain all those numbers Let s store all numbers from the array in binary trie and maintain the number of leaves in each subtree To answer each query we will descend the trie We need to get the lowest possible answer so if current bit of the number in the query equals or so we firstly check the subtree that corresponds to bit We will descend into the vertex only if the subtree is not a complete binary tree so there exists a number that would belong to this subtree but is not included in the array When we try to descend into an empty subtree then we set all remaining bits in the answer to zero https ideone com gVE1kC "}
{"statement": "Little Petya very much likes rectangular tables that consist of characters 0 and 1 Recently he has received one such table as a gift from his mother The table contained rows and columns The rows are numbered from top to bottom from to the columns are numbered from the left to the right from to Petya immediately decided to find the longest cool cycle whatever it takes A cycle is a sequence of pairwise distinct cells where each two consecutive cells have a common side besides the first cell has a common side with the last cell A cycle is called cool if it fulfills all the following conditions simultaneously The cycle entirely consists of the cells that contain 1 Each cell that belongs to the cycle has a common side with exactly two other cells that belong to the cycle Each cell of the table that contains 1 either belongs to the cycle or is positioned outside of it see definition below To define the notion of outside formally let s draw a cycle on a plane Let each cell of the cycle is the row number is the column number correspond to the point on the coordinate plane Let a straight line segment join each pair of points that correspond to the cells belonging to the cycle and sharing a side Thus we will get a closed polyline that has no self intersections and self touches The polyline divides the plane into two connected parts the part of an infinite area and the part of a finite area It is considered that cell lies outside of the cycle if it does not belong to the cycle and the corresponding point on the plane with coordinates lies in the part with the infinite area Help Petya to find the length of the longest cool cycle in the table The cycle length is defined as the number of cells that belong to the cycle ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "One can notice that the only possible variant of a cool cycle which doesn t have zeroes inside it is a 2x2 square of ones This case should be checked separately From this point we ll assume that the cool cycle we are looking for contains at least one 0 inside it Let s take any zero from the table If it is adjacent to another zero by a side or a corner then it can t lay inside a cool cycle which doesn t have any other zeroes inside it Thus this zero can lay inside a cool cycle only together with all zeroes adjacent to it Generalizing this fact one can show that the zero can lay inside a cool cycle only together with all zeroes reachable from it We ll assume that one zero is reachable from another zero if they can be connected with a path which consists only of zeroes and in which every two consecutive cells share either a side or a corner Let s find all the connected components of zeroes Two zeroes are connected if they share either a side or a corner If the component of zeroes has a cell adjacent to a border of the table then it can t lay inside any cool cycle and thus it should be ignored After that for each connected component of zeroes let s find all cells with 1 adjacent to it By the statement all those cells should be connected Also each cell from this set should share a common side with exactly two other cells from the set Note that if the set of cells with 1 satisfy those restrictions then it forms a cycle which doesn t contain any other cells with 1 inside it "}
{"statement": "Maksim has n objects and m boxes each box has size exactly k Objects are numbered from 1 to n in order from left to right the size of the i th object is a i Maksim wants to pack his objects into the boxes and he will pack objects by the following algorithm he takes one of the empty boxes he has goes from left to right through the objects and if the i th object fits in the current box the remaining size of the box is greater than or equal to a i he puts it in the box and the remaining size of the box decreases by a i Otherwise he takes the new empty box and continues the process above If he has no empty boxes and there is at least one object not in some box then Maksim cannot pack the chosen set of objects Maksim wants to know the maximum number of objects he can pack by the algorithm above To reach this target Your task is to say the maximum number of objects Maksim can pack in boxes he has Each time when Maksim tries to pack the objects into the boxes he will make empty all the boxes he has before do it and the relative order of the remaining set of objects will not change ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "The first solution is some kind of a straight forward understanding the problem Let s do binary search on the answer So our problem is to find the smallest such that the suffix of the array starting from the position can be packed in boxes It is easy to see that if we can do it for some then we always can do it for And to find the answer for the fixed we have to simulate the process described in the problem statement starting from the position Okay this is solution The second solution is more interesting than the first one The approach is to reverse the initial array simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all Why it works Let s take a look on the last box in the best answer if we will go from left to right in the initial array Let objects in this box be What do we see So all these objects are fit in the last box obviously Now if we will iterate over objects from right to left these objects will fit also It means that we cannot do worse by such a transform reversing at least for the last box But what will happen if we can put some of the previous objects in this box Well it will not make worse for this box but what about next boxes previous boxes in straight notation Let objects in the penultimate box be What do we see These objects are fit in this box obviously again What will happen if we will put in the last box one or more objects of this box Then the border of objects which we will put in it will not increase because we the number of object in this box So we can see that for previous boxes this condition is also satisfied So we can solve the problem with this approach Time complexity of this solution is "}
{"statement": "On an 8 times 8 grid of dots a word consisting of lowercase Latin letters is written vertically in one column from top to bottom What is it ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "You can iterate through the grid and then once you find a letter iterate downwards until you get the whole word However there is an approach that is even faster to code just input each character and output it if it is not a dot This works because we will input the characters in the same order from top to bottom The complexity is regardless "}
{"statement": "Mehrdad wants to invite some Hoses to the palace for a dancing party Each Hos has some weight and some beauty Also each Hos may have some friends Hoses are divided in some friendship groups Two Hoses and are in the same friendship group if and only if there is a sequence of Hoses such that and are friends for each and and Arpa allowed to use the amphitheater of palace to Mehrdad for this party Arpa s amphitheater can hold at most weight on it Mehrdad is so greedy that he wants to invite some Hoses such that sum of their weights is not greater than and sum of their beauties is as large as possible Along with that from each friendship group he can either invite all Hoses or no more than one Otherwise some Hoses will be hurt Find for Mehrdad the maximum possible total beauty of Hoses he can invite so that no one gets hurt and the total weight doesn t exceed ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "It s a simple knapsack problem Let s solve this version of knapsack problem first we have sets of items each item has value and weight find the maximum value we can earn if we can choose at most one item from each set and the sum of the chosen items must be less than or equal to Let be the max value we can earn if the sum of weights of chosen items is less than or equal to Now iterate on sets one by one and update as follows for each item and for each weight Run dfs and find groups at first The problem is same with above problem each group is some set in above problem just add the whole group as an item to the set that related to this group Time complexity "}
{"statement": "Levko loves tables that consist of rows and columns very much He especially loves beautiful tables A table is to Levko if the sum of elements in each row and column of the table equals Unfortunately he doesn t know any such table Your task is to help him to find at least one of them ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Matrix in which all diagonal elements equal and other elements equal satisfied all conditions For example if n 4 and k 7 our matrix will be 7 0 0 0 0 7 0 0 0 0 7 0 0 0 0 7 "}
{"statement": "Petya has an array consisting of numbers He wants to perform operations of two types add an integer to all elements whose indexes belong to the interval from to inclusive find and print on the screen how many lucky numbers there are among elements with indexes that belong to the interval from to inclusive Each lucky number should be counted as many times as it appears in the interval Petya has a list of all operations The operations are such that after all additions the array won t have numbers that would exceed Help Petya write a program that would perform these operations ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "In this problem you can use many different algorithms here is one of them Obviously number of different lucky number is 30 because Ai always is 10000 Let Di difference between minimum lucky number which is greater than or equal to Ai and Ai Now we need to have 5 but you can use less number of operation on D Subtract l r d subtract number d from all Ai l i r Minimum l r minumum number of all Di l i r Count l r how many times that minimum occared in that interval Left l r leftmost occarence of that minimum Set i d assign d to Di Di d Now we can do our operations If our operation is count then we need to find minimum number d d Minimum l r if it is equal to 0 then answer is Count l r 0 otherwise answer is 0 If out operation is add then we need to Subtract l r d but now some Di might be less than 0 So while Minimum l r 0 let j Left l r assign Dj new value use Set j Dj which can be calculated with complaxity O 1 "}
{"statement": "Asterix Obelix and their temporary buddies Suffix and Prefix has finally found the Harmony temple However its doors were firmly locked and even Obelix had no luck opening them A little later they found a string carved on a rock below the temple s gates Asterix supposed that that s the password that opens the temple and read the string aloud However nothing happened Then Asterix supposed that a password is some substring of the string Prefix supposed that the substring is the beginning of the string Suffix supposed that the substring should be the end of the string and Obelix supposed that should be located somewhere inside the string that is is neither its beginning nor its end Asterix chose the substring so as to please all his companions Besides from all acceptable variants Asterix chose the longest one as Asterix loves long strings When Asterix read the substring aloud the temple doors opened You know the string Find the substring or determine that such substring does not exist and all that s been written above is just a nice legend ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let us calculate a prefix function for all prefices of string Prefix function p i is maximal length of prefix that also is suffix of substring 1 i More about prefix function you can see in a description of Knuth Morris Pratt algorithm KMP The first of possible answers is prefix of length p n If p n 0 there is no solution For checking the first possible answer you should iterate over p i If at least one of them equal to p n but not n th of course you found the answer The second possible answer is prefix of length p p n If p p n 0 you also have no solution Otherwise you can be sure that the answer already found This substring is a prefix and a suffix of our string Also it is suffix of prefix with length p n that places inside of all string This solution works in O n Also this problem can be solved using hashing You can find hash of every substring in O 1 and compare substrings by comparing thier hashes Well let s check for every prefix that it is a suffix of our string and store thier lengths into some array in the increasing order Then using binary search over the array you can find maximal length of prefix that lie inside of string Check of every prefix you can do in O n So you have some solution In point of fact the array of prefix lengths in the previous solution is list p n p p n that written if reversed order From the first solution you know that the answer is prefix of length either p n or p p n if it exists of course Therefore some naive solution without binary search can fits in the limits if you will stupidly check all prefices in the order of decrease thier lengths This solution works in O n Also this problem can be solved using z function "}
{"statement": "Fox Ciel studies number theory She thinks a non empty set contains non negative integers is if and only if for any can be equal to Where operation means exclusive or operation Please calculate the number of perfect sets consisting of integers not greater than The answer can be very large so print it modulo ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "A perfect set correspond to a linear space so we can use base to represent it We do the Gauss Jordan elimination of vectors in that set and can get an unique base Note that we need to to the all process of Gauss Jordan elimination including the elimination after it reached upper triangular And we can construct the bases bit by bit from higher bit to lower for a bit We can add a vector to the base such that the bit is the highest bit of that vector And at this time all other vector will have 0 in this bit Otherwise we need to assign this bit of each vector already in the base If now we have k vector then we have 2 k choices And when we do this we need to know what s the maximal vector in this space It s not hard If we add a vector then in the maximal vector this bit will be 1 Otherwise if we don t have any vector in base yet then this bit will be 0 Otherwise there will be 2 k 1 choices results in this bit of maximal vector will be 0 and 2 k 1 choices results in 1 So we can solve this task by DP bit by bit "}
{"statement": "There are n fishermen who have just returned from a fishing trip The i th fisherman has caught a fish of size a i The fishermen will choose some order in which they are going to tell the size of the fish they caught the order is just a permutation of size n However they are not entirely honest and they may increase the size of the fish they have caught Formally suppose the chosen order of the fishermen is p 1 p 2 p 3 dots p n Let b i be the value which the i th fisherman in the order will tell to the other fishermen The values b i are chosen as follows the first fisherman in the order just honestly tells the actual size of the fish he has caught so b 1 a p 1 every other fisherman wants to tell a value that is than the value told by the previous fisherman and is divisible by the size of the fish that the fisherman has caught So for i 1 b i is the smallest integer that is both than b i 1 and a p i For example let n 7 a 1 8 2 3 2 2 3 If the chosen order is p 1 6 7 5 3 2 4 then b 1 a p 1 1 b 2 is the smallest integer divisible by 2 and greater than 1 which is 2 b 3 is the smallest integer divisible by 3 and greater than 2 which is 3 b 4 is the smallest integer divisible by 2 and greater than 3 which is 4 b 5 is the smallest integer divisible by 2 and greater than 4 which is 6 b 6 is the smallest integer divisible by 8 and greater than 6 which is 8 b 7 is the smallest integer divisible by 3 and greater than 8 which is 9 You have to choose the order of fishermen in a way that yields the minimum possible sum limits i 1 n b i ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "Suppose we have fixed some order of fishermen and calculated the values of Then we have the following constraints on all values of are pairwise distinct for every divides Not every possible array meeting these constraints can be achieved with some order of fishermen but we can show that if we choose an array with the among the arrays meeting these two constraints there exists an ordering of fishermen which yields this array The proof is simple suppose the ordering of fishermen is the following one the first fisherman is the one with minimum the second one the one with the second minimum and so on It s obvious that if we generate the values of according to this order they won t be greater than the values in the array we have chosen And if some value is less than the value in the chosen array it means that we haven t chosen the array with the minimum possible sum So we can rephrase the problem as the following one for each choose the value of so that it is divisible by all are distinct and their sum is minimized Using the pigeonhole principle we can show that for every we need to consider only the values of among So we can formulate the problem as an instance of the weighted bipartite matching build a graph with two parts where the left part contains nodes representing the values of the right part represents the values of the form where and there exists an edge between a vertex in the left part representing the number and a vertex in the right part representing the number with cost if and only if for some integer Okay now we need to solve this weighted matching problem but how The number of vertices is and the number of edges is as well so mincost flow will run in or which is too much Instead we can notice that the cost of the edges incident to the same vertex in the right part is the same so we can swap the parts of the graph sort the vertices of the new left part representing the numbers according to their costs and run the classical Kuhn s algorithm in sorted order Kuhn s algorithm in its original implementation will always match a vertex if it is possible so it obtains the minimum total cost for the matching if we do it in sorted order But this is still What should we do Well there are some implementations of Kuhn s algorithm which can run on graphs of size about sometimes even Why can t we use one of these Unfortunately For example greedy initialization of matching won t work So we need to choose optimizations carefully The model solution uses the following optimization of Kuhn s algorithm With this optimization Kuhn s algorithm works in where is the size of the maximum matching is the number of edges and is the number of vertices So this results in a solution with complexity of I think it s possible to show that some other optimizations of Kuhn can also work but the one I described is enough "}
{"statement": "Let s name a pair of positive integers x y if the greatest common divisor of them is equal to 1 gcd x y 1 Let s define a induced by x y as a sequence of pairs x y x 1 y 1 x 2 y 2 dots x k y k for some integer k ge 0 The of the chain is the number of pairs it consists of or k 1 Let s name such chain if all pairs in the chain are lucky You are given n pairs x i y i Calculate for each pair the length of the longest lucky chain induced by this pair Note that if x i y i is not lucky itself the chain will have the length 0 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Suppose It means that is also divisible by or is divisible by And backward if then is also divisible by or is divisible by Since is divisible by and is divisible by so In other words we proved that Now knowing the equivalence above we can understand that we are looking for the smallest such that In other words we are searching such that is divisible by some where is some divisor of The problem is that there are a handful of divisors for some But we can note that we can consider only divisors of if and is composite then there is some prime thus It s easy to prove that there are no more than prime divisors of some Now the question is how to find all these prime divisors Note that if you know only one prime divisor for each value from to then you can find all prime divisors for all in The prime divisors are next and so on until The final step is to calculate a prime divisor for each value from to where or We can do it by slight modifications of Sieve of Eratosthenes at the step where you have some prime and want to throw out all values set for each plus set As a result we firstly calculate Sieve in and secondly calculate answer for each pair in Note that the input and output is large so you should you tricks to speed up your input and output "}
{"statement": "Suppose you play a game where the game field looks like a strip of 1 times 10 9 square cells numbered from 1 to 10 9 You have n snakes numbered from 1 to n you need to place into some cells Initially each snake occupies exactly one cell and you can t place more than one snake into one cell After that the game starts The game lasts for q seconds There are two types of events that may happen each second snake s i if snake s i occupied cells l r it enlarges to a segment l r 1 snake s i if snake s i occupied cells l r it shrinks to a segment l 1 r Each second exactly one of the events happens If at any moment of time any snake runs into some obstacle either another snake or the end of the strip you lose Otherwise you win with the score equal to the maximum cell occupied by any snake so far What is the minimum possible score you can achieve ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "Note that when you place snakes on the strip in some order they form some permutation And when you fix that permutation you can place them greedily In other words when you know in what order you ll place snakes it s always optimal to place them as close to each other as possible Since the bigger the initial distance the bigger the resulting distance of the farthest snake or the bigger the final score We can even calculate that final score precisely it s equal to So we can solve the task in two steps First let s calculate the minimum possible distance between snakes and if we plan to place snake right after snake Suppose the initial between these snakes is Let s skim through all events each time the th snake enlarges our gap decreases or each time the th snake shrinks our gap increases or if at any moment becomes negative then we lose In other words we needed bigger initial We can rephrase what happens more formally for each event let if increases if decreases or otherwise Then after the th event the current gap will be equal to The following inequality should hold for each or So if we will find the minimum then we can set the initial distance to this minimum gap plus one or Now we know the minimum distances between neighboring snakes so we can find the optimal order Let s do it with bitmask dp since all we need to know in each state is the set of already placed snakes and the last snake Transitions are straightforward let s just choose the next snake to place and place it at distance The initial states are for each The answer is i e we just choose the last snake The time complexity is for the first part or if written more optimally plus for the second part "}
{"statement": "You are given a tree with vertexes and points on a plane no three points lie on one straight line Your task is to paint the given tree on a plane using the given points as vertexes That is you should correspond each vertex of the tree to exactly one point and each point should correspond to a vertex If two vertexes of the tree are connected by an edge then the corresponding points should have a segment painted between them The segments that correspond to non adjacent edges should not have common points The segments that correspond to adjacent edges should have exactly one common point ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "No three points are in the same line so the solution always exists First choose any one vertex as the root of tree Find size of each subtree using dfs Then we can build the answer recursively Put the root of tree to the most lower left point Sort all other points by angle relative to this lower left point Let us name the sizes of subtrees of the root as Run the algorithm recursively giving first points in sorted order for the first subtree of root next points for the second subtree and so on Obviously no two edges from different subtrees can intersect now At each step of recursion we are to put the root of current subtree to the first point in sorted by angle order and then sort other points by angle relative to it So no two subtrees will have any intersecting edges The asymptotic of solution is "}
{"statement": "Not so long ago Vlad had a birthday for which he was presented with a package of candies There were n types of candies there are a i candies of the type i 1 le i le n Vlad decided to eat exactly one candy every time choosing any of the candies of a type that is currently the most frequent if there are several such types he can choose of them To get the maximum pleasure from eating Vlad to eat two candies of the same type in a row Help him figure out if he can eat all the candies without eating two identical candies in a row ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "There will be three cases in total let s consider them on two types of candies then we will eat candies in this order then we will eat a candy of the type and then we will eat in this order almost as in the case above then we will eat a candy of the type but there will still be more of them than candies of the type and we will have to eat a candy of the type again So the answer is Now we prove that it is enough to check these conditions on two maximums of the array If the third condition is true the answer is obvious Otherwise we will by turns eat candies of the two maximum types until their number is equal to the third maximum after which we will by turns eat candies of these three types and so on "}
{"statement": "Limak is a little polar bear He plays by building towers from blocks Every block is a cube with positive integer length of side Limak has infinitely many blocks of each side length A block with side has volume A tower consisting of blocks with sides has the total volume Limak is going to build a tower First he asks you to tell him a positive integer the required total volume of the tower Then Limak adds new blocks greedily one by one Each time he adds the biggest block such that the total volume doesn t exceed Limak asks you to choose not greater than Also he wants to maximize the number of blocks in the tower at the end however he still behaves greedily Secondarily he wants to maximize Can you help Limak Find the maximum number of blocks his tower can have and the maximum that results this number of blocks ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Let s find the maximum that Then it s optimal to choose that the first block will have side or Let s see why We want to first maximize the number of blocks we can get with new limit Secondarily we want to have the biggest initial You can analyze the described above cases and see that the first block with side must be a worse choice than It s because we start with smaller and we are left with smaller The situation for even smaller side of the first block would be even worse Now you can notice that the answer will be small From of magnitude after one block we get of magnitude So from we go to which means that the answer is The exact maximum answer turns out to be The intended solution is to use the recursion and brutally check both cases taking and taking where is maximum that It s so fast that you can even find in increasing by one code1 "}
{"statement": "There is a sheet of paper that can be represented with a grid of size n times m n rows and m columns of cells All cells are colored in white initially q operations have been applied to the sheet The i th of them can be described as follows x i y i choose one of k non white colors and color the entire row x i and the entire column y i in it The new color is applied to each cell regardless of whether the cell was colored before the operation The sheet after applying all q operations is called a coloring Two colorings are different if there exists at least one cell that is colored in different colors How many different colorings are there Print the number modulo 998 244 353 ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s take a look at a final coloring Each cell has some color There exist cells such that there were no operation in their row and their column They are left white and they don t affect the answer All other cells are colored in one of colors For each cell there is a query that has been the last one to color this cell it covered row column or both of them So all cells that have the same query as the last one will have the same color Since the color for each query is chosen independently the number of colorings will be to the power of the number of queries that have at least one cell belong to them How to determine if a query has at least one cell This is true unless one of these things happen afterwards both its row and its column are recolored all rows are recolored all columns are recolored So the solution is to process the queries backwards Maintain the set of colored rows and colored columns For each query check the conditions If none hold multiply the answer by Overall complexity or per testcase "}
{"statement": "A batch of n goods n an even number is brought to the store i th of which has weight a i Before selling the goods they must be packed into packages After packing the following will be done There will be frac n 2 packages each package contains exactly two goods The weight of the package that contains goods with indices i and j 1 le i j le n is a i a j With this the cost of a package of weight x is always left lfloor frac x k right rfloor burles rounded down where k a fixed and given value Pack the goods to the packages so that the revenue from their sale is maximized In other words make such frac n 2 pairs of given goods that the sum of the values left lfloor frac x i k right rfloor where x i is the weight of the package number i 1 le i le frac n 2 is For example let n 6 k 3 weights of goods a 3 2 7 1 4 8 Let s pack them into the following packages In the first package we will put the third and sixth goods Its weight will be a 3 a 6 7 8 15 The cost of the package will be left lfloor frac 15 3 right rfloor 5 burles In the second package put the first and fifth goods the weight is a 1 a 5 3 4 7 The cost of the package is left lfloor frac 7 3 right rfloor 2 burles In the third package put the second and fourth goods the weight is a 2 a 4 2 1 3 The cost of the package is left lfloor frac 3 3 right rfloor 1 burle With this packing the total cost of all packs would be 5 2 1 8 burles ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Note that we do not need to consider the numbers we are only interested in the remainder of the division of by and we simply add the value to the answer We get an array where Let s sort it and greedily type index pairs such that This can be done with two pointers Then add the number of matching pairs to the answer counter This will be the answer to the problem "}
{"statement": "You have an initially empty cauldron and you want to brew a potion in it The potion consists of two ingredients magic essence and water The potion you want to brew should contain exactly k ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Since you need liters of essence to be exactly of potion then we can write an equality or and for some integer Since we need to minimize and then we should maximize but both and should be divisible by In other words taking as Greatest Common Divisor of and is optimal As a result "}
{"statement": "For a given unordered multiset of lowercase English letters multi means that a letter may appear more than once we treat all letters as strings of length and repeat the following operation times Remove any two elements and from the set and add their concatenation to the set The cost of such operation is defined to be where denotes the number of times character appears in string Given a non negative integer construct any valid non empty set of no more than letters such that the minimum accumulative cost of the whole process is It can be shown that a solution always exists ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "With several experiments you may have found that the minimum cost doesn t make sense the cost is always the same no matter how the characters are concatenated Precisely the cost of the process for a multiset of s s and s is It s in this form because every pair of same characters will contribute to the total cost Therefore we need to find such so that This can be done greedily and iteratively Every time we subtract the maximum possible from and add same new letters to the set until becomes This can be solved by any reasonable way say quadratic formula binary search or brute force Time complexity veries from to or any acceptable complexity depending on the choice of the method for finding Of course if a knapsack algorithm is used it will use the minimum possible number of different letters and works in "}
{"statement": "You are given an array of n positive integers a 1 a 2 ldots a n In one operation you can choose any number of the array and add 1 to it Make at most 2n operations so that the array satisfies the following property a i 1 is divisible by a i for each i 1 2 ldots n 1 You do need to minimize the number of operations ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "First we add one to all the numbers in the array equal to This uses at most operations Then we iterate through the elements of the array from left to right starting from the second element At each step let be the element we are iterating If is divisible by we add one to Now this element is not divisible by because otherwise both and are divisible by but that means is also divisible by which cannot happen since all the elements in the array are at least because of the first step we did This part also uses at most operations so we used at most operations in total The resulting array will satisfy the statement property Intended complexity per test case "}
{"statement": "Polycarp is wondering about buying a new computer which costs c tugriks To do this he wants to get a job as a programmer in a big company There are n positions in Polycarp s company numbered starting from one An employee in position i earns a i tugriks every day The higher the position number the more tugriks the employee receives Initially Polycarp gets a position with the number 1 and has 0 tugriks Each day Polycarp can do one of two things If Polycarp is in the position of x then he can earn a x tugriks If Polycarp is in the position of x x n and has at least b x tugriks then he can spend b x tugriks on an online course and move to the position x 1 For example if n 4 c 15 a 1 3 10 11 b 1 2 7 then Polycarp can act like this On the first day Polycarp is in the 1 st position and earns 1 tugrik Now he has 1 tugrik On the second day Polycarp is in the 1 st position and move to the 2 nd position Now he has 0 tugriks On the third day Polycarp is in the 2 nd position and earns 3 tugriks Now he has 3 tugriks On the fourth day Polycarp is in the 2 nd position and is transferred to the 3 rd position Now he has 1 tugriks On the fifth day Polycarp is in the 3 rd position and earns 10 tugriks Now he has 11 tugriks On the sixth day Polycarp is in the 3 rd position and earns 10 tugriks Now he has 21 tugriks Six days later Polycarp can buy himself a new computer Find the minimum number of days after which Polycarp will be able to buy himself a new computer ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Since the array does not decrease if we want to get the position at some point it is best to get it as early as possible because if we get it earlier we will earn no less money Therefore the solution looks like this rise to some position and earn money on it for a laptop Let s go through the number of the position and use simple formulas to calculate the number of days it takes to raise to this position and the number of days it takes to buy a laptop From all the options choose the minimum one "}
{"statement": "Monocarp plays a computer game There are n different sets of armor and m different weapons in this game If a character equips the i th set of armor and wields the j th weapon their power is usually equal to i j but some combinations of armor and weapons synergize well Formally there is a list of q ordered pairs and if the pair i j belongs to this list the power of the character equipped with the i th set of armor and wielding the j th weapon is not i j but i j 1 Initially Monocarp s character has got only the 1 st armor set and the 1 st weapon Monocarp can obtain a new weapon or a new set of armor in one hour If he wants to obtain the k th armor set or the k th weapon he must possess a combination of an armor set and a weapon that gets his power to k Of course after Monocarp obtains a weapon or an armor set he can use it to obtain new armor sets or weapons but he can go with any of the older armor sets and or weapons as well Monocarp wants to obtain the n th armor set the m th weapon What is the minimum number of hours he has to spend on it ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Among two armor sets one with the greater index is always better The same can be said about two different weapons So it is always optimal to use and obtain the best possible weapon or armor This observation allows us to model this problem with dynamic programming or shortest paths let be the minimum time in which Monocarp can obtain the armor and the weapon and in each transition we either get the best weapon we can or the best armor we can Similarly we can build a graph where the vertices represent these pairs and the edges represent getting the best possible weapon armor and find the shortest path from to using BFS Unfortunately it is But we can modify the BFS in the following fashion let s analyze each layer of BFS a layer is a set of vertices with the same distance from the origin In each layer there might be some redundant vertices if two vertices and belong to the same layer and then the vertex is redundant If we filter each layer removing all redundant vertices from it and continuing BFS only from non redundant ones the solution will be fast enough To prove it let s analyze the constraints on the answer Suppose The answer can be bounded as since we can reach the pair in steps using something similar to Fibonacci sequence building and then go from to in steps And the number of non redundant states on each layer is not greater than because of two states with the same weapon or the same armor set at least one is redundant So if we don t continue BFS from redundant vertices it will visit at most vertices There might be another logarithm in the asymptotic complexity of the solution if you use something like a set to store all combinations that synergize well but this implementation is still fast enough "}
{"statement": "An is a string yes in the real world accordions are musical instruments but let s forget about it for a while which can be represented as a concatenation of an opening bracket ASCII code 091 a colon ASCII code 058 some possibly zero vertical line characters ASCII code 124 another colon and a closing bracket ASCII code 093 The length of the accordion is the number of characters in it For example and are accordions having length 4 6 and 7 are not accordions You are given a string s You want to transform it into an accordion by removing some possibly zero characters from it Note that you may not insert new characters or reorder existing ones Is it possible to obtain an accordion by removing characters from s and if so what is the maximum possible length of the result ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "No cases No any special thoughts Just greedy The solution consists of six steps Remove the prefix of the string until the position of leftmost character If there is no such character print Remove the prefix of the string until the position of leftmost character If there is no such character print Reverse the string Remove the prefix of the string until the position of leftmost character If there is no such character print Remove the prefix of the string until the position of leftmost character If there is no such character print Print the number of characters in the remaining string plus four "}
{"statement": "Given a non negative integer number n n ge 0 Let s say a triple of non negative integers a b c is good if a b c n and digsum a digsum b digsum c digsum n where digsum x is the sum of digits of number x For example if n 26 then the pair 4 12 10 is good because 4 12 10 26 and 4 1 2 1 0 2 6 Your task is to find the number of good triples for the given number n The order of the numbers in a triple matters For example the triples 4 12 10 and 10 12 4 are two different triples ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "A triplet is considered good only if each digit of the number was obtained without carrying over during addition For example consider the sum of the digits is and the sum of the digits of their sum is This means that whenever there is a carry in one of the digits the sum always increases more than This allows us to consider each digit separately and multiply their answers The answer for each digit will be the number of digit triplets with the sum These values do not depend on the input data so they can be precalculated but this is not necessary to pass the tests "}
{"statement": "Alice and Bob play a game They have a binary string s a string such that each character in it is either 0 or 1 Alice moves first then Bob then Alice again and so on During their move the player can choose any number not less than one of in s and delete them For example if the string is 10110 there are 6 possible moves deleted characters are bold textbf 1 0110 to 0110 1 textbf 0 110 to 1110 10 textbf 1 10 to 1010 101 textbf 1 0 to 1010 10 textbf 11 0 to 100 1011 textbf 0 to 1011 After the characters are removed the characters to the left and to the right of the removed block become adjacent I e the following sequence of moves is valid 10 textbf 11 0 to 1 textbf 00 to 1 The game ends when the string becomes empty and the score of each player is Each player wants to maximize their score Calculate the resulting score of Alice ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The following greedy strategy works during each turn delete the largest possible substring consisting of characters So we have to find all blocks of characters sort them according to their length and model which blocks are taken by Alice and which by Bob Why does the greedy strategy work It s never optimal to delete some part of the block of ones because we either have to spend an additional turn to delete the remaining part or allow our opponent to take it which is never good Why don t we need to delete zeroes If we delete a whole block of zeroes our opponent can take the newly formed block of s during their turn and it is obviously worse than taking a part of that block And deleting some part of a block of zeroes doesn t do anything our opponent will never delete the remaining part because it s suboptimal "}
{"statement": "Mr Funt now lives in a country with a very specific tax laws The total income of mr Funt during this year is equal to burles and the amount of tax he has to pay is calculated as the maximum divisor of not equal to of course For example if then Funt has to pay burles while for he needs to pay and if he pays only burle As mr Funt is a very opportunistic person he wants to cheat a bit In particular he wants to split the initial in several parts here is arbitrary even is allowed and pay the taxes for each part separately He can t make some part equal to because it will reveal him So the condition should hold for all from to Ostap Bender wonders how many money Funt has to pay i e minimal if he chooses and optimal way to split in parts ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "The first obvious fact is that the answer for prime numbers is 1 If the number is not prime then the answer is at least 2 When is it possible It is possible in 2 cases when it is sum of 2 primes of its maximal divisor is 2 If 2 divides n then so does integer n 2 n 2 2 n 4 n 4 where n is prime According to Goldbach s conjecture which is checked for all numbers no more than 10 9 every number is a sum of two prime numbers Odd number can be sum of two primes if n 2 is prime the only even prime number is 2 Otherwise the answer is 3 n 3 n 3 n 3 is sum of 2 primes because it is even "}
{"statement": "In distant future on Earth day lasts for hours and that s why there are timezones Local times in adjacent timezones differ by one hour For describing local time hours numbers from to are used i e there is no time 0 hours instead of it hours is used When local time in the st timezone is hour local time in the th timezone is hours Some online programming contests platform wants to conduct a contest that lasts for an hour in such a way that its beginning coincides with beginning of some hour in all time zones The platform knows that there are people from th timezone who want to participate in the contest Each person will participate if and only if the contest starts no earlier than hours 00 minutes local time and ends not later than hours 00 minutes local time Values and are equal for all time zones If the contest starts at hours 00 minutes local time the person won t participate in it Help platform select such an hour that the number of people who will participate in the contest is maximum ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Initially compute prefix sums for each the total number of people in timezones from the first to the th Let s loop through all possible starting times of the competition Each starting time gives as one or two segments of timezones in which people will compete in the contest We can easily compute the total number of participants in with the use of prefix sums The total complexity is "}
{"statement": "Marina loves strings of the same length and Vasya loves when there is a third string different from them in exactly characters Help Vasya find at least one such string More formally you are given two strings of length and number Let s denote as the number of characters in which strings and are different Then your task will be to find any string of length such that If there is no such string print ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s find a string that will be equal to in positions and equal to in positions Let s denote quantity of that If then let s take positions such that and put in answer the same symbols Then put in other positions symbols which are not equal to corresponding in and we can do it because we have 26 letters Now So if there is an answer where exists such that let s denote and then in any position such that and and in the same position in we will choose such that and we can do it because So for every position from we can put symbols equal to corresponding symbols in and Now we have strings of length such that for every i and we should find string such that We know that so may be equal to corresponding in or to corresponding in or not equal to and to So we need at least symbols in answer to make and Consequently if the answer is and else just put first symbols in answer from next symbols from and others won t be equal to corresponding in and Solution works in "}
{"statement": "Vitaly503 is given a checkered board with a side of n and k chips He realized that all these k chips need to be placed on the cells of the board no more than one chip can be placed on a single cell Let s denote the cell in the i th row and j th column as i j A diagonal is the set of cells for which the value i j is the same For example cells 3 1 2 2 and 1 3 lie on the same diagonal but 1 2 and 2 3 do not A diagonal is called occupied if it contains at least one chip Determine what is the minimum possible number of occupied diagonals among all placements of k chips ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Obviously in this case it is worth filling the largest diagonal with chips then two that are smaller in size and so on The asymptotics turns out to be "}
{"statement": "You are given an integer array a 1 a 2 ldots a n The array b is called to be a of a if it is possible to remove some elements from a to get b Array b 1 b 2 ldots b k is called to be if it is not empty and for every i 1 le i le k b i is divisible by i Find the number of good subsequences in a modulo 10 9 7 Two subsequences are considered different if index sets of numbers included in them are different That is the values of the elements do not matter in the comparison of subsequences In particular the array a has exactly 2 n 1 different subsequences excluding an empty subsequence ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Let s introduce the following dynamic programming approach where indicates the number of ways to select a good subsequence of size from elements Our final answer will be Now maintaining a 2 D dp will exceed memory limit however notice that is calculated only on the basis of hence mainitaining a 1 D dp will work Also now is updated if and only if is a divisor of We can find divisors of a number in Overall Complexity Here indicates maximum number of divisors possible and indicates maximum value of possible Also we can use sieve to compute divisors of each number and achieve complexity of "}
{"statement": "You are given a permutation a 1 a 2 ldots a n of the first n positive integers A subarray l r is called if we can rearrange it so that it becomes a sequence of consecutive integers or more formally if max a l a l 1 ldots a r min a l a l 1 ldots a r r l For each k in the range 0 n print out the number of copium subarrays of a over all ways of rearranging the last n k elements of a ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "SolutionSolve the problem for fixed Call the last elements as special numbers Observation In optimal rearrangement every maximal segment of special numbers will be placed on consecutive positions in either ascending order or descending order For simplicity from now on we will call maximal segment of special number as maximal segment For example take a permutation and the maximal segments are and We divide the set of copium subarrays into three parts one for those lie entirely on prefix one for those lie entirely on suffix and one for the rest The number of subarrays in the first part can be calculated with the algorithm used in 526F Pudding Monsters The number of subarrays in the second part can be easily deduced from above observation Define an array such that for each and subarray contains consecutive nonspecial numbers For example take a permutation and then We will process array from right to left while adding special numbers from left to right Let us consider first add all special numbers which are missing from subarray at the end of current permutation If is not already copium we increase our answer by one Denote and as the minimum and maximum number in subarray Loot at two maximal segments one contains and one contains We can place them here to increase the answer For example let and the current permutation The two maximal segments are and We can place them like to increase the answer by 4 Furthermore we can see that three good positions and benefit from maximal segment In general consider consecutive good positions satisfying all of them can benefit from the same maximal segment if for all subarray is copium There is a similar condition when we consider consecutive good positions having the same So the algorithm goes like this For each value of and find the longest segment of good positions satisfying condition then multiply with the length of corresponding maximal segment and add to the answer Solve for each We will calculate the answer for each from to in this order We will store the longest segment for each prefix of equivalent and equivalent positions Note that when going from to only a suffix of will no longer be good so we can manually delete them one by one from right to left then add There will be at most good positions we need to consider The first one of course is If or let be the last position satisfying or the second one is the first good position after and it satisfies a property It must be the last position in the equivalent or equivalent positions The proof is left as an exercise Therefore updating this position will not affect the positions behind it The overall complexity is "}
{"statement": "The Fair Nut is going to travel to the Tree Country in which there are n cities Most of the land of this country is covered by forest Furthermore the local road system forms a tree connected graph without cycles Nut wants to rent a car in the city u and go by a simple path to city v He hasn t determined the path so it s time to do it Note that chosen path can consist of only one vertex A filling station is located in every city Because of strange law Nut can buy only w i liters of gasoline in the i th city We can assume that he has Each road has a length and as soon as Nut drives through this road the amount of gasoline decreases by length Of course Nut can t choose a path which consists of roads where he runs out of gasoline He can buy gasoline in visited city even in and He also wants to find the maximum amount of gasoline that he can have at the end of the path Help him count it ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Let s write on edge with length number Let sum on the path be sum of amounts of gasoline which can be bought in cities on this path plus sum of the numbers which were written on its edges If we don t run out of gasoline on some path sum on it will be equal to amount of gasoline at the end of way If we run out of gasoline on a path we can start from the next city after the road where it happened and sum on the path won t decrease So there is a path with maximal sum where we don t run out of gasoline This sum is answer to the problem How to find it Let is maximal sum on vertical way which starts in vertex It is not difficult to calculate using values for children of vertex Every way can be divided to two vertical ways so we can calculate answer by turning over which is the highest vertex of a path and taking the two biggest vertical ways which starts from vertex "}
{"statement": "Petya s been bored at work and he is killing the time by watching the parking lot at the office The parking lot looks from above like an table a cell of the table corresponds to a single parking spot Some spots in the parking lot are taken others are empty Petya watches cars riding into the parking lot one by one After a car settles down at the parking spot Petya amuzes himself by counting what maximum square of empty spots i e a square subtable can be seen on the parking lot if we look at it from above Also he takes notes of the square s size side length in his notebook You task is given the state of the parking lot at the initial moment of time and the information about where the arriving cars park restore what Petya wrote in his notebook It is midday so nobody leaves the lot ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "let s consider all empty square in the table There a too many of them but imagine that we can afford to loop through all of them If we fix a square we can find out when it is no longer empty find the first event that belongs to this square Let this event has number and the size of the square is Now we can update the answers for all events with numbers less than with a value of The model solution use the idea of Divide and Conquer Let s make a recursive routine that takes a rectangular sub table bounded with and a list of events that happen inside this sub table The purpose of the routine is to consider how maximal empty squares in this sub table change in time and to update the answers for some of the events Let s assume that the opposite case is symmetric Take the middle row Virtually split all the squares inside the sub table into those which lie above those which lie below and those which intersect For the first two parts make two recursive calls splitting the list of events as well Now focus on the squares that intersect the row Using initial table for each cell we can precompute the distance to the nearest taken cell in all four directions or the distance to the border if there is no such cell Using this values build two histograms for the row the first is an array of values where the second is an array of values where I say histograms here because these arrays actually can be viewed as heights of empty columns pointing from the row upwards and downwards Lets call the first histogram upper the second one lower Now consider all events inside the sub table in the order they happen Each event changes a single value in a histogram If after some event the maximum empty square found in the histograms has size and the next event has number we can update answers for all events with numbers with the value of It remains to learn to find a maximum square in two histograms It can be done by a two pointer approach Set both pointers to the beginning Move the second pointer until there is such square in histograms there is a square with side length if minimum on the interval in the upper histogram minimum on the interval in the upper histogram 1 k When the second pointer can not be moved any more update the answer and move the first pointer To find the minimum in O 1 author s solution creates a queue with minimum in O 1 support That is the maximum square can be found in linear time Let s try to estimate the running time Each call of the routine omitting inner calls costs where is the shortest side of the sub table and is the number of events in it If we draw a recursion tree we will see that each second call decreases twice The total cost of all operations in a single level of a recursion tree is where is the total number of events As long as we have overall complexity is "}
{"statement": "You are given a permutation p of length n A permutation is an array consisting of n distinct integers from 1 to n in any order For example 2 3 1 5 4 is a permutation while 1 2 2 is not since 2 appears twice and 1 3 4 is also not a permutation as n 3 but the array contains 4 To the permutation p you need to apply the following operation First you choose a segment l r 1 le l le r le n a segment is a continuous sequence of numbers p l p l 1 ldots p r 1 p r and reverse it Reversing a segment means swapping pairs of numbers p l p r p l 1 p r 1 p l i p r i where l i le r i Then you swap the prefix and suffix r 1 n and 1 l 1 note that these segments may be empty For example given n 5 p 2 color blue 3 color blue 1 5 4 if you choose the segment l 2 r 3 after reversing the segment p color green 2 color blue 1 color blue 3 color green 5 color green 4 then you swap the segments 4 5 and 1 1 Thus p color green 5 color green 4 1 3 color green 2 It can be shown that this is the maximum possible result for the given permutation You need to output the lexicographically permutation that can be obtained by applying the operation described A permutation a is lexicographically greater than permutation b if there exists an i 1 le i le n such that a j b j for 1 le j i and a i b i ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "In these constraints we could solve the problem for Let us note that there can be no more than two candidates for the value Since the first number in the permutation will be either if or if Then let s go through the value of and choose the one in which the first number in the resulting permutation is as large as possible Next if then we can have two candidates for is but note that it is always advantageous to put in that case since it will not spoil the answer Then we can go through and get the solution by the square but we can do something smarter Notice now that the answer already contains all the numbers where And then we write where is still unknown and then In that case let s write as and then write as long as they are larger than Otherwise we immediately determine the value of and finish the answer to the end Thus constructively we construct the maximal permutation "}
{"statement": "Polycarp has a string s Polycarp performs the following actions until the string s is empty t is initially an empty string he adds to the right to the string t the string s i e he does t t s where t s is a concatenation of the strings t and s he selects an arbitrary letter of s and removes from s all its occurrences Polycarp performs this sequence of actions in this order Note that after Polycarp finishes the actions the string s will be empty and the string t will be equal to some value that is undefined and depends on the order of removing E g consider s so the actions may be performed as follows t the letter is selected then s t the letter is selected then s t the letter is selected then s the empty string You need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Suppose it s given a string for which the answer exists Consider the last non empty value of Only letter occurs in the value and the letter is the last removed letter At the same time the value of is a suffix of so the last character of is the last removed letter Consider the second last non empty value of It contains exactly distinct letters so that one of them is the last removed letter and the other is the second last removed letter The concatenation of the second last and the last values of is a suffix of consisting only of the letters Therefore the letter which occurrence is the last of the occurrences of all letters except the last removed one is the second last removed letter Considering so other values we are proving that the order of removing the letters is the order occurrences of the letters occur in the string Suppose is the number of the step in which some letter was removed is the number of occurrences of the letter in the value of The letter occurs in exactly different values of In each of them the letter occurs exactly times So the letter occurs in exactly times Therefore using the number of the step in which the letter was removed and the number of the letter s occurrences in let s calculate the number of the letter s occurrences in the string If isn t completely divisible by there s no solution The sum of all of all letters occurring in is the length of the initial value of Since the initial value is a prefix of the possible answer is the prefix of having the length equal to the sum of all Before outputting the prefix check that you can get from the supposed value of the string the string Checking it you may use the algorithm from the statement If the resulting string is equal to the answer is correct and must be outputted otherwise there s no solution "}
{"statement": "Genos and Saitama went shopping for Christmas trees However a different type of tree caught their attention the exalted Power Tree A Power Tree starts out as a single root vertex indexed A Power Tree grows through a magical phenomenon known as an update In an a single vertex is added to the tree as a child of some other vertex Every vertex in the tree the root and all the added vertices has some value associated with it The of a vertex is defined as the strength of the multiset composed of the value associated with this vertex and the of its direct children The of a multiset is defined as the sum of all elements in the multiplied by the number of elements in it Or in other words for some Saitama knows the that will be performed on the tree so he decided to test Genos by asking him queries about the tree during its growth cycle An update is of the form and adds a new vertex with value as a child of vertex A query is of the form and asks for the power of vertex Please help Genos respond to these queries modulo ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Let s solve a restricted version of the problem where all queries are about the root First however let us define some notation In this editorial we will use d x to denote the number of children of vertex x If there is an update involved d x refers to the value prior to the update To deal these queries notice that each vertex within the tree has some contribution ci to the root power This contribution is an integer multiple mi of each vertex s value vi such that ci mi vi If we sum the contributions of every vertex we get the power of the root To deal with updates notice that adding a vertex u to a leaf p scales the multiplier of every vertex in p s subtree by a factor of As for the contribution of u notice that mu mp Now in order to handle both queries and updates efficiently we need a fast way to sum all contributions a way to scale contributions in a subtree and a way to add new vertices This sounds like a job for a segment tree We all know segment trees hate insertions so instead of inserting new vertices we pre build the tree with initial values 0 updating values instead of inserting new vertices In order to efficiently support subtree modification we construct a segment tree on the preorder walk of the tree so that every subtree corresponds to a contiguous segment within the segment tree This segment tree will store the contributions of each vertex and needs to support range sum query range multiply update and point update updating a single element The details of implementing such a segment tree and are left as an exercise to the reader Armed with this segment tree queries become a single range sum Scaling the contribution in a subtree becomes a range multiply we don t need to worry about multiplying un added vertices because they are set to 0 And adding a new vertex becomes a range sum query to retrieve the contribution of the parent and then a point set to set the contribution of the added vertex Finally to solve the full version of the problem notice that the power of a non root vertex w is a scaled down range sum in the segment tree The value of the scale is the proof of which is left as an exercise to the reader "}
{"statement": "Polycarp knows that if the sum of the digits of a number is divisible by 3 then the number itself is divisible by 3 He assumes that the numbers the sum of the digits of which is divisible by 4 are also somewhat interesting Thus he considers a positive integer n interesting if its sum of digits is divisible by 4 Help Polycarp find the nearest larger or equal interesting number for the given number a That is find the interesting number n such that n ge a and n is minimal ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Even if we will iterate over all possible numbers starting from and check if sum of digits of the current number is divisible by we will find the answer very fast The maximum possible number of iterations is no more than "}
{"statement": "We define the operatorname MAD Maximum Appearing Duplicate in an array as the largest number that appears at least twice in the array Specifically if there is no number that appears at least twice the operatorname MAD value is 0 For example operatorname MAD 1 2 1 1 operatorname MAD 2 2 3 3 3 operatorname MAD 1 2 3 4 0 You are given an array a of size n Initially a variable sum is set to 0 The following process will be executed in a sequential loop until all numbers in a become 0 Set sum sum sum i 1 n a i Let b be an array of size n Set b i operatorname MAD a 1 a 2 ldots a i for all 1 le i le n and then set a i b i for all 1 le i le n Find the value of sum after the process ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Let s consider only non decreasing arrays Observe a continuous segments a l r x l r x 0 after one operation we get a l 1 min r 1 n x holds We can conclude that if for all non zero contiguous segments in the array except the last one their lengths are all greater than 1 then the array follows the right shift parttern Let s say this kind of array good The last problem is when will the array become good Let s assume we get the array b after one operation on array a we get bi bi 1 bi 2 We can infer that bi ai bi 1 ai 1 and there is at least aj ai 1 j i which shows that a is not non decreasing In other words after two operations we can always get a good array Then the calculating is trival Time complexity O n "}
{"statement": "Recently a dog was bought for Polycarp The dog s name is Cormen Now Polycarp has a lot of troubles For example Cormen likes going for a walk Empirically Polycarp learned that the dog needs at least walks for any two consecutive days in order to feel good For example if and yesterday Polycarp went for a walk with Cormen times today he has to go for a walk at least times Polycarp analysed all his affairs over the next days and made a sequence of integers where is the number of times Polycarp will walk with the dog on the th day while doing all his affairs for example he has to go to a shop throw out the trash etc Help Polycarp determine the minimum number of walks he needs to do additionaly in the next days so that Cormen will feel good during all the days You can assume that on the day before the first day and on the day after the th day Polycarp will go for a walk with Cormen exactly times Write a program that will find the minumum number of additional walks and the appropriate schedule the sequence of integers where means the total number of walks with the dog on the th day ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "If we don t make enough walks during days and it s better to make an additional walk on day because it also counts as a walk during days and and if we walk one more time on day it won t help us in the future So we can start iterating from the second day indexed We will add walks to the day and to our answer so Cormen has enough walks during days and After we have iterated through all days we can print the answer Time complexity "}
{"statement": "A permutation of length n is an array p p 1 p 2 dots p n which contains every integer from 1 to n inclusive and moreover each number appears exactly once For example p 3 1 4 2 5 is a permutation of length 5 For a given number n n ge 2 find a permutation p in which absolute difference that is the absolute value of difference of any two neighboring adjacent elements is between 2 and 4 inclusive Formally find such permutation p that 2 le p i p i 1 le 4 for each i 1 le i n Print any such permutation for the given integer n or determine that it does not exist ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "If then there is no answer You can do some handwork to be sure Otherwise the answer exists and there is one simple way to construct it firstly let s put all odd integers into the answer in decreasing order then put and all other even numbers in increasing order To test that it always works you can run some kind of checker locally you can check all tests very fast in less than one second this may be very helpful sometimes "}
{"statement": "The boy Vitya loves to listen to music very much He knows that n albums are due to be released this Friday i th of which contains k i tracks Of course Vitya has already listened to all the tracks and knows that in the i th album the coolness of the j th track is equal to a i j Vitya has a friend Masha whom he really wants to invite to the festival where his favorite bands perform However in order for a friend to agree she must first evaluate the released novelties Vitya knows that if Masha listens to a track that was cooler than all the previous ones she will get 1 unit of impression Unfortunately albums can only be listened to in their entirety without changing the songs in them in places Help Vitya find such an order of albums so that Masha s impression turns out to be as much as possible and she definitely went to the festival with him ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Solution Let s introduce the concept of a compressed album for an album which is obtained from the original one by removing all elements except those that are the first maxima on their corresponding prefixes For example For the album the album will be compressed Now we note that the solution of the original problem is reduced to solving the same problem but on compressed albums Indeed the answer to them will not be different because if some element increased the impression on ordinary albums then it will increase if you compress albums and vice versa Next it will be assumed that all albums have been compressed beforehand Let s introduce the maximum impression that can be obtained if there were no albums such that they have elements larger than Then is equal to or you can add another element or two if is the maximum element for some album Then for all compressed albums it can be recalculated through the value of at the point before the first element of the album or through Thus for recalculation it is enough to know for each which albums ended in this index as well as for each album its first element Solution for Let s now solve the complete problem For each value of let s remember the indexes of albums that contain an element equal to We go in order of increasing we maintain for each album the value of the maximum impression that can be obtained if there were no elements of large and Masha listened to the last album Suppose for the next there is an album that there is a song with the coolness of in it Then should be taken as the maximum of and the values for all such that the maximum element in the th album is less than the maximum element of th since she could listen to this track either next in this album or after listening to some other album completely Note that you can store the value of maximum for all albums for which the maximum value in them is less than and recalculate it when moving to storing those albums that have ended then you will get a solution for "}
{"statement": "You are given an integer n and an integer k Your task is to construct a matrix of size n times n consisting of numbers 0 and 1 in such a way that the following conditions are true or report that it is impossible the sum of all the numbers in the matrix is exactly k the bitwise texttt XOR of all the numbers in the row i is the same for each i the bitwise texttt XOR of all the numbers in the column j is the same for each j ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "SolutionFirst let s note that when is odd the solution doesn t exist It s obvious since in the solution the xors of all the rows are the same it follows that the parity of the number of s in each row is the same and let s remember that is even and from these conditions get that solution exists only when is even Second let s note that for or the solution exists only for For all other cases a solution always exists when we can fill submatrices of size when Let s note that Let s write in the following positions After this we should fill the remaining ones and let s note that There are obvious submatrices of size which aren t filled yet outside the top left submatrix If then we can fill as many of those submatrices as necessary otherwise if we can also fill with s the following positions too "}
{"statement": "Alice and Bob are playing a fun game on a tree This game is played on a tree with n vertices numbered from 1 to n Recall that a tree with n vertices is an undirected connected graph with n 1 edges Alice and Bob take turns with Alice going first Each player starts at some vertex On their turn a player must move from the current vertex to a neighboring vertex that has not yet been visited by anyone The first player who cannot make a move loses You are given two vertices u and v Represent the simple path from vertex u to v as an array p 1 p 2 p 3 ldots p m where p 1 u p m v and there is an edge between p i and p i 1 for all i 1 le i m You need to determine the winner of the game if Alice starts at vertex 1 and Bob starts at vertex p j for each j where 1 le j le m ", "greedy": 1, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "SolutionFirst let s understand how the game proceeds Alice and Bob start moving toward each other along the path from vertex to vertex At some vertex one of the players can turn into a subtree of a vertex that is not on the path After this both players go to the furthest accessible vertex Let the path from vertex to vertex be denoted as where and Initially Alice is at vertex and Bob is at vertex For each vertex on the path we define two values the number of vertices that Alice will visit if she descends into the subtree of vertex that does not lie on the path the number of vertices that Bob will visit if he descends into the subtree of vertex that also does not lie on this path Let the distance to the furthest vertex in the subtree of vertex be denoted as Then the number of vertices Alice can visit if she descends into the subtree at vertex the number of vertices Bob can visit if he descends into the subtree at vertex Now consider what happens if Alice is at vertex and Bob is at vertex If Alice decides to descend into the subtree of vertex she will visit vertices Meanwhile Bob can reach any vertex on the segment It is advantageous for Bob to descend into the subtree of the vertex with the maximum value of where Therefore it is beneficial for Alice to descend into the subtree of vertex if the following condition holds Otherwise she should move to vertex The situation for Bob is similar he will descend into the subtree of vertex if the condition analogous to Alice s condition holds for him To efficiently find the maximum on the segment one can use a segment tree or a sparse table This allows finding the maximum in for each query resulting in an overall time complexity of However it can be proven that instead of using a segment tree or sparse table one can simply iterate through all vertices on the segment and terminate the loop upon finding a greater vertex This approach will yield a solution with a time complexity of "}
{"statement": "Slime is interested in sequences He defined positive integer sequences p of length n as follows For each k 1 that presents in p there should be at least one pair of indices i j such that 1 leq i j leq n p i k 1 and p j k For the given integer n the set of all good sequences of length n is s n For the fixed integer k and the sequence p let f p k be the number of times that k appears in p For each k from 1 to n Slime wants to know the following value left sum p in s n f p k right textrm mod 998 244 353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "First we can make a bijection between all the good sequences and permutations Let a permutation of length be and we fill or sign between each and so the value of is the number of sign between plus one it s easy to proof that this is a correct bijection Let be the number of permutations of length that have at least signs in it Then for each sign we can combine the places next to it so for some combined places there are only one way to put the numbers in it for a fix set of numbers And we know that have sets of combined places so the value of is the number of ways to assign numbers into different sets From the EGF of the second kind of Stirling numbers we know that We can also use DP that similar with the Stirling numbers to get all When we find the answers for each we consider the contribution of each places so for each we need to find the number of permutations that have signs before it So we can get If we can find for each then we can find the answer in one convolution And because of the simple DP algorithm to find all so we can get a complexity to solve the problem and it can pass the easy version other forms of DP can also get to this time complexity but now we only introduce the form that leads to the solution of the hard version "}
{"statement": "Recently Luba learned about a special kind of numbers that she calls numbers The number is called iff its binary representation consists of consecutive ones and then consecutive zeroes Some examples of beautiful numbers More formally the number is beautiful iff there exists some positive integer such that the number is equal to Luba has got an integer number and she wants to find its greatest beautiful divisor Help her to find it ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Let s notice that there are only beautiful numbers less than Generate them all and select the greatest one which is also divisor of Overall complexity "}
{"statement": "A cooperative game is played by m people In the game there are 3m sheets of paper m sheets with letter m sheets with letter and m sheets with letter Initially each person is given three sheets possibly with equal letters The goal of the game is to allow each of the m people to spell the word using their sheets of paper In other words everyone should have one sheet with letter one sheet with letter and one sheet with letter To achieve the goal people can make Two people participate in each exchange Both of them choose exactly one sheet of paper from the three sheets they own and exchange it with each other Find the shortest sequence of exchanges after which everyone has one one and one ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1900", "problem_editorial": "For each person there are three essential cases of what they could initially have Three distinct letters No need to take part in any exchanges Two equal letters and another letter e g An extra must be exchanged with someone s Three equal letters e g One must be exchanged with someone s another must be exchanged with someone s Let s create a graph on three vertices Whenever person has an extra letter and is lacking letter create a directed edge marked with Once the graph is built whenever you have a cycle of length that is it means person needs to exchange for while person needs to exchange for Thus both of their needs can be satisfied with just one exchange Finally once there are no cycles of length note that the in degree and the out degree of every vertex are equal If e g there are edges it follows that there are edges and edges It means we can form cycles of length The cycles could also go in the opposite direction In any case each cycle of length can be solved using exchanges "}
{"statement": "Polycarp is designing a level for a game The level consists of n segments on the number line where the i th segment starts at the point with coordinate l i and ends at the point with coordinate r i The player starts the level at the point with coordinate 0 In one move they can move to any point that is within a distance of no more than k After their i th move the player must land within the i th segment that is at a coordinate x such that l i le x le r i This means After the first move they must be inside the first segment from l 1 to r 1 After the second move they must be inside the second segment from l 2 to r 2 After the n th move they must be inside the n th segment from l n to r n The level is considered completed if the player reaches the n th segment following the rules described above After some thought Polycarp realized that it is impossible to complete the level with some values of k Polycarp does not want the level to be too easy so he asks you to determine the minimum integer k with which it is possible to complete the level ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "First let s note that if we can pass a level with some value of then we can make all the same moves and pass it with a larger value This allows us to use binary search for the answer To check whether it is possible to pass the level with a certain we will maintain a segment in which we can find ourselves After each move it expands by in both directions and is reduced to the intersection with the segment where the player must be at that move If at any point the intersection becomes empty then it is impossible to pass the level with such "}
{"statement": "Vova decided to clean his room The room can be represented as the coordinate axis OX There are n piles of trash in the room coordinate of the i th pile is the integer p i All piles have coordinates Let s define a as the following process The goal of this process is to collect the piles in different x coordinates To achieve this goal Vova can do several possibly zero moves During one move he can choose some x and move from x to x 1 or x 1 using his broom Note that he can t choose how many piles he will move Also there are two types of queries 0 x remove a pile of trash from the coordinate x It is guaranteed that there is a pile in the coordinate x at this moment 1 x add a pile of trash to the coordinate x It is guaranteed that there is no pile in the coordinate x at this moment Note that it is possible that there are zero piles of trash in the room at some moment Vova wants to know the number of moves he can spend if he wants to do a before any queries He also wants to know this number of moves after applying each query Queries are applied in the given order Note that the doesn t actually happen and doesn t change the state of piles It is only used to calculate the number of moves For better understanding please read the section below to see an explanation for the first example ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "First let s understand that if we choose some subset of points then it does not matter to which point we move it inside the segment because the minimum number of moves will always be the same and it is equal to Okay we need to split all points into two subsets and collect all points of the first subset in some point inside it and the same with the second subset What can we notice If we sort the points it s always optimal to choose these subsets as segments I e if the maximum point of the first subset is the minimum point of the second subset is and we can swap them and decrease answers for both subsets So we need to cover all the points with two segments with the minimum total length What is this length It is is the maximum distance between two consecutive points i e So we can solve the problem in without queries But how to deal with queries Let s maintain the set which contains all points and the multiset set with repetitions that maintains all gaps between two adjacent points So the answer is maximum in the set of points minus minimum in the set of points minus maximum in the multiset of lengths How do we recalculate these sets between queries If some point is removed let s find the maximum point less than let it be and the minimum point greater than let it be in the current set of points Both these points can be found in a logarithmic time Then we need to remove with from the multiset and add to the multiset and of course remove from the set If some point is added then we need to remove from the multiset and add with to the multiset and add to the set So we can process every query in time and the total time complexity is "}
{"statement": "Alice and Bob play the following game Alice has a set S of disjoint ranges of integers initially containing only one range 1 n In one turn Alice picks a range l r from the set S and asks Bob to pick a number in the range Bob chooses a number d l le d le r Then Alice removes l r from S and puts into the set S the range l d 1 if l le d 1 and the range d 1 r if d 1 le r The game ends when the set S is empty We can show that the number of turns in each game is exactly n After playing the game Alice remembers all the ranges l r she picked from the set S but Bob does not remember any of the numbers that he picked But Bob is smart and he knows he can find out his numbers d from Alice s ranges and so he asks you for help with your programming skill Given the list of ranges that Alice has picked l r for each range help Bob find the number d that Bob has picked We can show that there is always a unique way for Bob to choose his number for a list of valid ranges picked by Alice ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "If the length of a range is 1 that is then Otherwise if Bob picks a number then Alice the sets and if existed back to the set Thus there will be a moment that Alice picks the range if existed and another moment to pick the range if existed as well Using the above observation for each range we can iterate the number from to check if both range if and if existed in the Alice s picked ranges Or in other words check if these ranges are given in the input For checking we can either use data structures supported in most programming languages or simply use a 2 dimensional array for marking the picked ranges The time complexity is therefore "}
{"statement": "has an array a consisting of n non negative integers and an unlucky integer T Let s denote the misfortune of array b having length m as f b the number of pairs of integers i j such that 1 le i j le m and b i b j T has to paint each element of a into one of two colors white and black for each element the color is chosen independently and then create two arrays c and d so that all white elements belong to c and all black elements belong to d wants to paint the elements in such a way that f c f d is possible For example if n 6 T 7 and a 1 2 3 4 5 6 it is possible to paint the 1 st the 4 th and the 5 th elements white and all other elements black So c 1 4 5 d 2 3 6 and f c f d 0 0 0 if n 3 T 6 and a 3 3 3 it is possible to paint the 1 st element white and all other elements black So c 3 d 3 3 and f c f d 0 1 1 Help to paint the array optimally ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let us partition the array into three sets such that contains all numbers less than contains all numbers equal to and contains all numbers greater than It is clear that Now since each pair in makes a sum of the best solution is to distribute all numbers in equally among and Time complexity Space complexity "}
{"statement": "The famous global economic crisis is approaching rapidly so the states of Berman Berance and Bertaly formed an alliance and allowed the residents of all member states to freely pass through the territory of any of them In addition it was decided that a road between the states should be built to guarantee so that one could any point of any country can be reached from any point of any other State Since roads are always expensive the governments of the states of the newly formed alliance asked you to help them assess the costs To do this you have been issued a map that can be represented as a rectangle table consisting of rows and columns Any cell of the map either belongs to one of three states or is an area where it is allowed to build a road or is an area where the construction of the road is not allowed A cell is called if it belongs to one of the states or the road was built in this cell From any passable cells you can move up down right and left if the cell that corresponds to the movement exists and is passable Your task is to construct a road inside a minimum number of cells so that it would be possible to get from any cell of any state to any cell of any other state using only passable cells It is guaranteed that initially it is possible to reach any cell of any state from any cell of this state moving only along its cells It is also guaranteed that for any state there is at least one cell that belongs to it ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2200", "problem_editorial": "Affirmation Suppose we are given an undirected unweighted connected graph and three distinct chosen vertices u v w of this graph We state that at least one minimum connecting network for these three vertices has the following form some vertex c is chosen and the resulting network is obtained as a union of shortest paths from c to each of the chosen vertices Proof One of the optimal subgraphs connecting these three vertices is always a tree Really we can take any connecting subgraph and while there are cycles remaining in it take any cycle and throw away any edge of this cycle Moreover only vertices u v and w are allowed to be leaves of this tree as we can delete from the network any other leaves and the network will still be connected If the tree has no more than three leaves it has no more than one vertex with the degree greater than 2 This vertex is c from the statement above Any path from c to the leaves may obviously be replaced with the shortest path Special case is than there is no node with the degree greater than 2 meaning one of u v or w lies on the shortest path connecting two other vertices The solution is find the shortest path from each of the chosen vertices to all other vertices and then try every vertex of the graph as c Time complexity is O V E To apply this solution to the given problem we should first build a graph where cells of the table stand for the vertices and two vertices are connected by an edge if the corresponding cells were neighboring Now we should merge all vertices of a single state in one in order to obtain a task described in the beginning Time complexity is a linear function of the size of the table "}
{"statement": "A team of SIS students is going to make a trip on a submarine Their target is an ancient treasure in a sunken ship lying on the bottom of the Great Rybinsk sea Unfortunately the students don t know the coordinates of the ship so they asked Meshanya who is a hereditary mage to help them He agreed to help them but only if they solve his problem Let s denote a function that alternates digits of two numbers f a 1 a 2 dots a p 1 a p b 1 b 2 dots b q 1 b q where a 1 dots a p and b 1 dots b q are digits of two integers written in the decimal notation without leading zeros In other words the function f x y alternately shuffles the digits of the numbers x and y by writing them from the lowest digits to the older ones starting with the number y The result of the function is also built from right to left that is from the lower digits to the older ones If the digits of one of the arguments have ended then the remaining digits of the other argument are written out Familiarize with examples and formal definitions of the function below For example f 1111 2222 12121212 f 7777 888 7787878 f 33 44444 4443434 f 555 6 5556 f 111 2222 2121212Formally if p ge q then f a 1 dots a p b 1 dots b q a 1 a 2 dots a p q 1 b 1 a p q 2 b 2 dots a p 1 b q 1 a p b q if p q then f a 1 dots a p b 1 dots b q b 1 b 2 dots b q p a 1 b q p 1 a 2 dots a p 1 b q 1 a p b q Mishanya gives you an array consisting of n integers a i your task is to help students to calculate sum i 1 n sum j 1 n f a i a j modulo 998 244 353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Let be the number of with length We will calculate each number s contribution in the answer separately When we calculate the contribution of the current number in the answer let s iterate over all lengths from to where is the maximum length of some number in the array and add the following value to the answer The function means that we merge the number with some it does not matter number of length and digits of will be on odd positions in the resulting number except some leading digits which will be on odd and on even position as well And the function does almost the same thing but it counts digits of on even positions Time complexity is with the constant factor "}
{"statement": "You are given an undirected graph constisting of vertices and edges Each edge of the graph has some non negative integer written on it Let s call a triple if and there is a path i e it can visit the same vertices and edges multiple times between vertices and such that xor of all numbers written on the edges of this path is equal to It s not hard to prove that there are finite number of such triples Calculate the sum over modulo of the values of over all triples ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2600", "problem_editorial": "Without loss of generality let s assume that the graph is connected If not we will calculate the answer for each connected component and then sum them up Let s hoose two arbitrary vertices and such that and try to find all the interesting triples of the form Let s find any path connecting these two vertices and calculate the xor of the numbers written on the edges of the path Let s denote the obtained xor as Then take an arbitrary interesting triple and any path with the xor of the numbers on it equals to Consider the cycle of the following form let s go through the first path and then through the reversed direction of the second path Thus we will get a cycle containing the vertex with the xor of the numbers on it equals to On the other hand we can take any cycle which starts and ends in the vertex with the xor of the numbers on it equals to and insert it before the path Thus we will get the path with the xor of the numbers on it equals to i e we will get an interesting triple Note that in the same manner we can add cycle that doesn t pass through the vertex To do this we can find any path from the vertex to some of the vertices of the cycle then go through the cycle itself and then add the edges of same path in reversed order As a result all the edges of this path will be included in the resulting path twice and will not affect the resulting xor From this we get the following idea for a fixed pair of vertices we can find some path between them and then add different cycles to it to obtain all interesting triples Basis of the cycle space of the graph can be obtained as follows we find some spanning tree and then for each edge which is not included in that tree add the cycle containing this edge and the path in the tree connecting its endpoints to the basis For each cycle of the basis we will find xor of the numbers written in its edges Now let s move from the operation of taking xor of numbers to the operations with vectors To do this we can represent all the numbers in the graph in the form of vectors of length where th element of the vector will be equal to the value of the th bit in this number Then taking xor of two numbers will be reduced to the addition of two vectors over the modulo As a result we can move from cycle space of the graph to the space A linear combination of cycles of the graph gives us a linear combination of vectors corresponding to xor of the numbers on the edges of the cycles The set of linear combinations of the vectors form a subspace of We can find the basis of this subspace using Gaussian elimination Let s denote the dimension of the basis as Then for every pair of vertices and the amount of interest triples for these vertices is equal to and all values of the parameter for these triples can be obtained by adding the vector corresponding to an arbitrary path between these vertices to the described subspace Let s choose a pair of vertices and and some bit and count how many times the value of will appear in the resulting sum Let s assume that the value of the th bit on the path between the chosen vertices is equal to If th bit is equal to one for at least one vector of the basis then this bit will be equal to one in the triples Otherwise th bit in all the triples will be equal to Let s start the depth first search from some vertex fixed vertex and find a paths to each vertex of the graph For each of this paths we calculate the value of xor of the numbers on them For each bit let s count how many times it was equal to zero and one on these paths denote this numbers and Then for a fixed bit for exactly pairs of vertices it will be equal to one on the path connecting this vertices and for pairs it will be zero Thus if the th bit is equal to one in at least one vector from the basis we should add to the answer In the other case if bits is equal to zero for all vectors from the basis we should add to the answer The resulting complexity of this solution is "}
{"statement": "A in an array with the length of is an element which occupies position number after we sort the elements in the non decreasing order the array elements are numbered starting with A median of an array is the number and a median of array the number We define an expression as the integer part of dividing number by number One day Vasya showed Petya an array consisting of integers and suggested finding the array s median Petya didn t even look at the array and said that it equals Petya is a very honest boy so he decided to add several numbers to the given array so that the median of the resulting array would be equal to Petya can add any integers from to to the array including the same numbers Of course he can add nothing to the array If a number is added multiple times then we should consider it the number of times it occurs It is not allowed to delete of change initial numbers of the array While Petya is busy distracting Vasya your task is to find the minimum number of elements he will need ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "If the initial array doesn t contain number than you definitely need to add it that s 1 to answer Than do the following While median is strictly less than you need to increase it Obviously the surest way to increase the median is to add a maximal possible number Similarly while the median is strictly more than add a number to the array Constraints are small so you can add the numbers one by one and recalculate the median after every addition Also there is a solution without any cases while the median isn t equal to just add one more number to array "}
{"statement": "You are given a sequence of integers of length n and integer number k You should print number x in the range of 1 10 9 i e 1 le x le 10 9 such that exactly k elements of given sequence are less than or equal to x Note that the sequence can contain equal elements If there is no such x print without quotes ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "In this problem you can do the following thing firstly let s sort our array Let will be the answer Then you have two cases if then otherwise for 0 indexed array Then you need to calculate the number of the elements of the array that are less than or equal to Let it be Then if or then print otherwise print "}
{"statement": "You are given two positive integer numbers and An array is called an of iff the following conditions are met There are elements in and all of them are integer numbers You have to count the number of pairwise distinct arrays that are factorizations of Two arrays and are considered different iff there exists at least one index such that Since the answer can be very large print it modulo ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Fill the array with ones Now we should take every prime divisor of and distribute maximum power of this prime to appear in of it into some cells of the array It is pretty well known problem it s equal to Take product of this values for every prime This will be the answer if there were no negative numbers But we should also multiply it by number of ways to select even number of position to put unary minuses like you can fill in position anyhow and the final one will be determined by parity of current count To process many queries you should factorize numbers in by precalcing the smallest prime divisor of every number up to with sieve of Eratosthenes get in by precalcing factorials and inverse factorials and get in binary exponentiation Overall complexity "}
{"statement": "The Little Girl loves problems on games very much Here s one of them Two players have got a string consisting of lowercase English letters They play a game that is described by the following rules The players move in turns In one move the player can remove an arbitrary letter from string If the player before his turn can reorder the letters in string so as to get a palindrome this player wins A palindrome is a string that reads the same both ways from left to right and vice versa For example string is a palindrome and string isn t Determine which player will win provided that both sides play optimally well the one who moves first or the one who moves second ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s calculate the number of letters with odd number of occurrences in Let this value be equal to If then first player can win immediately he can easily build palindrome placing equal letters in different sides of resulting string he always can do it because total number of all letters is even If then first player can win immediately again at first he builds palindrome from letters with even number of occurrences in after that he inserts the rest of the letters in the middle of built in previous step string Let s proof very useful statement If our problem has the following solution if is even than second player is winner otherwise first player is winner Let At the beginning of the game first player can make move of two types Using move of first type first player can decrease to by erasing one appearance of letter with odd number of occurrences But this move leads him to defeat because after this move second player can build palindrome Using move of second type first player can increase to by erasing one appearance of letter with even number of occurrences In this case second player can make similar move he will erase the same letter Since the number of moves of this type is finite sooner or later first player will have to make a move of first type After this move he loses immediately So if than second player is a winner Let First player can decrease to by erasing the letter with odd number of occurrences If second player will try to increase to again by erasing the similar letter first player can decrease to again he erases the same letter again It s easy to see that the last move in this sequence of moves will be the move of first player So first player always can change the game in such a way that This position is losing position for second player and winning position for first player Now we can easily proof our statement for any using mathematical induction So we have quite easy solution with time complexity C code Java code "}
{"statement": "Do you know a story about the three musketeers Anyway you will learn about its origins now Richelimakieu is a cardinal in the city of Bearis He is tired of dealing with crime by himself He needs three brave warriors to help him to fight against bad guys There are warriors Richelimakieu wants to choose three of them to become musketeers but it s not that easy The most important condition is that musketeers must know each other to cooperate efficiently And they shouldn t be too well known because they could be betrayed by old friends For each musketeer his is the number of warriors he knows excluding other two musketeers Help Richelimakieu Find if it is possible to choose three musketeers knowing each other and what is minimum possible sum of their recognitions ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1500", "problem_editorial": "Warriors are vertices and knowing each other is an edge We want to find connected triple of vertices with the lowest sum of degrees and print because we don t want to count edges from one chosen vertex to another Brute force is We iterate over all triples and consider them as musketeers They must be connected by edges they must know each other If they are then we consider sum of their degrees We must notice that there is low limit for number of edges So instead of iterating over triples of vertices we can iterate over edges and then iterate over third vertex It gives us and it s intended solution To check if third vertex is connected with other two you should additionally store edges in 2D adjacency matrix It s also possible to write it by adding if in right place in brute forces to get Check it out in code "}
{"statement": "Alex doesn t like boredom That s why whenever he gets bored he comes up with games One long winter evening he came up with a game and decided to play it Given a sequence consisting of integers The player can make several steps In a single step he can choose an element of the sequence let s denote it and delete it at that all elements equal to and also must be deleted from the sequence That step brings points to the player Alex is a perfectionist so he decided to get as many points as possible Help him ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": " In this task we need to maximize the sum of numbers that we took Let precalc array number of integers in array Now we can easily calculate the DP The answer is Asymptotics "}
{"statement": "Little Vova studies programming in an elite school Vova and his classmates are supposed to write progress tests for each test they will get a mark from 1 to Vova is very smart and he can write every test for any mark but he doesn t want to stand out from the crowd too much If the sum of his marks for all tests exceeds value then his classmates notice how smart he is and start distracting him asking to let them copy his homework And if the median of his marks will be lower than points then his mom will decide that he gets too many bad marks and forbid him to play computer games Vova has already wrote tests and got marks He doesn t want to get into the first or the second situation described above and now he needs to determine which marks he needs to get for the remaining tests Help him do that ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "First count the number of marks that are less than If there are more than such marks we can t satisfy the second condition about the median and the answer is 1 Otherwise we can get exactly such number of marks so that the total number of marks greater than or equal to is at least maybe it s already satisfied This is the required action for satisfying the second condition Now in order not to break the first condition get the remaining marks as lower as possible all ones and check the sum of the marks If it is greater than the answer is 1 otherwise the correct answer is found "}
{"statement": "Given a list of distinct values we denote with and the three smallest values in increasing order A permutation p 1 p 2 dots p n is if the following statement holds for all pairs l r with 1 le l l 2 le r le n If p l p r are not necessarily in this order the first and second minimum of p l p l 1 dots p r then the third minimum of p l p l 1 dots p r is either p l 1 or p r 1 You are given an integer n and a string s of length m consisting of characters and Count the number of permutations p 1 p 2 dots p n such that for all 1 le i le m p i p i 1 if s i p i p i 1 if s i As the result can be very large you should print it modulo 998 244 353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "SolutionFirst of all let us state the following lemma which is sufficient to solve the problem in if one ignores the constraints given by the string We omit the proof as it is rather easy compared to the difficulty of the problem as a whole Lemma The following statements hold for a permutation is good if and only if and are good where If then is good if and only if and are good where If and then is good if and only if it is bitonic i e where Given we say that a permutation of is consistent if for any if if Informally speaking a permutation is consistent if it satisfies the constraints given by when it is written in the positions For let be the the number of good permutations which are consistent and respectively No additional conditions Start with End with Start with and end with Start with and end with For and let Informally speaking is if and only if it can be and is if and only if it can be Thanks to the Lemma one has the following relations For Analogous formula for and and For Analogous formula for The problem asks to compute Thanks to the formulas stated above it is straightforward to implement an solution Now we will tackle the hard task of optimizing it to In order to compute we will compute and for all We have the recurrence relation for Setting 1 is equivalent to for and also for This looks very similar to an identify between generating functions a derivative on the left a product on the right but for the fact that depends on two parameters To overcome this issue let us proceed as follows Notice that if we set to any of the functions it holds whenever Hence let us define and analogously With these new definitions 2 becomes for Let and So 3 simplifies to We precompute in the values of and for We can also precompute in the values of for In we compute also for all Thus in we can compute for all the values It is now time to start working with generating functions Let We know and at least the first coefficients and we want to compute Since we know Moreover 4 is equivalent to the ordinary differential equation This ODE is standard and its unique solution is given by Since the product of generating functions and the exponential of a generating function can be computed in we are able to obtain the values of for all and thus the values of Now let us see how to compute Since for all let us first compute for all By repeating verbatim the reasoning above we get that the generating function where is given by in this case So it remains only to compute for This can be done na vely in The overall complexity is "}
{"statement": "Buses run between the cities and the first one is at 05 00 AM and the last one departs not later than at 11 59 PM A bus from the city departs every minutes and arrives to the city in a minutes and a bus from the city departs every minutes and arrives to the city in a minutes The driver Simion wants to make his job diverse so he counts the buses going towards him Simion doesn t count the buses he meet at the start and finish You know the time when Simion departed from the city to the city Calculate the number of buses Simion will meet to be sure in his counting ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "The problem was suggested by Sergey Erlikh unprost Consider the time interval when Simion will be on the road strictly between cities Let s iterate over the oncoming buses Let be the time interval when the oncoming bus will be strictly between two cities If the intersection of that intervals is not empty than Simion will count that bus solution "}
{"statement": "Gildong is developing a game consisting of n stages numbered from 1 to n The player starts the game from the 1 st stage and should beat the stages in increasing order of the stage number The player wins the game after beating the n th stage There is at most one checkpoint on each stage and there is always a checkpoint on the 1 st stage At the beginning of the game only the checkpoint on the 1 st stage is activated and all other checkpoints are deactivated When the player gets to the i th stage that has a checkpoint that checkpoint is activated For each try of a stage the player can either beat the stage or fail the stage If they beat the i th stage the player is moved to the i 1 st stage If they fail the i th stage the player is moved to the most recent checkpoint they activated and they have to beat the stages after that checkpoint again For example assume that n 4 and the checkpoints are on the 1 st and 3 rd stages The player starts at the 1 st stage If they fail on the 1 st stage they need to retry the 1 st stage because the checkpoint on the 1 st stage is the most recent checkpoint they activated If the player beats the 1 st stage they re moved to the 2 nd stage If they fail it they re sent back to the 1 st stage again If they beat both the 1 st stage and the 2 nd stage they get to the 3 rd stage and the checkpoint on the 3 rd stage is activated Now whenever they fail on the 3 rd stage or the 4 th stage after beating the 3 rd stage they re sent back to the 3 rd stage If they beat both the 3 rd stage and the 4 th stage they win the game Gildong is going to build the stages to have equal difficulty He wants you to find any series of stages and checkpoints using at most 2000 stages where the expected number of tries over all stages is exactly k for a player whose probability of beating each stage is exactly cfrac 1 2 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "As already explained in the notes and is quite obvious the expected number of tries to beat stage with a checkpoint where stage also has a checkpoint or is the end of the game is What if stage doesn t have a checkpoint and stage has a checkpoint We can think of it like this It takes tries in expectation to get to stage and the player needs to add one more try trying times in total But this also has a probability of to succeed so the expected number of tries to actually get to stage is multiplied by making it in total This can be extended indefinitely Let s say is the expected number of tries to beat consecutive stages with only one checkpoint at the beginning If we extend it to consecutive stages it takes tries If this is not intuitive we can always use Monte Carlo method to simulate how many tries each takes The general term for this sequence is and it is introduced in OEIS A000918 with a similar example As each checkpoint makes the stages after that checkpoint independent of the previous stages we can just add up appropriate s to make it equal to Using means we append the stages in form where the number of s is As every term of the sequence is even the answer is if is odd Otherwise we can show that there always exists an answer for all even There are two simple strategies to make it with at most stages The first strategy is to greedily take the greatest where is the remaining number then append and subtract it from This works because either can be exactly or we can use once and repeat the process with The worst case for this strategy is to use all of and another which sums up to total of stages Another strategy is to use and if bit indexed is Since there can be at most bits the worst case for this strategy is still far less than Time complexity "}
{"statement": "There are n students standing in a circle in some order The index of the i th student is p i It is guaranteed that all indices of students are distinct integers from 1 to n i e they form a permutation Students want to start a round dance A round dance can be started if the student 2 comes right after the student 1 in clockwise order there are no students between them the student 3 comes right after the student 2 in clockwise order and so on and the student n comes right after the student n 1 in clockwise order A round dance is almost the same thing the only difference is that the student i should be right after the student i 1 in counterclockwise order this condition should be met for every i from 2 to n For example if the indices of students listed in clockwise order are 2 3 4 5 1 then they can start a clockwise round dance If the students have indices 3 2 1 4 in clockwise order then they can start a counterclockwise round dance Your task is to determine whether it is possible to start a round dance Note that the students cannot change their positions before starting the dance they cannot swap or leave the circle and no other student can enter the circle You have to answer q independent queries ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "We just need to find the position of the in the array and then check if the sequence is going counterclockwise or clockwise from the position or correspondingly We can do this by two cycles Total complexity "}
{"statement": "The Squareland national forest is divided into equal 1 times 1 square plots aligned with north south and east west directions Each plot can be uniquely described by integer Cartesian coordinates x y of its south west corner Three friends Alice Bob and Charlie are going to buy three distinct plots of land A B C in the forest Initially all plots in the forest including the plots A B C are covered by trees The friends want to visit each other so they want to clean some of the plots from trees After cleaning one should be able to reach any of the plots A B C from any other one of those by moving through adjacent cleared plots Two plots are adjacent if they share a side Of course the friends don t want to strain too much Help them find out the smallest number of plots they need to clean from trees ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "The smallest possible number of plots required to connect all three plots is at least where and here are extreme coordinate values among the three given plots It now suffices to find any suitable collection of plots of this size Let and be the median values of and For each of the plots connect it with the plot with any shortest path if one of coincides with just do nothing One can check that the resulting collection has size exactly and it clearly connects and together The above solution has complexity where is the largest coordinate value Given that is quite small one could go with slower solutions for instance instead of try all plots as the connecting plot "}
{"statement": "By 2312 there were Large Hadron Colliders in the inhabited part of the universe Each of them corresponded to a single natural number from to However scientists did not know what activating several colliders simultaneously could cause so the colliders were deactivated In 2312 there was a startling discovery a collider s activity is safe if and only if all numbers of activated colliders are pairwise relatively prime to each other two numbers are relatively prime if their greatest common divisor equals If two colliders with relatively nonprime numbers are activated it will cause a global collapse Upon learning this physicists rushed to turn the colliders on and off and carry out all sorts of experiments To make sure than the scientists quickness doesn t end with big trouble the Large Hadron Colliders Large Remote Control was created You are commissioned to write the software for the remote well you do not expect anybody to operate it manually do you Initially all colliders are deactivated Your program receives multiple requests of the form activate deactivate the th collider The program should handle requests in the order of receiving them The program should print the processed results in the format described below To the request of that is to activate the th collider the program should print exactly one of the following responses if the activation was successful if the th collider was already activated before the request if there is a conflict with the th collider that is the th collider is on and numbers and are not relatively prime In this case the th collider shouldn t be activated If a conflict occurs with several colliders simultaneously you should print the number of any of them The request of that is to deactivate the th collider should receive one of the following responses from the program if the deactivation was successful if the th collider was already deactivated before the request You don t need to print quotes in the output of the responses to the requests ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "The clueless solution store all the enabled numbers and compare each new number with each of them works too slow as we can add all the prime numbers below number of which is O n log n We can note that for each number k 1 at any time no more than one collider is turned on which number is divided by k Let us store an array which has in k th element the number of turned on collider which is divided by k on 0 if there is no such at the moment To enable the collider with number q we can look over q s divisors and check whether all the array s elements with these numbers have 0 s If some of them has a positive integer that s the number of collider we conflict with we can just print it and go on Otherwise we have to put q into all the overlooked elements This works in O M sqrt N N There s faster solution as we can store all of the above only for prime divisors Total size of the prime divisors list for number from 1 to N is O N log log N Thus we have a solution with complexity O N log log N M log N as the number of prime divisors of k doesn t exceed log k exact upper bound log k log log k 1 o 1 "}
{"statement": "Creatnx has n mirrors numbered from 1 to n Every day Creatnx asks exactly one mirror Am I beautiful The i th mirror will tell Creatnx that he is beautiful with probability frac p i 100 for all 1 le i le n Initially only the 1st mirror is a checkpoint It remains a checkpoint all the time Creatnx asks the mirrors one by one starting from the 1 st mirror Every day if he asks i th mirror there are two possibilities The i th mirror tells Creatnx that he is beautiful In this case if i n Creatnx will stop and become happy otherwise he will continue asking the i 1 th mirror next day In the other case Creatnx will feel upset The next day Creatnx will start asking You are given q queries each query is represented by an integer u If the u th mirror isn t a checkpoint then we set it as a checkpoint Otherwise the u th mirror is no longer a checkpoint After each query you need to calculate the expected number of days until Creatnx becomes happy Each of this numbers should be found by modulo 998244353 Formally let M 998244353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 le x M and x cdot q equiv p pmod M ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Assuming that currently there are checkpoints the journey becoming happy of Creatnx can be divided to stages where in th stage Creatnx moving from mirror to mirror at position Denote the th stage as These stages are independent so the sum of expected number of days Creatnx spending in each stage will be the answer to this problem When a new checkpoint appear between 2 old checkpoints and stage will be removed from the set of stages and 2 new stages will be added they are and Similarly when a checkpoint between 2 checkpoints and is no longer a checkpoint 2 stages and will be removed from the set of stages and new stage will be added These removed added stages can be fastly retrieved by storing all checkpoints in an ordered data structure such as in C For removed added stages we subtract add its expected number of days from to the current answer We see that when a query occurs the number of stages removed added is small just 3 in total Therefore if we can calculate the expected number of days for an arbitrary stage fast enough we can answer any query in a reasonable time From the solution of problem Beautiful Mirror we know that the expected number of days Creatnx spending in stage is The denominator can be computed by using a prefix product array a common useful trick We prepare an array where After that can be obtained by using 1 division For numerator we also use the same trick An array will be prepare where We have so "}
{"statement": "Imp is watching a documentary about cave painting Some numbers carved in chaotic order immediately attracted his attention Imp rapidly proposed a guess that they are the remainders of division of a number by all integers from to Unfortunately there are too many integers to analyze for Imp Imp wants you to check whether all these remainders are distinct Formally he wants to check if all are distinct i e there is no such pair that where is the remainder of division by ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Consider the way remainders are obtained Remainder can be obtained only when is taken modulo Remainder can either be obtained when taken modulo or Since the remainder modulo is already fixed the only opportunity left is Proceeding this way we come to a conclusion that if answer exists then holds This condition is equal to mod i e should be divisible by all numbers between and In other words must be divisible by their LCM Following the exponential growth of LCM we claim that when is huge enough the answer won t exists more precisely at And for small we can solve the task naively "}
{"statement": "You are given a binary table of size n times m This table consists of symbols 0 and 1 You can make such operation select 3 different cells that belong to one 2 times 2 square and change the symbols in these cells change 0 to 1 and 1 to 0 Your task is to make all symbols in the table equal to 0 You are allowed to make at most nm operations It can be proved that it is always possible ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1900", "problem_editorial": "Consider two cases If and there are only possible operations and we can use up to operations So one can check all the possible ways of choosing these operations and seeing which combination of these operation will result in a full grid Otherwise at least one of and is bigger than Without loss of generality imagine Take the th row For each cell within that row we can use one operation on it its left neighbour and the two cells above to fix this cell We can do this for the first cells in the row and fix the last two with one operation on them We will make at most operations and reach a situation with one empty row We can take the last row away and apply this procedure for the remaining grid If we say inductively that we will have at most operations for the remaining grid we will have done at most operations in total When we can do the same with the columns and when we can fix the remaining grid as we discussed above Time complexity for each case "}
{"statement": "Given a cyclic array a of size n where a i is the value of a in the i th position Let us define that a permutation of a is equal to another permutation of a if and only if their values are the same for each position i or we can transform them to each other by performing some cyclic rotation Let us define for a cyclic array b its number of components as the number of connected components in a graph where the vertices are the positions of b and we add an edge between each pair of adjacent positions of b with equal values note that in a cyclic array the first and last position are also adjacents Find the expected value of components of a permutation of a if we select it equiprobably over the set of all the different permutations of a ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "SolutionThe problem can be solved by applying Burnside s lemma The number of different permutations of the cyclic array is equal to the sum of number of fixed points for each permutation function divided by the number of permutations functions Let s focus on two parts First part find the number of different permutations of Let s define a permutation function as the function that cyclically shifts the array by positions In this problem for an array of size we have possible permutations functions and we would need to find the sum of the number of fixed points for each permutation function To find the number of fixed points for a permutation function we have that must be equal to if we add an edge for each position then by number theory we would obtain that cycles would be formed and each one of size then we can note that each position will belong to the th cycle so we can say that the problem can be transformed into counting the number of permutations with repetition in an array of size Let us denote as the number of values equal to in array when we are processing the function and we reduce the problem to an array of size we should also decrease to since each component is made up of values also we must observe that for solving a problem for an array of size then should be a divisor of Let us denote So to count the number of permutations with repetition for that can be formed with the frequency array we can use the formula Let us denote Let us denote as the number of divisors of Let us denote as the number of permutations with repetition for an array of size from what has been said before we have that must be divisible by so we only need to calculate the permutations with repetition for arrays Now suppose that the number of different values of array is then must be at most because the gcd of several numbers is always less than or equal to the smallest of them Now to calculate the permutations with repetition for a we do it in for that we need to precalculate some factorials and modular inverses before and since we need to calculate them times then we have that in total the complexity would be but since is at most and is at most substituting it would be equal to So to find the sum of the number of fixed points we need the sum of for and divides to at the end of all we divide the sum of the number of fixed points by and we would obtain the number of different permutations of To find the for we do it with the Euclid s algorithm in complexity so in total the complexity is Second part find the expected value of components of different permutations of Here we will use the Linear Expectation property and we will focus on calculating the contribution of each component separately the first thing is to realize that the number of components is equal to the number of different adjacent values so we only need to focus on two adjacent values except if it is a single component this would be a special case If we have different values we can use each different pair of them that in total would be pairs we can realize that when we put a pair its contribution would be equal to the number of ways to permute the remaining values which if we are in an array of size and we use the values and it would be equal to because we removing a value and another value from the set so if we have the formula and and are the first two elements then it would be which would be equivalent to Now to calculate the contribution of the pairs we can realize that taking common factor in the previous expression it only remains to find the sum of for all this can be found in easily by keeping the prefix sum and doing some multiplication Then at the end we multiply by since there are possible pairs of adjacent elements in the general array Let us define as the contribution of components of the permutations with repetition for an array of size then Now for each possible permutation with repetition we have by the Burnside s lemma that in the end we divide it by so we should also divide by the contribution of each component Let s define and Let s define as the sum of for and divide to Let s define as the sum of for and divide to The final answer would be The final complexity then is Code "}
{"statement": "Polycarp has a cat and his cat is a real gourmet Dependent on a day of the week he eats certain type of food on Mondays Thursdays and Sundays he eats on Tuesdays and Saturdays he eats on other days of week he eats Polycarp plans to go on a trip and already packed his backpack His backpack contains a daily rations of b daily rations of c daily rations of Polycarp has to choose such day of the week to start his trip that his cat can eat without additional food purchases as long as possible Print the maximum number of days the cat can eat in a trip without additional food purchases if Polycarp chooses the day of the week to start his trip optimally ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let the number of rations of fish food be the number of rations of rabbit stew be and the number of rations of chicken stakes be so we have an array consisting of elements Let be the maximum number of full weeks cat can eat if the starting day of the trip can be any day of the week The value of is Let s subtract the value from and from and We can see that we cannot feed the cat at least one more full week So the final answer is where Now it s time for some good implementation Of course you can try to analyze all cases and handle them using ifs or something similar but I will try to suggest you a good enough way to implement the remaining part of the problem Let s create an array of length where means the type of the food cat eats during the th day of the week for fish food for rabbit stew and for chicken stake It will be Now let s iterate over the day we will start our trip Let it be For the current starting day let be the number of rations cat has eaten already initially it is zero be the current day of the trip initially it is and the array be the copy of the array Then let s do the following sequence of the operations while is greater than zero decrease by one increase by one and set take it modulo and add one After this cycle we can update the answer with the value of "}
{"statement": "Catherine received an array of integers as a gift for March 8 Eventually she grew bored with it and she started calculated various useless characteristics for it She succeeded to do it for each one she came up with But when she came up with another one of all pairwise sums of elements in the array she realized that she couldn t compute it for a very large array thus she asked for your help Can you do it Formally you need to compute a 1 a 2 oplus a 1 a 3 oplus ldots oplus a 1 a n oplus a 2 a 3 oplus ldots oplus a 2 a n ldots oplus a n 1 a n Here x oplus y is a bitwise XOR operation i e x y in many modern programming languages You can read about it in Wikipedia https en wikipedia org wiki Exclusive orBitwise operation ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s calculate each bit in the answer separately Suppose we want to know the value of k th in 0 indexation bit in the answer Then we can notice that we are only interested in bits from 0 th to k th which means that we can take all numbers modulo 2k 1 After that the sum of the two numbers can t exceed 2k 2 2 k th bit is 1 if and only if sum belongs to 2k 2k 1 or 2k 1 2k 2k 2 2 So we have to count the number of pairs of numbers that give a sum that belongs to these segments Let s sort all numbers taken by modulo and make a pass with two pointers or do binary searches for each number "}
{"statement": "The Berland capital is shaken with three bold crimes committed by the Pihsters a notorious criminal gang The Berland capital s map is represented by an rectangular table Each cell of the table on the map represents some districts of the capital The capital s main detective Polycarpus took a map and marked there the districts where the first three robberies had been committed as asterisks Deduction tells Polycarpus that the fourth robbery will be committed in such district that all four robbed districts will form the vertices of some rectangle parallel to the sides of the map Polycarpus is good at deduction but he s hopeless at math So he asked you to find the district where the fourth robbery will be committed ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Required row is row that have only one star inside Requred column is comumn that also have only one star inside So you can iterate over all rows columns calculate number of stars inside them and find the answer "}
{"statement": "Timur has a stairway with n steps The i th step is a i meters higher than its predecessor The first step is a 1 meters higher than the ground and the ground starts at 0 meters Timur has q questions each denoted by an integer k 1 dots k q For each question k i you have to print the maximum possible height Timur can achieve by climbing the steps if his legs are of length k i Timur can only climb the j th step if his legs are of length at least a j In other words k i geq a j for each step j climbed Note that you should answer each question independently ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let s compute the prefix sums of the array let Rephrasing the problem for each question containing an integer we need to find the largest such that are all at most and then output In other words Let s make the prefix maximums of the array let Then we need to find the largest such that which is doable using binary search since the array is non decreasing Once we find the index we simply need to output The time complexity is per testcase "}
{"statement": "Polycarp is going to participate in the contest It starts at h 1 m 1 and ends at h 2 m 2 It is guaranteed that the contest lasts an even number of minutes i e m 1 ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Firstly let s parse both strings to four integers Just read them and then use some standard functions to transform them into integers or we can do it manually The second part is to obtain and Then let It is the answer We have to print and where is divided by rounding down and is modulo The only thing we should do more carefully is to print one leading zero before if it is less than and do the same for "}
{"statement": "Gustaw is the chief bank manager in a huge bank He has unlimited access to the database system of the bank in a few clicks he can move any amount of money from the bank s reserves to his own private account However the bank uses some fancy AI fraud detection system that makes stealing more difficult Gustaw knows that the anti fraud system just detects any operation that exceeds some fixed limit M euros and these operations are checked manually by a number of clerks Thus any fraud operation exceeding this limit is detected while any smaller operation gets unnoticed Gustaw doesn t know the limit M and wants to find it out In one operation he can choose some integer X and try to move X euros from the bank s reserves to his own account Then the following happens If X le M the operation is unnoticed and Gustaw s account balance raises by X euros Otherwise if X M the fraud is detected and cancelled Moreover Gustaw has to pay X euros from his own account as a fine If he has less than X euros on the account he is fired and taken to the police Initially Gustaw has 1 euro on his account Help him find the exact value of M in no more than 105 operations without getting him fired ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3200", "problem_editorial": "Our solution consists of two parts First of all find an upper bound for M To achieve this we try to query 1 2 4 8 and so on until we fail After the first unsuccessful query we will have 0 euro and know that the answer is on some segment 2k 2k 1 It takes at most 47 queries Now one could do something like the following binary search take the left border of our segment of money then on each query try the left border and then the middle If the queries are successful then all good otherwise we lose L R L2 where L is taken at the beginning of this iteration and all R L2 cannot sum up into something greater than the initial left border we obtained because initially R L L and each time R L decreases twice However this solution requires another 2log 1014 queries which is too much Let s divide the segment into two non equal parts sometimes Note that if the left side of the partition doesn t exceed half of the segment then that extra L we have is enough to cover all our expenses Also let s use that we actually get extra M L R2 after successful middle queries We want our algorithm to look something like the following Let the current segment equal l r and the current balance is at least l y r l for some integer y Then if y 0 then we query l and if y 1 then we query whatever we want on the segment It is easy to see that after an unsuccessful query our balance is at least l y 1 r l for new l and r and after a successful query we will think that our balance is at least l y 1 r l for new l or r The latter is not always the case we will discuss that later Now our balance is described by the only integer y Let dp x y equal the maximal d so that it s possible to find the answer on l l d having y l d money initially Then dp x y dp x 1 y 1 dp x 1 y 1 it is easy to compute and follow in the solution One can show that dp k 0 k k 2 It implies that k 49 This adds up to 97 queries Now remember that if we proceed from l r y to m r y 1 then our balance was y l r l and became y l m while we need y 1 m for our estimations Hence we need some extra cash to cover such expenses It can be proven that they don t exceed three of initial L s which gives the total of 100 queries "}
{"statement": "A non empty digit string is if the number of occurrences of each character in it doesn t exceed the number of distinct characters in it For example string is diverse because appears in it 1 time and the number of distinct characters in it is 1 string is diverse because appears in it 2 times and the number of distinct characters in it is 1 string is diverse because both and appear in it 2 times and the number of distinct characters in it is 2 string is diverse because appears in it 3 times and the number of distinct characters in it is 2 You are given a string s of length n consisting of only digits 0 to 9 Find how many of its frac n n 1 2 substrings are diverse A string a is a substring of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end Note that if the same diverse string appears in s multiple times each occurrence should be counted independently For example there are two diverse substrings in both equal to so the answer for the string is 2 ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "SolutionIn a diverse string there are at most distinct characters 0 1 9 Therefore each of these characters can appear at most times in a diverse string With all this in mind the maximum possible length of a diverse string is To solve this problem we only need to check whether each substring of length is diverse Time complexity per testcase "}
{"statement": "Ayrat has number represented as it s prime factorization of size i e Ayrat got secret information that that the product of all divisors of taken modulo is the password to the secret data base Now he wants to calculate this value ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Let d x be a number of divisors of x and f x be the product of divisors Let then There is pairs of divisors of type and if x is a perfect square we have one more divisor for a prime and the statement little Fermat theorem We can see that if a and b are co prime Now we can count the answer code 15260890 Another problem Given secquence distinct primes and q queries l r to calculate Can you solve with complexity Suppose r l 1 M const in all queries Can you solve with complexity "}
{"statement": "Valery is a PE teacher at a school in Berland Soon the students are going to take a test in long jumps and Valery has lost his favorite ruler However there is no reason for disappointment as Valery has found another ruler its length is centimeters The ruler already has marks with which he can make measurements We assume that the marks are numbered from 1 to in the order they appear from the beginning of the ruler to its end The first point coincides with the beginning of the ruler and represents the origin The last mark coincides with the end of the ruler at distance from the origin This ruler can be repesented by an increasing sequence where denotes the distance of the th mark from the origin Valery believes that with a ruler he can measure the distance of centimeters if there is a pair of integers and such that the distance between the th and the th mark is exactly equal to in other words Under the rules the girls should be able to jump at least centimeters and the boys should be able to jump at least centimeters To test the children s abilities Valery needs a ruler to measure each of the distances and Your task is to determine what is the minimum number of additional marks you need to add on the ruler so that they can be used to measure the distances and Valery can add the marks at any integer non negative distance from the origin not exceeding the length of the ruler ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "It is easy to see that the answer is always 0 1 or 2 If we can already measure both and output 0 Then try to measure both and by adding one more mark If it was not successful print two marks one at other at So how to check if the answer is 1 Consider all existing marks Let some mark be at Try to add the new mark in each of the following positions If it become possible to measure both and you have found the answer It is easy to check this if for example we are trying to add the mark at we just check if there is a mark at or by a binary search since the marks are sorted Make sure that the adde marks are in "}
{"statement": "You are given a string consisting of lowercase English letters and the integer One should choose some symbols from the given string so that any contiguous subsegment of length has at least one selected symbol Note that here we choose positions of symbols not the symbols themselves Then one uses the chosen symbols to form All symbols from the chosen position should be used but we are allowed to rearrange them in any order Formally we choose a subsequence of indices The selected sequence must meet the following condition for every such that there must be at least one selected index that belongs to the segment i e there should exist a from to such that Then we take any permutation of the selected indices and form a new string Find the lexicographically smallest string that can be obtained using this procedure ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "It is not hard to see that if we choose some subset of the letters then to achieve lexicographically smallest string you must first write all of the letters then all of the letters b and so on Let s assume that the string in the answer consists only of the letters Then it should be as small of them as possible to get lexicographically smallest string We can check whether it is enough to take only the letters to meet the requirement on the density of the indices in each subsegment of length it has to be at least one letter If this is true we can find the minimum number of letters which will satisfy the density requirement using the greedy algorithm every time we will take the rightmost letter which is separated from the previous one by no more than positions If this is not true then the answer must contain some other letters except for This means that we need to take as much letters as possible So we can take all of them because adding any additional letter will not affect the density requirement Then do the same with the letter bearing in mind that all of the letters is already taken If the letters is not enough then take all of the letters all of the letters and proceed to the next letter and so on "}
{"statement": "You are given a permutation p of size n You want to minimize the number of subarrays of p that are permutations In order to do so you must perform the following operation once Select integers i j where 1 le i j le n then Swap p i and p j For example if p 5 1 4 2 3 and we choose i 2 j 3 the resulting array will be 5 4 1 2 3 If instead we choose i j 5 the resulting array will be 5 1 4 2 3 Which choice of i and j will minimize the number of subarrays that are permutations A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array An array a is a subarray of an array b if a can be obtained from b by the deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let be the position of the element in and consider what happens if is in between and Notice that any subarray of size greater than that is a permutation must contain and So it must also contain every index in between including Therefore is an element of the permutation subarray so it must be of size at least and therefore must be the whole array Therefore if is in between and the only subarrays that are permutations are and These two subarrays will always be permutations so this is minimal To achieve this we have 3 cases If lies in between and swap and If swap with the smaller of If swap with the larger of In all three of these cases after the swap will lie in between and minimizing the number of permutation subarrays Complexity "}
{"statement": "Vova has won n trophies in different competitions Each trophy is either golden or silver The trophies are arranged in a row The of the arrangement is the length of the longest subsegment consisting of golden trophies Vova wants to swap two trophies not necessarily adjacent ones to make the arrangement as beautiful as possible that means to maximize the length of the longest such subsegment Help Vova Tell him the maximum possible beauty of the arrangement if he is allowed to do at most one swap ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let be the maximal segment of gold cups that begins in the cup Let be the maximum segment of gold cups that ends in the cup Also let the total number of gold cups be Note that it makes no sense to change the cups of the same color Then let s consider the silver cup which will change with the gold cup let its number be Then if then we will update the answer with the value and otherwise with the value This will not work if all the cups are golden In this case the answer is "}
{"statement": "Integers from 1 to n inclusive were sorted lexicographically considering integers as strings As a result array a 1 a 2 dots a n was obtained Calculate value of sum i 1 n i a i mod 998244353 mod 10 9 7 x mod y here means the remainder after division x by y This remainder is always non negative and doesn t exceed y 1 For example 5 mod 3 2 1 mod 6 5 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3400", "problem_editorial": "Suppose is an inverse permutation of that is that is is an index of in the lexicographical sorting Rewrite desired sum replacing First we need to understand how to calculate s Observe that equals plus number of integers so that These integers are of two possible kinds own prefixes of the number of such depends only on the length of and integers having a common prefix with of some length and a smaller digit in th index If we fix values of length of we have a mask of the following kind and we are interested in the number of matching this mask This number almost always depends on the number of with minor exceptions concerning E g consider for the example above So in the desired sum we group summands by the following markers of brute force the value of these markers Length of Position of first digit different in and cases where is an own prefix of shall be considered separately The value of this digit So we know description of of the following kind where are fixed and are arbitrary integer variables in Observe that both and are linear combination of variables and so is also a linear combination of them The only issue is computing modulo To do summing over all we use the meet in the middle method bruteforce separately the values for the first half and the second half and then match one with another If the solution works in or "}
{"statement": "You re given a tree consisting of n nodes Every node u has a weight a u You want to choose an integer k 1 le k le n and then choose k connected components of nodes that don t overlap i e every node is in at most 1 component Let the set of nodes you chose be s You want to maximize frac sum limits u in s a u k In other words you want to maximize the sum of weights of nodes in s divided by the number of connected components you chose Also if there are several solutions you want to Note that adjacent nodes belong to different components Refer to the third sample ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Assume you already chose the components Let the sum of nodes in the component be Then the expression in the problem is equivalent to Assume we only bother about the fraction maximization problem and don t care about Then it ll always be better to choose the component with the maximum and throw away the rest This is because of the famous inequality and the equality only occurs if all are equal This means that the maximum value of the fraction is simply the maximum sum of a sub component in the tree To calculate it let s root the tree at node 1 and calculate the maximum sum of a sub component that contains node Now I ll put the code and explain it after denotes the maximum sub component sum First we call We calculate the of all the children of For every child we extend the component of with the component of if and do nothing otherwise Now we solved the first half of our problem but what about maximizing Notice that all components you choose must have a sum of weights equal to because the equality occurs if and only if all are equal You just want to maximize their count Let s calculate our again Assume We have 2 choices either mark the and its component as a component in the answer but then other nodes won t be able to use them because the components can t overlap or wait and extend the component The idea is that there s no reason to wait If we extend the component with some nodes they won t change the sum and they may even have another sub component with maximal sum that we re merging to our component and wasting it Thus we ll always go with the first choice making so that its parent can t use it and increasing D Code link https pastebin com 8pCrTfuP Time complexity "}
{"statement": "You are given a tree dagger In one you can do follows Choose two vertices of the tree u and v Compress all the vertices on the path from u to v into one vertex In other words all the vertices on path from u to v will be erased from the tree a new vertex w will be created Then every vertex s that had an edge to some vertex on the path from u to v will have an edge to the vertex w Determine the minimum number of zelda operations required for the tree to have only one vertex dagger A tree is a connected acyclic undirected graph ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "SolutionWe can prove by induction that on any tree with leaves the answer is where with we denote the greatest integer smaller than This can be proven by induction we will give an overview of what a proof would look like For two leaves the answer is clearly For three leaves the answer is clearly For more than four leaves it is always the case that we can find two leaves for which the node that will be created as a result of applying an operation on these two will have degree greater than i e it will not be a leaf The third argument holds because in a tree with four leaves we have either at least two nodes with degree at least and as such we can choose two leaves which contain these two nodes on their chain or a node with degree at least Furthermore it reduces the number of leaves in the tree by "}
{"statement": "Nikita recently held a very controversial round after which his contribution changed very quickly The announcement hung on the main page for n seconds In the ith second a i th person either liked or removed the like Nikita was lucky in this task and there are no dislikes If a i 0 then the a ith person put a like If a i 0 then the person a i removed the like Since Nikita s contribution became very bad after the round he wanted to analyze how his contribution changed while the announcement was on the main page He turned to the creator of the platform with a request to give him the sequence a 1 a 2 ldots a n But due to the imperfection of the platform the sequence a was shuffled You are given a shuffled sequence of a that describes user activity You need to tell for each moment from 1 to n what the maximum and minimum number of likes could be on the post at that moment ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "SolutionLet s show a construction that maximizes the number of likes We need to first leave all the likes that we can put and only then delete them To minimize the number of likes we need to delete the like if we can immediately after we post it The code below implements these constructs "}
{"statement": "BerDonalds a well known fast food restaurant is going to open a cafe in Bertown The important thing is to choose the new restaurant s location so that it would be easy to get there The Bertown road system is represented by junctions connected by bidirectional roads For each road we know its length We also know that we can get from any junction to any other one moving along the roads Your task is to find such location of the restaurant that the shortest distance along the roads from the cafe to the farthest junction would be minimum Note that the restaurant can be located not only on the junction but at any point of any road ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "I ll tell a few ideas how to solve this problem Firstly describe the solution with time Consider every edge of length where could be the answer point Let this point lie at a distance from vertex So the distance from this point to vertex would be where distance between vertices and Equate these values and get the critical value for vertex It follows that the answer to the problem is half integer So for every edge and every other vertex we get set of critical points We should check them all include the vertices of the graph ends of the segments This solution may probably pass with some optimizations Another solution with complexity Multiply all weights by Consider every edge where should be the answer and make binary search for the answer in integers To check some current value you should consider every vertex and assume that the answer is achieved in this vertex In this case the answer point must lie on this edge some value or some value This subproblem is solved using offline algorithm using sorting events and maintaining the balance Also you can use ternary search on every edge of the graph But you should divide every edge on several segments and find the answer on every segment because the ternary search is incorrect in this problem The last two solutions can provide accepted if you realize them carefully Also note that there is the solution with complexity by the author RAD "}
{"statement": "Jellyfish has n green apples with values a 1 a 2 dots a n and Gellyfish has m green apples with values b 1 b 2 ldots b m They will play a game with k rounds For i 1 2 ldots k in this order they will perform the following actions If i is odd Jellyfish can choose to swap one of her apples with one of Gellyfish s apples or do nothing If i is even Gellyfish can choose to swap one of his apples with one of Jellyfish s apples or do nothing Both players want to maximize the sum of the values of their apples Since you are one of the smartest people in the world Jellyfish wants you to tell her the final sum of the value of her apples after all k rounds of the game Assume that both Jellyfish and Gellyfish play optimally to maximize the sum of values of their apples ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "TutorialLet us define to be the minimum value of in the current round to be the maximum value of in the current round to be the minimum value of in the current round to be the maximum value of in the current round to be the minimum value of all the apples to be the maximum value of all the apples By greedy and induction we would come to the following conclusion If Jellyfish is the one operating this round If she will swap this two apples otherwise she will do nothing If Gellyfish is the one operating this round If he will swap this two apples otherwise she will do nothing We consider who and will belong to after the first round In the first round If And because Jellyfish will swap this two apples So belongs to Jellyfish If If then Jellyfish will do nothing Otherwise Jellyfish won t swap the apple with value In conclusion belongs to Jellyfish We can also show that belongs to Gellyfish and the proof is symmetric with the above So in the second round We have So Gellyfish will swap this two apples in the third round Jellyfish will swap this two apples So after the first round the game will go two rounds at a time with two people swapping two apples with the minimum value and the maximum value back and forth So we only need to know the answer for and Time complexity per test case Memory complexity per test case "}
{"statement": "Little Elephant loves magic squares very much A is a table each cell contains some positive integer At that the sums of integers in all rows columns and diagonals of the table are equal The figure below shows the magic square the sum of integers in all its rows columns and diagonals equals 15 The Little Elephant remembered one magic square He started writing this square on a piece of paper but as he wrote he forgot all three elements of the main diagonal of the magic square Fortunately the Little Elephant clearly remembered that all elements of the magic square did not exceed Help the Little Elephant restore the original magic square given the Elephant s notes ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Since each number is less than or equal to you can loop all possible values the rest of cells can be calculated from this "}
{"statement": "Recently Polycarp noticed that some of the buttons of his keyboard are malfunctioning For simplicity we assume that Polycarp s keyboard contains 26 buttons one for each letter of the Latin alphabet Each button is either working fine or malfunctioning To check which buttons need replacement Polycarp pressed some buttons in sequence and a string s appeared on the screen When Polycarp presses a button with character c one of the following events happened if the button was working correctly a character c appeared at the end of the string Polycarp was typing if the button was malfunctioning characters c appeared at the end of the string For example suppose the buttons corresponding to characters and are working correctly and the button corresponding to is malfunctioning If Polycarp presses the buttons in the order then the string he is typing changes as follows rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow You are given a string s which appeared on the screen after Polycarp pressed some buttons Help Polycarp to determine which buttons are working correctly for sure that is this string could not appear on the screen if any of these buttons was malfunctioning You may assume that the buttons don t start malfunctioning when Polycarp types the string each button either works correctly throughout the whole process or malfunctions throughout the whole process ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "If a key malfunctions each sequence of presses of this key gives a string with even number of characters So if there is a substring consisting of odd number of equal characters such that it cannot be extended to the left or to the right without adding other characters then it could not be produced by presses of button if was malfunctioning The only thing that s left is to find all maximal by inclusion substrings consisting of the same character "}
{"statement": "You have an array a of n integers You perform exactly k operations on it In one operation you select any contiguous subarray of the array a possibly empty and insert the sum of this subarray anywhere in the array Your task is to find the maximum possible sum of the array after k such operations As this number can be very large output the answer modulo 10 9 7 Reminder the remainder of a number x modulo p is the smallest non negative y such that there exists an integer q and x p cdot q y ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s denote as the sum of the original array and as the sum of the subarray with the maximum sum from the original array We solve the problem when equals In this case we need to find the subarray of the array with the maximum sum and insert this sum anywhere in the array so the answer is Now let be In this case there is already a value where we insert the sum of the subarray with the maximum sum Then we can increase the sum of the subarray with the maximum sum by no more than we can increase it by simply by inserting it into the subarray with the maximum sum and obtain the sum of the subarray with the maximum sum Then insert it anywhere in the array thus obtaining the sum of the final array equal to Similarly for any the sum of the subarray with the maximum sum is initially then then then the answer is equal to "}
{"statement": "A boy Petya loves chess very much He even came up with a chess piece of his own a semiknight The semiknight can move in any of these four directions squares forward and squares to the right squares forward and squares to the left squares backward and to the right and squares backward and to the left Naturally the semiknight cannot move beyond the limits of the chessboard Petya put two semiknights on a standard chessboard Petya simultaneously moves with both semiknights The squares are rather large so after some move the semiknights can meet that is they can end up in the same square After the meeting the semiknights can move on so it is possible that they meet again Petya wonders if there is such sequence of moves when the semiknights meet Petya considers some squares bad That is they do not suit for the meeting The semiknights can move through these squares but their meetings in these squares don t count Petya prepared multiple chess boards Help Petya find out whether the semiknights can meet on some good square for each board Please see the test case analysis ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Autors have proposed different solutions One can notice that if semiknights did not have a meeting after first step it is not necessary they have a meeting in good square they will not meet at all This fact appears from board size and possible semiknight s moves As the initial semiknight s squares are considered good for the meeting the semiknights have arrived to the one square and then they move together to one of the initial squares and meeting will count "}
{"statement": "There is a card game called Durak which means Fool in Russian The game is quite popular in the countries that used to form USSR The problem does not state all the game s rules explicitly you can find them later yourselves if you want To play durak you need a pack of cards Each card has a suit and and a rank in the increasing order and At the beginning of the game one suit is arbitrarily chosen as trump The players move like that one player puts one or several of his cards on the table and the other one should beat each of them with his cards A card beats another one if both cards have similar suits and the first card has a higher rank then the second one Besides a trump card can beat any non trump card whatever the cards ranks are In all other cases you can not beat the second card with the first one You are given the trump suit and two different cards Determine whether the first one beats the second one or not ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": " Solution of this problem is written in the fourth paragraph of the statements You should carefully read and implement it Only one difficult part is how to to determine which card has higher rank You can for every card iterate over array 6 7 8 9 T J Q K A and determine numbers of ranks in this array Finally just compare them "}
{"statement": " You are given a permutation p 1 p 2 ldots p n of integers from 1 to n Let s define the weight of the permutation q 1 q 2 ldots q n of integers from 1 to n as q 1 p q 2 q 2 p q 3 ldots q n 1 p q n q n p q 1 You want your permutation to be as lightweight as possible Among the permutations q with the smallest possible weight find the lexicographically smallest Permutation a 1 a 2 ldots a n is lexicographically smaller than permutation b 1 b 2 ldots b n if there exists some 1 le i le n such that a j b j for all 1 le j i and a i b i ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "We will start by proving that the weight is at least where is the number of cycles and understanding the structure of optimal permutations in the process Again consider splitting of into cycles where a cycle is an array such that for Let s say there are of such cycles Now consider a graph on nodes and draw an edge from to for each from to there may be self loops and multi edges here Each node has one incoming and outgoing edge so the entire graph is split into several cycles Consider any such cycle where all are distinct Its contribution to the answer is We will show that This value is at least Wlog is the smallest among and is the largest with Then It s only when the numbers on the cycle are some consecutive numbers and are increasing on the path from the smallest number to the largest and decreasing on the way back It s just the case when all the inequalities in the expression above become equalities Now assign each cycle of a number from to and consider the graph on nodes draw an edge between the nodes corresponding to the cycles where and belong As and are in the same cycle for each we get that every two consecutive edges we draw share a node As we will draw an edge from every cycle the graph is connected Each edge in corresponds to an edge in edge between and in corresponds to an edge in between the nodes corresponding to the cycles where and belong Now consider any spanning tree in graph Clearly any cycle of length in can contain at most edges from it if it contained edges from it we would have a cycle in So the total sum of over all cycles in is at least and therefore the total contribution to the weight is at least Now let s give a characterization of all permutations which have the weight It turns out that they are in correspondence with graphs on nodes which satisfy the following conditions Each node has one incoming and one outgoing edge and therefore graph is split into cycles In if a cycle has length then it consists of consecutive integers where numbers go up from the smallest number to the largest and down on the way backThe sum of over all cycles is precisely If we draw an edge between two cycles of if an element of the first cycle is connected to the element of the second cycle in this graph on nodes is connected Each such graph is a corresponding graph of some optimal permutation The proof is left for the reader as an exercise Now how to solve our problem Let s build element by element The weights of all cyclic shifts of the same permutation are the same so we start with Now the only subproblem we have to be able to solve is to check if the current prefix of length is a prefix of some permutation with weight So we have to check if our current edges can be a subset of some graph satisfying all the conditions above Denote these edges If edge has consider segment and call it segment If edge has consider segment and call it segment If call node We can show that the following criteria are sufficient No two right segments intersect internally No two left segments intersect internally No right left segment contains a loop node Consider a graph on nodes corresponding to the cycles of For each if is contained in some segment draw an edge between the corresponding cycles in which are Then this graph can t have a cycle has to be a forest Consider a graph on nodes corresponding to the cycles of For each unless or are loop nodes or is the right end of two segments or is the left end of two segments draw an edge between the corresponding cycles in which are Then this graph must be connected These conditions may sound complicated but they are very simple implications of the conditions on above The proof that if these conditions are satisfied then edges form a subset of some valid is left to the reader as an exercise too tutorial is already too long sorry Total complexity is as we can do up checks and each check takes time "}
{"statement": "You are given a weighed undirected graph consisting of n vertices and m edges You should answer q queries the i th query is to find the shortest distance between vertices u i and v i ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2400", "problem_editorial": "Firstly let s find any spanning tree and root it at any vertex For each vertex we calculate the distance to the root let it be for vertex There are no more than edges that don t belong to the tree For each of these edges let s run Dijkstra s algorithm from some vertex incident to this edge Suppose we are answering a query If the shortest path between these vertices passes only along the edges of the tree then it can be calculated by the formula where is the lowest common ancestor of vertices and You may use any fast enough algorithm you know to calculate Otherwise there exists at least one vertex such that we ran Dijkstra s algorithm from it and it belongs to the shortest path Just iterate on every vertex for which we ran Dijkstra and update the answer with the value of where is the shortest path to the vertex from the fixed vertex "}
{"statement": "Today Wet Shark is given bishops on a by grid Both rows and columns of the grid are numbered from to Rows are numbered from top to bottom while columns are numbered from left to right Wet Shark thinks that two bishops attack each other if they share the same diagonal Note that this is the only criteria so two bishops may attack each other according to Wet Shark even if there is another bishop located between them Now Wet Shark wants to count the number of pairs of bishops that attack each other ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s start with two bishops x1 y1 and x2 y2 Notice that if x1 y1 attacks x2 y2 either x1 y1 x2 y2 OR x1 y1 x2 y2 So for each bishop x y we will store x y in one map and x y in another map "}
{"statement": "Vasya has got an undirected graph consisting of n vertices and m edges This graph doesn t contain any self loops or multiple edges Self loop is an edge connecting a vertex to itself Multiple edges are a pair of edges such that they connect the same pair of vertices Since the graph is undirected the pair of edges 1 2 and 2 1 is considered to be multiple edges Isolated vertex of the graph is a vertex such that there is no edge connecting this vertex to any other vertex Vasya wants to know the minimum and maximum possible number of isolated vertices in an undirected graph consisting of n vertices and m edges ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1300", "problem_editorial": "Vasya can decrease number of isolated vertices up to using one edge and pairing them So minimum number of isolated vertices is To calculate maximum number of isolated vertices let s keep number of non isolated vertices knowing that each pair connected by edge i e size of clique Let we have size of clique and edges remained unassigned at current step If then answer is Otherwise we need to increase clique with one vertex Maximum number of edges we can add to connect this vertex is So subtract it from and increase by one Repeat this step while greater than zero Answer is One corner case is next if then answer is not "}
{"statement": "Suppose you are given a string s of length n consisting of lowercase English letters You need to compress it using the smallest possible number of coins To compress the string you have to represent s as a concatenation of several non empty strings s t 1 t 2 ldots t k The i th of these strings should be encoded with one of the two ways if t i 1 meaning that the current string consists of a single character you can encode it paying a coins if t i is a substring of t 1 t 2 ldots t i 1 then you can encode it paying b coins A string x is a substring of a string y if x can be obtained from y by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end So your task is to calculate the minimum possible number of coins you need to spend in order to compress the given string s ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Let s say that is the minimal cost to encode the prefix of with length the answer is If we want to encode the prefix with length then the last symbol in our encoded string either equals or represents some substring so that it occurs in the prefix of length Therefore one can see that One way to implement this is to calculate this forward and use hashes but it may require some efforts to avoid collisions and fit into the time limit Another way is to find for each all appropriate s by calculating z function on the reverse of The total complexity in this case is "}
{"statement": "Luke Skywalker got locked up in a rubbish shredder between two presses R2D2 is already working on his rescue but Luke needs to stay alive as long as possible For simplicity we will assume that everything happens on a straight line the presses are initially at coordinates and and they move towards each other with speed and respectively Luke has width and is able to choose any position between the presses Luke dies as soon as the distance between the presses is less than his width Your task is to determine for how long Luke can stay alive ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Width of free space is decreasing by per second It means that it ll decrease from to in seconds The moment when width gets a value of is the last when Luke is alive so is the answer "}
{"statement": "Andrewid the Android is a galaxy famous detective Now he is busy with a top secret case the details of which are not subject to disclosure However he needs help conducting one of the investigative experiment There are pegs put on a plane they are numbered from to the coordinates of the th of them are Then we tie to the bottom of one of the pegs a weight on a tight rope of length thus its coordinates will be equal to where is the number of the used peg Then the weight is pushed to the right so that it starts to rotate counterclockwise At the same time if the weight during rotation touches some of the other pegs it then begins to rotate around that peg Suppose that each peg itself is very thin and does not affect the rope length while weight is rotating around it More formally if at some moment the segment of the rope contains one or more pegs in addition to the peg around which the weight is rotating the weight will then rotate around the farthermost one of them on a shorter segment of a rope In particular if the segment of the rope touches some peg by its endpoint it is considered that the weight starts to rotate around that peg on a segment of the rope of length At some moment the weight will begin to rotate around some peg without affecting the rest of the pegs Andrewid interested in determining the number of this peg Andrewid prepared queries containing initial conditions for pushing the weight help him to determine for each of them around what peg the weight will eventually rotate ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "I call the length of the part of the rope from the weight to the last met peg the active length denoted as After each met peg active length is reduced Let s process queries separately at each step we can find next peg with using binary search If active length becomes at least two times shorter or current step is the first one we proceed to the next step Otherwise say current peg is peg and the next one is peg without loss of generality Then after peg the rope will again touch peg and the weight will again rotate around peg Indeed so the weight will rotate around a peg not to the right to peg And either or so it won t also rotate around a peg to the left to peg As long as the weight will rotate around these two pegs so we can skip through several steps momentarily This way active length is shortened at least twice so there will be no more than steps Time solution "}
{"statement": "Given two positive integers n and k and another array a of n integers In one operation you can select any subarray of size k of a then remove it from the array without changing the order of other elements More formally let l r be an operation on subarray a l a l 1 ldots a r such that r l 1 k then performing this operation means replacing a with a 1 ldots a l 1 a r 1 ldots a n For example if a 1 2 3 4 5 and we perform operation 3 5 on this array it will become a 1 2 Moreover operation 2 4 results in a 1 5 and operation 1 3 results in a 4 5 You have to repeat the operation while the length of a is greater than k which means a gt k What is the largest possible median dagger of all remaining elements of the array a after the process daggerThe median of an array of length n is the element whose index is left lfloor n 1 2 right rfloor after we sort the elements in non decreasing order For example median 2 1 5 4 3 3 median 5 5 and median 6 8 2 4 4 ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Note in order to explain this solution easier we ll suppose all arrays are 0 indexed If we don t have to remove any segment since the statement only tell us to do it while the length of is greater than That way the median of is fixed Let s find a way to calculate this value without sorting the array Given an integer If is less than or equal to the median of then suppose we sort in increasing order is somewhat to the left of That means the number of elements greater than or equal to is more than the number of elements less than Using this observation we can create another array of the same size as such that if otherwise The trick here is if then the condition is satisfied Using this trick we can easily binary search the median of by fixing value of checking if and adjusting the value range of How about In this case we ll keep using the same strategy as above That is fix the value of find a way to delete segments of so that the array has largest sum check if that sum is greater than and adjust the value range of the answer Note that each time we delete a segment the size of is reduced by We do that until Let s call the final array after deleting segments After some calculation we come up with Also it can be seen that the elements where always originate from the elements such that Why Suppose we want to delete the segment from This operation shift all the elements from the right by units to the left which means the indexes are subtracted by units But if we only care about the indexes modulo before and after deleting the segments shifting units doesn t change their modulos at all With all above observations we come up with the following DP formula to find the optimal segment deletions If and then Otherwise If then maximize by Then the maximum sum of in the optimal deletions equals to Time complexity "}
{"statement": "A string s of length n 1 le n le 26 is called if it can be obtained using the following algorithm first write an empty string to s i e perform the assignment s then perform the next step n times at the i th step take i th lowercase letter of the Latin alphabet and write it either to the left of the string s or to the right of the string s i e perform the assignment s c s or s s c where c is the i th letter of the Latin alphabet In other words iterate over the n first letters of the Latin alphabet starting from and etc Each time we prepend a letter to the left of the string s or append a letter to the right of the string s Strings that can be obtained in that way are alphabetical For example the following strings are alphabetical and The following strings alphabetical and From the given string determine if it is alphabetical ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "For a start let s find the position of the letter in string If this position does not exist then the answer would be Suppose that this position exists and equals Let s create two pointers and Initially We will try to build string using the algorithm from the statement Suppose that we have built substring in iterations Consider the next letter of the Latin alphabet Let s look at cases find position of the letter in if it does not exist then if then make an assignment and process the next letter if then make an assignment and process the next letter otherwise string is not alphabetical and the answer is So if we have built the string in iteration then string is alphabetical and the answer is "}
{"statement": "You are given a sequence of numbers and a number Check if it is possible to choose a non empty subsequence such that the sum of numbers in this subsequence is divisible by ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Let s consider two cases n m and n m If n m let s look at prefix sums By pigeonhole principle there are two equals sums modulo m Assume Slmodm Srmodm Then the sum on segment l 1 r equals zero modulo m that means the answer is definitely YES If n m we ll solve this task using dynamic programming in O m2 time Assume can i r means if we can achieve the sum equal to r modulo m using only first i 1 items The updates in this dynamic programming are obvious we either take number ai and go to the state can i 1 r ai mod m or not then we ll get to the state can i 1 r "}
{"statement": "Kawashiro Nitori is a girl who loves competitive programming One day she found a string and an integer As an advanced problem setter she quickly thought of a problem Given a string s and a parameter k you need to check if there exist k 1 non empty strings a 1 a 2 a k 1 such that s a 1 a 2 ldots a k a k 1 R a k R a k 1 ldots R a 1 Here represents concatenation We define R x as a reversed string x For example R abcd dcba Note that in the formula above the part R a k 1 is intentionally skipped ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "If or is a palindrome the answer is yes Otherwise the answer is no Note that when the answer is no too The time complexity is for each test case "}
{"statement": "A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not You are given an integer n Your goal is to construct and print different regular bracket sequences of length 2n ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "There are many ways to solve this problem The model solution does the following thing start with the sequence merge the first characters into one sequence to get merge the first characters into one sequence to get and so on "}
{"statement": "John Doe has four arrays and Each array consists of integers Elements of all arrays are indexed starting from Array is a permutation of integers to John invented a game for his friends and himself Initially a player is given array The player must consecutively execute exactly operations on You are permitted to execute the following operations Operation 1 For each change into Expression means applying the operation of a bitwise xor to numbers and The given operation exists in all modern programming languages for example in language and it is marked as in as xor Operation 2 For each change into When this operation is executed all changes are made at the same time After all operations are applied the number of points the player gets is determined by the formula John wants to find out what maximum number of points a player can win in his game Help him ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Main idea bruteforce in complexity O Fun where Fu if fibonacci number at position u This problem had complex statements We have an array a and we can transform it in two ways The goal was to maximize the sum of all its elements with given multipliers after exactly u operations A simple bruteforce of all combinations of operations with subsequent modeling leads to complexity O 2u nu what is not fast enough That was possible to optimize it by modeling parallel to recursive bruteforce Now we have complexity O 2un Actually the correct solution is not too far from this algorithm There is just one conjecture every two successive xor operations change nothing and we can move them to any place of the combination Thus it will be enough to bruteforce only combinations in which every pair of successive xor operations is at the end It could be done using recoursive bruteforce We must change in previous solution two things First we must n t put xor after xor Besides that we should update answer if number u l is even where l is current level of recoursion all remaining operations in the end separates to pairs of xors Let s calculate complexity of this algo There are Fi sequences of length i without two consecutive xors It s easy to proof you can calculate some dp to see it That s why complexity of our algo is O Fun "}
{"statement": "Arkady is playing Battleship The rules of this game aren t really important There is a field of n times n cells There should be exactly one k decker on the field i e a ship that is k cells long oriented either horizontally or vertically However Arkady doesn t know where it is located For each cell Arkady knows if it is definitely empty or can contain a part of the ship Consider all possible locations of the ship Find such a cell that belongs to the maximum possible number of different locations of the ship ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s compute for each cell four values the number of cells where a part of the ship can be located to the right to the left up and down including the cell itself Then if then there are positions of the ship containing this cell and if it s easy to check whether this value is or After that you should just print the maximum among all cells This solution works in "}
{"statement": "In a computer game you are fighting against n monsters Monster number i has a i health points all a i are integers A monster is alive while it has at least 1 health point You can cast spells of two types Deal 1 damage to any single alive monster of your choice Deal 1 damage to all alive monsters If at least one monster dies ends up with 0 health points as a result of this action then repeat it and keep repeating while at least one monster dies every time Dealing 1 damage to a monster reduces its health by 1 Spells of type 1 can be cast any number of times while a spell of type 2 can be cast at most once during the game For every k 1 2 ldots n answer the following question Suppose that only the first k monsters with numbers 1 2 ldots k are present in the game What is the smallest number of times you need to cast spells of type 1 to kill all k monsters ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Continuing on the solution to the easy version now we have a set of integers we need to add elements into one by one and maintain the answer to the problem Recall that for every either or Note that can only happen when Let s call such an element If we remove a useless element the answer does not change If there are no useless elements we have and for that is Thus the answer to the problem can be easily calculated as where is the current size of the set We can formulate the condition there are no useless elements as follows For any let be the number of elements in not exceeding Then On the other hand suppose that for some we have Let s find the smallest such Then we can see that contains a useless element equal to and we can safely remove it We can check this condition after adding each new element to using a segment tree In every cell of the array maintained by the segment tree we will store the difference Initially cell contains value When a new element appears we should subtract from all cells in range Then if a cell with a negative value appears that is which is equivalent to we should find the leftmost such cell and remove an element equal to In particular we should add to all cells in range Thus we can use a segment tree with range add and global min At most one useless element can appear every time we enlarge and if that happens we can identify and remove it in resulting in an time complexity "}
{"statement": "The process of mammoth s genome decoding in Berland comes to its end One of the few remaining tasks is to restore unrecognized nucleotides in a found chain Each nucleotide is coded with a capital letter of English alphabet or Unrecognized nucleotides are coded by a question mark Thus is a string consisting of letters and characters It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "Let is the length of the given string The number of each letter in the resulting string must be equals to If does not equal to 0 there is no solution If some letter meets in the given string more than times there is no solution After that we always can build the answer We need to iterate through the given string and change question symbols on any letter which meets in the current string less than times "}
{"statement": "Anya loves to watch horror movies In the best traditions of horror she will be visited by ghosts tonight Anya has lots of candles prepared for the visits each candle can produce light for exactly seconds It takes the girl one second to light one candle More formally Anya can spend one second to light one candle then this candle burns for exactly seconds and then goes out and can no longer be used For each of the ghosts Anya knows the time at which it comes the th visit will happen seconds after midnight all s are distinct Each visit lasts exactly one second What is the minimum number of candles Anya should use so that during each visit at least candles are burning Anya can start to light a candle at any time that is integer number of seconds from midnight possibly at the time before midnight ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "This problem can be solved with help of greedy algorithm Let s iterate on moments when ghosts will appears We need to use use array in wich we will mark moments of time in wich we lighted candles for example put in corresponding positions 1 Than for every new ghost will count how many candles lights in time of his visit from our array If ghost appears in moment of time wi iterate on out array from wi 1 to wi t where t count of seconds which candle burns and count the number of ones If this count is not less than r continue iterating on ghosts Else iterate on our array from wi 1 to wi t and if in current second candle didn t lighted make it and put in this position in array 1 We need to do such operation while count of ones in this section of our array will not be equals to r If we can t do this fore some ghost we can print 1 Answer to this problem count of ones in our array Asymptotic behavior of this solution O mt where m count of ghosts t the duration of a candle s burning "}
{"statement": "Suppose you are performing the following algorithm There is an array v 1 v 2 dots v n filled with zeroes at start The following operation is applied to the array several times at i th step 0 indexed you can either choose position pos 1 le pos le n and increase v pos by k i or not choose any position and skip this step You can choose how the algorithm would behave on each step and when to stop it The question is can you make array v equal to the given array a v j a j for each j after some step ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "This is the solution that doesn t involve masks Let s reverse the process and try to get all zeroes from the array since all we can start from maximum The key idea since then there should be no more than one position such that and we should decrease it by Now we can decrease by and repeat the same process If at any step there are at least two or as result we won t get array filled with then there is no way to build the array "}
{"statement": "Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online Now players from all over the world can try his level All levels in this game have two stats to them the number of plays and the number of clears So when a player attempts the level the number of plays increases by 1 If he manages to finish the level successfully then the number of clears increases by 1 as well so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears Polycarp is very excited about his level so he keeps peeking at the stats to know how hard his level turns out to be So he peeked at the stats n times and wrote down n pairs of integers p 1 c 1 p 2 c 2 dots p n c n where p i is the number of plays at the i th moment of time and c i is the number of clears at the same moment of time i e the order of given pairs is exactly the same as Polycarp has written down Between two consecutive moments of time Polycarp peeked at the stats many players but possibly zero could attempt the level Finally Polycarp wonders if he hasn t messed up any records and all the pairs are correct If there could exist such a sequence of plays and clears respectively that the stats were exactly as Polycarp has written down then he considers his records correct Help him to check the correctness of his records For your convenience you have to answer multiple independent test cases ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let s use the fact that initially the level has plays and clears Call the differences before the previous stats and the current ones and The stats are given in chronological order so neither the number of plays nor the number of clears should decrease i e and Finally should be greater or equal to It s easy to show that if players pass the level successfully and players just try the level then such deltas are achieved So in implementation it s enough to check these three conditions between the consecutive pieces of data including the initial Overall complexity "}
{"statement": "Given an integer x Your task is to find out how many positive integers n 1 leq n leq x satisfy n cdot a n equiv b quad textrm mod p where a b p are all known constants ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Trying all integers from to is too slow to solve this problem So we need to find out some features of that given equation Because we have when is a prime it is obvious that falls into a loop and the looping section is Also has a looping section We can try to list a chart to show what is with some specific In the chart shown below is equal to For a certain we can see that And it s not hard for us to prove that has a looping section So we don t need to list Therefore we can enumerate from to and calculate Let s say the result is then we have You can refer to the chart shown above to see if it is So for a certain the possible can only be Then we can calculate how many possible answers in this situation i e decide the minimum and maximum possible using the given lower bound and upper bound Finally we add them together and get the answer or depending on how you calculate By the way you can also try to solve this problem "}
{"statement": "For an array u 1 u 2 ldots u n define a prefix maximum as an index i such that u i u j for all j i a suffix maximum as an index i such that u i u j for all j i an ascent as an index i i 1 such that u i u i 1 You are given three cost arrays a 1 a 2 ldots a n b 1 b 2 ldots b n and c 0 c 1 ldots c n 1 Define the of an array that has x prefix maximums y suffix maximums and z ascents as a x cdot b y cdot c z Let the sum of costs of all permutations of 1 2 ldots n be f n Find f 1 f 2 f n modulo 998 244 353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "We can use dp to calculate the number of permutations of 1 n with i prefix maximums and j ascents f n i j consider where 1 is inserted we will have a O n3 dp that finds f n i j for all suitable n i j s For suffix maximums the number of permutations of 1 n with i prefix maximums and j ascents g n i j we can just reverse some dimension of f To calculate the answer consider the position of n Suppose it s p The the answer is np 1 p 1i 0 n pj 0 p 1x 0 n py 0f p 1 i x g n p j y n 1p 1 ai 1bj 1cx y p 1 Let u x y if x i y ai 1 v x y zg x i y bi 1 both of these are calculated in O n3 then the answer is np 1 p 1x 0 n py 0u p 1 x v n p y n 1p 1 cx y p 1 By seeing u and v as 2D polynomials this can be calculated with 2D FFT in O n2logn "}
{"statement": "You are given a complete undirected graph with vertices A number is assigned to each vertex and the weight of an edge between vertices and is equal to Calculate the weight of the minimum spanning tree in this graph ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "We can use Boruvka s algorithm to solve this problem This algorithm usually works in initially MST is empty and then we run a number of iterations During each iteration we find connected components in the graph formed by already added edges and for each component we find the shortest edge that leads out of this component Then we add the edges we found to the MST but we should be careful to avoid adding edges that form cycles in MST The number of iterations is at most and each of iterations can be done in However in this problem we need to speed up this algorithm We can do each iteration in time using a binary trie We can store all values from in a trie When we need to find the shortest edge that connects some component with vertices outside of it we firstly remove all values contained in this component from the trie After that for each vertex in the component we can find the closest vertex outside the component in by descending the trie And then we insert the values of belonging to the component back into the trie Since for each vertex we descend the trie three times to remove it to find closest vertex and to add it back each iteration requries and the whole algorithm works in time "}
{"statement": "ZS the Coder loves mazes Your job is to create one so that he can play with it A maze consists of rooms and the rooms are arranged in rows numbered from the top to the bottom starting from and columns numbered from the left to the right starting from The room in the th row and th column is denoted by A player starts in the room and wants to reach the room Each room has four doors except for ones at the maze border one on each of its walls and two adjacent by the wall rooms shares the same door Some of the doors are locked which means it is impossible to pass through the door For example if the door connecting and is locked then we can t go from to Also one can only travel between the rooms downwards from the room to the room or rightwards from the room to the room provided the corresponding door is not locked ZS the Coder considers a maze to have if there is exactly ways of travelling from the room to the room Two ways are considered different if they differ by the sequence of rooms visited while travelling Your task is to create a maze such that its difficulty is exactly equal to In addition ZS the Coder doesn t like large mazes so the size of the maze and the number of locked doors are limited Sounds simple enough right ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "Prerequisites None The solution to this problem is quite simple if you get the idea Thanks to danilka pro for improving the solution to the current constraints which is much harder than my original proposal Note that to calculate the difficulty of a given maze we can just use dp We write on each square room the number of ways to get from the starting square to it and the number written on will be the sum of the numbers written on and and the edge between and is blocked we don t add the number written on and similarly for We ll call the rooms squares and the doors as edges We ll call locking doors as edge deletions First we look at several attempts that do not work Write in its binary representation To solve the problem we just need to know how to construct a maze with difficulty and from a given maze with difficulty The most direct way to get from to is to increase both dimensions of the maze by Let s say the bottom right square of the grid was and increased to So the number is written at Then we can block off the edge to the left of and above This will make the numbers in these two squares equal to so the number in square would be as desired To create from we can increase both dimensions by remove edges such that contains while contains this requires deleting most of the edges joining the th column and th column Thus the number in would be This would ve used way too many edge deletions and the size of the grid would be too large This was the original proposal There s another way to do it with binary representation We construct a grid with difficulty and from a grid with difficulty The key idea is to make use of surrounding s and maintaining it with some walls so that can be easily constructed This method is shown in the picture below This method would ve used around grid and edge deletions which is too large to pass Now what follows is the AC solution Since it s quite easy once you get the idea I recommend you to try again after reading the hint To read the full solution click on the spoiler tag Hint Binary can t work since there can be up to binary digits for and our grid size can be at most In our binary solution we used a grid to multiply the number of ways by What about using other grid sizes instead Full SolutionOur AC solution uses base instead of binary Write in base Note that has at most digits in base so to add a new digit we can increase the dimensions by and the number of deleted edges can be up to per digit We ll construct such a way This method is explained in the picture below The key is to first construct a grid which has in it then find a way to get for all from by maintaining a wall of s around the squares This method uses a grid and at most edge deletions and will get AC "}
{"statement": "In the most popular card game in Berland a deck of n times m cards is used Each card has two parameters suit and rank Suits in the game are numbered from 1 to n and ranks are numbered from 1 to m There is exactly one card in the deck for each combination of suit and rank A card with suit a and rank b can beat a card with suit c and rank d in one of two cases a 1 c ne 1 a card of suit 1 can beat a card of any other suit a c b d a card can beat any other card of the same suit but of a lower rank Two players play the game Before the game starts they receive exactly half of the deck each The first player wins if for every card of the second player he can choose his card that can beat it and there is no card that is chosen twice i e there exists a matching of the first player s cards with the second player s cards such that in each pair the first player s card beats the second player s card Otherwise the second player wins Your task is to calculate the number of ways to distribute the cards so that the first player wins Two ways are considered different if there exists a card such that in one way it belongs to the first player and in the other way it belongs to the second player The number of ways can be very large so print it modulo 998244353 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Suppose we re solving the problem for one suit Consider a distribution of cards between two players how to check if at least one matching between cards of the first player and cards of the second player exists Let s order the cards from the highest rank to the lowest rank and go through them in that order If we get a card of the first player we can add it to the pool of cards to be matched if we get a card belonging to the second player we match it with one of the cards from the pool if there are none there is no valid matching So if there exists a prefix of this order where the number of cards of the second player exceeds the number of cards belonging to the first player it is not a valid distribution Does this sound familiar Let s say that a card belonging to the first player is represented by an opening bracket and a card belonging to the second player is represented by a closing bracket Then if we need to solve the problem for just one suit the distribution must be a regular bracket sequence So in this case we just need to count the number of regular bracket sequences However if there are at least suits there might be extra cards of the st suit belonging to the first player which we can match with extra cards of other suits belonging to the second player To resolve this issue we can use the following dynamic programming let be the number of ways to distribute the cards of the first suits so that there are extra cards of the st suit belonging to the st player To calculate we have to count the number of bracket sequences such that the balance on each prefix is at least and the balance of the whole sequence is exactly In my opinion the easiest way to do this is to run another dynamic programming something like is the number of sequences with elements and balance however you can try solving it in a combinatorial way similar to how Catalan numbers are calculated What about transitions from to Let s iterate on the number of extra cards we will use to match the cards of the th suit belonging to the second player so we transition from to Now we need to count the ways to distribute cards of the same suit so that the second player receives cards more than the first player and all cards of the first player can be matched Consider that we ordered the cards from the lowest rank to the highest rank Then on every prefix the number of cards belonging to the first player should not exceed the number of cards belonging to the second player otherwise we won t be able to match all cards belonging to the first player and in total the number of cards belonging to the second player should be greater by So this is exactly the number of bracket sequences with balance on every prefix and balance equal to in total and we have already calculated that So the solution consists of two steps First for every we calculate the number of bracket sequences with non negative balance on each prefix and total balance equal to then we run dynamic programming of the form is the number of ways to distribute the cards of the first suits so that there are extra cards of the st suit belonging to the st player The most time consuming part of the solution is this dynamic programming and it works in so the whole solution works in "}
{"statement": "One day Vasya was lying in bed watching his electronic clock to fall asleep quicker Vasya lives in a strange country where days have hours and every hour has minutes Clock shows time in decimal number system in format where the string always has a fixed length equal to the number of digits in the decimal representation of number To achieve this leading zeros are added if necessary The string has a similar format and its length is always equal to the number of digits in the decimal representation of number For example if then time equal to 13 hours and 75 minutes will be displayed as Vasya had been watching the clock from hours minutes to hours minutes inclusive and then he fell asleep Now he asks you to count how many times he saw the moment at which at least digits changed on the clock simultaneously For example when switching 04 19 04 20 two digits change When switching 23 59 00 00 four digits change Consider that Vasya has been watching the clock for strictly less than one day Note that the last time Vasya saw on the clock before falling asleep was That is Vasya the moment at which time switched to the next value ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Let s consider function F x where x is some moment of time amount of moments from 0 00 00 00 up to x and x doesn t switch to next moment when n k or more digits will be changed The answer will be F h2 m2 F h1 m1 also it s necessary not to forget that if h2 m2 h1 m1 then F h2 m2 will be enlarged by a day Now we will learn how to calculate F x To start with let s count amount of such numbers when hour will remain the same As hour is not changing then k or more digits have to be changed in minutes but in this case we need our number of minutes to be of the following form a a99 9 where a means any digit and at the end we have k 1 nines So k digits are changing every moment that is divisible by 10k 1 So the total amount of such moments without changing an hour is wherehx mx are numbers of hour and minute in time moment x and is integer part Now let s deal with such moments when hour is changing If this happens then minute turns from m 1 to 0 and we have y different digits where y is amount of non zero digits of number m 1 Therefore we have to count for hours in similar way amount of moments when k y or more digits will be changed k y digits are changing every moment that is divisible by 10max 0 k y 1 this means that total amount of such moments is And the final value of F is "}
{"statement": "You are given a sequence a of length n consisting of integers from 1 to n Find the number of tuples of m 3 elements such that the maximum number in the tuple differs from the minimum by no more than k 2 Formally you need to find the number of triples of indices i j z such that max a i a j a z min a i a j a z le 2 For example if n 4 and a 1 2 4 3 then there are two such triples i 1 j 2 z 4 and i 2 j 3 z 4 If n 4 and a 1 1 1 1 then all four possible triples are suitable ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "In the easy version of the problem you can count how many times each number occurs the numbers themselves do not exceed Note that we do not have very many options for which triples of numbers can be included in the answer Let s iterate over the minimum number in the triples Then there are the following options In each option you need to multiply the number of ways to choose one two or three numbers from all occurrences of this number This is done using binomial coefficients Formally if is the number of occurrences of the number then the formulas corresponding to the options in the list above are as follows If we sum these values over all from to then we get the answer to the problem "}
{"statement": "After years of hard work scientists invented an absolutely new e reader display The new display has a larger resolution consumes less energy and its production is cheaper And besides one can bend it The only inconvenience is highly unusual management For that very reason the developers decided to leave the e readers software to programmers The display is represented by square of pixels each of which can be either black or white The display rows are numbered with integers from to upside down the columns are numbered with integers from to from the left to the right The display can perform commands like When a traditional display fulfills such command it simply inverts a color of where is the row number and is the column number But in our new display every pixel that belongs to at least one of the segments and both ends of both segments are included inverts a color For example if initially a display in size is absolutely white then the sequence of commands leads to the following changes You are an e reader software programmer and you should calculate minimal number of commands needed to display the picture You can regard all display pixels as initially white ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "You can see that every command i j you should do no more than once Also order of commands doesn t matter Actually sequence of command you can represent as boolean matrix A with size n n where aij 1 mean that you do the command i j and aij 0 mean that you don t do it Let us describe one way to construct the matrix Let the starting image is boolean matrix G A boolean matrix B of size n n stores intermediate image that you will recieve during process of doing commands For the upper half of matrix G without main diagonal you should move line by line from the up to the down For every line you should move from the right to the left You can see that for every positions all nonconsidered positions do not affect the current position So if you see that values for position i j in the matrices G and B are different you should do command i j set in the matrix A aij 1 and change segments i i i j and j j i j in the matrix B For the lower half of the matrix G without main diagonal you should do it absolutely symmetric At the end you should iterate over main diagonal Here it should be clear Well for matrix G you always can build matrix A and do it by exactly one way It mean that this way requires minimum number of commands So you can get answer for problem by following way you can build the matrix A from the matrix G and output number of ones in the matrix A There is only one problem that you should solve Algorithm that you can see above works in O n3 that doesn t fit into time limits Let s speed up it to O n2 Consider in the matrix B the upper half without main diagonal During doing commands all columns of cells that placed below current position will have same values Values above current position are not matter for us Therefore instead of the matrix B you can use only one array that stores values of columns It allows you do every command in O 1 instead of O n This optimization gives a solution that works in O n2 "}
{"statement": "You are given a string s You can build new string p from s using the following operation choose any subsequence s i 1 s i 2 dots s i k where 1 le i 1 i 2 dots i k le s erase the chosen subsequence from s s can become empty concatenate chosen subsequence to the right of the string p in other words p p s i 1 s i 2 dots s i k Of course initially the string p is empty For example let s text ababcd At first let s choose subsequence s 1 s 4 s 5 text abc we will get s text bad and p text abc At second let s choose s 1 s 2 text ba we will get s text d and p text abcba So we can build text abcba from text ababcd Can you build a given string t using the algorithm above ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Let s look at string Since we should get it using no more than two subsequences then where is the first subsequence and is the second one In the general case can be empty Let iterate all possible lengths of so we can check the existence of solution for each pair and If we d fix and we need to check the following is it true that contains and as subsequences and these subsequences don t intersect Initially we can invent the following dp let be if the prefix of of length contains prefixes of and of length and as non intersecting subsequences The transitions are straingforward if we can either skip indexed and update If indexed then we can update and if then we can update But this dp has complexity in general case But we can transform it in the next way instead of the boolean value we will make as a value of dp In other words we will maintain as minimal appropriate prefix But the problem now is to define transitions Let s note the next fact suppose we have and we d like to add next character to which is equal to The idea is next it s always optimal to choose the first occurrence of in It can be proved by contradiction if the first occurrence is free then it s better to take it or if the first occurrence will be occupied by then this will be handled by the other state with The logic for increasing is analogical In result we need to precalculate array with the next occurrence of character in suffix of one time before choosing and and use it each time to acquire complexity The total complexity if for each test case "}
{"statement": "Artsem has a friend Saunders from University of Chicago Saunders presented him with the following problem Let denote the set We will also write when a function is defined in integer points and all its values are integers from 1 to Now then you are given a function Your task is to find a positive integer and two functions such that for all and for all or determine that finding these is impossible ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Suppose that that is the functions match on all inputs and the identity function Hence we must have It means that if then that is all distinct values of must be its stable points If this is violated we can have no answer We will put equal to the number of stable points Let s enumerate all distinct values of as and define a function that maps a point to the index We will determine functions and We can see that if then if then All enumeration can be done in linear time "}
{"statement": "Joe has been hurt on the Internet Now he is storming around the house destroying everything in his path Joe s house has floors each floor is a segment of cells Each cell either contains nothing it is an empty cell or has a brick or a concrete wall always something one of three It is believed that each floor is surrounded by a concrete wall on the left and on the right Now Joe is on the th floor and in the first cell counting from left to right At each moment of time Joe has the direction of his gaze to the right or to the left always one direction of the two Initially Joe looks to the right Joe moves by a particular algorithm Every second he makes one of the following actions If the cell directly under Joe is empty then Joe falls down That is he moves to this cell the gaze direction is preserved Otherwise consider the next cell in the current direction of the gaze If the cell is empty then Joe moves into it the gaze direction is preserved If this cell has bricks then Joe breaks them with his forehead the cell becomes empty and changes the direction of his gaze to the opposite If this cell has a concrete wall then Joe just changes the direction of his gaze to the opposite concrete can withstand any number of forehead hits Joe calms down as soon as he reaches cell of the first floor The figure below shows an example Joe s movements around the house Determine how many seconds Joe will need to calm down ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Stupid emulation is very slow It has complexity and answer can be about You should speed up stupid emulation using following way For every floor you should store segment of visited cells two integers L and R bounds We know that under every cell of this segment all cells are non empty Therefore after every changing of move direction you can go through all the segment in After every one or two teleportations through segment you either expand bounds of the segnent or change some brick cell into empty cell or fall down But actions of every type you can do no more than times so this optimization improves complexety to Author is Ripatti "}
{"statement": "You are given an integer n You have to change the minimum number of digits in it in such a way that the resulting number and If there are multiple ways to do it print any of them If the given number is already divisible by 7 leave it unchanged ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "A lot of different solutions can be written in this problem The model solution relies on the fact that every th integer is divisible by and it means that there is always a way to change the last digit of or leave it unchanged so that the result is divisible by So if is already divisible by we just print it otherwise we change its last digit using some formulas or iteration on its value from to "}
{"statement": "Raj has a single physical network line that connects his office to the Internet This line bandwidth is b bytes per millisecond There are n users who would like to use this network line to transmit some data The i th of them will use the line from millisecond s i to millisecond f i inclusive His initial data rate will be set to d i That means he will use data rate equal to d i for millisecond s i and then it will change according to the procedure described below The flow control will happen as follows Suppose there are m users trying to transmit some data via the given network line during millisecond x Denote as t i the data rate that the i th of these m users has at the beginning of this millisecond All t i are non negative integer values If m 0 i e there are no users trying to transmit data during this millisecond nothing happens If the sum of all t i is less than or equal to b each active user successfully completes his transmission the i th active user transmits t i bytes After that the data rate of each active user grows by 1 i e each t i is increased by 1 If the sum of all t i is greater than b the congestion occurs and no data transmissions succeed this millisecond at all If that happens each t i decreases twice i e each t i is replaced with lfloor frac t i 2 rfloor Raj knows all the values n b s i f i and d i he wants to calculate the total number of bytes transmitted by all the users in the aggregate ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "The problem is inspired by AIMD algorithm for TCP flow and congestion control The key solution idea comes from a real world networking every time the congestion happens the difference between the maximum active t i and the minimum active t i halves Thus if all users were to start and to stop at the same time there will be no more than two distinct values of t i in just log C congestions Here C stands for the upper limit on values d i and b Let s store all the unique values of active t i in a hash map together with a supplementary information Information we need is the sum of all t i right after the last congestion the number of milliseconds past since the last congestion and so on Using this information we can compute the time of the next congestion in O 1 The processing of one congestion will work in O d time where d is the current number of distinct values of t i We also need to be able to merge two groups when congestion happens this information will be used to process delete operations That can be done using DSU with path compression and doesn t add much to the total complexity We will call the period between two consecutive congestions an epoch There are epochs of two types general and repetitive A repetitive epoch is an epoch that goes in exactly the same way as the previous epoch That means no new users appear no users turn off the epoch starts with exactly the same values of t i as the previous epoch and gets to exactly the same state after the closest congestion happens All other epochs are called general Though the total number of epochs can be large up to max f i there will be no more than n log C general epochs Indeed if no users start or finish data transmission the process will converge to a repetitive epoch in no more than log C congestions Here C is the upper bound for b and values d i Repetitive epochs contain no more than two distinct value of t i they can be identified and simulated efficiently How do we simulate general epochs There is no need to this efficiently doing this in O d d is the number of distinct t i will be efficient enough One can prove this using amortized analysis with the following potential function Let d be the number of distinct values of t i and t 0 t 1 ldots t d 1 be the sequence of these values P epoch d sum i 0 d 2 log t i 1 t i The total complexity is O n log C n log n "}
{"statement": "Let s call an array of non negative integers a 1 a 2 ldots a n a k extension for some non negative integer k if for all possible pairs of indices 1 leq i j leq n the inequality k cdot i j leq min a i a j is satisfied The expansion coefficient of the array a is the maximal integer k such that the array a is a k extension Any array is a 0 expansion so the expansion coefficient always exists You are given an array of non negative integers a 1 a 2 ldots a n Find its expansion coefficient ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let our array be a extension All inequalities for can be changed to For all inequalities are always true because all numbers are non negative So the maximum possible value of is equal to the minimum of for all Let s note that So we need to take a minimum of for all If we will fix the minimum value for all is equal to and it is reached at the maximum denominator value because So the answer is equal to and it can be simply found by linear time Complexity "}
{"statement": "The BerTV channel every day broadcasts one episode of one of the k TV shows You know the schedule for the next n days a sequence of integers a 1 a 2 dots a n 1 le a i le k where a i is the show the episode of which will be shown in i th day The subscription to the show is bought for the entire show i e for all its episodes for each show the subscription is bought separately How many minimum subscriptions do you need to buy in order to have the opportunity to watch episodes of purchased shows d 1 le d le n days in a row In other words you want to buy the minimum number of TV shows so that there is some segment of d consecutive days in which all episodes belong to the purchased shows ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "We are looking for a segment of length d with the smallest number of distinct values In small limitations one could just try all segments and count the number of distinct elements naively for example by sorting or with an std set "}
{"statement": "You are given an array of non negative integers A 5 tuple of integers is said to be valid if it satisfies the following conditions for some integer Here is the bitwise OR is the bitwise AND and is the bitwise XOR operation Find the sum of over all valid 5 tuples where is the th Fibonnaci number Since answer can be is huge output it modulo ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Apologies we didn t expect an solution The expected solution was as follows Let be the number of pairs in the array such that their bitwise OR is and multiplied by This can be done using subset convolution Let be the count of each element in array multiplied by Let be the number of pairs such that their bitwise xor is multiplied by This can be done using Xor convolution Let be the And Convolution of and Then the answer is given by the expression Complexity "}
{"statement": "You are given a number k and a string s of length n consisting of the characters and You want to replace some of the characters with characters so that the following conditions are met The first character in the original string should be replaced with The last character in the original string should be replaced with The distance between two neighboring replaced characters must not exceed k more formally if you replaced characters at positions i and j i j and at positions i 1 j 1 there is no symbol then j i must be no more than k For example if n 7 s and k 3 then the following strings will satisfy the conditions above But for example the following strings will not meet the conditions the first character should be replaced with the last character should be replaced with the distance between characters at positions 2 and 6 is greater than k 3 Given n k and s find the minimum number of characters that must be replaced with in order to meet the above conditions ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "To solve this problem you can use the dynamic programming method or the greedy algorithm Let s describe the greedy solution Until we get to the last character we will do the following being in position find the maximum such that and and move to position Since we make the longest move on each turn we will make the minimum number of substitutions "}
{"statement": "There are n products in the shop The price of the i th product is a i The owner of the shop wants to equalize the prices of all products However he wants to change prices smoothly In fact the owner of the shop can change the price of some product i in such a way that the difference between the old price of this product a i and the new price b i is at most k In other words the condition a i b i le k should be satisfied x is the absolute value of x He can change the price for each product Note that he can leave the old prices for some products The new price b i of each product i should be positive i e b i 0 should be satisfied for all i from 1 to n Your task is to find out the possible price B of productts with the restriction that for all products the condiion a i B le k should be satisfied where a i is the old price of the product and B is the same new price of all products or report that it is impossible to find such price B You should answer q independent queries ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "It is very intuitive that the maximum price we can obtain is where is the minimum value in the array For this price we should check that we can change prices of all products to it It can be done very easily we can just check if each segment covers the point But this is not necessary because if we can change the price of the maximum to this value then we can change each price in the segment to this value So we just need to check that and if it is then print otherwise print "}
{"statement": "Oleg came to see the maze of mirrors The maze is a n by n room in which each cell is either empty or contains a mirror connecting opposite corners of this cell Mirrors in this maze reflect light in a perfect way which causes the interesting visual effects and contributes to the loss of orientation in the maze Oleg is a person of curious nature so he decided to install n lasers facing internal of the maze on the south wall of the maze On the north wall of the maze Oleg installed n receivers also facing internal of the maze Let s number lasers and receivers from west to east with distinct integers from 1 to n Each laser sends a beam of some specific kind and receiver with number a i should receive the beam sent from laser number i Since two lasers beams can t come to the same receiver these numbers form a each of the receiver numbers occurs exactly once You came to the maze together with Oleg Help him to place the mirrors in the initially empty maze so that the maximum number of lasers beams will come to the receivers they should There are no mirrors outside the maze so if the laser beam leaves the maze it will not be able to go back ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "The answer is always if the permutation is identity lasers or otherwise Clearly we can t have more than matching lasers if the permutation is not identity Consider just the very first line with mirrors If the first mirror in this line is then we miss the laser below this mirror if the very last mirror is we miss the laser below it Otherwise there are neighbouring and and we lost two lasers now The proof of is constructive one Ignore all fixed points in permutation all that Select arbitrary cycle and select one point in it as dead We can spend operations to fix all points in this cycle But we also need to fix all other cycles We can do it in operations move arbitrary beam to the wasted laser fix all other points and move that point back But this is a bit too much lines The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line if we select as the trash beam the rightmost point See the following picture for an example trash beam is the rightmost column "}
{"statement": " You are given n segments on the coordinate axis OX Segments can intersect lie inside each other and even coincide The i th segment is l i r i l i le r i and it covers all integer points j such that l i le j le r i The integer point is called if it is covered by than k segments Your task is to remove the minimum number of segments so that there are no points at all ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "In this problem the following greedy solution works let s find the leftmost point covered by more than segments We should fix it somehow How to do it Let s find some segment that was not removed already it covers this point and its rightmost end is maximum possible and remove this segment You can implement it in any time you want even in naively "}
{"statement": "Recently you bought a brand new smart lamp with programming features At first you set up a schedule to the lamp Every day it will turn power on at moment 0 and turn power off at moment M Moreover the lamp allows you to set a program of switching its state states are lights on and lights off Unfortunately some program is already installed into the lamp The lamp allows only programs Good program can be represented as a non empty array a where 0 a 1 a 2 dots a a M All a i must be integers Of course preinstalled program is a good program The lamp follows program a in next manner at moment 0 turns power and light on Then at moment a i the lamp flips its state to opposite if it was lit it turns off and vice versa The state of the lamp flips instantly for example if you turn the light off at moment 1 and then do nothing the total time when the lamp is lit will be 1 Finally at moment M the lamp is turning its power off regardless of its state Since you are not among those people who read instructions and you don t understand the language it s written in you realize after some testing the only possible way to alter the preinstalled program You can element into the program a so it still should be a program after alteration Insertion can be done between any pair of consecutive elements of a or even at the begining or at the end of a Find such a way to alter the program that the total time when the lamp is lit is maximum possible Maybe you should leave program untouched If the lamp is lit from x till moment y then its lit for y x units of time Segments of time when the lamp is lit are summed up ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "At first let s insert and in array so all possible positions for inserting will always belong to At second let be value to insert and It can be proven that it s always optimal to move to or to So for each we need to check only and To check it fast enough we need to know total time of lamp is lit for each prefix and precalculate for each total time of lamp is lit if starting from light is on lights is off Result complexity is "}
{"statement": "You are given a string s You need to find two non empty strings a and b such that the following conditions are satisfied Strings a and b are both of s For each index i character s i of string s must belong to of strings a or b String a is minimum possible string b may be any possible string Given string s print any valid a and b A string a b is a of a string s if a b can be obtained from s by deletion of several possibly zero elements For example and are subsequences of while and are not A string x is than a string y if and only if one of the following holds x is a prefix of y but x ne y in the first position where x and y differ the string x has a letter that appears earlier in the alphabet than the corresponding letter in y ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Note that taking as minimum character in is always optimal starts with minimum possible character and is prefix of any other longer string In such case is just all characters from except character from "}
{"statement": "Now Dmitry has a session and he has to pass n exams The session starts on day 1 and lasts d days The ith exam will take place on the day of a i 1 le a i le d all a i are different For the session schedule Dmitry considers a special value mu the smallest of the rest times before the exam for all exams For example for the image above mu 1 In other words for the schedule he counts exactly n numbers how many days he rests between the exam i 1 and i for i 0 between the start of the session and the exam i Then it finds mu the minimum among these n numbers Dmitry believes that he can improve the schedule of the session He may ask to change the date of one exam change one arbitrary value of a i Help him change the date so that all a i remain different and the value of mu is as large as possible For example for the schedule above it is most advantageous for Dmitry to move the second exam to the very end of the session The new schedule will take the form Dmitry can leave the proposed schedule unchanged if there is no way to move one exam so that it will lead to an improvement in the situation ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "To begin with we will learn how to find the optimal place for the exam that we want to move Let s imagine that it is not in the schedule in this case we have two options Put the exam at the end of the session so that there are days before it Put it in the middle of the largest break between exams let its length be so that between it and the nearest one there is because this is no worse than putting it in any part of any other break That is the answer for such an arrangement is the minimum of the larger of these options and the minimum break in schedule without the moved exam Now note that the minimum break in most variants is the same minimum in the initial schedule So in order to reduce you need to move exactly one of the two exams that form it and you need to check which of the two options is better "}
{"statement": "Suppose you are living with two cats A and B There are n napping spots where both cats usually sleep Your cats like to sleep and also like all these spots so they change napping spot each hour cyclically Cat A changes its napping place in order n n 1 n 2 dots 3 2 1 n n 1 dots In other words at the first hour it s on the spot n and then goes in decreasing order cyclically Cat B changes its napping place in order 1 2 3 dots n 1 n 1 2 dots In other words at the first hour it s on the spot 1 and then goes in increasing order cyclically The cat B is much younger so they have a strict hierarchy A and B don t lie together In other words if both cats d like to go in spot x then the A takes this place and B moves to the next place in its order if x n then to x 1 but if x n then to 1 Cat B follows his order so Calculate where cat B will be at hour k ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "If is even then each hour A and B are on the spots with different parity so they will never meet Otherwise let s look closely what happens At the start A in and B in But since we can form a cycle from spots then it means that and in reality are neighbors After that A and B starting from neighboring positions just go in opposite directions and meet each other in the opposite spot after exactly steps After meeting B jumps over A making extra step and the situation become practically the same A and B are neighbors and move in the opposite direction In other words each steps B makes one extra step so the answer if both and spots are indexed is "}
{"statement": "n players are playing a game There are two different maps in the game For each player we know his strength on each map When two players fight on a specific map the player with higher strength on that map always wins No two players have the same strength on the same map You are the game master and want to organize a tournament There will be a total of n 1 battles While there is more than one player in the tournament choose any map and any two remaining players to fight on it The player who loses will be eliminated from the tournament In the end exactly one player will remain and he is declared the winner of the tournament For each player determine if he can win the tournament ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1700", "problem_editorial": "Let s look at the fights in the reversed order If player is the winner then he won against some player in the last fight In th fight either or won against some player and so on We always expand the set by adding a player that can lose against at least one player in the set so if we can start from and end up with the set of all players can win the tournament If we construct a directed graph where we add an edge from player to player if and only if can win against in a fight the problem is equivalent to finding the set of nodes from which we can reach all the other nodes To reduce the number of edges to we can sort players descending by and by and add only edges from th to th player in these orders Notice that can win the tournament if and only if there is a path from to the player with maximum To find the set of such nodes we can run DFS from the player with maximum on the graph with each edge reversed or do two pointers technique on arrays of players sorted by and "}
{"statement": "Polycarp calls an array dense if the greater of any two adjacent elements is not more than twice bigger than the smaller More formally for any i 1 le i le n 1 this condition must be satisfied frac max a i a i 1 min a i a i 1 le 2For example the arrays 1 2 3 4 3 1 1 1 and 5 10 are dense And the arrays 5 11 1 4 2 6 6 1 are dense You are given an array a of n integers What is the minimum number of numbers you need to add to an array to make it dense You can insert numbers anywhere in the array If the array is already dense no numbers need to be added For example if a 4 2 10 1 then the answer is 5 and the array itself after inserting elements into it may look like this a 4 2 underline textbf 3 underline textbf 5 10 underline textbf 6 underline textbf 4 underline textbf 2 1 there are other ways to build such a ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Note that adding elements between positions and will not change the ratio of the adjacent elements except for the ones just added Therefore for each pair of adjacent numbers the problem can be solved independently Let us solve the problem for a adjacent pair of numbers and for which the inequality from the statements does not hold Suppose that if not we will swap them Then between and it requires to insert elements of the form It is better not to use explicit formula but to use the following cycle "}
{"statement": "Lee thinks a regular n sided convex polygon is if and only if he can rotate it in such a way that at least one of its edges is parallel to the OX axis and at least one of its edges is parallel to the OY axis at the same time Recall that a regular n sided polygon is a convex polygon with n vertices such that all the edges and angles are equal Now he is shopping the market has t regular polygons For each of them print if it is beautiful and otherwise ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Proof by contradiction One can prove that if two edges in a regular polygon make a degrees angle then for each edge there exist two another edges and such that and make a degrees angle as well as and proof is left as an exercise for the reader Consider a rotation such that an edge is parallel to axis and an edge is parallel to axis then and are perpendicular i e the angle between them is degrees we can see that there exist a third edge such that it s also parallel to axis and a forth edge such that it s also parallel to axis so and and Our polygon is regular so all the angles are equal so that the number of angles between and is equal to the number of angles between and and so on also we know that a regular sided convex polygon has angles so is divisible by contradiction "}
{"statement": "Your friends have an array of n elements calculated its array of prefix sums and passed it to you accidentally losing one element during the transfer Your task is to find out if the given array can matches A permutation of n elements is an array of n numbers from 1 to n such that each number occurs exactly times in it The array of prefix sums of the array a is such an array b that b i sum j 1 i a j 1 le i le n For example the original permutation was 1 5 2 4 3 Its array of prefix sums 1 6 8 12 15 Having lost one element you can get for example arrays 6 8 12 15 or 1 6 8 15 It can also be shown that the array 1 2 100 does not correspond to any permutation ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "To begin with let s learn how to reconstruct an array from its prefix sum array This can be done by calculating the differences between adjacent elements If the element is missing from the array we will add it and check if the array corresponds to some permutation Otherwise there is a missing element in the middle or at the beginning of the array Let s count the occurrences of each difference between adjacent elements Obviously we should have one extra number and missing numbers If the count of differences occurring at least times is at least the answer is The answer is also if any difference occurs at least times Otherwise we check that exactly distinct numbers are missing and their sum is equal to the only duplicate "}
{"statement": "As Famil Door s birthday is coming some of his friends like Gabi decided to buy a present for him His friends are going to buy a string consisted of round brackets since Famil Door loves string of brackets of length more than any other strings The sequence of round brackets is called if and only if the total number of opening brackets is equal to the total number of closing brackets for any prefix of the sequence the number of opening brackets is greater or equal than the number of closing brackets Gabi bought a string of length and want to complete it to obtain a valid sequence of brackets of length He is going to pick some strings and consisting of round brackets and merge them in a string that is add the string at the beginning of the string and string at the end of the string Now he wonders how many of strings and exists such that the string is a valid sequence of round brackets As this number may be pretty large he wants to calculate it modulo ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "This problem can be solved with dynamic programming Calculate How many sequences of brackets of length has balance and intermediate balance never goes below zero They form a prefix of a valid sequence of brackets For the given sequence of length calculate the resulting balance and the minimum balance Try the length of the sequence added at the beginning and its balance If then add to the answer Time complexity C Solution "}
{"statement": "LuoTianyi gives you dagger string s and she wants you to find out the length of the longest non empty subsequence ddagger of s which is not a palindrome string If there is no such subsequence output 1 instead dagger A palindrome is a string that reads the same backward as forward For example strings are palindromes but strings are not ddagger A string a is a subsequence of a string b if a can be obtained from b by deletion of several possibly zero or all characters from b For example strings are subsequences of string but strings are not ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Consider the substring of s from the second character to the last or s2s3 sn If it s not palindrome then the answer must be n 1 What if it s palindrome This implies that s2 sn s3 sn 1 and so on Meanwhile the fact that s is palindrome implies s1 sn s2 sn 1 etc So we get s1 sn s2 sn 1 or that all characters in s is the same In this situation every subsequence of s is palindrome of course so the answer should be 1 "}
{"statement": "The company Divan s Sofas is planning to build n 1 different buildings on a coordinate line so that the coordinate of each building is an integer number no two buildings stand at the same point Let x i be the coordinate of the i th building To get from the building i to the building j spends x i x j minutes where y is the absolute value of y All buildings that is going to build can be numbered from 0 to n The businessman will live in the building 0 the new headquarters of Divan s Sofas In the first ten years after construction will visit the i th building a i times each time spending 2 cdot x 0 x i minutes for walking asks you to choose the coordinates for all n 1 buildings so that over the next ten years the businessman will spend as little time for walking as possible ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "SolutionObviously the more often we have to go to the building the closer it should be to the main office This implies a greedy algorithm Let s put the main office at and sort the rest by Then we put the most visited building at a point with a coordinate of the second at the third at etc The resulting asymptotics in time is "}
{"statement": "Hacker Zhorik wants to decipher two secret messages he intercepted yesterday Yeah message is a sequence of encrypted blocks each of them consists of several bytes of information Zhorik knows that each of the messages is an archive containing one or more files Zhorik knows how each of these archives was transferred through the network if an archive consists of files of sizes bytes then the th file is split to one or more blocks here the total length of the blocks is equal to the length of the file and after that all blocks are transferred through the network maintaining the order of files in the archive Zhorik thinks that the two messages contain the same archive because their total lengths are equal However each file can be split in blocks in different ways in the two messages You are given the lengths of blocks in each of the two messages Help Zhorik to determine what is the maximum number of files could be in the archive if the Zhorik s assumption is correct ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Let s define and as sums of first elements of and and can be same file iff this three conditions are true because we need to divide prefix into files because we need to divide suffix into files segments have same sum It s easy to see that if two first conditions are true then the third are true too because and because of this fact and condition from statement answer is a number of non empty prefixes with the same sum Time complexity is if you use two pointers or if you use some data structure You lost block from second message and you interested in maximal possible number of files if you can insert this block anywhere in second message In this case it graduated that "}
{"statement": "The prehistoric caves of El Toll are located in Moi Barcelona You have heard that there is a treasure hidden in one of possible spots in the caves You assume that each of the spots has probability to contain a treasure You cannot get into the caves yourself so you have constructed a robot that can search the caves for treasure Each day you can instruct the robot to visit exactly distinct spots in the caves If none of these spots contain treasure then the robot will obviously return with empty hands However the caves are dark and the robot may miss the treasure even when visiting the right spot Formally if one of the visited spots does contain a treasure the robot will obtain it with probability otherwise it will return empty Each time the robot searches the spot with the treasure his success probability is independent of all previous tries that is the probability to miss the treasure after searching the right spot times is What is the expected number of days it will take to obtain the treasure if you choose optimal scheduling for the robot Output the answer as a rational number modulo Formally let the answer be an irreducible fraction then you have to output It is guaranteed that is not divisible by ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "Let be the number of times we have checked spot after days Assuming that the spot contains the treasure we can see that the expected number of days to find the treasure is Hence the unconditional expectation of the answer is This formula implies that the optimal strategy is to keep the visiting frequencies for all spots as close as possible since the sum is minimized under when is the smoothest partition of One implementation of this strategy is to visit spots on day Note further that this strategy always visits spots in batches of size hence we can divide both and by their GCD Let us now consider an example of Let be the expected number of days to find the treasure in spot according to the optimal strategy above We can see that because a cell is visited on day iff the cell was visited on day We also have for the same reason except for that the cell was visited on the first day This argument allows to express say as a linear expression of itself and find the answer in time Another approach is to substitute the expressions until we cross the end of the sequence once also but We have obtained a similar set of linear relations of three spots with difference 2 To reduce to let us group by We can see that the total contribution of all for is a linear function in with coefficients depending on whether The main idea is that we continue this process with a different set of linear equations effectively obtaining Euclid s algorithm that stores some additional data Let us now describe the general solution Assume that we have a set of variables satisfying for and for Assume further that the answer Let For by applying relations and successively we obtain hence for Similarly for Also where It follows that the transformation produces the same answer In the end of this process we have hence we have a linear equation After finding the answer is The number of reductions of the above type is with each transformation possible to do in time and require fast matrix exponentation The total number of operations is per test "}
{"statement": "You are given a tree with nodes numbered from to rooted at node Also each node has two values associated with it The values for th node are and You can jump from a node to any node in its subtree The cost of one jump from node to node is the product of and The total cost of a path formed by one or more jumps is sum of costs of individual jumps For every node calculate the minimum total cost to reach any leaf from that node Pay attention that root can never be leaf even if it has degree Note that you cannot jump from a node to itself ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "The problem can be solved by dynamic programming Let be the minimum cost to reach a leaf from node Then where This is equivalent to finding the minimum at among lines Thus convex hull trick of dp optimization can be used to find the minimum value Once the value is calculated for a node a line with slope and y intercept is added to the hull However at all times we need to maintain a lower convex hull of only the nodes in the current subtree The trick of merging small to large can be used here While we are at a node we form a convex hull for the subtree rooted at each child The convex hulls of the light children can then be merged into the convex hull of the heavy child Once the convex hull for the entire subtree is formed a query for the minimum value at x coordinate in the lower hull gives the value of The merging of small to large has time complexity of while the addition of a line into the hull requires time Complexity "}
{"statement": "Suppose you are given a sequence S of k pairs of integers a 1 b 1 a 2 b 2 dots a k b k You can perform the following operations on it Choose some position i and a i by 1 That can be performed only if there exists at least one such position j that i ne j and a i a j The cost of this operation is b i Choose some position i and a i by 1 That can be performed only if there exists at least one such position j that a i a j 1 The cost of this operation is b i Each operation can be performed arbitrary number of times possibly zero Let f S be minimum possible x such that there exists a sequence of operations with total cost x after which all a i from S are pairwise distinct You are given a sequence P consisting of n pairs of integers a 1 b 1 a 2 b 2 dots a n b n All b i are pairwise distinct Let P i be the sequence consisting of the first i pairs of P Your task is to calculate the values of f P 1 f P 2 dots f P n ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Let s firstly try to come up with some naive solution Suppose we have a list and want to calculate for it Let s sort this list comparing the pairs by their values of and then process them one by one We will divide this list into some parts we will call them with the following process when processing the first pair in the sorted order let s iterate on the next pairs also in the sorted order and add them to the first pair s component until the following condition is met where is the index of the first pair we added and is the index of the pair we are currently trying to add to s component remember that we consider all these pairs in the sorted order What is the meaning of this condition means that the number of pairs between and including these two is not less that the number of integers in and while this condition is met we can use the first operation in order to make a pair having for every And the first time when the condition is met we obviously cannot expand the segment in such a way It means that the value of will always be greater than value of and won t belong to the same component with and will start creating its own component instead These components we form have one special property Suppose we expanded the component so that there are no two equal values of in it Then we may reorder the pairs in this component as we wish to do so we may contract the component using the second operation and then expand it again Of course the best course of action is to sort the pairs in the component by their values of in descending order After doing this for every component we will obtain an optimal configuration such that all values of are distinct and it s easy to calculate the answer Okay now we need to do it fast The following will help us DSU Some implicit logarithmic data structure the operations we need are count the sum of elements less than and count the number of elements greater than your implementation might use other operations Small to large merging DSU will help us maintain the components A data structre will be built for each component containing the values of in it it will help us to maintain the sum of where is the optimal index of in this component Depending on your implementation you may or may not need to store the minimum value of in the component When inserting some element having into some component the elements having don t change their position the new element will be added right after them and the remaining elements will be shifted to the right so the sum of can be maintained if we query the number of elements greater than and the sum of elements less than Okay but we still don t know how we create the components and how we determine if two components are to merge We will keep these components in expanded form that is when processing a pair let s find the leftmost unoccupied position after or if it is not occupied and occupy it with the new pair creating a new component for it If the newly occupied index is let s try to merge new component with components occupying and if there are any to merge two components do the required operations in DSU and unite the data structures built in these components with small to large method All this works in the most time consuming part is merging the data structures "}
{"statement": "When he s not training for IOI Little Alawn enjoys playing with puzzles of various types to stimulate his brain Today he s playing with a puzzle that consists of a 2 times n grid where each row is a permutation of the numbers 1 2 3 ldots n The goal of Little Alawn s puzzle is to make sure no numbers on the same column or row are the same we ll call this state of the puzzle as solved and to achieve this he is able to swap the numbers in any column However after solving the puzzle many times Little Alawn got bored and began wondering about the number of possible solved configurations of the puzzle he could achieve from an initial configuration only by swapping numbers in a column Unfortunately Little Alawn got stuck while trying to solve this harder problem so he was wondering if you could help him with it Find the answer modulo 10 9 7 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1300", "problem_editorial": "Define the direction of a column as the orientation of its numbers Swapping the numbers in a column will flip its direction Let s create a simple undirected graph where the nodes are the columns on the puzzle and we draw one edge connecting it to the other columns that share a number with it Notice that the degree of every node in this graph is so the graph must be made of some number of disjoint simple cycles Now consider any component in the graph If we fix the direction of any of the columns in the component that will fix the direction of the columns adjacent to it and so on until the direction of every column in the component has been fixed also note that as the component is a simple cycle we will never get a contradiction As there are possible directions for any column there are thus ways to direct the columns in this component Lastly notice that the columns in each component are independent so the answer is simply where is the number of components in our graph Time Complexity with DFS "}
{"statement": "Let s consider the following simple problem You are given a string s of length n consisting of lowercase Latin letters as well as an array of indices ind of length m 1 leq ind i leq n and a string c of length m consisting of lowercase Latin letters Then in order you perform the update operations namely during the i th operation you set s ind i c i Note that you perform all m operations from the first to the last Of course if you change the order of indices in the array ind and or the order of letters in the string c you can get different results Find the lexicographically smallest string s that can be obtained after m update operations if you can rearrange the indices in the array ind and the letters in the string c as you like A string a is lexicographically less than a string b if and only if one of the following conditions is met a is a prefix of b but a neq b in the first position where a and b differ the symbol in string a is earlier in the alphabet than the corresponding symbol in string b ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": " Let i1 i2 ik be the set of indices of the array ind Note that the indices of the string s that are not in this set will simply not change their value Then we want to place the smallest character of the string c at position i1 the next smallest at position i2 and so on To achieve this we can sort all the characters in the string c This approach to obtaining the answer is possible because all other operations except those described above can be performed first and will not affect the answer "}
{"statement": "The array a a 1 a 2 ldots a n 1 le a i le n is given Its element a i is called special if there exists a pair of indices l and r 1 le l r le n such that a i a l a l 1 ldots a r In other words an element is called special if it can be represented as the sum of of an array no matter if they are special or not Print the number of special elements of the given array a For example if n 9 and a 3 1 4 1 5 9 2 6 5 then the answer is 5 a 3 4 is a special element since a 3 4 a 1 a 2 3 1 a 5 5 is a special element since a 5 5 a 2 a 3 1 4 a 6 9 is a special element since a 6 9 a 1 a 2 a 3 a 4 3 1 4 1 a 8 6 is a special element since a 8 6 a 2 a 3 a 4 1 4 1 a 9 5 is a special element since a 9 5 a 2 a 3 1 4 Please note that some of the elements of the array a may be equal if several elements are equal and special then all of them should be counted in the answer ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "The intended solution for this problem uses time and memory Firstly let s calculate for each from to where is the number of occurrences of in This part can be done in Then let s iterate over all segments of of length at least maintaining the sum of the current segment We can notice that we don t need sums greater than because all elements do not exceed So if the current sum does not exceed then add to the answer and set to prevent counting the same elements several times This part can be done in "}
{"statement": "During her journey with Kosuke Sakurako and Kosuke found a valley that can be represented as a matrix of size n times n where at the intersection of the i th row and the j th column is a mountain with a height of a i j If a i j 0 then there is a lake there Kosuke is very afraid of water so Sakurako needs to help him With her magic she can select a square area of mountains and increase the height of each mountain on the main diagonal of that area by exactly one More formally she can choose a submatrix with the upper left corner located at i j and the lower right corner at p q such that p i q j She can then add one to each element at the intersection of the i k th row and the j k th column for all k such that 0 le k le p i Determine the minimum number of times Sakurako must use her magic so that there are no lakes ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "In this task we were supposed to find the minimal possible amount of moves that Sakurako needs to make in order to make all elements in the matrix non negative The key observation is to notice that Sakurako can only add simultaneously to elements that lay on one diagonal For cell let the index of diagonal which it is placed on is equal to This is proven by the fact that for and the equation holds We are able to add to a pair of elements and simultaneously if and only if From this we can reduce our problem to finding the amount of times that we need to add 1 to this diagonal in order for all of its elements to become non negative For each diagonal we find the minimal element in it and there will be two cases 1 The minimal element is non negative we don t need to add anything to that diagonal 2 The minimal element is negative and equal to we will need to add one at least times remember that is negative After that the answer for our task is the sum of answers for each individual diagonal Total time complexity "}
{"statement": "Upon clearing the Waterside Area Gretel has found a monster named Genokraken and she s keeping it contained for her scientific studies The monster s nerve system can be structured as a tree dagger of n nodes numbered from 0 to n 1 with node 0 as the root Gretel s objective is to learn the exact structure of the monster s nerve system more specifically she wants to know the values p 1 p 2 ldots p n 1 of the tree where p i 0 le p i i is the direct parent node of node i 1 le i le n 1 She doesn t know exactly how the nodes are placed but she knows a few convenient facts If we remove root node 0 and all adjacent edges this tree will turn into a forest consisting of only paths ddagger Each node that was initially adjacent to the node 0 The nodes are indexed in a way that if 1 le x le y le n 1 then p x le p y Node 1 has adjacent nodes including the node 0 Gretel can make queries to the containment cell 1 le a b n a ne b the cell will check if the simple path between nodes a and b contains the node 0 However to avoid unexpected consequences by overstimulating the creature Gretel wants to query at most 2n 6 times Though Gretel is gifted she can t do everything all at once so can you give her a helping hand dagger A tree is a connected graph where every pair of distinct nodes has exactly one simple path connecting them ddagger A path is a tree whose vertices can be listed in the order v 1 v 2 ldots v k such that the edges are v i v i 1 1 le i k ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1800", "problem_editorial": "For simplicity we ll use the term tentacle to call each path tree in the forest made by cutting off node We also notice that in each tentacle two nodes will never have the same distance from root node The condition of iff leads to a crucial observation of the system it is indexed in accordance to a BFS order of the tree Hence we now have two goals Determine the number of tentacles From node to assign every node to their respective tentacles Due to the BFS order at the moment of assignment the previous tip of the tentacle is the parent of the current node and the current node becomes the new tip of the tentacle For the first objective we see that node is guaranteed to be connected with nodes and Furthermore is the first non zero node where the path between it and does not cross Therefore you can keep querying for increasing until you find a to get For the second objective we need to find the tentacle that each node belongs to in other words find the node so that query yields a Denote as the tentacle associated with node then note that If and share the same distance from then obviously i e will be a tentacle at the forward direction from in the tentacle list If and don t share the same distance from then can be any tentacle in the list So we can approach this objective like this denote as the next tentacle in the list after or if was at the end of the list starting from we ll keep re assigning until query yields a From hindsight it looks like we ll need query count order to finish this part but there is another crucial observation due to the nodes being indexed in BFS order if any tentacle yields a during probing that tentacle will never be extended again proof for this is pretty intuitive but a bit lengthy to express in words so we ll leave it as an exercise for the reader thus if you reach an that has already been deactivated before you ignore it and call again which wouldn t count towards the queries as it is your internal processing Let s count the number of queries we used Let be the number of tentacles then If the second objective wouldn t be needed so we end up with queries in total as If note that each time we process a query either a node is appended to a tentacle or a tentacle is removed Since at most tentacles can be removed and there are nodes to be processed the second phase uses at most queries so in total we use queries To process the list of tentacles there are a few options Naively mark the tentacles as active inactive to know when to stop by for queries and when to skip Time complexity will be and though it can still pass in fact one such solution from the author passed nicely it is not recommended Maintain the list of tentacles in a if a node is known to be inactive remove it Time complexity will be Maintain the list of tentacles in a similar manner as above but using a doubly linked list this time Time complexity will be "}
{"statement": "You are living on an infinite plane with the Cartesian coordinate system on it In one move you can go to any of the four adjacent points left right up down More formally if you are standing at the point x y you can go left and move to x 1 y or go right and move to x 1 y or go up and move to x y 1 or go down and move to x y 1 There are n boxes on this plane The i th box has coordinates x i y i It is guaranteed that the boxes are either on the x axis or the y axis That is either x i 0 or y i 0 You can collect a box if you and the box are at the same point Find the minimum number of moves you have to perform to collect all of these boxes if you have to at the point 0 0 ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Suppose we only have boxes on the axis then the optimal strategy is going in the following way There is no way to do in less than moves What if we have boxes on two axis Let s assume it is suppose we have a strategy to go in the following way In this case it is optimal to fill the three dots with which is just solving each axis independently Therefore the number of axis does not matters For each axis that has at least one box go from to the farthest one then come back to Time complexity Solution "}
{"statement": "There is a pyramid which consists of n floors The floors are numbered from top to bottom in increasing order In the pyramid the i th floor consists of i rooms Denote the j th room on the i th floor as i j For all positive integers i and j such that 1 le j le i n there are 2 staircases which lead from i j to i 1 j and from i j to i 1 j 1 respectively In each room you can either put a torch or leave it empty Define the of a room i j to be the number of rooms with a torch from which you can reach the room i j through a non negative number of staircases For example when n 5 and torches are placed in the rooms 1 1 2 1 3 2 4 1 4 3 and 5 3 the pyramid can be illustrated as follows In the above picture rooms with torches are colored in yellow and empty rooms are white The blue numbers in the bottom right corner indicate the brightness of the rooms The room 4 2 the room with a star has brightness 3 In the picture below the rooms from where you can reach 4 2 have red border The brightness is 3 since there are three torches among these rooms The pyramid is called if and only if for all floors all rooms in the floor have the same brightness Define the of a nice pyramid to be the sum of brightness over the rooms 1 1 2 1 3 1 n 1 Find an arrangement of torches in the pyramid such that the resulting pyramid is nice and its brilliance is maximized We can show that an answer always exists If there are multiple answers output any one of them ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Note that the brightnesses of the rooms on the th floor is at most This is because in room only rooms namely can reach to through some number of staircases It is also possible to find a configuration of torches in the pyramid such that the brightnesses of the rooms on the th floor is exactly i e it attains the upper bound The configuration is as follows Room contains a torch if and only if it is the leftmost room or the rightmost room on the th floor This is valid because for all rooms it can be reached from and In other words room has brightness so the pyramid is nice Code in C "}
{"statement": "Surely you have seen insane videos by South Korean rapper PSY such as Gangnam Style Gentleman and Daddy You might also hear that PSY has been recording video Oppa Funcan Style two years ago unfortunately we couldn t find it on the internet We will remind you what this hit looked like you can find original description here On the ground there are n platforms which are numbered with integers from 1 to n on i th platform there is a dancer with number i Further every second all the dancers standing on the platform with number i jump to the platform with the number f i The moving rule f is selected in advance and is not changed throughout the clip The duration of the clip was k seconds and the rule f was chosen in such a way that after k seconds all dancers were in their initial positions i e the i th dancer stood on the platform with the number i That allowed to loop the clip and collect even more likes PSY knows that enhanced versions of old artworks become more and more popular every day So he decided to release a remastered version of his video In his case enhanced version means even more insanity so the number of platforms can be up to 10 18 But the video director said that if some dancer stays on the same platform all the time then the viewer will get bored and will turn off the video immediately Therefore for all x from 1 to n f x neq x must hold Big part of classic video s success was in that looping so in the remastered version all dancers should return to their initial positions in the end of the clip as well PSY hasn t decided on the exact number of platforms and video duration yet so he asks you to check if there is a good rule f for different options ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3300", "problem_editorial": "Let s understand the problem first The rule must be bijective because otherwise some platforms will be empty in seconds So we are looking for permutations of size Let s say that cycles of the permutation have lengths is an identity permutation if and only if divides for all Also So we need to check if there are such numbers for which all these holds is a divisor of It is not profitable to use composite divisors of because we can substitute each of them with any its prime divisor repeated necessary number of times Let s say that the list of all distinct prime divisors of Then the problem is essentially Check if there are nonnegative coefficients such that If answer is NO If then the answer is YES if and only if is divisible by If then you have to say if there is a nonnegative solution to Diophantine equation It can be done using extended Euclid algorithm And if then Let s find the minimal number equal to modulo that can be written in form If we do this the answer is obvious YES if and only if To find all the we ll build a directed graph It s vertices are the remainders modulo and there is a directed edge from to with weight for all and Let s see that the path from in this graph is a set of its weight is the sum of and it leads to a remainder of this sum modulo Therefore is shortest path from to in this graph There are vertices and edges in this graph so dijkstra s running time is We also need to factorize Let s build sieve once and find all the primes up to Then we can factorize numbers up to in just like in trivial algorithm but trying only prime divisors Let s calculate complexity now Let s say that number of all tests is and number of different is Solutions for and works in and time so total time is Solution for works in but this dijkstra should be done once for each for different we should only check one condition using calculated distances Therefore total time for these solutions is Also there is sieve in and factorization in times Total complexity "}
{"statement": "Oleg the client and Igor the analyst are good friends However sometimes they argue over little things Recently they started a new company but they are having trouble finding a name for the company To settle this problem they ve decided to play a game The company name will consist of letters Oleg and Igor each have a set of letters which might contain multiple copies of the same letter the sets can be different Initially the company name is denoted by question marks Oleg and Igor takes turns to play the game Oleg moves first In each turn a player can choose one of the letters in his set and replace any of the question marks with Then a copy of the letter is removed from his set The game ends when all the question marks has been replaced by some letter For example suppose Oleg has the set of letters and Igor has the set of letters One possible game is as follows Initially the company name is Oleg replaces the second question mark with The company name becomes The set of letters Oleg have now is Igor replaces the third question mark with The company name becomes The set of letters Igor have now is Finally Oleg replaces the first question mark with The company name becomes The set of letters Oleg have now is In the end the company name is Oleg wants the company name to be as lexicographically small as possible while Igor wants the company name to be as lexicographically large as possible What will be the company name if Oleg and Igor always play optimally A string is called lexicographically smaller than a string where if where is the smallest index such that so for all ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "First it is clear that Oleg will place letters and Igor will place letters Next it is clear that Oleg and Igor will both choose their smallest and biggest letters respectively to place in the final string Thus we now consider that Oleg places his smallest letters and Igor places his largest letters Consider the following greedy strategy When it s Oleg s turn he will replace the frontmost question mark with his smallest letter When it s Igor s turn he will replace the frontmost question mark with his largest letter At first glance you might think that this works However there s another case that we haven t considered Suppose Oleg has the letters x y z and Igor has the letters a b c According to our previous strategy Oleg will place x as the first letter However that s not optimal He can place his letters at the back and force Igor to place the first letter The reason is because the largest letter of Igor is not larger than the smallest letter of Oleg Thus it is beneficial for Oleg to place his letters at the back and force Igor to place his letters in front So what exactly will the final string look like We ll look at the moves one by one If at some point Oleg s smallest letter is still strictly smaller than Igor s largest letter then both player must put their smallest largest if it s Igor letter as the frontmost letter Why Suppose not then on the next turn the other player will occupy that spot with their best smallest if Oleg largest if Igor letter and the resulting string will be worse for the current player This proves that greedy is correct in this case Now what if Oleg s smallest letter is not smaller than Igor s largest letter In this case both players will want to force the other player to place their own letter at the beginning of the string It can be proven that in this case each person will place their current worst largest if Oleg smallest if Igor letter at the back of the string in the optimal strategy Thus we can calculate the final string starting from this point and after that reverse this part and combine it with the first part of the string where both players greedily place their best letters in the beginning Time Complexity O n Many people failed on pretest 6 initially because they didn t consider the second case "}
{"statement": "There are n houses numbered from 1 to n on a circle For each 1 leq i leq n 1 house i and house i 1 are neighbours additionally house n and house 1 are also neighbours Initially m of these n houses are infected by a deadly virus Each Cirno can choose a house which is uninfected and protect the house from being infected permanently Every day the following things happen in order Cirno chooses an uninfected house and protect it permanently All uninfected unprotected houses which have at least one neighbor become infected Cirno wants to stop the virus from spreading Find the minimum number of houses that will be infected in the end if she optimally choose the houses to protect Note that every day Cirno always chooses a house to protect the virus spreads Also a protected house will not be infected forever ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "First considering it is easier to calculate the number of houses which are not infected so we focus on it firstly Conspicuously if between and there are houses Array has been sorted and the infection will last days there will remain houses on the end Simultaneously every day we can protect at least one house permanently which indicates that for every distance between and if we have an opportunity to get one house protected Moreover the longer uninfected segments have priorities because we can set two houses to stop the spread of inflection and the loss per day will be prevented By contrast for shorter segments when all the houses in this segment are infected then there won t be any loss afterwards In other words the loss of longer segments will last for longer time if we do not take actions in time As a result if we operate the longer segments as early as possible we can protect more houses In conclusion our final strategy can be decribed as following Sort the uninfected segments of houses according to their length then the longer the segment is the earlier we will deal with the houses lying on the side of the segment "}
{"statement": "Dmitry has an array of n non negative integers a 1 a 2 dots a n In one operation Dmitry can choose any index j 1 le j le n and increase the value of the element a j by 1 He can choose the same index j multiple times For each i from 0 to n determine whether Dmitry can make the mathrm MEX of the array equal to exactly i If it is possible then determine the minimum number of operations to do it The mathrm MEX of the array is equal to the minimum non negative integer that is not in the array For example the mathrm MEX of the array 3 1 0 is equal to 2 and the array 3 3 1 4 is equal to 0 ", "greedy": 1, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "First let s sort the array Then we will consider its elements in non decreasing order To make MEX equal to you need to increase all zeros To make MEX at least you first need to make MEX at least and then if the number is missing in the array you need to get it If there are no extra values less than then this and all subsequent MEX values cannot be obtained Otherwise you can use the maximum of the extra array values To do this you can use a data structure such as a stack If an element occurs more than once in the array put its extra occurrences on the stack "}
{"statement": "The next lecture in a high school requires two topics to be discussed The i th topic is interesting by a i units for the teacher and by b i units for the students The pair of topics i and j i j is called if a i a j b i b j i e it is more interesting for the teacher Your task is to find the number of pairs of topics ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Let s rewrite the inequality from to This looks much simpler Let s build the array where and sort this array Now our problem is to find the number of pairs such that Let s iterate over all elements of from left to right For simplicity we consider only greater summands Because our sum must be greater than then at least one of these summands will be positive So if just skip it Now and we need to calculate the number of such that and It means that each for some will be okay Such leftmost position can be found with or binary search Then add the value to the answer and consider the next element Time complexity "}
{"statement": "You are given a tree with n vertices numbered 1 2 ldots n Initially all vertices are colored white You can perform the following two step operation Choose a vertex v 1 leq v leq n and a distance d 0 leq d leq n 1 For all vertices u 1 leq u leq n such that text dist dagger u v d color u black Construct a sequence of operations to color all the nodes in the tree black using the minimum possible number of operations It can be proven that it is always possible to do so using at most n operations dagger text dist x y denotes the number of edges on the unique simple path between vertices x and y on the tree ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Solution For a line an obvious bound on the answer is as we can colour atmost nodes per operation I claim this is achieveable except for when mod where we do worse That is however still provably optimal as you can bicolour the line and operations only colours nodes black which are in the same bicolouring Construction for lineWhen mod simply use the centre of the line and do operations of the form When mod for convenience let the line be Then we can do operations like When mod either of the above methods can be adapted to work because we are allowed extra operation Now that we have the solution for the line case lets divide into cases based on parity of diamater maximum number of nodes on a path diameter mod Find the centre of the diamater Then we can simply do operations of the form for all If this doesn t colour all nodes then one can easily check that the diamater we found is not the real diamater as the node which is not coloured is an endpoint of a larger diameter diamater mod Find the centres of the diameter Then the following set of operations satisfy the requirements and for all odd satisfying The intuition behind this is to basically split the nodes into sets according to a bicolouring and then centre colours all nodes of a certain colour while the other centre colours all nodes of the other colour "}
{"statement": "Let us remind you the rules of a very popular game called Snake or sometimes Boa Python or Worm The game field is represented by an rectangular table Some squares of the field are considered impassable walls all other squares of the fields are passable You control a snake the snake consists of segments Each segment takes up exactly one passable square of the field but any passable square contains at most one segment All segments are indexed by integers from to where is the snake s length The th segment is the head and the th segment is the tail For any segments with indexes and are located in the adjacent squares of the field that is these squares share a common side One of the passable field squares contains an apple The snake s aim is to reach the apple and eat it that is to position its head in the square with the apple The snake moves throughout the game During one move the snake can move its head to an adjacent field square All other segments follow the head That is each segment number moves to the square that has just had segment number Consider that all segments including the head move simultaneously see the second test sample If the snake s head moves to an unpassable square or to the square occupied by its other segment the snake dies That s why we will consider such moves unvalid Your task is to determine the minimum number of valid moves that the snake needs to reach the apple ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2200", "problem_editorial": "There is just BFS State is head place and mask that store place of tail using 2 bits you can code position of every segment in relation to previous segment Mask will contain no more than 16 bits and number of all states will be no more than 48 15 15 also you can try understand that number of states no more than 38 15 15 "}
{"statement": "Mr Apple a gourmet works as editor in chief of a gastronomic periodical He travels around the world tasting new delights of famous chefs from the most fashionable restaurants Mr Apple has his own signature method of review in each restaurant Mr Apple orders two sets of dishes on two different days All the dishes are different because Mr Apple doesn t like to eat the same food For each pair of dishes from different days he remembers exactly which was better or that they were of the same quality After this the gourmet evaluates each dish with a positive integer Once during a revision of a restaurant of Celtic medieval cuisine named Poisson that serves chestnut soup with fir warm soda bread spicy lemon pie and other folk food Mr Apple was very pleasantly surprised the gourmet with its variety of menu and hence ordered too much Now he s confused about evaluating dishes The gourmet tasted a set of n dishes on the first day and a set of m dishes on the second day He made a table a of size n times m in which he described his impressions If according to the expert dish i from the first set was better than dish j from the second set then a ij is equal to in the opposite case a ij is equal to Dishes also may be equally good in this case a ij is Now Mr Apple wants you to help him to evaluate every dish Since Mr Apple is very strict he will evaluate the dishes so that the maximal number used is as small as possible But Mr Apple also is very fair so he never evaluates the dishes so that it goes against his feelings In other words if a ij is then the number assigned to dish i from the first set should be less than the number of dish j from the second set if a ij is then it should be greater and finally if a ij is then the numbers should be the same Help Mr Apple to evaluate each dish from both sets so that it is consistent with his feelings or determine that this is impossible ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2000", "problem_editorial": "This task has different possible solutions One of them is as follows make a DSU for all dishes Disjoint Set Union data structure https en wikipedia org wiki Disjoint set data structure and unite all dishes that should be evaluated with the same number according to the table unite dishes and if equals Then create graph We will iterate over all and add a directed edge in some direction between the sets corresponding to the and if one of them is better then the other In case the graph has a self loop or cycle it s easy to see that the answer is impossible Otherwise assign numbers where the vertex gets the least number greater than the vertex it goes to This is the answer "}
{"statement": "O o and Another Young BoyAn array of n integers a 1 a 2 ldots a n fell down on you from the skies along with a positive integer k le n You can apply the following operation at most k times Choose an index 1 le i le n and an integer 1 le x le 10 9 Then do a i x assign x to a i Then build a complete undirected graph with n vertices numbered with integers from 1 to n where edge l r 1 le l r le n has weight min a l a l 1 ldots a r You have to find the maximum possible of the resulting graph after performing at most k operations The of a graph is equal to max limits 1 le u v le n operatorname d u v where operatorname d u v is the length of the shortest path between vertex u and vertex v ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "First of all we will always use the operation to assign to 1 Suppose Then Proof since the weight of an edge is always the best we can do with one edge is And the best we can possibly do with two edges is which turns out possible to achieve Subproof suppose is the index of one of the minimums in the array If then is optimal so we don t need two edges in the first place Else either or In the first case we can notice that In the second case 2 The diameter of the graph is equal to Proof since the minimum of a subsegment can only decrease when it s length increases it is optimal to look only at the distance between two adjacent vertices Now we can either do binary search on the answer or we can do a clever greedy Binary search solution Suppose the answer is First of all we need to apply the operation for all If there are not enough operations to do this return false Otherwise assign to such If there are no operations left just calculate the diameter and see if it is If there is at least one operation left there are two cases and If the first case it is optimal to apply our operation near one of the maximums in the array to maximize so we need to return true if With it is optimal to apply the operation near an index which has been turned into so we always return true Make sure to binary search on from to inclusive Doing it from to needs another case to work Complexity Greedy solution We can actually maintaining the diameter of the graph while supporting point update queries set to some value To do this we can use any structure that can get multiset segment tree and another structure to maintain the minimum in the array Change the smallest values in the array into For every from to change to get the diameter and then change back to it s original value The answer is the max value over all the returned diameters Proof obviously works for so suppose Since we changed at least one value we will check if having two adjacent is optimal maximizing And we will also check if we need to change the th smallest value in this case maximizing Complexity Note it is also possible to solve without data structures by doing a bit more casework but the solution is still due to sorting "}
{"statement": "Ksyusha decided to start a game development company To stand out among competitors and achieve success she decided to write her own game engine The engine must support a set initially consisting of n distinct integers a 1 a 2 ldots a n The set will undergo m operations sequentially The operations can be of the following types Insert element x into the set Remove element x from the set Report the k load of the set The k load of the set is defined as the integer d such that the integers d d 1 ldots d k 1 do not appear in this set For example the 3 load of the set 3 4 6 11 is 7 since the integers 7 8 9 are absent from the set and no smaller value fits Ksyusha is busy with management tasks so you will have to write the engine Implement efficient support for the described operations ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "We will maintain the elements of a set in We will also maintain a of free segments in the form of half intervals These segments can be easily updated during insertion and deletion operations In one case we need to remove a large segment and insert two small ones in another case we need to remove two small ones and insert one large segment We will find suitable segments using To answer the query we will maintain a Cartesian tree where the keys are pairs Additionally we will store the minimum of all left boundaries at the nodes Now to answer the query it is sufficient to cut the Cartesian tree at and take the minimum from the stored minimums The time complexity of the solution is "}
{"statement": "Nauuo is a girl who loves playing cards One day she was playing cards but found that the cards were mixed with some empty ones There are n cards numbered from 1 to n and they were mixed with another n empty cards She piled up the 2n cards and drew n of them The n cards in Nauuo s hands are given The remaining n cards in the pile are also given in the order from top to bottom In one operation she can choose a card in her hands and play it put it at the bottom of the pile then draw the top card from the pile Nauuo wants to make the n numbered cards piled up in increasing order the i th card in the pile from top to bottom is the card i as quickly as possible Can you tell her the minimum number of operations ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "First try to finish it without playing any empty cards If that s not possible the best choice is to play several empty cards in a row then play from to For a card suppose that it is in the th position in the pile if it is in the hand you have to play at least empty cards So the answer will be "}
{"statement": "Some country consists of cities located along a straight highway Let s number the cities with consecutive integers from to in the order they occur along the highway Thus the cities are connected by segments of the highway the th segment connects cities number and Every segment of the highway is associated with a positive integer the period of traffic jams appearance on it In order to get from city to city some drivers use the following tactics Initially the driver is in city and the current time equals zero Until the driver arrives in city he perfors the following actions if the current time is a multiple of then the segment of the highway number is now having traffic problems and the driver stays in the current city for one unit of time formally speaking we assign if the current time is not a of then the segment of the highway number is now clear and that s why the driver uses one unit of time to move to city formally we assign and You are developing a new traffic control system You want to consecutively process queries of two types determine the final value of time after the ride from city to city assuming that we apply the tactics that is described above Note that for each query is being reset to replace the period of traffic jams appearing on the segment number by value formally assign Write a code that will effectively process the queries given above ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "The solution of a problem 60 LCM of a numbers from 2 to 6 segment trees In th segment tree we will hold for every segment the next value minimum time needed to get from to if we start in a moment of time equal to modulo 60 Using these trees values it is easy to quickly answer the questions carefully changing the trees values "}
{"statement": "There is a system of vessels arranged one above the other as shown in the figure below Assume that the vessels are numbered from 1 to in the order from the highest to the lowest the volume of the th vessel is liters Initially all the vessels are empty In some vessels water is poured All the water that overflows from the th vessel goes to the th one The liquid that overflows from the th vessel spills on the floor Your task is to simulate pouring water into the vessels To do this you will need to handle two types of queries Add liters of water to the th vessel Print the number of liters of water in the th vessel When you reply to the second request you can assume that all the water poured up to this point has already overflown between the vessels ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "The naive solution for this problem will work like this Let us store an amount of water in each vessel in some array If we need to know how much water is in some vessel we just take the number from the array If we need to pour units of water into vessel number we must follow the simple procedure 1 If then all water is poured and we must end the procedure 2 If Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX In the worst case scenario such procedure can iterate through all vessels each time For example if there are vessels and each vessels have capacity of one unit of water each query like Unable to parse markup type CF TEX To make this solution faster we should notice that once completely filled vessel can be skipped during the algorithm above because it can not consume any more water So instead of Unable to parse markup type CF TEX Unable to parse markup type CF TEX To implement this function we can use different structures For example we can use sorted set of numbers set in C TreeSet in Java Let store the set of indices of unfilled vessels So to find next not filled vessel from th vessel we must find smallest number that is contained in set and is strictly greater than There are built in methods for it upper bound in C higher in Java Also each time we fill the vessel we must erase corresponding index from the set So now we can see that algorithm can not complete more that Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX "}
{"statement": "You are given a string t and n strings s 1 s 2 dots s n All strings consist of lowercase Latin letters Let f t s be the number of occurences of string s in string t For example f text aaabacaa text aa 3 and f text ababa text aba 2 Calculate the value of sum limits i 1 n sum limits j 1 n f t s i s j where s t is the concatenation of strings s and t Note that if there are two pairs i 1 j 1 and i 2 j 2 such that s i 1 s j 1 s i 2 s j 2 you should include both f t s i 1 s j 1 and f t s i 2 s j 2 in answer ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Let s look at any occurrence of arbitrary pair There is exactly one special split position where the ends and starts So instead of counting occurrences for each pair we can iterate over the position of split and count the number of pairs This transformation is convenient since any which ends in split position can be paired with any which starts here So all we need is to calculate for each suffix the number of strings which starts here and for each prefix the number of strings which ends here But calculating the prefixes can be transformed to calculating suffixes by reversing both and all Now we need for each position calculate the number of strings which occur from It can be done by Aho Corasick Suffix Array Suffix Automaton Suffix Tree but do we really need them since constrains are pretty low The answer is NO We can use sqrt heuristic Let s divide all in two groups short and long The is short if There are no more than long strings and for each such string we can find all its occurrences with z function or prefix function It will cost as What to do with short strings Let s add them to trie The trie will have vertices but only depth So we can for each move down through the trie while counting the occurrences using only substring It will cost us So if we choose we can acquire complexity using only basic string structures "}
{"statement": "Recently you have bought a snow walking robot and brought it home Suppose your home is a cell 0 0 on an infinite grid You also have the sequence of instructions of this robot It is written as the string s consisting of characters and If the robot is in the cell x y right now he can move to one of the adjacent cells depending on the current instruction If the current instruction is then the robot can move to the left to x 1 y if the current instruction is then the robot can move to the right to x 1 y if the current instruction is then the robot can move to the top to x y 1 if the current instruction is then the robot can move to the bottom to x y 1 You ve noticed the warning on the last page of the manual if the robot visits some cell 0 0 twice then it breaks So the sequence of instructions is valid if the robot starts in the cell 0 0 performs the given instructions visits no cell other than 0 0 two or more times and ends the path in the cell 0 0 Also cell 0 0 should be visited two times at the beginning and at the end if the path is empty then it is visited only once For example the following sequences of instructions are considered valid and the following are considered invalid the endpoint is not 0 0 and the cell 0 1 is visited twice The initial sequence of instructions however might be not valid You don t want your robot to break so you decided to reprogram it in the following way you will remove some possibly all or none instructions from the initial sequence of instructions then rearrange the remaining instructions as you wish and turn on your robot to move Your task is to remove as few instructions from the initial sequence as possible and rearrange the remaining ones so that the sequence is valid Report the valid sequence of the maximum length you can obtain Note that you can choose order of remaining instructions you don t need to minimize the number of swaps or any other similar metric You have to answer q independent test cases ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "Let be the number of occurrences of the character in the initial string the number of occurrences of the character and are the same things for remaining characters It is obvious that in every answer the number of equals the number of and the same for and The maximum theoretic answer we can obtain has length And We almost always can obtain this answer If there is at least one occurrence of each character then we can construct some kind of rectangular path moves right then moves up and the completing part But there are some corner cases when some characters are missing If then our answer is empty or if it is possible it is The same if Time complexity per test case "}
{"statement": "Andrey needs one more problem to conduct a programming contest He has friends who are always willing to help He can ask some of them to come up with a contest problem Andrey knows one value for each of his fiends the probability that this friend will come up with a problem if Andrey asks him Help Andrey choose people to ask As he needs only one problem Andrey is going to be really upset if no one comes up with a problem or if he gets more than one problem from his friends You need to choose such a set of people that maximizes the chances of Andrey not getting upset ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Let s sort all friends in such a way that iff If there is Andrey should ask only this friend Now we can assume that all probabilities are less then 1 What should we maximize Let Assume we already have some group of people we would ask a help Let s look what will happen with the probability of success if we add a friend with probability to this group It means adding a new people to group will increase a probability of success only if Now let s look at another question We have some group of people with And we want to add only one friend to this group Which one is better Let the probability of the first friend is and the second friend is It s better to add first one if As we get But it s only a local criteria of optimality But we can prove that globally you should use only a group of people with the biggest probabilities We can use proof by contradiction Let s look at the optimal answer with biggest used suffix in the begining of editorial we sort all friends Of all such answers we use one with minimum number of people in it Where are two friends and and th friend is in answer and th isn t Let s look at the answer if we exclude th friend It should be smaller because we used optimal answer with minimum numer of people in it So adding a new people to this group will increase success probability But we know that adding th is better than th So we have found a better answer So we have a very easy solution of this problem After sorting probabilities we should you some suffix of it Because of sorting time complexity is "}
{"statement": "Ohana Matsumae is trying to clean a room which is divided up into an by grid of squares Each square is initially either clean or dirty Ohana can sweep her broom over columns of the grid Her broom is very strange if she sweeps over a clean square it will become dirty and if she sweeps over a dirty square it will become clean She wants to sweep some columns of the room to maximize the number of rows that are completely clean It is not allowed to sweep over the part of the column Ohana can only sweep the whole column Return the maximum number of rows that she can make completely clean ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "For each row there is only one set of columns we can sweep so it becomes completely clean So there are only configurations of sweeping columns to look at Checking a configuration takes time to count the number of rows that are completely clean There are configurations in all so this takes time total Alternatively another way of solving this problem is finding the maximum number of rows that are all the same Example code http codeforces com contest 554 submission 11767576 "}
{"statement": "There is an integer n in its decimal representation Alice and Bob are playing a game with this integer Alice starts first They play the game in turns On her turn Alice swap any two digits of the integer that are on different positions Bob on his turn always removes the last digit of the integer The game ends when there is only one digit left You have to find the smallest integer Alice can get in the end if she plays optimally ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let be the length of Let be the th digit of indexation from the left The game ends immediately so the answer is itself Alice should make the first move and she has to swap and After that Bob removes and in the end there is only Alice can make swaps in such way that when there are only two digits left the second digit will be the maximal digit of Then she will make a swap and the maximal digit will be on the first position The other one will be removed by Bob This way she can always get the maximal digit of in the end of the game "}
{"statement": "Katie Kuro and Shiro are best friends They have known each other since kindergarten That s why they often share everything with each other and work together on some very hard problems Today is Shiro s birthday She really loves pizza so she wants to invite her friends to the pizza restaurant near her house to celebrate her birthday including her best friends Katie and Kuro She has ordered a very big round pizza in order to serve her many friends Exactly n of Shiro s friends are here That s why she has to divide the pizza into n 1 slices Shiro also needs to eat She wants the slices to be exactly the same size and shape If not some of her friends will get mad and go home early and the party will be over Shiro is now hungry She wants to cut the pizza with of straight cuts A cut is a straight segment it might have ends inside or outside the pizza But she is too lazy to pick up the calculator As usual she will ask Katie and Kuro for help But they haven t come yet Could you help Shiro with this problem ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "SolutionIf the answer is obviously If is even we can make diametric cuts Otherwise the only way is to make cuts Time complexity "}
{"statement": " You are given an array a consisting of n integers In one move you can choose any a i and divide it by 2 rounding down in other words in one move you can set a i lfloor frac a i 2 rfloor You can perform such an operation possibly zero number of times with a i Your task is to calculate the minimum possible number of operations required to obtain at least k equal numbers in the array ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Let be the number such that after some sequence of moves there will be at least elements in the array We can see that there is always possible candidates because all values are among all possible values of for some from to So we need to check each candidate separately and try to update the answer with it How to do this Let the current number we trying to obtain is Then let s iterate over all in any order Let be the current value of Let s divide it by while its value is greater than and carry the number of divisions we made If after all divisions then let s remember the value of in some array If after iterating over all elements of the size of is greater than or equal to then let s sort it and update the answer with the sum of smallest values of Time complexity or depends on sorting method "}
{"statement": "After finally qualifying for the IOI 2023 wxhtzdy was very happy so he decided to do what most competitive programmers do trying to guess the problems that will be on IOI During this process he accidentally made a problem which he thought was really cool You are given a tree a connected acyclic graph with n vertices and n 1 edges Vertex i 1 le i le n has a value a i Lets define g u v as the bitwise or of the values of all vertices on the shortest path from u to v For example let s say that we want to calculate g 3 4 on the tree from the first test case in the example On the path from 3 to 4 are vertices 3 1 4 Then g 3 4 a 3 a 1 a 4 here represents the bitwise OR operation Also you are given q queries and each query looks like this You are given x and y Let s consider all vertices z such that z is on the shortest path from x to y inclusive Lets define the of a vertex z as the sum of the number of non zero bits in g x z and the number of non zero bits in g y z You need to find the maximum among all vertices z on the shortest path from x to y Since his brain is really tired after solving an output only problem on SIO he had to do it to qualify for the IOI he wants your help with this problem ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Observation 1 it s enough to only consider vertices on the shortest path from to as candidates for for each query Why Because at most vertices can add a bit to and we only need to maximize the number of bits in the number of bits in and all the other vertices will not contribute to the sum at all so we don t even need to consider them for Now we need to find those vertices We know that for each bit the vertex which we will consider can give this bit to will be the closest one to vertex on the path from to How do we find these vertices qucikly First let s arbitrarily root the tree Now let s precalculate for each vertex and bit as the number of vertices on the path from the root to this vertex which have this bit set in their value Then for each bit we can binary search to find it s first occurenece on the path from to and the path from to We do binary search by taking from vertex to vertex and calculating the number of vertices which have the current bit set by using the matrix combined with range minimum query or binary lifting to find the lowest common ancestor We are searching for the first position where the number of those is 0 Once we find all the vertices we can for each of those in calculate it s niceness and take the maximum out of those Time complexity "}
{"statement": "Given two positive integers n and m Find the sum of all possible values of a 1 bigoplus a 2 bigoplus ldots bigoplus a m where a 1 a 2 ldots a m are non negative integers such that a 1 a 2 ldots a m n Note that all possible values a 1 bigoplus a 2 bigoplus ldots bigoplus a m should be counted in the sum As the answer may be too large output your answer modulo 998244353 Here bigoplus denotes the bitwise XOR operation ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "Editorial If it is clear that we only can have so the answer is If gives a xor of so all with the same parity as and at most can be achieved Notice xor and sum are identical in terms of parity and So these restrict that only values of that has same parity with and is at most is possible as a result of the xor Therefore we can use to calculate the sum of all non negative integers at most and have same parity as It remains to handle the case when We create the functions and where is the sum of all possible values of the xor and counts the number of all possible values of the xor We then consider the following If is odd then one of is even and the other is odd WLOG assume is even and is odd Then we let and We can see that and Hence we know that and If is even there are two cases If and are both even we let and We can see that and If and are both odd we let and We can see that and Hence we know that and So we can simply DP It can be seen that the time complexity is per test case so we are done "}
{"statement": "Petya has an array a consisting of n integers He wants to remove duplicate equal elements Petya wants to leave only the rightmost entry occurrence for each element of the array The relative order of the remaining unique elements should not be changed ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "We will store integers which we already met in a set Let s iterate through the given array from the right to the left Let the current element is equal to So if does not contain in we add in a vector answer and add in After we considered all elements the answer sequence contains in the vector in reversed order So we should reverse the vector and simply print all its elements "}
{"statement": "You are given a binary string of length n You have k moves In one move you must select a single bit The state of all bits that bit will get flipped 0 becomes 1 1 becomes 0 You need to output the lexicographically largest string that you can get after using k moves Also output the number of times you will select each bit If there are multiple ways to do this you may output any of them A binary string a is lexicographically larger than a binary string b of the same length if and only if the following holds in the first position where a and b differ the string a contains a 1 and the string b contains a 0 ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1300", "problem_editorial": "Let s see how many times a given bit will get flipped Clearly a bit gets flipped whenever it is not selected in an operation Therefore the th bit gets flipped times We want to select a bit as few times as possible Now we can handle a few cases is even bit is even number of flips don t change the bit is even bit is odd number of flips toggle the bit from to is odd bit is even number of flips don t change the bit is odd bit is odd number of flips toggle the bit from to Process the string from left to right until you can t anymore If you still have some remaining moves at the end you can just give them all to the last bit Then you can construct the final string by checking the parity of Time complexity "}
{"statement": "Having the magical beanstalk Jack has been gathering a lot of peanuts lately Eventually he has obtained n pockets of peanuts conveniently numbered 1 to n from left to right The i th pocket has a i peanuts Jack and his childhood friend Alice decide to play a game around the peanuts First Alice divides the pockets into some boxes each box will have a non zero number of pockets and each pocket will obviously belong to exactly one box At the same time Alice does not change the order of the boxes that is the boxes are numbered in ascending order of the indices of the pockets in them After that Alice and Jack will take turns alternately with Alice going first At each turn the current player will remove a positive number of peanuts from pocket which belongs to the i e the leftmost box containing at least one non empty pocket In other words if we number the boxes from left to right then each player can only pick peanuts from the pocket in the j th box j ge 2 only if the j 1 th box has no peanuts left The player who cannot make a valid move loses Alice is sure she will win since she has the advantage of dividing the pockets into boxes herself Thus she wanted to know how many ways there are for her to divide the peanuts into boxes at the start of the game so that she will win assuming both players play optimally Can you help her with the calculation As the result can be very large output it modulo 998 244 353 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Let s get the trivial case out of the way If the peanut pockets always contain nut each then partitioning the pockets doesn t affect the game s outcome at all Alice will always win if is odd and there are ways to partition pockets Jack will always win if is even Proof for the trivial case is indeed trivial For the main problem we see that this is a derivative of a game of Nim To be exact each box is a vanilla Nim game To determine the winner of a vanilla Nim game when both players play optimally is trivial if not for you I strongly suggest reading about the game and the Sprague Grundy theorem before continuing In short the Nim sum of a Nim game is the xor sum of all values presented and if that value is at least the first player will win if they play optimally The original game of this problem is a series of consecutive Nim games with the loser of the previous game becoming the first player of the next game Clearly trying to win all the boxes isn t a correct approach one of the simplest counterexamples is a partition with two boxes both with the first player winning if played optimally so of course if the first player wins the first box they immediately lose the second one and thus lose the whole game In short sometimes tactically losing some boxes might be required But how to know which player would lose if they both aimed for it Now introducing the mirrored version of a Nim game a Mis re Nim game where the winning condition is the original Nim game s losing condition If the peanut pockets always contain nut each then the winner of a Mis re Nim game can be easily declared by the parity of Otherwise the winner of a Mis re Nim game can be decided using the same nimber used in a regular Nim game if the nimber is not the first player wins both the original and the Mis re version otherwise the second player wins the optimal strategies to acquire such outcome have the exact mirror intents of those in a regular Nim game Also surpassing the leading s in array both Alice and Jack have the rights to tactically lose Thus any of them would win the game if and only if they could win the first box containing non trivial pockets here defined as pockets with more than nut we ll call a box having at least one non trivial pocket a non trivial box if both play optimally until there as proven above if they could theoretically win it they could also tactically lose it thus they would have full control of the game and they could make a decision in accordance with whatever partition coming next in the remaining pockets We ll denote as the number of trivial pockets i e pockets with nut each standing at the left side of array i e the pocket will be the leftmost one to have more than nut We ll consider all possible options for first boxes containing non trivial pockets and thus we ll iterate in range First we denote as the xor sum of all elements of the prefix of array up until the element This value will determine how much control Alice would have If Alice will lose in all cases with the first non trivial box ending at Proof is simple if this box has an even amount of s before it obviously Alice will be the starting player of a game with nimber of and thus cannot control it to her will and if the amount of preceding s is odd then the first non trivial box is a game with nimber of and Jack as first player thus Jack retains full control If Alice will win in all cases with the first non trivial box ending at Proof is literally the reverse of the above case If both Alice and Jack have full control to win it thus Alice will win if and only if she is the starting player of the game at the first non trivial box So we have the detailed winning condition Now towards the maths First whatever pockets after the first non trivial box doesn t matter Thus for each there exists different partitions of the pockets following the one We don t consider cases with obviously If all partitions involving only the first pockets are allowed In fact there are items here trivial pockets and the first non trivial blob always coming last thus the number of different partitions of the pockets preceding the one in this case is If we ll consider all even in range with denoting the number of s not within the first non trivial box Clearly for each the number of different partitions would be And since is fixed and this process has no relation with this value could be pre calculated In more details denoting that value as we have All powers of could be pre calculated as well saving a considerable amount of runtime All pre calculations have time complexity in linear order of the maximum size of array Time complexity "}
{"statement": "Little girl Masha likes winter sports today she s planning to take part in slalom skiing The track is represented as a grid composed of squares There are rectangular obstacles at the track composed of grid squares Masha must get from the square to the square She can move from a square to adjacent square either to the right or upwards If the square is occupied by an obstacle it is not allowed to move to that square One can see that each obstacle can actually be passed in two ways either it is to the right of Masha s path or to the left Masha likes to try all ways to do things so she would like to know how many ways are there to pass the track Two ways are considered different if there is an obstacle such that it is to the right of the path in one way and to the left of the path in the other way Help Masha to find the number of ways to pass the track The number of ways can be quite big so Masha would like to know it modulo The pictures below show different ways to pass the track in sample tests ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "3100", "problem_editorial": "First let us consider all paths from the starting square to the finish one Let us say that two paths are equivalent if each obstacle is at the same side for both paths For each class of equivalence let us choose the representative path the one that tries to go as low as possible lexicographically minimum Let us use dynamic programming For each square let us count the number of representative paths that go from the starting square to this one When the obstacle starts some paths can now separate The new representatives will pass this obstacle from above it will be to the right of them So we add the sum of values for squares below it but above any other lower obstacle to the value for the square right above the obstacle To overcome the time and memory limits that the naive solution with O nm memory and O nm2 time complexity we use segment tree for range sum queries with mass update running scanline and events start of an obstacle end of an obstacle This leads to the solution with O m memory and O n log m time complexity "}
{"statement": "Gerald got a very curious hexagon for his birthday The boy found out that all the angles of the hexagon are equal to Then he measured the length of its sides and found that each of them is equal to an integer number of centimeters There the properties of the hexagon ended and Gerald decided to draw on it He painted a few lines parallel to the sides of the hexagon The lines split the hexagon into regular triangles with sides of 1 centimeter Now Gerald wonders how many triangles he has got But there were so many of them that Gerald lost the track of his counting Help the boy count the triangles ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Let s consider regular triangle with sides of Let s split it to regular triangles with sides of by lines parallel to the sides Big triange area times larger then small triangles area and therefore big triangle have splitted by small triangles If we join regular triangles to sides and of hexagon we get a triangle sides of Then hexagon area is equals to "}
{"statement": "You are given an integer n which you want to obtain You have an unlimited supply of every integer from 1 to k except integer x there are no integer x at all You are allowed to take an arbitrary amount of each of these integers possibly zero Can you make the sum of taken integers equal to n If there are multiple answers print any of them ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The problem is about considering the least amount of cases possible I propose the following options If then you can always print ones So the answer is If then no integer is available so the answer is If then only is available so you can only collect even So if it s odd the answer is Otherwise you can always collect with the following construction if is even then take otherwise take Then take twos You can see that an even only uses twos so it fits the previous check If it s odd then is at least so is allowed to take Overall complexity per testcase "}
{"statement": "You are given an array a consisting of n integers and an integer k A pair l r is if there exists a sequence of indices i 1 i 2 dots i m such that i 1 l and i m r i j i j 1 for all 1 leq j m and a i j a i j 1 leq k for all 1 leq j m Find the number of pairs l r 1 leq l leq r leq n that are ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "SolutionHow to prove the claim in hint Suppose we have a good pair such that Now using exchange arguments we can claim that there always exists a sequence say starting at index and ending at index such that difference between adjacent elements of is atmost strictly increasing if strictly decreasing if Thus will be counted in if and will be counted in if Time complexity is "}
{"statement": "Once upon a time Mike and Mike decided to come up with an outstanding problem for some stage of ROI rare olympiad in informatics One of them came up with a problem prototype but another stole the idea and proposed that problem for another stage of the same olympiad Since then the first Mike has been waiting for an opportunity to propose the original idea for some other contest Mike waited until this moment You are given an array a of n integers You are also given q queries of two types Replace i th element in the array with integer x Replace each element in the array with integer x After performing each query you have to calculate the sum of all elements in the array ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "As we want to perform queries fast we will store some variables current sum of all elements in the array index of the last query of the second type and its value For each element of the array we will also store index of the last query of the first type that changed this element and its value Now let s answer the queries If we are going to perform a query of the first type we have to know what the number equals now If then now and otherwise Now let s subtract from the sum change and and add the new value to the sum If we are going to perform a query of the second type we have to update values and The new sum of all elements of the array is Time complexity "}
{"statement": "One day a bear lived on the axis He was afraid of the dark so he couldn t move at night along the plane points that aren t lit One day the bear wanted to have a night walk from his house at point to his friend s house at point along the segment of length Of course if he wants to make this walk he needs each point of the segment to be lit That s why the bear called his friend and yes in the middle of the night asking for a very delicate favor The axis contains floodlights Floodlight is at point and can light any angle of the plane as large as degree with vertex at point The bear asked his friend to turn the floodlights so that he the bear could go as far away from his house as possible during the walking along the segment His kind friend agreed to fulfill his request And while he is at it the bear wonders what is the furthest he can go away from his house Hep him and find this distance Consider that the plane has no obstacles and no other light sources besides the floodlights The bear s friend cannot turn the floodlights during the bear s walk Assume that after all the floodlights are turned in the correct direction the bear goes for a walk and his friend goes to bed ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "In this task it is crucial to understand that whether there is lighted part of road with length then next part should be lit in a such way that leftmost lighted point is touching with Let s suppose that road is lit from to How we can find rightmost point on X axis that would be lit by next floodlight We can just use concepts of vector and rotation matrix Let s find vector from floodlight to point on X axis Next point to rotate vector by degrees We can use rotation matrix for this purpose Next we should make second component of equal to by multiplying on coefficient Now we can determine rightmost lighted point of X axis It is You shouldn t forget that there is possibility for rightmost point to be infinitely far point From now on we can forget about geometry in this task Let s find fast way to determine optimal order of floodlights To achieve this goal we can use dynamic programming approach Namely let s calculate answer for subsets of floodlights Each subset would be represented as integer where bit would be if floodlight is presented in subset and if it is not i e so named binary mask For example is optimal answer for subset from and floodlight Now let s look through subsets in In subset let s go through absent floodlights and update result for subset where floodlight is present i e dp or max dp or dp calc rightmost lighted point As we can calculate rightmost lighted point so updating of answer shouldn t be a problem "}
{"statement": "A tennis tournament with participants is running The participants are playing by an olympic system so the winners move on and the losers drop out The tournament takes place in the following way below is the number of the participants of the current round let be the maximal power of the number such that participants compete in the current round and a half of them passes to the next round the other participants pass to the next round directly when only one participant remains the tournament finishes Each match requires bottles of water for each participant and one bottle for the judge Besides towels are given to each participant for the whole tournament Find the number of bottles and towels needed for the tournament Note that it s a tennis tournament so in each match two participants compete one of them will win and the other will lose ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "The problem was suggested by unprost Here you can simply model the process Or you can note that after each match some player drops out In total players will drop out So the first answer is Obviously the second answer is solution 1 solution 2 Complexity or depends on the realization "}
{"statement": "Polycarp loves lowercase letters and dislikes uppercase ones Once he got a string consisting only of lowercase and uppercase Latin letters Let be a set of positions in the string Let s call it if following conditions are met letters on positions from in the string are all distinct and lowercase there are no uppercase letters in the string which are situated between positions from i e there is no such that is an uppercase letter and for some and from Write a program that will determine the maximum number of elements in a set of positions ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Let s solve the given problem in the following way We will iterate through the letters in the string in order from left to right If we are in position and the next letter is uppercase we skip it In the other case we need to create and put letter in it After that we iterate through string to the right until we do not met uppercase letter or until the string does not ended We put in each new lowercase letter After we met uppercase letter let position of this letter is or string is ended we update the answer with the number of elements in and repeat described algorithm starting from position "}
{"statement": "Stepan is a very busy person Today he needs to send n messages at moments m 1 m 2 dots m n m i m i 1 Unfortunately by the moment 0 his phone only has f units of charge left At the moment 0 the phone is turned on The phone loses a units of charge for each unit of time it is on Also at any moment Stepan can turn off the phone and turn it on later This action consumes b units of energy each time Consider turning on and off to be instantaneous so you can turn it on at moment x and send a message at the same moment and vice versa send a message at moment x and turn off the phone at the same moment If at any point the charge level drops to 0 becomes le 0 it is impossible to send a message at that moment Since all messages are very important to Stepan he wants to know if he can send all the messages without the possibility of charging the phone ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "The most challenging part of this problem was probably carefully understanding the problem statement The problem can be reduced to the following There are time intervals from 0 to from to from to For each interval we need to find a way to spend as little charge of the phone as possible and check that the total amount of charge we spend is less than the initial charge of the phone To spend the minimum amount of charge for one time interval we can act in one of two ways Let the length of the interval be We either leave the phone on and spend units of charge or turn off the phone at the very beginning of the interval and turn it on at the very end spending units of charge The total time complexity of this solution is "}
{"statement": "Daniel has a string consisting of lowercase English letters and period signs characters Let s define the operation of as the following sequence of steps find a substring two consecutive periods in string of all occurrences of the substring let s choose the first one and replace this substring with string In other words during the replacement operation the first two consecutive periods are replaced by one If string contains no two consecutive periods then nothing happens Let s define as the minimum number of operations of to perform so that the string does not have any two consecutive periods left You need to process queries the th results in that the character at position of string is assigned value After each operation you have to calculate and output the value of Help Daniel to process all queries ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "Lets find how replacements occur If we have segment of points with length we need operations and stop replacements for this segment If we sum lenghts of all segments and its quantity then answer will be total length of segments quantity of segments After change of one symbol length changes by 1 Quantity of segments can be supported by array Consider events of merging dividing creation and deletion of segments For merging we need to find if both of neighbors right and left are points then merging occured and quantity of segments reduced by 1 Other cases can be cosidered similarly Solutions "}
{"statement": "Bessie and the cows have recently been playing with cool sequences and are trying to construct some Unfortunately they are bad at arithmetic so they need your help A pair of positive integers is cool if can be expressed as the sum of consecutive integers not necessarily positive A sequence is cool if the pairs are all cool The cows have a sequence of positive integers In one move they may replace some with any other positive integer there are no other limits on the new value of Determine the smallest number of moves needed to make the resulting sequence cool ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Here is a full solution to Codeforces 174 div 1 D Let 2 n denote the exponent of the largest power of 2 that divides n For example 2 5 0 2 96 5 Let f n denote the largest odd factor of n Note the following formula for sum of arithmetic series I claim that the pair x y is cool if and only if and one of the following is true begin enumerate item 2 x 1 2 y item 2 y 0 end enumerate This can be proven by casework on the number on the parity of y If y is odd the average term of the arithmetic sequence is an integer so f y y divides f x and 2 y 0 If y is even the average is of the form 5 k where k is odd so so it follows that y divides x so f y divides f x and furthermore From this observation it follows that for fixed ai aj i j we can construct a cool sequence ai bi bi 1 bj 1 bj aj if and only if and either 2 ai j i 2 aj or 2 aj j i 1 Now that we have this observation we can finish the problem using dynamic programming where the kth state is the maximum number of ai i k we can keep so that it is possible to make a1 ak cool Then the answer is just n max dp 1 dp 2 dp n "}
{"statement": "Mahmoud and Ehab continue their adventures As everybody in the evil land knows Dr Evil likes bipartite graphs especially trees A tree is a connected acyclic graph A bipartite graph is a graph whose vertices can be partitioned into sets in such a way that for each edge that belongs to the graph and belong to different sets You can find more formal definitions of a tree and a bipartite graph in the notes section below Dr Evil gave Mahmoud and Ehab a tree consisting of nodes and asked them to add edges to it in such a way that the graph is still bipartite Besides after adding these edges the graph should be simple doesn t contain loops or multiple edges What is the maximum number of edges they can add A loop is an edge which connects a node with itself Graph doesn t contain multiple edges when for each pair of nodes there is no more than one edge between them ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1300", "problem_editorial": "The tree itself is bipartite so we can run a dfs to partition the tree into the 2 sets called bicoloring We can t add an edge between any 2 nodes in the same set and we can add an edge between every 2 nodes in different sets so let the number of nodes in the left set be and the number of nodes in the right set be The maximum number of edges that can exist is but edges already exist so the maximum number of edges to be added is Time complexity Solution link me https pastebin com w3bF7gKS Solution link mahmoudbadawy https pastebin com PMpte7nC "}
{"statement": "You are given a string consisting of lowercase Latin letters Character is called dominant iff each substring of with length at least contains this character You have to find minimum such that there exists at least one dominant character ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "At first notice that the final answer is minimum over answers for each character The answer for one character can be obtained like this Write down lengths of segments between two consecutive occurrences of this character from the first occurrence to the start of the string and from the last to the end of the string Take maximum of these values Answer will be this maximum 1 Overall complexity "}
{"statement": "We picked an array of whole numbers a 1 a 2 ldots a n 0 le a i le 10 9 and concealed zero in it Your goal is to find the location of this zero that is to find i such that a i 0 You are allowed to make several queries to guess the answer For each query you can think up three distinct indices i j k and we will tell you the value of max a i a j a k min a i a j a k In other words we will tell you the difference between the maximum and the minimum number among a i a j and a k You are allowed to make no more than 2 cdot n 2 queries and after that you have two tries to guess where the zero is That is you have to tell us two numbers i and j and you win if a i 0 or a j 0 Can you guess where we hid the zero Note that the array in each test case is fixed beforehand and will not change during the game In other words the interactor is not adaptive ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Notice that for any four numbers we can locate at least two numbers among them that are certainly zeroes using only four queries as follows For each of the four numbers compute it s that is the difference between the maximum and the minimum of the other three numbers and so on This takes exactly four queries Now consider what happens if one of the four numbers was a zero For instance if then so the two largest complements in this example are always complements of non zeroes Of course the order of the values could be different but the numbers with the two largest complements will always be guaranteed non zeroes If there is no zero among these numbers then we can still run this algorithm because it doesn t matter exactly which numbers it will yield they are all non zero anyway Now let s learn how to solve the problem using this algorithm Start with a pile of the first four numbers apply the algorithm and throw two certain non zeroes away Add the next two numbers to the pile and drop two non zeroes again Repeat this until there are two or three numbers left in the pile depending on the parity of If there are three elements left add some number that we have already dropped to the pile again and apply the algorithm the last time If is even we have made queries If is odd we have made queries The complexity of this solution is and the solution uses no more than queries "}
{"statement": "Alice has a coins She can open a bank deposit called Profitable but the minimum amount required to open this deposit is b coins There is also a deposit called Unprofitable which can be opened with amount of coins Alice noticed that if she opens the Unprofitable deposit with x coins the minimum amount required to open the Profitable deposit decreases by 2x coins However these coins cannot later be deposited into the Profitable deposit Help Alice determine the maximum number of coins she can deposit into the Profitable deposit if she first deposits some amount of coins possibly 0 into the Unprofitable deposit If Alice can never open the Profitable deposit output 0 ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Let s say we have deposited coins into the Unprofitable deposit then we can open a Profitable deposit if is satisfied Which is equivalent to the inequality Thus we need to open an Unprofitable deposit for coins and open a Profitable deposit for the rest of the coins "}
{"statement": "This winter is so well you ve got the idea The Nvodsk road system can be represented as junctions connected with bidirectional roads so that there is a path between any two junctions The organizers of some event want to choose a place to accommodate the participants junction and the place to set up the contests junction Besides at the one hand they want the participants to walk about the city and see the neighbourhood that s why the distance between and should be no less than On the other hand they don t want the participants to freeze so the distance between and should be no more than Besides for every street we know its beauty some integer from to Your task is to choose the path that fits in the length limits and has the largest average beauty We shall define the average beauty as a median of sequence of the beauties of all roads along the path We can put it more formally like that let there be a path with the length Let be a non decreasing sequence that contains exactly elements Each number occurs there exactly the number of times a road with such beauty occurs along on path We will represent the path median as number assuming that is used is number rounded down to the nearest integer For example if then the median equals to and if then the median is number It is guaranteed that there will be at least one path with the suitable quantity of roads ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "3000", "problem_editorial": "If there exists a path with the median for some then there exists a path with the median for each That means we can use binary search to calculate the answer So now the task is is there any path with the median greater or equal to We will calc the edge as if it s wight or as in other case Now we only need to check if there exists a path with legal length and the sum greater than or equal to zero Let s denote some node as a root All paths can be divided into two types that contains and that do not Now we are to process all first type paths and run the algorithm on all subtrees That is so called divide and conquer strategy We can trivially show that it is always possible to choose such vertex that all it s subtrees will have size less than or equal to the size of the whole tree That means that each node will be proccessed in trees max So if we solve the task for one level of recursion in we ll solve it in time on the whole First lets get For each node we shall calc it s deepness cost of the path to the root ans the first edge the number of the root s subtree It will be better now to use 2 and 0 as the edges costs instead of 1 and 1 Now we shall process root s subtrees one by one For each node we want to know if there exists a node in any other subtree such that the Unable to parse markup type CF TEX To achieve an AC contestants were to write all code optimally or to think of one more idea It is possible to have on one level of recursion and in total if you sort roots subtrees in non decreasing order and use any structure that can answer getmax query on all segments of length and all prefixes and suffixes Best of luck to you in upsolving this problem "}
{"statement": "One day Petya encountered a tree with vertexes Besides the tree was weighted i e each edge of the tree has weight a positive integer An edge is lucky if its weight is a lucky number Note that a is an undirected connected graph that has exactly edges Petya wondered how many vertex triples exists that on the way from to as well as on the way from to there must be at least one lucky edge all three vertexes are pairwise distinct The order of numbers in the triple matters that is the triple is not equal to the triple and is not equal to the triple Find how many such triples of vertexes exist ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Solve this problem using dynamic programming Consider that root of a tree is vertex with number 1 Let F x number of vertex in subtree of vertex x for which there is a path containing lucky edge We will calculate F x using recursion If x is a leaf than F x 0 Else if there is an edge from x that leads to y and this edge is lucky then to F x we need to add C y otherwise we add F y here C y number of vertex in subtree of y including y But to solve this problem we need to know also F x number of vertex which are not in subtree of x and there exits a path from x to that vertex that contains lucky edge For a root of tree F x equals to 0 We should go recursive from root and if we are in vertex x now we suppose that F x is already calculated If from x we can directly go to y and that edge is lucky then F y C 0 C y otherwise F y F x F x F y After that result equals to "}
{"statement": "A sequence of m integers a 1 a 2 ldots a m is if and only if there exists at least one i 1 le i le m such that a i i For example 3 2 3 is a good sequence since a 2 2 a 3 3 while 3 1 1 is not a good sequence since there is no i such that a i i A sequence a is if and only if there exists at least one subsequence of a satisfying that this subsequence is good For example 4 3 2 is a beautiful sequence since its subsequence 4 2 is good while 5 3 4 is not a beautiful sequence A sequence b is a subsequence of a sequence a if b can be obtained from a by the deletion of several possibly zero or all elements Now you are given a sequence check whether it is beautiful or not ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "TutorialThe necessary and sufficient condition for a beautiful sequence is that there exist one such that Just check the sequence for the condition "}
{"statement": "Serval loves playing music games He meets a problem when playing music games and he leaves it for you to solve You are given n positive integers s 1 s 2 ldots s n f x is defined as the number of i 1 leq i leq n that exist non negative integers p i q i such that s i p i left lfloor s n over x right rfloor q i left lceil s n over x right rceilFind out sum x 1 s n x cdot f x modulo 998 244 353 As a reminder lfloor x rfloor denotes the maximal integer that is no greater than x and lceil x rceil denotes the minimal integer that is no less than x ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Consider the following two cases Case 1 is not a factor of In this case we have Let It can be shown that there are at most different values of The constraint of can be written in the following form For a certain such and do not exist if and only if To prove it we show the contradiction that and we can give a construction of and when that and By observation these are in one of the following intervals We can count the number of these by pre calculating the prefix sums to calculate This case can be solved in time and we will show this fact When there are intervals that need to be considered for a certain Since this part can be solved in time When notice that there are at most intervals that need to be considered for a certain Recall that there are at most different values of in this part so it can be solved in time Case 2 is a factor of In this case we have Let The constraint of becomes To calculate we only need to count the number of multiples of To do this we can first calculate for all in time It is obvious that is a factor of For a certain we can enumerate all the factors of find out the multiples of among them and sum up the times that they occurred in Recall that has at most factors so this takes time This case can be solved in time in total Time complexity solutions can pass all the tests where denotes the sum of all the factors of A well implemented solutions may pass the tests too Bonus Solve this problem in time "}
{"statement": "Carol has a sequence s of n non negative integers She wants to play the Guess Game with Alice and Bob To play the game Carol will select two integer indices i a and i b within the range 1 n and set a s i a b s i b Please note that i a and i b may coincide Carol will tell the value of a to Alice the value of b to Bob the value of a mid b to both Alice and Bob where denotes the bitwise OR operation Please note that Carol will tell any information about s to either Alice or Bob Then the guessing starts The two players take turns making guesses with Alice starting first The goal of both players is to establish which of the following is true a b a b or a b In their turn a player can do one of the following two things say I don t know and pass the turn to the other player say I know followed by the answer a b a b or a b then the game ends Alice and Bob hear what each other says and can use this information to deduce the answer Both Alice and Bob are smart enough and only say I know when they are completely sure You need to calculate the expected value of the number of turns taken by players in the game Output the answer modulo 998 244 353 Formally let M 998 244 353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 le x M and x cdot q equiv p pmod M ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "TutorialFirst let s analize a single game for fixed and how many turns it takes Consider the binary representation of We consider bits from highest to lowest For bits with a value of we can ignore it because it firmly tells us that both bits of and are For convenience we assume that all bits of are In the first round if the highest bit of is then Alice can immediately say that Otherwise in the second round of the game Bob knows that the highest bit of is not If the highest or the second highest bit of b is then Bob can immediately say that Otherwise in the third round of the game Alice knows that the highest and the second highest bits of are not and so on Consider only set bits in Let s enumerate these bits from highest to lowest After some observation we can conclude that If and the th bit in is zero then the answer is If then the answer is where is the number of set bits in If and the th bit in is zero then the answer is Now that we have a brute force algorithm for how can we optimize it We can build a bit trie and traverse all nodes We can easily calculate the number of s that pass from a node to the root node as well as the number of numbers prefixed with it and followed by or Use this information to calculate the answer "}
{"statement": "There are n positive integers a 1 a 2 ldots a n on Bob s homework paper where n is always an number Bob is asked to divide those numbers into groups where each group must contain at least 2 numbers Suppose the numbers are divided into m groups and the sum of the numbers in the j th group is s j Bob s aim is to minimize the sum of the square of s j that is sum j 1 m s j 2 Bob is puzzled by this hard problem Could you please help him solve it ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "This problem is easy as it looks like and it is proved to be simple As is even the optimal grouping policy is to group the smallest with the largest the second smallest with the second largest etc First it is easy to prove that it is optimal to group these numbers by so the proof is given as an exercise to you The proof of the second part is about the Rearrangement Inequality Let s consider two of the permutations of the sequence Suppose they are where if and only if Then the sum is one of the grouping policy of As we do not care about the part We only aim to minimize That is the direct application of the Rearrangement Inequality "}
{"statement": "There is a binary string t of length 10 100 and initally all of its bits are texttt 0 You are given a binary string s and perform the following operation some times Select some substring of t and replace it with its XOR with s dagger After several operations the string t has exactly two bits texttt 1 that is there are exactly two distinct indices p and q such that the p th and q th bits of t are texttt 1 and the rest of the bits are texttt 0 Find the lexicographically largest ddagger string t satisfying these constraints or report that no such string exists dagger Formally choose an index i such that 0 leq i leq 10 100 s For all 1 leq j leq s if s j texttt 1 then toggle t i j That is if t i j texttt 0 set t i j texttt 1 Otherwise if t i j texttt 1 set t i j texttt 0 ddagger A binary string a is lexicographically larger than a binary string b of the same length if in the first position where a and b differ the string a has a bit texttt 1 and the corresponding bit in b is texttt 0 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Ignore leading zeroes of We can add them back at the end Let s view the string as a polynomial in Then in an operation we can multiply by any monomial for some so after some number of operations we can multiply by some other polynomial At the end we have a string with two flipped bits We can in fact make the first character equal to by finding the smallest such that Such a exists because the constant term of is and is arbitrary Rewrite this as Now it s clear that the answer is a divisor of the order of in We can use polynomial factoring algorithms or baby step giant step and meet in the middle The time complexity is or "}
{"statement": "Boboniu defines as a string s of characters B and N You can perform the following operations on the BN string s Remove a character of s Remove a substring or of s Add a character B or N to the end of s Add a string or to the end of s Note that a string a is a of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end Boboniu thinks that BN strings s and t are if and only if s t There exists a permutation p 1 p 2 ldots p s such that for all i 1 le i le s s p i t i Boboniu also defines text dist s t the between s and t as the minimum number of operations that makes s to t Now Boboniu gives you n non empty BN strings s 1 s 2 ldots s n and asks you to find a BN string t such that the maximum distance to string s is minimized i e you need to minimize max i 1 n text dist s i t ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2600", "problem_editorial": "It s obvious that the operation of is equivalent to the operation of which I m talking about for a multi set contains only B and N Remove a B or an N if exists from Insert a B or an N into Remove a B and an N from Insert a B and an N into So let s use pair to denote a which means there are B and N in it We can do an operation to move to The definition of of and is simply and Now the problem is to find a and minimize There are many algorithms to solve it and I ll describe two of them We can figure out the distance between and is It can be shown that the answer is a unimodal function on So by using we can solve the problem in where denotes the times of iteration We also have non randomized algorithm It can be shown that for a fixed pair all the pair with from forms a hexagon So if we draw a hexagon centered on with radius then it must cover all So we can try to find a hexagon with minimal radius to cover all and then we can easily calculate Let s use binary search and do some condition tests to calculate The total time complexity is "}
{"statement": "Emperor Palpatine loves owls very much The emperor has some blueprints with the new Death Star the blueprints contain distinct segments and distinct circles We will consider the segments indexed from to in some way and the circles indexed from to in some way Palpatine defines an owl as a set of a pair of distinct circles and one segment such that circles and are symmetrical relatively to the straight line containing segment circles and don t have any common points circles and have the same radius segment intersects the segment that connects the centers of circles and Help Palpatine count the number of distinct owls on the picture ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "It s possible to solve this problem by using only integer calculations Normalization of the line is following operation we multiply our equation on the value where if then equals to else sgn equals to Now the solution We will have two maps map in TreeMap HashMap in Java to a set of points it s possible that some points will have multiply occurrence into the set In first map we will store right boundaries of the segments in second left boundaries in increasing order In advance for every segment we will build a normalized line and for this normalized line we will put in our maps left and right segments of the segment After all for every fixed line let s sort our sets Let s fix two different circles After that let s check that distance beetween them is greater then sum their radiuses also you should check that circles has same radius We can assume that we builded a line between centers of circles and Perpendicular to this line will have next coefficients center of the segment also will belong to the next line After that you need to calculate values by using binary search on set of points that lie on this line amount of left boundaries that lie on the right side of point amount of right boundaries that lie on the left side of the point After that you should add to answer value l where amount of segments that lie on the nolmalized line Total complexity solution 4632546 "}
{"statement": "The city where Mocha lives in is called Zhijiang There are n 1 villages and 2n 1 directed roads in this city There are two kinds of roads n 1 roads are from village i to village i 1 for all 1 leq i leq n 1 n roads can be described by a sequence a 1 ldots a n If a i 0 the i th of these roads goes from village i to village n 1 otherwise it goes from village n 1 to village i for all 1 leq i leq n Mocha plans to go hiking with Taki this weekend To avoid the trip being boring they plan to go through every village They can start and finish at any villages Can you help them to draw up a plan ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1200", "problem_editorial": "If then the path is valid If then the path is valid Otherwise since there must exists an integer where then the path is valid This is a step to prove that there always exists an Hamiltonian path in a tournament graph "}
{"statement": "Alice and Bob play a game There are n marbles the i th of them has color c i The players take turns Alice goes first then Bob then Alice again then Bob again and so on During their turn a player take of the remaining marbles and remove it from the game If there are no marbles left all n marbles have been taken the game ends Alice s score at the end of the game is calculated as follows she receives 1 point for every color x such that she has taken at least one marble of that color additionally she receives 1 point for every color x such that she has taken marbles of that color of course only colors present in the game are considered For example suppose there are 5 marbles their colors are 1 3 1 3 4 and the game goes as follows Alice takes the 1 st marble then Bob takes the 3 rd marble then Alice takes the 5 th marble then Bob takes the 2 nd marble and finally Alice takes the 4 th marble Then Alice receives 4 points 3 points for having at least one marble for colors 1 3 and 4 and 1 point for having all marbles of color 4 Alice wants to maximize her score at the end of the game Bob wants to minimize it Both players play optimally i e Alice chooses a strategy which allows her to get as many points as possible and Bob chooses a strategy which minimizes the amount of points Alice can get Calculate Alice s score at the end of the game ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "It s fairly intuitive that if there is at least one unique marble available a marble is unique if there are no other marbles with the same color taking it is optimal if Alice takes that marble she gets points and if Bob takes that marble he denies points to Alice So initially both players take unique marbles one by one until there is none left Let s denote the number of unique marbles as then Alice takes unique marbles and gets points for each of them After that all remaining marbles are non unique for each remaining color there are at least two marbles Let s denote the number of remaining colors as We can show that Alice can get more points no matter how Bob plays but she can t get more points if Bob plays optimally There exists a symmetric strategy for each player if during the previous turn your opponent took the first marble of some color respond by taking a marble of the same color otherwise play any legal move This symmetric strategy ensures that Alice gets exactly point for each remaining color since each color will be shared between two players So Alice can always achieve points and Bob can make sure she doesn t get more than So to solve this problem you need to calculate the number of marbles for each color Then let the number of colors with exactly one marble be and the number of colors with more than marble be Alice s score will be "}
{"statement": "Valera loves to participate in competitions Especially in programming contests Today he has participated in the contest with his team consisting of students including Valera This contest was an individual competition so each student in the team solved problems individually After the contest was over Valera was interested in results He found out that each student in the team scored at least points and at most points in total all members of the team scored exactly points the total score of the members of the team who scored the most points is equal to exactly more formally if is the sequence of points earned by the team of students in the non increasing order then However Valera did not find out exactly how many points each of students scored Valera asked you to recover any distribution of scores between the students of the team such that all the conditions above are met ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "In this task you are to determine such array that following conditions are met It s clear to understand that value should be distributed evenly between the first elements For example you can use following algorithm If you should use same algorithm with other elements but there are to distribute value Some participants forgot about test where They received RE11 Author s solution 5306414 "}
{"statement": "Vasily exited from a store and now he wants to recheck the total price of all purchases in his bill The bill is a string in which the names of the purchases and their prices are printed in a row without any spaces Check has the format where name of the th purchase is a non empty string of length not more than consisting of lowercase English letters and the price of the th purchase is a non empty string consisting of digits and dots decimal points It is possible that purchases with equal names have different prices The price of each purchase is written in the following format If the price is an integer number of dollars then cents are not written Otherwise after the number of dollars a dot decimal point is written followed by cents if number of cents is between and inclusively there is a leading zero Also every three digits from less significant to the most in dollars are separated by dot decimal point No extra leading zeroes are allowed The price always starts with a digit and ends with a digit For example and are valid prices and are not valid Write a program that will find the total price of all purchases in the given bill ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "In this problem we need to simply implement calculating the sum of prices At first we need to find all prices sequences of consecutive digits and dots Then we need to find the integer number of dollars in each price and count integer sum of dollars in the variable Also we need to make the same thing for cents and calculate in the variable After process all prices we need to transform cents in rubles i e add to the value and assign to Now we need only to print the answer and do not forget that for cents if we need to print 0 at first and then because the number of cents must consisting of two digits like wrote in the statement "}
{"statement": "Alice likes snow a lot Unfortunately this year s winter is already over and she can t expect to have any more of it Bob has thus bought her a gift a large snow maker He plans to make some amount of snow every day On day he will make a pile of snow of volume and put it in her garden Each day every pile will shrink a little due to melting More precisely when the temperature on a given day is each pile will reduce its volume by If this would reduce the volume of a pile to or below zero it disappears forever All snow piles are independent of each other Note that the pile made on day already loses part of its volume on the same day In an extreme case this may mean that there are no piles left at the end of a particular day You are given the initial pile sizes and the temperature on each day Determine the total volume of snow melted on each day ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "We can directly simulate the process but it takes time which is too slow There are multiple approaches how to make this simulation faster We present two of them In the first solution instead of calculating the total volume of the snow melted we first calculate two quantities F i the number of piles left after day i and M i the total volume of piles that disappear on day i The answer will then be F i T i M i Calculate prefix sums of the temperatures This way when a snow pile is formed on day i we can use binary search to determine on which day it will disappear completely Denote this day by j and put j N 1 if the pile survives We can note that on every day k between i and j 1 inclusive this pile will lose T k of its volume which corresponds to increasing F k by one Furthermore we add the remaining volume to M j To calculate all F i s fast we can again use prefix sums adding 1 to interval can then be done by two additions The second solution can handle queries online For each pile we calculate how big it would be if it was created on the first day We maintain all existing piles in a multiset When a day i starts we add V i into the multiset Then we remove all piles with those are the piles that disappear on day i and easily calculate the total volume of melted snow in them All the piles left in the multiset contribute exactly As the multiset is sorted and each pile is added and removed only once the total complexity is "}
{"statement": "As you probably know chess is a game that is played on a board with 64 squares arranged in an 8 times 8 grid Columns of this board are labeled with letters from to and rows are labeled with digits from to Each square is described by the row and column it belongs to The rook is a piece in the game of chess During its turn it may move any non zero number of squares horizontally or vertically Your task is to find all possible moves for a rook on an empty chessboard ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The answer includes all cells that share the same column or row with the given cell Let s iterate through all the columns keeping the row constant and vice versa iterate through the rows without changing the column To ensure that the input cell is not included in the answer you can either skip it or add all positions to a set and then remove it from there "}
{"statement": "Vasiliy likes to rest after a hard work so you may often meet him in some bar nearby As all programmers do he loves the famous drink which can be bought in different shops in the city It s known that the price of one bottle in the shop is equal to coins Vasiliy plans to buy his favorite drink for consecutive days He knows that on the th day he will be able to spent coins Now for each of the days he want to know in how many different shops he can buy a bottle of ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1100", "problem_editorial": "Consider c x the number of stores in which the price per drink is x We calculate this array prefix sum Then the following options 1 If the current amount of money m is larger than the size of the array with the prefix sums than answer is n 2 Otherwise the answer is c m Time Complexity O n q "}
{"statement": "One evening Rainbow Dash and Fluttershy have come up with a game Since the ponies are friends they have decided not to compete in the game but to pursue a common goal The game starts on a square flat grid which initially has the outline borders built up Rainbow Dash and Fluttershy have flat square blocks with size 1 times1 Rainbow Dash has an infinite amount of light blue blocks Fluttershy has an infinite amount of yellow blocks The blocks are placed according to the following rule each newly placed block must touch the built on the previous turns figure by a side note that the outline borders of the grid are built initially At each turn one pony can place any number of blocks of her color according to the game rules Rainbow and Fluttershy have found out that they can build patterns on the grid of the game that way They have decided to start with something simple so they made up their mind to place the blocks to form a Rainbow Dash is well known for her speed so she is interested in the minimum number of turns she and Fluttershy need to do to get a chess coloring covering the whole grid with blocks Please help her find that number Since the ponies can play many times on different boards Rainbow Dash asks you to find the minimum numbers of turns for several grids of the games The chess coloring in two colors is the one in which each square is neighbor by side only with squares of different colors ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "By modeling the game on different grids it was possible to notice that the answer is equal to You can prove that this is the answer by using induction method separately for grids with even and odd sides Initially it was asked to solve the problem for rectangular grids You can think about this version of the problem "}
{"statement": "You work as a system administrator in a dormitory which has n rooms one after another along a straight hallway Rooms are numbered from 1 to n You have to connect all n rooms to the Internet You can connect each room to the Internet directly the cost of such connection for the i th room is i coins Some rooms also have a spot for a router The cost of placing a router in the i th room is also i coins You cannot place a router in a room which does not have a spot for it When you place a router in the room i you connect all rooms with the numbers from max 1 i k to min n i k inclusive to the Internet where k is the range of router The value of k is the same for all routers Calculate the minimum total cost of connecting all n rooms to the Internet You can assume that the number of rooms which have a spot for a router is not greater than the number of routers you have ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Firstly I know that this problem has very pretty linear solution and its author can describe it if he wants I ll describe my own solution without any data structures but Let be the total cost to connect all rooms from to to the Internet indexed Initially all other values are Let s iterate over all from to and make some transitions After all the answer will be The first transition is the easier update with just connect the current room directly To do other transitions let s carry two sets and and one array of vectors of length Set carries all values Initially it carries Set carries the minimum cost to cover some suffix of rooms that also covers the room Array of vectors helps us to carry the set efficiently First of all if then let s remove from Then let s remove all values of from Then if is not empty let s update with the minimum value of Then if then let be the minimum value of plus Update with and insert into Also let s add into if And after we make all we need with the current add the value to the set Time complexity It can be optimized to solution with some advanced data structures as a queue with minimums "}
{"statement": "BerSoft is the biggest IT corporation in Berland There are n employees at BerSoft company numbered from 1 to n The first employee is the head of the company and he does not have any superiors Every other employee i has exactly one direct superior p i Employee x is considered to be a superior direct or indirect of employee y if one of the following conditions holds employee x is the direct superior of employee y employee x is a superior of the direct superior of employee y The structure of BerSoft is organized in such a way that the head of the company is superior of every employee A programming competition is going to be held soon Two person teams should be created for this purpose However if one employee in a team is the superior of another they are uncomfortable together So teams of two people should be created so that no one is the superior of the other Note that no employee can participate in more than one team Your task is to calculate the maximum possible number of teams according to the aforementioned rules ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "Note that the problem basically states the following you are given a rooted tree you can pair two vertices and if neither is an ancestor of nor is an ancestor of Each vertex can be used in at most one pair Calculate the maximum possible number of pairs you can make Let s look at subtrees of child nodes of the root If two vertices belong to different subtrees we can pair them up So we can slightly rephrase the problem given types of objects with counts find the maximum number of pairs that can be formed using objects of different types This is a well known problem with the following solution Let be the total number of objects and be the type that has the maximum number of objects maximum value of If the number of objects of type is at most the number of all other objects i e then we can pair all objects except if the total number of objects is odd Otherwise we can create pairs of the form for all except Now we can return to the original problem If the first aforementioned option is met for the root then we know the answer to the problem is Otherwise we can create pairs but some nodes from the th child s subtree are left unmatched there are not enough vertices outside that subtree So we can recursively look at the th child subtree and solve the same problem The only difference is that some number of vertices from that subtree are already matched To solve this issue we can add the parameter how many vertices in the current subtree are already matched we care only about the number of them From the second paragraph we know that the best situation we can pair all objects appears when the maximum value is at most the number of all other objects Using this fact we can say that matched vertices belong to the th child s subtree So we have to modify our check formula from to This process goes on until the current vertex subtree is a leaf or the condition is met This solution works in if we precalculate the sizes for all the subtrees with a DFS before running it "}
{"statement": "You have n stacks r 1 r 2 ldots r n Each stack contains some positive integers ranging from 1 to n Define the following functions function init pos stacks an array that contains n stacks r 1 r 2 r n return get stacks pos function get stacks pos if stacks pos is empty return pos else new pos the top element of stacks pos pop the top element of stacks pos return get stacks new pos You want to know the values returned by texttt init 1 texttt init 2 ldots texttt init n Note that during these calls the stacks r 1 r 2 ldots r n don t change so the calls texttt init 1 texttt init 2 ldots texttt init n are independent ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3000", "problem_editorial": "Let s first consider an easy version of the problem what if there is only one element in each stack Let be the element in stack If we link these edges will form several directed pseudo trees For each pseudo tree there is a cycle It s not hard to find that those cycles actually can be ignored because if we go on the cycle we will come back to the first node on the cycle and the cycle will be eliminated After deleting the edges on the cycle there are only trees left Thus the root of each tree is the answer of nodes on the tree When it comes back to the original problem similarly let be the top element of stack The rest are the same cycles can be eliminated In this case we should run cycle elimination process many times until there is no cycle in the graph Time complexity "}
{"statement": "Petya decided to visit Byteland during the summer holidays It turned out that the history of this country is quite unusual Initially there were n different countries on the land that is now Berland Each country had its own territory that was represented as a rectangle on the map The sides of the rectangle were parallel to the axes and the corners were located at points with integer coordinates Territories of no two countries intersected but it was possible that some territories touched each other As time passed sometimes two countries merged into one It only happened if the union of their territories was also a rectangle In the end only one country remained Byteland Initially each country had a rectangular castle inside its territory Its sides were parallel to the axes and its corners had integer coordinates Some castles might touch the border of the corresponding country and sides or other castles Miraculously after all the unions the castles are still intact Unfortunately their locations are the only information we have to restore the initial territories of the countries The possible formation of Byteland The castles are shown in blue Petya wonders why no information about the initial countries remained He suspected that the whole story is a fake You were recommended to him as a smart person Please check whether or not there exists a possible set of initial territories that could make the story true ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "We can rephrase the problem as follows There is a set of non intersecting rectangles on the plane Let s say that some rectangular area on the plane is good if it contains exactly one rectangle in it or there exists a vertical or horizontal cut which cuts the area into two good areas You are asked to check whether the area 0 109 0 109 is good It s easy to see that it is exactly the same process as in the statement except we don t merge countries into one we look at the reversed process where we split one country into many Also let s notice that when we found some cutting line which doesn t goes through inner part of any rectangle we can always apply it to separate our area into two We can do that since our predicate of set of rectangles being nice is monotonic if we replace set of rectangles with its subset it only can make better Now let s analyze when the cut is good This already gives us a solution in O n2log which passes the easy version of the problem Simply solve the problem recursively sorting rectangles as shown above and symmetrically for horizontal cuts and try finding a cut Once we find it solve the problem recursively Now we have working time T n T x T n x O nlogn where x is a size of one part of the cut The worse case is x 1 so T n O n2log For the full version we need a faster solution The key idea is let s cut always smaller from larger Suppose we are magically able to find any valid cut in O 1 basically the number x Then we could have spent O x to cut out the smaller part into new recursive call While we can continue the process of cutting with the remaining rectangles in this recursion call This solution works in O nlogn Each time the size of problem reduces at least twice when we go into recursion so there are only log levels However we need to handle magic here For example one could have used a segment tree to implement all mentioned above it would give a O nlog2 time But there is a simpler solution Let s sort rectangles using all 4 possible sortings And let s iterate over all this sortings simultaneously We need 4 directions instead of 2 because if we would e g only iterate from let to right we wouldn t be able to cut out the smaller from larger in case the smaller is to the right of larger So we want to both go from left to right and from right to left When in one of the directions we see a valid place to make a cut we remove all the rectangles into the separate recursion call We also mark all those rectangles in the current recursion call as deleted and start the procedure of cutting again We can simply skip the rectangles marked as deleted when we encounter them For example we could use a linked list for that So now we got a solution in O nlog2 one logarithm is from cutting smaller from larger and one logarithm is from sorting One could drop the second logarithm For that we should sort all rectangles at the beginning and then carefully pass the correct ordering down the recursion But that wasn t required "}
{"statement": "Vasya s house is situated in a forest and there is a mushroom glade near it The glade consists of two rows each of which can be divided into consecutive cells For each cell Vasya knows how fast the mushrooms grow in this cell more formally how many grams of mushrooms grow in this cell each minute Vasya spends exactly one minute to move to some adjacent cell Vasya cannot leave the glade Two cells are considered adjacent if they share a common side When Vasya enters some cell he instantly collects all the mushrooms growing there Vasya begins his journey in the left upper cell Every minute Vasya must move to some adjacent cell he cannot wait for the mushrooms to grow He wants to visit all the cells and maximize the total weight of the collected mushrooms Initially all mushrooms have a weight of Note that Vasya doesn t need to return to the starting cell Help Vasya Calculate the maximum total weight of mushrooms he can collect ", "greedy": 0, "math": 0, "implementation": 1, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "A route visiting each cell exactly once can always be denoted as follows several possibly zero first columns of the glade are visited in a zigzag pattern then Vasya goes to the right until the end of the glade makes one step up or down and goes left until he visits all remaining cells There are such routes To calculate the weight of collected mushrooms quickly we will precompute three arrays for the first row of the glade and will be used to compute the weight of mushrooms collected when Vasya moves to the right until the last column of the glade when Vasya moves to the left from the last column and to handle the growth of mushrooms Also we have to compute the same arrays for the second row of the glade Let s iterate on the number of columns Vasya will pass in a zigzag pattern and maintain the weight of mushrooms he will collect while doing so Then we have to add the weight of the mushrooms Vasya will gather while moving to the right and then while moving to the left The first can be handled by arrays and the second by arrays and "}
{"statement": "Iahub wants to meet his girlfriend Iahubina They both live in axis the horizontal axis Iahub lives at point 0 and Iahubina at point Iahub has positive integers The sum of those numbers is Suppose is a permutation of Then let and so on The array b is called a route There are different routes one for each permutation Iahub s travel schedule is he walks steps on axis then he makes a break in point Then he walks more steps on axis and makes a break in point Similarly at th time he walks more steps on axis and makes a break in point Iahub is very superstitious and has integers which give him bad luck He calls a route good if he never makes a break in a point corresponding to one of those numbers For his own curiosity answer how many good routes he can make modulo ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Usually when dealing with complicated problems a good idea is to solve them for small cases Let s try this here First case K 0 The answer is obviously N each permutation of p1 p2 pn would be good Next case K 1 The answer of this one is N L1 By L1 I denote all routes for which a prefix sum is equal to first lucky number Obviously if from all routes I exclude the wrong ones I get my answer If we can find an algorithm to provide L1 in good time then problem is solved for K 1 We can just try all N permutations Despite this method is simple it has complexity O N too much for the constraints Suppose we ve founded a set of positions p1 p2 pk such as a p1 a p2 a pk U1 first unlucky number How many permutations can we make The first k positions need to be p1 p2 pk but in any order Hence we get k The not used positions can also appeared in any order starting from k 1 position As they are n k we can permute them in n k ways Hence the answer is k n k Instead of permuting 1 2 n now we need to find subsets of it Hence the running time becomes O 2 n This is still too much Meet in the middle We make all subsets for first half of positions from 1 to N 2 and them for second half from N 2 1 to N For each subset we keep 2 information sum cnt representing that there is a subset of sum sum containing cnt elements For each X Y from left we iterate in the right After choosing one element from the left and one from the right we just split them To split 2 states A B and C D the new state becomes A C B D But we know that A C U1 This comes us to the idea for each X Y in the left I check U1 X 1 U1 X 2 U1 X K from the right For each of them the answer would be Y K N Y K I can store using any data structure that allows this operations I suggest a hash how C D how many times does state C D appear in the right So for a state A B the answer becomes a sum of how U1 A K B K N B K Doing the sum for all states A B we get our answer The complexity of this method is O 2 N 2 N Final Case K 2 The whole meet in the middle explanation worthed We will do something very similar to solve this case Suppose U1 and U2 are the unlucky numbers Without loosing the generality let s assume U1 U2 Following Principle of inclusion and exclusion paradigm google about it if you never heard before we can write our solution as N L1 L2 intersection between L1 and L2 Again by L1 2 I denote the number of routes which have a prefix sum equal to number U1 2 The X is again the cardinal of this set Basically we can calculate X as for K 1 The only problem remained is calculating intersection between L1 and L2 The intersection between L1 and L2 is the number of permutations which have a prefix sum equal to U1 and a prefix sum equal to U2 Since U1 U2 we can split a permutation from this set in 3 parts 1 p1 p2 pk such as a p1 a p2 a pk U1 2 pk 1 pk 2 pm such as a pk 1 a pk 2 a pm U2 U1 Note that a p1 a p2 a pm U2 3 The rest of elements until position n By a perfectly identical logic from K 1 case the number of permutations given those p would be k m k n m So the problem reduces to find all indices set p1 p2 and q1 q2 such as a p1 a p2 a pn1 U1 and a q1 a q2 a qn2 U2 U1 Then we can apply formula using n1 and n2 described above The first idea would be O 3 N for each position from 1 2 n atribute all combinations of 0 1 2 0 means that position i is 1 1 means that position i is in 2 and 2 means that position i is in 3 This would time out Happily we can improve it with meet in the middle principle The solution is very similar with K 1 case I won t fully explain it here if you understood principle from K 1 this shouldn t be a problem The base idea is to keep S1 S2 cnt1 cnt2 for both left and right S1 S2 cnt1 cnt2 represents a subset which has sum of elements from 1 equal to S1 sum of elements from 2 equal to S2 in 1 we have cnt1 element and in 2 we get cnt2 elements For a S1 S2 cnt1 cnt2 state from left we are looking in the right for something like U1 S1 U2 U1 S2 i j We get O 3 N 2 N 2 complexity Unexpected solution During the round we saw a lot of O 2 N N solutions passing This was totally out of expectations I believe if would make tests stronger this solution won t pass and round would be more challenging That s it nothing is perfect As requested I ll explain that solution here Before explaining the solution I assume you have some experience with bitmask dp technique If you don t please read before http community topcoder com tc module Static d1 tutorials d2 bitManipulation http codeforces com blog entry 337 In this problem we ll assume that a is 0 based For a mask consider bits from right to left noting them bit 0 bit 1 and so on Bit i is 1 if and only if a i is in the subset which is in a bijective replation with the mask For example for mask 100011101 the subset is a0 a2 a3 a4 a8 I ll call from now on the subset subset of mask Also the sum of all elements in a subset will be called sum of mask i e a0 a2 a3 a4 a8 We ll explain the solution based by watashi s submission 4017915 First step of the algorithm is to calculate sum of each mask Let dp i the sum of mask i Remove exactly one element from the subset of mask Suppose the new mask obtained is k and removed element is j Then dp i dp k a j dp k is always calculated before dp i to proof write both k and i in base 10 k is always smaller than i Having j an element from subset of mask i we can compute mask k by doing i 1 j Bit j is 1 and by xor ing it with another 1 bit it becomes 0 Other bits are unchanged by being xor ed by 0 This method works very fast to compute sum of each mask From now on let s denote a new array dp2 i how many good routes can I obtain with elements from subset of mask i Watashi uses same dp array but for making it clear in editorial I ll use 2 separate arrays Suppose that CNT i is number of elements from subset of mask i We are interested in how many ways we can fill positions 1 2 CNT i with elements from subset of mask i such as each prefix sum is different by each unlucky number Next step of the algorithm is to see which sum of masks are equal to one of unlucky numbers We mark them as 1 in dp2 Suppose we founded a subset a1 a2 ax for which a1 a2 ax one of unlucky numbers Then none permutation of a1 a2 ax is allowed to appear on first x positions When we arrive to a 1 state we know that the number of good routes for its subset of mask is 0 Now finally the main dp recurrence If for the current mask i dp2 i 1 then dp2 i 0 and continue we discard the state as explained above Otherwise we know that there could exist at least one way to complete positions 1 2 CNT i with elements of subset of mask i But how to calculate it We fix the last element the element from the position CNT I with some j from subset of mask i The problem reduces now with how many good routes can I fill in positions 1 2 CNT i 1 with elements from subset of mask i from which we erased element j With same explanation of sum of mask calculations this is already calculated in dp2 i 1 j The result is dp2 1 N 1 number of good routes containing all positions Editorial has been made by me and ll931110 The authors of the problems Div 2 A Div 2 B me Div 2 C Div 2 D Div 2 E ll931110 "}
{"statement": "You are given an integer n In one move you can either multiply n by two or divide n by 6 if it is divisible by 6 without the remainder Your task is to find the minimum number of moves needed to obtain 1 from n or determine if it s impossible to do that You have to answer t independent test cases ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "900", "problem_editorial": "If the number consists of other primes than and then the answer is Otherwise let be the number of twos in the factorization of and be the number of threes in the factorization of If then the answer is because we can t get rid of all twos Otherwise the answer is Time complexity "}
{"statement": "Given an array a of length n find another array b of length n such that for each i 1 le i le n MEX b 1 b 2 ldots b i a i The MEX of a set of integers is the smallest non negative integer that doesn t belong to this set If such array doesn t exist determine this ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1600", "problem_editorial": "The key observation is if for some index then must be equal to since it s the only way to even change the prefix We can use this observation to fill some indices of Now how do we fill the rest Let s start by avoiding every element in Something special will happen if we avoid using any element from again If we look at the first numbers in will indeed be excluded so Now we need to make it as big as possible How do we make it as big as possible The logical thing to do is to fill the rest of with the numbers not in in increasing order It turns out this construction always satisfies the conditions Indeed if we look at the first elements in every element less than will be present because and we added the rest of the elements in increasing order Code link https pastebin com x9VtuBym "}
{"statement": "Let s call some square matrix with integer values in its cells if it doesn t change after the order of rows is reversed and it doesn t change after the order of columns is reversed For example the following matrices are The following matrices are because they change after the order of rows is reversed The following matrices are because they change after the order of columns is reversed You are given n 2 integers Put them into a matrix of n rows and n columns so that each number is used exactly once each cell contains exactly one number and the resulting matrix is If there are multiple answers print any If there is no solution print ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "Basically what does the matrix being palindromic imply For each values in cells and are equal all zero indexed You can easily prove it by reversing the order of rows or columns and checking the overlapping cells in them Thus all cells can be split up into equivalence classes The even case is simple all classes have size The odd case has classes of sizes and Let s fill the classes one by one Obviously the order between the classes of the same size doesn t matter I claim that filling the classes in order in sizes construct the answer if any exists The key observation is that each next size is divisible by the previous one The implementation can come in lots of different forms and complexities Mine works in you can refer to it in attachment "}
{"statement": "Let there be a set that contains positive integers To expand the set to contain as many integers as possible Eri can choose two integers x neq y from the set such that their average frac x y 2 is still a positive integer and isn t contained in the set and add it to the set The integers x and y remain in the set Let s call the set of integers if after the elements are sorted the difference between any pair of adjacent elements is 1 For example sets 2 2 5 4 3 5 6 8 7 are consecutive while 2 4 5 6 9 7 are not Eri likes consecutive sets Suppose there is an array b then Eri puts all elements in b into the set If after a finite number of operations described above the set can become consecutive the array b will be called Note that if the same integer appears in the array multiple times we only put it into the set as a set always contains distinct positive integers Eri has an array a of n positive integers Please help him to count the number of pairs of integers l r such that 1 leq l leq r leq n and the subarray a l a l 1 ldots a r is brilliant ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "Let s consider the elements in the final set and take as its difference array Observation 1 is odd Otherwise we can turn into two Observation 2 Adjacent are not different Suppose and are different and odd then is even and so can be larger Thus the array is an arithmetic progression with an odd tolerance If you notice this and can also notice the monotonicity you can maintain for a range of numbers to show that the final set is an arithmetic progression starting from consisting of elements and has tolerance It s amazing that two pieces of information like this can be merged so we can use sparse table to maintain However there s a better way to solve it Similar to Euclidean Algorithm the tolerance is equal to the maximum odd divisor of the gcd of the difference array of that is Then the restriction means that is a power of For a fixed point find the smallest that interval is good A divisor of a power of is still a power of so it has monotonicity which makes it possible to use two pointers to maintain it in or Using sparse table or binary lifting may reach the same complexity Note that adjacent same numbers should be carefully dealt with "}
{"statement": "Monocarp s current password on Codeforces is a string s consisting of lowercase Latin letters Monocarp thinks that his current password is too weak so he wants to into the password to make it stronger Monocarp can choose any letter and insert it anywhere even before the first character or after the last character Monocarp thinks that the password s strength is proportional to the time it takes him to type the password The time it takes to type the password is calculated as follows the time to type the first character is 2 seconds for each character other than the first the time it takes to type it is 1 second if it is the same as the previous character or 2 seconds otherwise For example the time it takes to type the password is 14 the time it takes to type the password is 2 the time it takes to type the password is 11 You have to help Monocarp insert a lowercase Latin letter into his password so that the resulting password takes the maximum possible amount of time to type ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "The time it takes to type a string can actually be calculated as follows where is the number of characters in the string and is the number of pairs of adjacent equal characters usually a character takes seconds to type but the right character in every pair of adjacent equal characters takes only so each pair reduces the total time by Since we always add a new character will increase by no matter what so we need to minimize Now there are two cases if there is a pair of adjacent equal characters in the string we can decrease by by breaking it as follows choose any character different from the characters in that pair and insert it between them It s easy to see that we can break at most one such pair so we can t do better otherwise is already so we just need to keep it equal to For example we can choose any character not equal to the last character in the string and append it to the right of it There are other solutions as well like iterating on all possible characters and all possible insertion positions "}
{"statement": "Petya has got cards each card contains some integer The numbers on the cards can be the same Let s index all cards by consecutive integers from to We ll denote the number that is written on a card with number as In order to play one entertaining game with his friends Petya needs to split the cards into pairs so that each pair had equal numbers on the cards Help Petya do that ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1200", "problem_editorial": "For each from 1 to 5000 store a list of such indexes that Then just check that all lists have even size and output the elements of each list in pairs "}
{"statement": "For a long time no one could decipher Sumerian cuneiform However it has finally succumbed to pressure Today you have the chance to decipher Yandex cuneiform Yandex cuneiform is defined by the following rules An empty string is a Yandex cuneiform If you insert exactly one copy of each of the three letters and into a Yandex cuneiform in such a way that no two adjacent letters become equal after the operation you obtain a Yandex cuneiform If a string can t be obtained using the above rules it is not a Yandex cuneiform You are given a template A template is a string consisting of the characters and You need to check whether there exists a way to replace each question mark with or to obtain a Yandex cuneiform and if it exists output any of the matching options as well as a sequence of insertion operations to obtain the resulting cuneiform In this version of the problem the number of question marks in the template can be arbitrary ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3500", "problem_editorial": "We will isolate substrings from the string that consist entirely of For each we will denote its length as leni and the two neighboring symbols standing to the left and right as li ri If the right and or left symbol is absent we will take it as a symbol that does not match any of our interests We will write trivial constraints on the number of available symbols of each type on the segment It is obvious that the number of symbols of each type cannot exceed leni 12 we will place one symbol for every other symbol But if for example we had a symbol Y on the left the number of positions where we can place Y decreases by 1 In total we can place no more than len 1 li b ri b 2 symbols of type b We will write such constraints for each type of symbol and denote them as Y D X respectively It turns out that we can arrange y symbols Y d symbols D and x symbols X if and only if y d x leni and 0 y Y 0 d D 0 x X This can be proven by induction or checked with stress tests on small values From this we conclude that in order to be able to arrange x d y symbols of each type the inequalities above must hold From the equality y d x leni we express d leni x y This results in three constraints 0 x X 0 y Y 0 leni x y D The first two form a rectangle and the third cuts off two corners at a 45 degree angle This is a convex polygon Thus if for each segment of we write a polygon and sum them using Minkowski sum we will obtain constraints for the entire string Since in the Minkowski sum after merging collinear consecutive segments there will be at most 6 points we can write a greedy algorithm that sequentially tries to match the required symbol to each The final asymptotic complexity is O n with some constant "}
{"statement": "Given a string find the number of ways to split to substrings such that if there are substrings in partition then for all and is even Since the number of ways can be large print it modulo ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2900", "problem_editorial": "Let n be the length of the string Consider the string The problem can be reduced to finding the number of ways to partition string into palindromic substrings of even length Proof Let be the total number of partitions Let where denotes length of and denotes character of The part of string corresponding to these two partitions is which is an even length palindrome Similarly the converse is also true Dynamic programming can be used to solve the problem Let be the number of ways to partition into even length palindromes Then where is an even length palindrome Of course for odd As discussed in thisblog we can use an eertree to implement the solution On the other hand we can avoid the use of any suffix structure by following the algorithm described in thispaper Complexity "}
{"statement": "A sequence of n non negative integers n ge 2 a 1 a 2 dots a n is called good if for all i from 1 to n 1 the following condition holds true a 1 a 2 dots a i a i 1 a i 2 dots a n where denotes the bitwise AND operation You are given an array a of size n n geq 2 Find the number of permutations p of numbers ranging from 1 to n for which the sequence a p 1 a p 2 a p n is good Since this number can be large output it modulo 10 9 7 ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "Consider an arbitrary sequence First let us define the arrays and of length where and According to the definition of good sequence which means Now Also according to definition of good sequence This means that Similarly for all from to we get and Therefore for the sequence to be good and the must be a super mask of for all from to Initially we have an array Let the minimum value among these elements be Let the number of elements that have the value of be In order to rearrange the elements of to a good sequence we need to have and the remaining elements need to be a super mask of If we don t meet this criterion then the answer is Else the answer will be The time complexity is "}
{"statement": "Jamie is getting very busy with his school life He starts to forget the assignments that he has to do He decided to write the things down on a to do list He assigns a value for each of his assignment so he can decide which he needs to spend more time on After a few days Jamie finds out the list is too large that he can t even manage the list by himself As you are a good friend of Jamie help him write a program to support the following operations on the to do list Add assignment to the to do list if it is not present and set its to If assignment is already in the to do list its to Remove assignment from the to do list if it is present in it Output the number of assignments that are more important have a value than assignment so Jamie can decide a better schedule Output if is not in the to do list Undo all changes that have been made in the previous days not including the day of this operation At day the to do list is empty In each of the following days Jamie will do out of the four operations If the operation is a you should or poor Jamie cannot make appropriate decisions ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2200", "problem_editorial": "Let s solve a version that does not consist of undo operation first The task can be divided to two parts finding the priority of a string and finding the rank of a priority Both parts can be solved using trie trees The first part is basic string trie with get and set operation so I will not describe it here in details The second part is finding a rank of the number which can be supported by a binary trie To support the undo operation observe that each operation only add at most 31 nodes to the trie trees Therefore we can make use the idea of persistent data structure and store all versions by reusing old versions of the data structure with pointers Remember to flush the output after each query operation As pointed out by some of you there exists alternative solutions using persistent dynamic segment trees My implementation 34342389 sorry for a bit messy "}
{"statement": "The crowdedness of the discotheque would never stop our friends from having fun but a bit more spaciousness won t hurt will it The discotheque can be seen as an infinite plane in which there are a total of dancers Once someone starts moving around they will move only inside their own movement range which is a circular area described by a center and a radius that is for every pair either ranges and are disjoint or one of them is a subset of the other Note that it s possible that two ranges borders share a single common point but no two dancers have exactly the same ranges Tsukihi being one of them defines the to be An example is shown below with shaded regions representing the if everyone moves at the same time But no one keeps moving for the whole night after all so the whole night s time is divided into two halves before midnight and after midnight Every dancer moves around in one half while sitting down with friends in the other The of two halves are calculated separately and their sum should of course be as large as possible The following figure shows an optimal solution to the example above By different plans of who dances in the first half and who does in the other different sums of over two halves are achieved You are to find the largest achievable value of this sum ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "Circles borders do not intersect that is each circle is directly contained in another circle or is among the outermost ones Can you see a tree forest structure out of this We create a node for each of the circles with weight equal to its area Its parent is the circle which directly contains it namely the one with smallest radius among those circles containing If a circle is an outermost one then it s made a root This tree structure can be found in time Consider what happens if there s only one group the equals the sum of weights of all nodes whose depths are even minus the sum of weights of all nodes whose depths are odd Now we are to split the original tree forest into two disjoint groups This inspires us to think of a DP approach consider a vertex and the parity oddness evenness of number of nodes in its ancestors from the first and the second group Under this state let be the largest achievable answer in s subtree The recursion can be done from bottom to top in and the answer we need is the sum of for all being roots Time complexity is for the tree part and for the DP part See the code for the complete recursion Build the tree in time Find different greedy solutions for this problem and try to prove their correctness "}
{"statement": "Vector Willman and Array Bolt are the two most famous athletes of Byteforces They are going to compete in a race with a distance of meters today Willman and Bolt have exactly the same speed so when they compete the result is always a tie That is a problem for the organizers because they want a winner While watching previous races the organizers have noticed that Willman can perform steps of length equal to meters and Bolt can perform steps of length equal to meters Organizers decided to slightly change the rules of the race Now at the end of the racetrack there will be an abyss and the winner will be declared the athlete who manages to run farther from the starting point of the the racetrack which is not the subject to change by any of the athletes Note that none of the athletes can run infinitely far as they both will at some moment of time face the point such that only one step further will cause them to fall in the abyss In other words the athlete fall into the abyss if the total length of all his steps will be less or equal to the chosen distance Since the organizers are very fair the are going to set the length of the racetrack as an integer chosen randomly and uniformly in range from 1 to both are included What is the probability that Willman and Bolt tie again today ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1800", "problem_editorial": "Let D be the length of the racetrack Since both athletes should tie Let M lcm B W then D k M r None of the athletes should give one step further therefore r min B 1 W 1 T X D must be greater than 0 and less than or equal to T so r M k T r M For r 0 the number of valid racetracks is and for r 0 the number of racetracks is Iterating over all possible r we can count the number of racetracks in which Willman and Bolt ties Note that That means that for exactly M values of r We can count the number of values of r in which and the values of r in which Each of the remaining values v1 1 v1 2 v2 1 will appear exactly M times "}
{"statement": "Josuke received a huge undirected weighted complete dagger graph G as a gift from his grandfather The graph contains 10 18 vertices The peculiarity of the gift is that the weight of the edge between the different vertices u and v is equal to gcd u v ddagger Josuke decided to experiment and make a new graph G To do this he chooses two integers l le r and deletes all vertices except such vertices v that l le v le r and also deletes all the edges except between the remaining vertices Now Josuke is wondering how many different weights are there in G Since their count turned out to be huge he asks for your help dagger A complete graph is a simple undirected graph in which every pair of distinct vertices is adjacent ddagger gcd x y denotes the greatest common divisor GCD of the numbers x and y ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "TutorialLet s fix and check that the weight edge exists in The first number which is divided into starting with and the second note that their is so the edge between these vertices weighs If the second number is greater the edge with weight in the doesn t exist because on the segment from to at most one vertex which is divided by That is we should calculate the number of such which is For Get the upper limit on the That is all on segment from to occur in the as weight some edge Add them to the answer Look at Note that takes a of different values Let s fix some Note that corresponds to a consecutive segment Let s brute this segments in ascending order Then if there is a left border of the segment you can find either by binary search or by writing the formula The next left border is Then note if is fixed then is equivalent to That is with a fixed segment from to occurs in the as weight some edge if Then brute all these segments and sum up of all good Overall time complexity is or "}
{"statement": "As we know DZY loves playing games One day DZY decided to play with a matrix To be more precise he decided to modify the matrix with exactly operations Each modification is one of the following Pick some row of the matrix and decrease each element of the row by This operation brings to DZY the value of pleasure equal to the sum of elements of the row before the decreasing Pick some column of the matrix and decrease each element of the column by This operation brings to DZY the value of pleasure equal to the sum of elements of the column before the decreasing DZY wants to know what is the largest total value of pleasure he could get after performing exactly modifications Please help him to calculate this value ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "If apperently the best choice is choosing the row or column which can give greatest pleasure value each time Ignore first then we can get a greatest number Then if we choose rows for times choose columns for times should subtract So we could enumerate i form 0 to k and calculate each time max is the maximum possible pleasure value DZY could get Let be the maximum pleasure value we can get after choosing rows and be the maximum pleasure value we can get after choosing columns Then We can use two priority queues to calculate and quickly "}
{"statement": "Two friends are on the coordinate axis in points with integer coordinates One of them is in the point another one is in the point Each of the friends can move by one along the line in any direction unlimited number of times When a friend moves the tiredness of a friend changes according to the following rules the first move increases the tiredness by the second move increases the tiredness by the third by and so on For example if a friend moves first to the left then to the right returning to the same point and then again to the left his tiredness becomes equal to The friends want to meet in a integer point Determine the minimum total tiredness they should gain if they meet in the same point ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "800", "problem_editorial": "Initially we need to understand the following fact Since the number of teams in each round is even should be a power of two We will solve the problem for the 0 indexing commands so we decrease the given and on one For each round we will determine the number of the match in which the teams with initial numbers and will play The command will play in the match number and the command will play in the match number If then these teams will play in the same match and we need to print the number of the current round as an answer If the number of remaining teams equals to two this will be the final match of the tournament If the match numbers not equal we consider the next round In this case the number of command becomes and the number of number becomes The number of teams which will go to the next round is This process is always finite because sooner or later will remain only teams and in this round will be only one match the final match of the tournament "}
{"statement": "Arthur has bought a beautiful big table into his new flat When he came home Arthur noticed that the new table is unstable In total the table Arthur bought has legs the length of the th leg is Arthur decided to make the table stable and remove some legs For each of them Arthur determined number the amount of energy that he spends to remove the th leg A table with legs is assumed to be stable if there are more than half legs of the maximum length For example to make a table with legs stable you need to make sure it has at least three out of these five legs of the maximum length Also a table with one leg is always stable and a table with two legs is stable if and only if they have the same lengths Your task is to help Arthur and count the minimum number of energy units Arthur should spend on making the table stable ", "greedy": 1, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "This problem can be solved as follows At first we need to sort all legs in non descending order of their length Also we need to use array cnt Let iterate on length of legs which will stand table from the least Let this lenght is equals to maxlen Count of units of energy which we need for this we will store in variable cur Obviously that we must unscrew all legs with lenght more than maxlen For calculate count of units of energy for doing it we can use array with suffix sums for exapmle Then we add this value to cur If count of legs with length maxlen is not strictly greater than the number of the remaining legs then we need to unscrew some count of legs with length less than maxlen For this we can use array cnt In cnt i we will store count of legs with difficulty of unscrew equals to i In this array will store information about legs which already viewed We will iterate on difficulty of unscrew from one and unscrew legs with this difficulties and add this difficulties to variable cur while count of legs with length maxlen will not be strictly greater than the number of the remaining legs When it happens we need to update answer with variable cur Asymptotic behavior of this solution O n d where n count of legs and d difference between maximal and minimal units of energy which needed to unscrew some legs "}
{"statement": "You are given a connected undirected graph with n vertices and m edges Vertices of the graph are numbered by integers from 1 to n and edges of the graph are numbered by integers from 1 to m Your task is to answer q queries each consisting of two integers l and r The answer to each query is the smallest non negative integer k such that the following condition holds For all pairs of integers a b such that l le a le b le r vertices a and b are reachable from one another using only the first k edges that is edges 1 2 ldots k ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2300", "problem_editorial": "If answer is From now on we assume Say we have a function that tells us for some the answer for the query Then for some query the answer will be This is true because Since all consecutive nodes are connected the first edges will be sufficient to connect all nodes Say that it is possible to connect these nodes using the first edges We know that there is at least index such that But if the answer for this query is then it must be true that because we can reach vertex from vertex using only the first edges then Then we have which is a contradiction So if we precompute the values of for all we can answer any query efficiently using a range max query structure for example a sparse table or segment tree Here s how to find Weight the edges so that the th edge has a weight Find the unique minimum spanning tree of this weighted graph will be the maximum weight of an edge on the path from to This will always give the correct value for since edges not in the MST are useless Let s imagine building the MST with Kruskal s if we don t add the th edge that means that the first edges are sufficient to connect and and we can use those instead to get a better answer On the resulting tree the optimal way to connect any two nodes is to use the edges on the simple shortest path between them Finding the max edge weight in a path on a tree can be done for example with binary lifting for each node we store the maximum weight on the path to the root with length and so on Then we can find the max edge weight on the path from any two nodes to their LCA in Instead of using binary lifting we can also directly represent the MST in the DSU After successfully merging two components rooted at and in the DSU we add an edge with the weight being the edge number from the input will then be the maximum edge from to in the newly constructed tree We can just walk up the tree since the maximum depth is at most assuming the DSU implementation uses small to large merging This gives an or solution depending on the implementation "}
{"statement": "Vladik has favorite game in which he plays all his free time Game field could be represented as matrix which consists of cells of three types normal cell player can visit it finish cell player has to finish his way there to win There is exactly one cell of this type dangerous cell if player comes to this cell he loses Initially player is located in the left top cell with coordinates Player has access to buttons each of them move player up down left and right directions respectively But it s not that easy Sometimes friends play game and change functions of buttons Function of buttons and could have been swapped also functions of buttons and could have been swapped Note that functions of buttons can be changed only at the beginning of the game Help Vladik win the game ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2100", "problem_editorial": "It s clear that to reach finish without stepping into dangerous cells we have to know whether our buttons are broken Firstly let s find any route to the finish using bfs dfs At the first moment of this route when we have to go down we would find out if our button is broken because we are still at the first row of the matrix and if the button is broken we just won t move anywhere Similarly for left and right pair of buttons After that we found out that button was broken we can change in our route moves to opposite ones "}
{"statement": "Let s define the transformation of a sequence of integers as where for all where is the bitwise OR operation Vasya consequently applies the transformation to all sequences of length consisting of integers from to inclusive He wants to know how many of these sequences have such property that their transformation is a sequence Help him to calculate this number modulo ", "greedy": 0, "math": 1, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "3300", "problem_editorial": "First observation is that if the sequence of prefix xors is strictly increasing than on each step has at least one new bit comparing to the previous elements So since there are overall bits the length of the sequence can t be more than So if the answer is 0 Let s firstly solve the task with complexity We calculate the number of sequences of length such that has bits The transition is to add a number with new bits and choose those bits which are already in the prefix xor arbitrarily So is increased by The last binomial coefficient complies with the choice these very bits from which will be present in Note now that the transition doesn t depend on so let s try to use the idea of the binary exponentiation Suppose we want to merge two dynamics where is the number of bits present in and correspondingly Now we want to obtain for arrays of size The formula is Here corresponds to the bits present in the xor of the left part and for each number of the right part we can choose these bits arbitrarily Rewrite the formula in the following way So we can compute for all having multiplied two polynomials and We can obtain the coefficients of the first polynomial from the coefficients of the second in So we can compute this dynamic programming for all lengths powers of two in using the fast Fourier transform In fact it is more convenient to compute using the same equation After that we can use the same merge strategy to compute the answer for the given using dynamics for the powers of two Overall complexity is We decided to ask the answer modulo to not let the participants easily guess that these problem requires FFT So in order to get accepted you had to implement one of the methods to deal with the large modulo in polynomial multiplication using FFT Another approach was to apply Karatsuba algorithm our realisation timed out on our tests but qdai0815 somehow made it pass "}
{"statement": "Eric is the teacher of graph theory class Today Eric teaches independent set and edge induced subgraph Given a graph G V E an is a subset of vertices V subset V such that for every pair u v in V u v not in E i e no edge in E connects two vertices from V An consists of a subset of edges E subset E and all the vertices in the original graph that are incident on at least one edge in the subgraph Given E subset E denote G E the edge induced subgraph such that E is the edge set of the subgraph Here is an illustration of those definitions In order to help his students get familiar with those definitions he leaves the following problem as an exercise Given a tree G V E calculate the sum of w H over all except null edge induced subgraph H of G where w H is the number of independent sets in H Formally calculate sum limits emptyset not E subset E w G E Show Eric that you are smarter than his students by providing the correct answer as quickly as possible Note that the answer might be large you should output the answer modulo 998 244 353 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "We will call one vertice is colored if and only if it is in the independent set And a coloring is valid if and only if no two adjacent vertices are both colored Therefore we are asked to calculate the sum of number of valid colorings over all edge induced subgraphs To deal with the task one should notice that for a edge induced subgraph and one valid coloring we may add those vertices which are removed due to the generation of edge induced subgraph and remain it uncolored Therefore for a coloring on the original graph we could consider removing edges such that it will behave the same with above procedure In fact given a coloring we can define edge removing is valid if and only if there is no adjacent colored vertice and We can actually show that there is almost a one to one corresponding relation betweeen those two procedure except for the case where all vertices remains uncolored and all edges are removed Therefore we can actually solve the following task Given a tree for any given coloring define a edge removal is valid if it satisfies above constrains And it will suddenly becoming something easy to solve with tree dp Define be the answer for subtree rooted at with additional constraint such that is not colored be the answer where is colored and be the answer where edges from to its children are removed Therefore the dp formula should be The answer is easily calculated with those three states "}
{"statement": "You are given 4 integers n l r and z Count the number of arrays a of length n containing non negative integers such that l le a 1 a 2 ldots a n le r and a 1 oplus a 2 oplus ldots oplus a n z where oplus denotes the bitwise XOR operation Since the answer can be large print it modulo 10 9 7 ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2400", "problem_editorial": "Let s put aside the XOR constraint and only focus on the sum constraint let be the number of ways to construct integers such that their sum is at most We will construct each bit of the integers at the same time we want to guarantee that the contribution of the sum of the bits generated at each position plus the sum of the previous bits wont exceed we only have to know the difference between the previous bits of add 1 if the current bit is on and the sum of the generated bits However we know for sure that at each position we can generate at most bits which will sum to at most so for the next position the difference will be the current difference the sum of the bits at the cur position we can see that if the current difference has a value we can place any number of bits at the remaining positions Let s define as the number of ways to construct the first bits of the integers such that their sum doesn t exceed where is min between the difference between the previous bits and and We can have from 0 to ones placed at the current bit and for each we have ways to distribute them Formally where is one if the limit have the bit on For the XOR constraint we only have to make sure that count is even if the current bit of Z is 0 or odd if the current bit is 1 The answer of the problem will be "}
{"statement": "You are given an integer x of n digits a 1 a 2 ldots a n which make up its decimal notation in order from left to right Also you are given a positive integer k n Let s call integer b 1 b 2 ldots b m if b i b i k for each i such that 1 leq i leq m k You need to find the smallest integer y such that y geq x ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1700", "problem_editorial": "At first let s set ai ai k for all i k If it is at least the initial a then you can print it as the answer Otherwise Let s find the last non nine digit among the first k increase it by one and change all 9 s on the segment from it to k th character to 0 After that again set ai ai k for all i k Then you can print it as the answer "}
{"statement": "Recently the Fair Nut has written k strings of length n consisting of letters and He calculated c the number of strings that are prefixes of at least one of the written strings Then he lost his sheet with strings He remembers that all written strings were lexicographically than string s and than string t He is interested what is the maximum value of c that he could get A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "If and are equal answer is Let s cut common prefix of and and increase answer to its length Now starts from and starts from Let is new lengths of and If string weren t written we can change the lexicographically smallest string to and will not decrease We can do the same thing with Now and are in answer We can increase answer by decrease by 2 and don t count strings which are prefixes of and while calculating Let s divide strings in answer into groups two strings are in one group if and only if their first characters are equal and their largest common prefixes with or it depends on the first character are equal Let length of group be where length of this common prefix is equal to the number of vertexes in trie on written strings If we have fixed number of strings which will belong to some group we have to maximize size of set of vertexes which is union of ways in full binary tree with height equals to length of group It can be proved by induction that the first way increases size of set by the second by next 2 ways by next 4 ways by etc We can create array where how many ways increase answer by Note that these values are additive if we have two independent binary trees and want to distribute some number of ways between them we can sum their arrays and it is how prove the previous fact We have independent groups and we want to sum their arrays fast Every binary tree increases values on suffix by Let s forget about the first and add it in the end Then put to the second position in suffix and add to for in increasing order where array which we want to get Note that values in this array could be very big but if we change values bigger than to answer will not change because there are only ways To calculate answer let s take the prefix with sum if there are no such prefix we take the first prefix with sum which is bigger than and decrease last element fill other elements with Answer will be equal sum for "}
{"statement": "Vasya is studying in the last class of school and soon he will take exams He decided to study polynomials is a function Numbers are called of a polynomial non negative integer is called a of a polynomial Vasya has made a bet with his friends that he can solve any problem with polynomials They suggested him the problem Determine how many polynomials exist with coefficients so that and where and are given positive integers Vasya does not like losing bets but he has no idea how to solve this task so please help him to solve the problem ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "Let s discuss 2 case 1 t 1 2 t 1 1 If our function is not constant n 1 than a is greater all the coefficients so the only polynom can be the number b in the a ary counting system We must only check that one and constant function 2 if t 1 must be careful in case 1 1 1 the answer is inf in case 1 1 n the answer is 0 in case 1 x x integer x 0 the answer is 1 in the other cases P 1 is greater than other coefficients "}
{"statement": "Swing is given an n times n matrix M containing positive integers He has q queries to ask you For each query he gives you four integers x 1 y 1 x 2 y 2 and asks you to flatten the submatrix bounded by x 1 y 1 and x 2 y 2 into an array A Formally A M x1 y1 M x1 y1 1 ldots M x1 y2 M x1 1 y1 M x1 1 y1 1 ldots M x2 y2 The following image depicts the flattening of a submatrix bounded by the red dotted lines The orange arrows denote the direction that the elements of the submatrix are appended to the back of A and A is shown at the bottom of the image Afterwards he asks you for the value of sum i 1 A A i cdot i sum of A i cdot i over all i ", "greedy": 0, "math": 1, "implementation": 1, "dp": 1, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2100", "problem_editorial": "Problem Credits cry Analysis chromate00 Solution Consider translating the sum back onto the matrix For simplicity we discuss about querying the whole matrix The sum we would like to find is Here corresponds to so we will translate this to The issue left is on the multiplied to it Remember that we index the entries in increasing order of and then increasing order of Assuming and were indexed this will mean entry corresponds to also indexed You can notice that this naturally corresponds to the order we had defined as well Then what we want to find is Notice are independent and we can split them into sums Each of these three sums can be precomputed entry by entry and a 2D prefix sum can solve the answer for the entire matrix The query for a submatrix is very similar Formally you have to care about That we have columns instead of now That the precomputed values might not start from on the first row column of the query Still these two issues can be fixed using the three sums we have precomputed The time complexity becomes "}
{"statement": "Today is Sage s birthday and she will go shopping to buy ice spheres All n ice spheres are placed in a row and they are numbered from 1 to n from left to right Each ice sphere has a positive integer price In this version all prices are different An ice sphere is cheap if it costs strictly less than two neighboring ice spheres the nearest to the left and the nearest to the right The leftmost and the rightmost ice spheres are not cheap Sage will choose all cheap ice spheres and then buy only them You can visit the shop before Sage and reorder the ice spheres as you wish Find out the maximum number of ice spheres that Sage can buy and show how the ice spheres should be reordered ", "greedy": 1, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 1, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "Let s learn how to check whether it s possible to buy x ice spheres Let s sort the array a in the non decreasing order and then take x smallest elements of it We will suppose that these x ice spheres will be cheap To make these ice spheres cheap we need x 1 ice spheres more so let s take x 1 most expensive ice spheres Why it s always good to take x 1 most expensive ice spheres If we had an ice sphere with the price y and we took an ice sphere with price z y the answer will not become worse Now we know how to check whether it s possible to buy x ice spheres If we can buy x ice spheres then it s also possible to buy x 1 ice spheres For that reason the binary search for the answer is working "}
{"statement": "A sequence of n numbers is called if it contains all numbers from 1 to n exactly once For example the sequences 3 1 4 2 1 and 2 1 are permutations but 1 2 1 0 1 and 1 3 4 are not For a permutation p of even length n you can make an array b of length frac n 2 such that b i max p 2i 1 p 2i for 1 le i le frac n 2 For example if p 2 4 3 1 5 6 then b 1 max p 1 p 2 max 2 4 4 b 2 max p 3 p 4 max 3 1 3 b 3 max p 5 p 6 max 5 6 6 As a result we made b 4 3 6 For a given array b find the permutation p such that you can make the given array b from it If b 4 3 6 then the lexicographically minimal permutation from which it can be made is p 1 4 2 3 5 6 since b 1 max p 1 p 2 max 1 4 4 b 2 max p 3 p 4 max 2 3 3 b 3 max p 5 p 6 max 5 6 6 A permutation x 1 x 2 dots x n is lexicographically smaller than a permutation y 1 y 2 dots y n if and only if there exists such i 1 le i le n that x 1 y 1 x 2 y 2 dots x i 1 y i 1 and x i y i ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1900", "problem_editorial": "First let s check the array for correctness that is that it has no repeating elements Then let s look at the following ideas each number must be paired with another permutation element with by the definition of array Then since we want a lexicographically minimal permutation it is always more advantageous to put element before for the permutation to be lexicographically minimal the smallest possible numbers must be placed at the beginning Consequently the largest numbers must be placed at the end Let s proceed as follows Let s select the set of numbers that are not included in the array For an element find the maximum number of the set such that and put that number in front of the element moving from the end of the array to its beginning each element will be matched with such an element If at some point can not be matched array is not composed correctly and the answer to the query Otherwise print and the resulting permutation "}
{"statement": "The protection of a popular program developed by one of IT City companies is organized the following way After installation it outputs a random five digit number which should be sent in SMS to a particular phone number In response an SMS activation code arrives A young hacker Vasya disassembled the program and found the algorithm that transforms the shown number into the activation code The found algorithm looks the following way At first the digits of the number are shuffled in the following order first digit third digit fifth digit fourth digit second digit For example the shuffle of should lead to On the second stage the number is raised to the fifth power The result of the shuffle and exponentiation of the number is The answer is the last digits of this result For the number the answer should be Vasya is going to write a keygen program implementing this algorithm Can you do the same ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "In this problem just implementation of the actions described in the statement is required However there are two catches in this problem The first catch is that the fifth power of five digit number cannot be represented by a 64 bit integer But we need not the fifth power we need the fifth power modulo 105 And mod operation can be applied after each multiplication see problem A above The second catch is that you need to output five digits not the fifth power modulo 105 The difference is when fifth digit from the end is zero To output a number with the leading zero one can either use corresponding formatting 05d in printf or extract digits and output them one by one "}
{"statement": "Nezzar designs a brand new game Hidden Permutations and shares it with his best friend Nanako At the beginning of the game Nanako and Nezzar both know integers n and m The game goes in the following way Firstly Nezzar hides two permutations p 1 p 2 ldots p n and q 1 q 2 ldots q n of integers from 1 to n and Nanako secretly selects m unordered pairs l 1 r 1 l 2 r 2 ldots l m r m After that Nanako sends his chosen pairs to Nezzar On receiving those m unordered pairs Nezzar checks if there exists 1 le i le m such that p l i p r i and q l i q r i have different signs If so Nezzar instantly loses the game and gets a score of 1 Otherwise the score Nezzar gets is equal to the number of indices 1 le i le n such that p i neq q i However Nezzar accidentally knows Nanako s unordered pairs and decides to take advantage of them Please help Nezzar find out two permutations p and q such that the score is maximized ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2800", "problem_editorial": "We can describe the problem in graph theory terms We are given a graph of vertices and edge The th edge connects vertices and We need to write down two numbers on each vertices on th vertex we write and on it so that and forms a permutation from to For each edge the relative order between and must be the same as between and We want to maximize the number of vertices so that We can observe the following For any vertex with degree Proof For such vertex let Then there are exactly neighbors of that has its number smaller than Similarly let Then there are exactly neighbors of that has its number smaller than Since the relative order between and its neighbors must be the same across and which leads to We can assign those numbers with any unused number and delete them from the graph Now we will consider only vertices with degree where is the number of remaining vertices We claim that the maximum number of differing position to be exactly As all vertices have degree it is easier to consider the complement graph where in is connected if and only if is not connected in Notice that consists of connected components and each vertex has at least one neighbor We will focus on a single connected component Let us find any spanning tree of this particular component If the spanning tree is astar Let the center of star be and the other vertices be Then the following is a valid assignment for Otherwise we claim that we can decompose any tree into different connected stars with at least two nodes each If we can do so we can assign numbers to first star with nodes to second star with nodes and so on Notice that the relative order between nodes of different stars never change The remaining part is to decompose tree into stars There are a lot of algorithms to do so one of them would be Iterate all unassigned nodes For any unassigned node If any neighbors of are unassigned assign to be the center of new star component along with all unassigned neighbors of Otherwise notice that all neighbors of is now a non center member of some star component Pick up any of s neighbor If the star component of has at least two non center nodes remove from its original star component and make node and node a star component centered at Otherwise make to be the center of its star component and add to it We can see that the algorithm produces star components of at least two nodes each and therefore we can apply the assignment of numbers to each stars individually and concat the results In the end all nodes will have their and assigned differently It is possible to find all the needed spanning tree in time Then it takes total time to compute answers for all trees Therefore time complexity is "}
{"statement": "Recently a wild Krakozyabra appeared at Jelly Castle It is truth to be said always eager to have something for dinner Its favorite meal is natural numbers typically served with honey sauce or to be more precise the zeros in their corresponding decimal representations As for other digits Krakozyabra dislikes them moreover they often cause it indigestion So as a necessary precaution Krakozyabra prefers to sort the digits of a number in non descending order before proceeding to feast Then the leading zeros of the resulting number are eaten and the remaining part is discarded as an For example if Krakozyabra is to have the number for dinner its would be the number Slastyona is not really fond of the idea of Krakozyabra living in her castle Hovewer her natural hospitality prevents her from leaving her guest without food Slastyona has a range of natural numbers from to which she is going to feed the guest with Help her determine how many distinct are going to be discarded by Krakozyabra by the end of the dinner ", "greedy": 1, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2700", "problem_editorial": "Combinatorics or strong faith At first we might assume without loss of generality that both left and right bounds are strictly less than otherwise we just append to the list of unedible tails and hence consider only numbers with no more than 18 decimal digits Notice that there are not than many numbers without leading zeros they are no more than the number of solutions to where the number of s in a number To be precise there are only such numbers in range Thus we might simply brute all such numbers and for a fixed candidate let s denote it as whether it is possible using some additional zeros if neccessary to form the number from the range How do we check it rapidly Let s represent and as vectors of length we might add some leading zeros to if neccessary and as an array with possible additional zeros We will brute it in the following way which keeps out current position and indicates whether the currently obtained number is equal to the corresponding prefix of Several cases to consider If we return true If we strictly follow the prefixes of and There are two deeper cases If the only way out is to place decrease the number of corresponding digits in and proceed to Else if we have to check if there s an element in It s obvious that the answer is true in this case since after we get right between and we can assign the suffix whichever way we want Otherwise we first consider the possibility of placing and proceeding to or placing and proceeding to If nothing returns true the answer is false If only left flag is active we need a random digit from the suffix If we find it the answer is true If no we try and or return false A lone right flag is processed in a simular way with the only difference that we try the prefix or and At a first glance it seems that out bruteforce will end up being But an easy observation shows that there can be no more that two separate branches here The total bruteforce complexity is where stands for the maximum number length "}
{"statement": "Santa Hayate has a tree with n nodes Hayate now wants you to answer q queries Each query consists of a node x and k other additional nodes a 1 a 2 ldots a k These k 1 nodes are guaranteed to be all distinct For each query you must find the length of the longest simple path starting at node x dagger after removing nodes a 1 a 2 ldots a k along with all edges connected to at least one of nodes a 1 a 2 ldots a k dagger A simple path of length k starting at node x is a sequence of nodes x u 0 u 1 ldots u k such that there exists a edge between nodes u i 1 and u i for all 1 leq i leq k ", "greedy": 0, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "2500", "problem_editorial": "SolutionConsider the Euler tour of the tree where is the entry time of each node and is the exit time The interval corresponds to the subtree of Removing a node is equivalent to blocking some intervals on the Euler tour There are two cases when is blocked with respect to query node If is an ancestor of then the set of reachable nodes is reduced to the interval where is the first node on the path from to This is equivalent to blocking the intervals and If is not an ancestor then the interval is blocked Lets build a lazy segment tree on the Euler tour of the tree Each leaf node will correspond to the depth of a node on the tree We can re root the tree from to by subtracting one from all nodes the range and adding one to all other nodes Thus we can traverse the tree while re rooting and process our queries offline When the query node is the root block all the necessary intervals and then find the maximum value in the segment tree "}
{"statement": "Mihai has just learned about the MEX concept and since he liked it so much he decided to use it right away Given an array a of n non negative integers Mihai wants to create that is formed in the following way While a is not empty Choose an integer k 1 leq k leq a Append the MEX of the first k numbers of the array a to the end of array b and erase them from the array a shifting the positions of the remaining numbers in a But since Mihai loves big arrays as much as the MEX concept he wants the new array b to be the So Mihai asks you to tell him what the maximum array b that can be created by constructing the array optimally is An array x is lexicographically greater than an array y if in the first position where x and y differ x i y i or if x y and y is a prefix of x where x denotes the size of the array x The of a set of non negative integers is the minimal non negative integer such that it is not in the set For example 1 2 3 0 and 0 1 2 4 5 3 ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "1400", "problem_editorial": "The splitting points can be picked greedily Firstly find the MEX of all suffixes this can be easily done in or Instead of removing elements we consider that we need to split the array into some number of subarrays Let be the index we are currently at and MEX the MEX of the set formed from the numbers Start the process by looking at the first element so initially Then do the following process as long as find the first position such that MEX MEX add this MEX to the array and do the same process starting from position so This process always produces the optimal answer because if for each element in we choose to remove the minimum amount of elements from to obtain the maximum element so we have more elements in the future to do the same optimal choices Complexity or depending on implementation "}
{"statement": "You are given an array a 1 a 2 dots a n where each element is an integer from 1 to x You can perform the following operation with it any number of times choose three integers l r and k such that 1 le l le r le n 1 le k le x and element a i such that l le i le r is different from k Then for each i in l r replace a i with k In other words you choose a subsegment of the array and an integer from 1 to x which does not appear in that subsegment and replace every element in the subsegment with that chosen integer Your goal is to make all elements in the array equal What is the minimum number of operations that you have to perform ", "greedy": 0, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "First of all we claim the following if you apply an operation on a segment you may treat the resulting segment as one element i e we can merge the elements affected by an operation into one This is quite intuitive but the formal proof is kinda long so if you re not interested in it feel free to skip the next paragraphs written in italic This means that after you ve done an operation on a segment the next operations will either affect that whole segment or not affect any element from the segment at all This allows us to use the following dynamic programming idea let be the minimum number of operations required to turn all elements on the segment into If we want to transform all elements into then there are two options either the last operation will turn the whole segment into so we need to calculate the number of operations required to get rid of all elements equal to from the segment or the segment can be split into several segments which we will turn into separately The second option can be modeled quite easily we iterate on the splitting point between two parts and update with However the first option is a bit more complicated Let s introduce a second dynamic programming to our solution let be the minimum number of operations to remove all occurrences of from the segment Then the first option for computing can be implemented by simply updating with Now let s show how to calculate It s quite similar to the first dynamic programming either the last operation on the segment will turn the whole segment into some other element so we can iterate on it and update with or the segment can be split into two parts and we will get rid of elements equal to from these parts separately so we update with Okay it looks like we got a solution working in There s just one problem though There are cyclic dependencies in our dynamic programming depends on depends on where depends on depends on We have to either somehow deal with them or get rid of them The model solution eliminates these cyclic dependencies as follows when we need to calculate let s discard all elements equal to from the ends of the segment i e move to and to where and are the first and last occurrences of elements not equal to Similarly when we need to calculate let s discard all elements not equal to from the ends of the segment It s quite easy to show that these operations won t make the answer worse if you remove an element from an array the minimum number of operations to fix the array doesn t increase It s also not that hard to show that this method gets rid of all cyclic dependencies if we consider the cyclic dependency we described earlier we can see that the element will be discarded from the segment either when computing if or when computing if That way we get a dynamic programming solution working in "}
{"statement": "You are given an array a 1 a 2 dots a n consisting of n integers You are also given two integers k and x You have to perform the following operation exactly once add x to the elements on k positions and subtract x from all the others For example if a 2 1 2 3 k 1 x 2 and we have picked the first element then after the operation the array a 4 3 0 1 Let f a be the maximum possible sum of a subarray of a The subarray of a is a contiguous part of the array a i e the array a i a i 1 dots a j for some 1 le i le j le n An empty subarray should also be considered it has sum 0 Let the array a be the array a after applying the aforementioned operation Apply the operation in such a way that f a is the maximum possible and print the maximum possible value of f a ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "There are greedy and dynamic programming solutions We will describe dynamic programming solution The main task is to choose some segment that is the answer to the problem while choosing positions to increase by To do this we can use dynamic programming where is the number of positions that have already been considered from to is the number of elements that have already been increased by from to is the flag showing the current state whether we are before the chosen segment inside the segment or after the segment Transitions in such dynamic programming are quite simple we have a choice either to increase by then the value of the th element is or not to increase then the value of the th element is we can also change the state of the flag note that you can only switch from the current state to the subsequent ones i e for example you cannot switch from the state the segment has already ended to the state inside the segment If the current state of the flag is inside the segment then or depending on the selected transition should be added to the dynamic programming value itself So we got a solution in "}
{"statement": "Recently Polycarp was given an unusual typewriter as a gift Unfortunately the typewriter was defective and had a rather strange design The typewriter consists of n cells numbered from left to right from 1 to n and a carriage that moves over them The typewriter cells contain n integers from 1 to n and each cell i initially contains the integer p i Before all actions the carriage is at cell number 1 and there is nothing in its buffer storage The cell on which the carriage is located is called the cell The carriage can perform five types of operations Take the integer from the current cell if it is not empty and put it in the carriage buffer if it is empty this buffer can contain integer Put the integer from the carriage buffer if it is not empty into the current cell if it is empty Swap the number in the carriage buffer with the number in the current cell if both the buffer and the cell contain integers Move the carriage from the current cell i to cell i 1 if i n while the integer in the buffer is preserved Reset the carriage i e move it to cell number 1 while the integer in the buffer is preserved Polycarp was very interested in this typewriter so he asks you to help him understand it and will ask you q queries of three types Perform a cyclic shift of the sequence p to the left by k j Perform a cyclic shift of the sequence p to the right by k j Reverse the sequence p Before and after each query Polycarp wants to know what number of carriage resets is needed for the current sequence in order to distribute the numbers to their cells so that the number i ends up in cell number i Note that Polycarp only wants to know the minimum number of carriage resets required to arrange the numbers in their places but Help Polycarp find the answers to his queries ", "greedy": 0, "math": 1, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2500", "problem_editorial": "Let s solve the problem if there are no requests The key object for us will be such cells that the number in them is less than the cell index Note that for one carriage reset we can transfer no more than one such number So we have a lower bound on the answer Let s build a graph with edges Then it will break up into cycles Let s find the first position where take a number from this position shift it to take a number from position and so on Then we will put the whole cycle in its place How many carriage drops will there be Exactly as many edges as there are such that That is the answer is exactly equal to the number of positions where Let s learn how to solve for shifts Let s find for each cell such positions of the beginning of the array that it will satisfy in this configuration It is easy to see that for a particular cell such indexes will form a segment possibly a prefix suffix Let s create a separate array and add one on these segments Then in the i th position there will be an answer if the array starts from the i th cell Now let s solve for an array flip It is easy to see that for this you can simply maintain the entire previous structure but with the inverted original configuration of cells Asymptotic "}
{"statement": "On her way to programming school tiger Dasha faced her first test a huge staircase The steps were numbered from one to infinity As we know tigers are very fond of all striped things it is possible that it has something to do with their color So on some interval of her way she calculated two values the number of steps with even and odd numbers You need to check whether there is an interval of steps from the th to the th for which values that Dasha has found are correct ", "greedy": 0, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "1000", "problem_editorial": "It s obvious that if the answer is answer was also in the case when and are equal to because according to the statement such interval should exist In other cases the answer is "}
{"statement": "Last year Bob earned by selling memory sticks During each of days of his work one of the two following events took place A customer came to Bob and asked to sell him a MB memory stick If Bob had such a stick he sold it and got berllars Bob won some programming competition and got a MB memory stick as a prize Bob could choose whether to present this memory stick to one of his friends or keep it Bob never kept more than one memory stick as he feared to mix up their capacities and deceive a customer unintentionally It is also known that for each memory stick capacity there was at most one customer who wanted to buy that memory stick Now knowing all the customers demands and all the prizes won at programming competitions during the last days Bob wants to know how much money he could have earned if he had acted optimally ", "greedy": 1, "math": 0, "implementation": 0, "dp": 1, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "In this problem we need big integers because the number 22000 doesn t fit in int64 We are given an assertion that for every memory stick there will be at most one potential customer Since 2x 2x 1 2x 2 20 the earnings of selling the most expensive stick will be greater than the earnings of selling all other sticks So we first try to sell the most expensive stick then the second one and so on So one should try to sell sticks in descending order of their costs "}
{"statement": "Master Andrey loves trees dagger very much so he has a tree consisting of n vertices But it s not that simple Master Timofey decided to steal one vertex from the tree If Timofey stole vertex v from the tree then vertex v and all edges with one end at vertex v are removed from the tree while the numbers of other vertices remain unchanged To prevent Andrey from getting upset Timofey decided to make the resulting graph a tree again To do this he can add edges between any vertices a and b but when adding such an edge he must pay a b coins to the Master s Assistance Center Note that the resulting tree vertex v Timofey has not yet decided which vertex v he will remove from the tree so he wants to know for each vertex 1 leq v leq n the minimum number of coins needed to be spent to make the graph a tree again after removing vertex v as well as which edges need to be added dagger A tree is an undirected connected graph without cycles ", "greedy": 1, "math": 0, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2800", "problem_editorial": "TutorialLet s fix some vertex for which the answer is being calculated Suppose the degree of the vertex in the tree is then it s clear that it s necessary to add edges Consider the components that appear after removing Then the goal is to use the new edges to unite all the components into one using the minimum total cost This is the same as finding the minimum spanning tree in a graph where the vertices are the components that resulted from removing and for every an edge with a weight of is drawn between the components containing and Let s simulate Kruskal s algorithm for this graph Consider all the single weight edges in this graph It s clear that using the single weight edges the vertices with numbers will definitely end up in one component and the vertices with numbers will also end up in one component To unite these two components it would be optimal to add an edge It turns out that it s sufficient to consider only all the single weight edges and the edge Let s limit the number of single weight edges to For this in each component calculate and the minimum and maximum in the component respectively Claim among the single weight edges it s sufficient to consider edges of the form ProofFirst understand when it s necessary to add the edge Note that if there s at least one component such that then the edge won t be needed otherwise it will be This is quite easy to show by simulating Kruskal s algorithm Let We ll show that using edges all components will unite Go through the vertices from to and maintain the invariant that all vertices from to are in one component At this holds When is the minimum in some component then the edge will be added and since is in one component with will now also be When is not the minimum in some component then the minimum in the component will be in one component with the invariant holds meaning will also be in one component with Thus it turns out that all will be in one component Now consider an arbitrary Separately consider the prefix of vertices and the suffix Then similarly to it can be shown that for the prefix of vertices using edges of the form you can unite Similarly for the suffix of vertices using edges of the form you can unite Now if the edge is necessary then add it to the answer Otherwise there s at least one component such that meaning the prefix of vertices and the suffix will unite into one component Finding for each component is straightforward what remains is to determine which components are connected by the edges This can be done with binary search through the Euler tour of the tree After that Kruskal s algorithm can be initiated to calculate the answer Let s estimate the time complexity For a specific vertex the time complexity will be so the total time complexity is Depending on the implementation of the last step the problem can be solved in where is the inverse Ackermann function relative to "}
{"statement": "As usual Sereja has array its elements are integers Let s introduce notation A swap operation is the following sequence of actions choose two indexes perform assignments What maximum value of function can Sereja get if he is allowed to perform at most swap operations ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 1, "graphs": 0, "problem_dificulty": "1500", "problem_editorial": "Lets backtrack interval on which will contain maximal sum To improve our sum we can swap not more then minimal elements from the interval to maximal elements that don t belong to interval As isn t big we can do it in any way Author solution sort all elemets from interval in increasing order and all elements that don t belong to interval by descreasing order We will swap elements one by one while we haven t done swaps and we have some unswaped elements in first set and we have some unswaped elemets in second set and swap is optimal we will optimize the answer after this swap Author solution works in time Is there some ideas how to solve this problem in time or "}
{"statement": "There are people taking part in auction today The rules of auction are classical There were bids made though it s not guaranteed they were from different people It might happen that some people made no bids at all Each bid is define by two integers where is the index of the person who made this bid and is its size Bids are given in chronological order meaning for all Moreover participant never makes two bids in a row no one updates his own bid i e for all Now you are curious with the following question who and which bid will win the auction if some participants were absent Consider that if someone was absent all his bids are just removed and no new bids are added Note that if during this imaginary exclusion of some participants it happens that some of the remaining participants makes a bid twice or more times in a row only first of these bids is counted For better understanding take a look at the samples You have several questions in your mind compute the answer for each of them ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 1, "brute force": 0, "binary search": 1, "sortings": 0, "graphs": 0, "problem_dificulty": "2000", "problem_editorial": "For every man at the auction we will save two values his maximum bid and the list of all his bids Then save all men in the set sorted by the maximal bid Now when the query comes we will remove from the set all men who left the auction then answer the query and then add the men back The total number of deletions and insertions will not exceed 200000 How to answer the query Now our set contains only men who has not left If the set is empty the answer is 0 0 Otherwise the maximal man in the set is the winner Now we have to determine the winning bid Let s look at the second maximal man in the set If it doesn t exist the winner takes part solo and wins with his minimal bid Otherwise he should bid the minimal value that is greater than the maximal bid of the second man in the set This is where we need a list of bids of the first maximal man We can apply binary search and find the maximal bid of the second man there "}
{"statement": "In Byteland there are two political parties fighting for seats in the Parliament in the upcoming elections and As they want to convince as many citizens as possible to cast their votes on them they keep promising lower and lower taxes There are n cities in Byteland connected by m one way roads Interestingly enough the road network has no cycles it s impossible to start in any city follow a number of roads and return to that city Last year citizens of the i th city had to pay h i bourles of tax Parties will now alternately hold the election conventions in various cities If a party holds a convention in city v the party needs to the taxes in this city to a non negative integer amount of bourles However at the same time they can arbitrarily modify the taxes in each of the cities that can be reached from v using a single road The only condition that must be fulfilled that the tax in each city has to remain a non negative integer amount of bourles The first party to hold the convention is It s predicted that the party to hold the last convention will win the election Can win regardless of s moves ", "greedy": 0, "math": 0, "implementation": 0, "dp": 0, "constructive algorithms": 0, "data structures": 0, "brute force": 0, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "3200", "problem_editorial": "Let s get straight to the main lemma For any vertex let s define the of as where is the minimum excluded function Moreover for any let be the xor sum of the taxes in all cities fulfilling that is The starting party loses if and only if for all s that is if all xor sums are equal to 0 Let s consider any move from the position in which all xor sums are zero If we re holding the convention in the city then we the amount of taxes in this city Note however that there is no direct connection from to any other city having the same level as as is the smallest integer the set Therefore there is exactly one tax value changing at level and thus the value must change As it was zero before it must become non zero Now consider any configuration where some xor sums are non zero Let be the highest level at which We want to hold the election in a selected city at level Which one Notice that no city at a single level is connected to each other and therefore we can only afford to pick one city and its tax This is equivalent to the game of Nim where each city corresponds to a single stack of stones We perform a single optimal move in this game pick a city and decrease the tax in the city by a non zero amount of bourles leading to the position where the new xor sum of the taxes at this level is equal to zero We also need to take care of zeroing all s for This is however straightforward for each pick a single city fulfilling at level directly reachable from there must be one from the definition of and alter the value of tax in order to nullify The proof above is actually constructive and allows us to compute a single winning move in time As a small bonus if you re into advanced game theory you can come up with the lemma above without much guesswork One can compute the nimbers for the state where there are no taxes anywhere except a single city where the tax is equal to and it turns out to be equal to where is the smallest infinite ordinal number Moreover it s not that hard to see that the nimber for the state where there are more taxed cities is a nim sum of the nimbers corresponding to the states with only one taxed city This all should quite naturally lead to the lemma above "}
{"statement": "A big football championship will occur soon n teams will compete in it and each pair of teams will play exactly one game against each other There are two possible outcomes of a game the game may result in a tie then both teams get 1 point one team might win in a game then the winning team gets 3 points and the losing team gets 0 points The score of a team is the number of points it gained during all games that it played You are interested in a hypothetical situation when all teams get the same score at the end of the championship A simple example of that situation is when all games result in ties but you want to minimize the number of ties as well Your task is to describe a situation choose the result of each game so that all teams get the same score and the number of ties is the minimum possible ", "greedy": 1, "math": 1, "implementation": 1, "dp": 0, "constructive algorithms": 1, "data structures": 0, "brute force": 1, "binary search": 0, "sortings": 0, "graphs": 1, "problem_dificulty": "1500", "problem_editorial": "If is odd then we can solve the problem without any ties each team should win exactly matches and lose the same number of matches Finding which matches each team wins and which matches each team loses can be done with some graph algorithms like Eulerian cycles or circulations or with a simple construction place all teams in a circle in any order and let the th team win against the next teams after it in the circle and lose to all other teams Unfortunately if is even we need to use some ties since the total sum of scores over all teams is exactly when there are no ties and this number is not divisible by when is even Each tie reduces the total sum by and the minimum number of ties to make divisible by is since So if we find an answer with exactly ties it is optimal And it s easy to find one once again place all teams in a circle in any order make the th team win against next teams in the circle lose against previous teams in the circle and tie with the opposite team in the circle "}
